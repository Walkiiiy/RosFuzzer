{
  "fn_def_list": [
    {
      "fn_code": "static const unsigned char *\n  ares_dns_cookie_fetch(const ares_dns_record_t *dnsrec, size_t *len)\n{\n  const ares_dns_rr_t *rr  = ares_dns_get_opt_rr_const(dnsrec);\n  const unsigned char *val = NULL;\n  *len                     = 0;\n\n  if (rr == NULL) {\n    return NULL;\n  }\n\n  if (!ares_dns_rr_get_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE,\n                                &val, len)) {\n    return NULL;\n  }\n\n  return val;\n}",
      "fn_code_pos": [
        [
          198,
          0
        ],
        [
          215,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_cookie_fetch",
        "parameters": {
          "dnsrec": "ares_dns_record_t",
          "len": "size_t"
        },
        "return_type": null
      }
    },
    {
      "fn_code": "static ares_bool_t timeval_is_set(const ares_timeval_t *tv)\n{\n  if (tv->sec != 0 && tv->usec != 0) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          217,
          0
        ],
        [
          223,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "timeval_is_set",
        "parameters": {
          "tv": "ares_timeval_t"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t timeval_expired(const ares_timeval_t *tv,\n                                   const ares_timeval_t *now,\n                                   unsigned long         millsecs)\n{\n  ares_int64_t   tvdiff_ms;\n  ares_timeval_t tvdiff;\n  ares_timeval_diff(&tvdiff, tv, now);\n\n  tvdiff_ms = tvdiff.sec * 1000 + tvdiff.usec / 1000;\n  if (tvdiff_ms >= (ares_int64_t)millsecs) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          225,
          0
        ],
        [
          238,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "timeval_expired",
        "parameters": {
          "tv": "ares_timeval_t",
          "now": "ares_timeval_t",
          "millsecs": "unsigned long"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static void ares_cookie_clear(ares_cookie_t *cookie)\n{\n  memset(cookie, 0, sizeof(*cookie));\n  cookie->state = ARES_COOKIE_INITIAL;\n}",
      "fn_code_pos": [
        [
          240,
          0
        ],
        [
          244,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_cookie_clear",
        "parameters": {
          "cookie": "ares_cookie_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void ares_cookie_generate(ares_cookie_t *cookie, ares_conn_t *conn,\n                                 const ares_timeval_t *now)\n{\n  ares_channel_t *channel = conn->server->channel;\n\n  ares_rand_bytes(channel->rand_state, cookie->client, sizeof(cookie->client));\n  memcpy(&cookie->client_ts, now, sizeof(cookie->client_ts));\n  memcpy(&cookie->client_ip, &conn->self_ip, sizeof(cookie->client_ip));\n}",
      "fn_code_pos": [
        [
          246,
          0
        ],
        [
          254,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_cookie_generate",
        "parameters": {
          "cookie": "ares_cookie_t",
          "conn": "ares_conn_t",
          "now": "ares_timeval_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void ares_cookie_clear_server(ares_cookie_t *cookie)\n{\n  memset(cookie->server, 0, sizeof(cookie->server));\n  cookie->server_len = 0;\n}",
      "fn_code_pos": [
        [
          256,
          0
        ],
        [
          260,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_cookie_clear_server",
        "parameters": {
          "cookie": "ares_cookie_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_bool_t ares_addr_equal(const struct ares_addr *addr1,\n                                   const struct ares_addr *addr2)\n{\n  if (addr1->family != addr2->family) {\n    return ARES_FALSE;\n  }\n\n  switch (addr1->family) {\n    case AF_INET:\n      if (memcmp(&addr1->addr.addr4, &addr2->addr.addr4,\n                 sizeof(addr1->addr.addr4)) == 0) {\n        return ARES_TRUE;\n      }\n      break;\n    case AF_INET6:\n      /* This structure is weird, and due to padding SonarCloud complains if\n       * you don't punch all the way down.  At some point we should rework\n       * this structure */\n      if (memcmp(&addr1->addr.addr6._S6_un._S6_u8,\n                 &addr2->addr.addr6._S6_un._S6_u8,\n                 sizeof(addr1->addr.addr6._S6_un._S6_u8)) == 0) {\n        return ARES_TRUE;\n      }\n      break;\n    default:\n      break; /* LCOV_EXCL_LINE */\n  }\n\n  return ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          262,
          0
        ],
        [
          291,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_addr_equal",
        "parameters": {
          "addr1": "struct ares_addr",
          "addr2": "struct ares_addr"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_cookie_apply(ares_dns_record_t *dnsrec, ares_conn_t *conn,\n                                const ares_timeval_t *now)\n{\n  ares_server_t *server = conn->server;\n  ares_cookie_t *cookie = &server->cookie;\n  ares_dns_rr_t *rr     = ares_dns_get_opt_rr(dnsrec);\n  unsigned char  c[40];\n  size_t         c_len;\n\n  /* If there is no OPT record, then EDNS isn't supported, and therefore\n   * cookies can't be supported */\n  if (rr == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* No cookies on TCP, make sure we remove one if one is present */\n  if (conn->flags & ARES_CONN_FLAG_TCP) {\n    ares_dns_rr_del_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE);\n    return ARES_SUCCESS;\n  }\n\n  /* Look for regression */\n  if (cookie->state == ARES_COOKIE_SUPPORTED &&\n      timeval_is_set(&cookie->unsupported_ts) &&\n      timeval_expired(&cookie->unsupported_ts, now,\n                      COOKIE_REGRESSION_TIMEOUT_MS)) {\n    ares_cookie_clear(cookie);\n  }\n\n  /* Handle unsupported state */\n  if (cookie->state == ARES_COOKIE_UNSUPPORTED) {\n    /* If timer hasn't expired, just delete any possible cookie and return */\n    if (!timeval_expired(&cookie->unsupported_ts, now,\n                         COOKIE_REGRESSION_TIMEOUT_MS)) {\n      ares_dns_rr_del_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE);\n      return ARES_SUCCESS;\n    }\n\n    /* We want to try to \"learn\" again */\n    ares_cookie_clear(cookie);\n  }\n\n  /* Generate a new cookie */\n  if (cookie->state == ARES_COOKIE_INITIAL) {\n    ares_cookie_generate(cookie, conn, now);\n    cookie->state = ARES_COOKIE_GENERATED;\n  }\n\n  /* Regenerate the cookie and clear the server cookie if the client ip has\n   * changed */\n  if ((cookie->state == ARES_COOKIE_GENERATED ||\n       cookie->state == ARES_COOKIE_SUPPORTED) &&\n      !ares_addr_equal(&conn->self_ip, &cookie->client_ip)) {\n    ares_cookie_clear_server(cookie);\n    ares_cookie_generate(cookie, conn, now);\n  }\n\n  /* If the client cookie has reached its maximum time, refresh it */\n  if (cookie->state == ARES_COOKIE_SUPPORTED &&\n      timeval_expired(&cookie->client_ts, now, COOKIE_CLIENT_TIMEOUT_MS)) {\n    ares_cookie_clear_server(cookie);\n    ares_cookie_generate(cookie, conn, now);\n  }\n\n  /* Generate the full cookie which is the client cookie concatenated with the\n   * server cookie (if there is one) and apply it. */\n  memcpy(c, cookie->client, sizeof(cookie->client));\n  if (cookie->server_len) {\n    memcpy(c + sizeof(cookie->client), cookie->server, cookie->server_len);\n  }\n  c_len = sizeof(cookie->client) + cookie->server_len;\n\n  return ares_dns_rr_set_opt(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE, c,\n                             c_len);\n}",
      "fn_code_pos": [
        [
          293,
          0
        ],
        [
          367,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_cookie_apply",
        "parameters": {
          "dnsrec": "ares_dns_record_t",
          "conn": "ares_conn_t",
          "now": "ares_timeval_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_cookie_validate(ares_query_t            *query,\n                                   const ares_dns_record_t *dnsresp,\n                                   ares_conn_t *conn, const ares_timeval_t *now,\n                                   ares_array_t **requeue)\n{\n  ares_server_t           *server = conn->server;\n  ares_cookie_t           *cookie = &server->cookie;\n  const ares_dns_record_t *dnsreq = query->query;\n  const unsigned char     *resp_cookie;\n  size_t                   resp_cookie_len;\n  const unsigned char     *req_cookie;\n  size_t                   req_cookie_len;\n\n  resp_cookie = ares_dns_cookie_fetch(dnsresp, &resp_cookie_len);\n\n  /* Invalid cookie length, drop */\n  if (resp_cookie && (resp_cookie_len < 8 || resp_cookie_len > 40)) {\n    return ARES_EBADRESP;\n  }\n\n  req_cookie = ares_dns_cookie_fetch(dnsreq, &req_cookie_len);\n\n  /* Didn't request cookies, so we can stop evaluating */\n  if (req_cookie == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* If 8-byte prefix for returned cookie doesn't match the requested cookie,\n   * drop for spoofing */\n  if (resp_cookie && memcmp(req_cookie, resp_cookie, 8) != 0) {\n    return ARES_EBADRESP;\n  }\n\n  if (resp_cookie && resp_cookie_len > 8) {\n    /* Make sure we record that we successfully received a cookie response */\n    cookie->state = ARES_COOKIE_SUPPORTED;\n    memset(&cookie->unsupported_ts, 0, sizeof(cookie->unsupported_ts));\n\n    /* If client cookie hasn't been rotated, save the returned server cookie */\n    if (memcmp(cookie->client, req_cookie, sizeof(cookie->client)) == 0) {\n      cookie->server_len = resp_cookie_len - 8;\n      memcpy(cookie->server, resp_cookie + 8, cookie->server_len);\n    }\n  }\n\n  if (ares_dns_record_get_rcode(dnsresp) == ARES_RCODE_BADCOOKIE) {\n    /* Illegal to return BADCOOKIE but no cookie, drop */\n    if (resp_cookie == NULL) {\n      return ARES_EBADRESP;\n    }\n\n    /* If we have too many attempts to send a cookie, we need to requeue as\n     * tcp */\n    query->cookie_try_count++;\n    if (query->cookie_try_count >= COOKIE_RESEND_MAX) {\n      query->using_tcp = ARES_TRUE;\n    }\n\n    /* Resend the request, hopefully it will work the next time as we should\n     * have recorded a server cookie */\n    ares_requeue_query(query, now, ARES_SUCCESS,\n                       ARES_FALSE /* Don't increment try count */, NULL,\n                       requeue);\n\n    /* Parent needs to drop this response */\n    return ARES_EBADRESP;\n  }\n\n  /* We've got a response with a server cookie, and we've done all the\n   * evaluation we can, return success */\n  if (resp_cookie_len > 8) {\n    return ARES_SUCCESS;\n  }\n\n  if (cookie->state == ARES_COOKIE_SUPPORTED) {\n    /* If we're not currently tracking an error time yet, start */\n    if (!timeval_is_set(&cookie->unsupported_ts)) {\n      memcpy(&cookie->unsupported_ts, now, sizeof(cookie->unsupported_ts));\n    }\n    /* Drop it since we expected a cookie */\n    return ARES_EBADRESP;\n  }\n\n  if (cookie->state == ARES_COOKIE_GENERATED) {\n    ares_cookie_clear(cookie);\n    cookie->state = ARES_COOKIE_UNSUPPORTED;\n    memcpy(&cookie->unsupported_ts, now, sizeof(cookie->unsupported_ts));\n  }\n\n  /* Cookie state should be UNSUPPORTED if we're here */\n  return ARES_SUCCESS;\n}",
      "fn_code_pos": [
        [
          369,
          0
        ],
        [
          460,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_cookie_validate",
        "parameters": {
          "query": "ares_query_t",
          "dnsresp": "ares_dns_record_t",
          "conn": "ares_conn_t",
          "now": "ares_timeval_t",
          "requeue": "ares_array_t"
        },
        "return_type": "ares_status_t"
      }
    }
  ],
  "fn_declaraion": [
    {
      "fn_code": "ares_dns_cookie_fetch(const ares_dns_record_t *dnsrec, size_t *len)",
      "fn_dec_pos": [
        [
          199,
          2
        ],
        [
          199,
          69
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_cookie_fetch",
        "parameters": {
          "dnsrec": "ares_dns_record_t",
          "len": "size_t"
        },
        "return_type": null
      }
    }
  ],
  "class_node_list": {},
  "struct_node_list": [
    [
      "struct ares_addr",
      {},
      "",
      [
        262,
        41
      ],
      [
        262,
        57
      ]
    ],
    [
      "struct ares_addr",
      {},
      "",
      [
        263,
        41
      ],
      [
        263,
        57
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        185,
        0
      ],
      [
        186,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}