{
  "fn_def_list": [
    {
      "fn_code": "int ares_init(ares_channel_t **channelptr)\n{\n  return ares_init_options(channelptr, NULL, 0);\n}",
      "fn_code_pos": [
        [
          66,
          0
        ],
        [
          69,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_init",
        "parameters": {
          "channelptr": "ares_channel_t"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "static int ares_query_timeout_cmp_cb(const void *arg1, const void *arg2)\n{\n  const ares_query_t *q1 = arg1;\n  const ares_query_t *q2 = arg2;\n\n  if (q1->timeout.sec > q2->timeout.sec) {\n    return 1;\n  }\n  if (q1->timeout.sec < q2->timeout.sec) {\n    return -1;\n  }\n\n  if (q1->timeout.usec > q2->timeout.usec) {\n    return 1;\n  }\n  if (q1->timeout.usec < q2->timeout.usec) {\n    return -1;\n  }\n\n  return 0;\n}",
      "fn_code_pos": [
        [
          71,
          0
        ],
        [
          91,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_query_timeout_cmp_cb",
        "parameters": {
          "arg1": "void",
          "arg2": "void"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "static int server_sort_cb(const void *data1, const void *data2)\n{\n  const ares_server_t *s1 = data1;\n  const ares_server_t *s2 = data2;\n\n  if (s1->consec_failures < s2->consec_failures) {\n    return -1;\n  }\n  if (s1->consec_failures > s2->consec_failures) {\n    return 1;\n  }\n  if (s1->idx < s2->idx) {\n    return -1;\n  }\n  if (s1->idx > s2->idx) {\n    return 1;\n  }\n  return 0;\n}",
      "fn_code_pos": [
        [
          93,
          0
        ],
        [
          111,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "server_sort_cb",
        "parameters": {
          "data1": "void",
          "data2": "void"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "static void server_destroy_cb(void *data)\n{\n  if (data == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  ares_destroy_server(data);\n}",
      "fn_code_pos": [
        [
          113,
          0
        ],
        [
          119,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "server_destroy_cb",
        "parameters": {
          "data": "void"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_status_t init_by_defaults(ares_channel_t *channel)\n{\n  char         *hostname = NULL;\n  ares_status_t rc       = ARES_SUCCESS;\n#ifdef HAVE_GETHOSTNAME\n  const char *dot;\n#endif\n  struct ares_addr addr;\n  ares_llist_t    *sconfig = NULL;\n\n  /* Enable EDNS by default */\n  if (!(channel->optmask & ARES_OPT_FLAGS)) {\n    channel->flags = ARES_FLAG_EDNS;\n  }\n  if (channel->ednspsz == 0) {\n    channel->ednspsz = EDNSPACKETSZ;\n  }\n\n  if (channel->timeout == 0) {\n    channel->timeout = DEFAULT_TIMEOUT;\n  }\n\n  if (channel->tries == 0) {\n    channel->tries = DEFAULT_TRIES;\n  }\n\n  if (ares_slist_len(channel->servers) == 0) {\n    /* Add a default local named server to the channel unless configured not\n     * to (in which case return an error).\n     */\n    if (channel->flags & ARES_FLAG_NO_DFLT_SVR) {\n      rc = ARES_ENOSERVER;\n      goto error;\n    }\n\n    addr.family            = AF_INET;\n    addr.addr.addr4.s_addr = htonl(INADDR_LOOPBACK);\n\n    rc = ares_sconfig_append(channel, &sconfig, &addr, 0, 0, NULL);\n    if (rc != ARES_SUCCESS) {\n      goto error; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    rc = ares_servers_update(channel, sconfig, ARES_FALSE);\n    ares_llist_destroy(sconfig);\n\n    if (rc != ARES_SUCCESS) {\n      goto error;\n    }\n  }\n\n  if (channel->ndomains == 0) {\n    /* Derive a default domain search list from the kernel hostname,\n     * or set it to empty if the hostname isn't helpful.\n     */\n#ifndef HAVE_GETHOSTNAME\n    channel->ndomains = 0; /* default to none */\n#else\n    size_t len        = 256;\n    channel->ndomains = 0; /* default to none */\n\n    hostname = ares_malloc(len);\n    if (!hostname) {\n      rc = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto error;       /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    if (gethostname(hostname, (GETHOSTNAME_TYPE_ARG2)len) != 0) {\n      /* Lets not treat a gethostname failure as critical, since we\n       * are ok if gethostname doesn't even exist */\n      *hostname = '\\0';\n    }\n\n    dot = strchr(hostname, '.');\n    if (dot) {\n      /* a dot was found */\n      channel->domains = ares_malloc(sizeof(char *));\n      if (!channel->domains) {\n        rc = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto error;       /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      channel->domains[0] = ares_strdup(dot + 1);\n      if (!channel->domains[0]) {\n        rc = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto error;       /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      channel->ndomains = 1;\n    }\n#endif\n  }\n\n  if (channel->nsort == 0) {\n    channel->sortlist = NULL;\n  }\n\n  if (!channel->lookups) {\n    channel->lookups = ares_strdup(\"fb\");\n    if (!channel->lookups) {\n      rc = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  /* Set default fields for server failover behavior */\n  if (!(channel->optmask & ARES_OPT_SERVER_FAILOVER)) {\n    channel->server_retry_chance = DEFAULT_SERVER_RETRY_CHANCE;\n    channel->server_retry_delay  = DEFAULT_SERVER_RETRY_DELAY;\n  }\n\nerror:\n  if (hostname) {\n    ares_free(hostname);\n  }\n\n  return rc;\n}",
      "fn_code_pos": [
        [
          121,
          0
        ],
        [
          235,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "init_by_defaults",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "int ares_init_options(ares_channel_t           **channelptr,\n                      const struct ares_options *options, int optmask)\n{\n  ares_channel_t *channel;\n  ares_status_t   status = ARES_SUCCESS;\n\n  if (ares_library_initialized() != ARES_SUCCESS) {\n    return ARES_ENOTINITIALIZED; /* LCOV_EXCL_LINE: n/a on non-WinSock */\n  }\n\n  channel = ares_malloc_zero(sizeof(*channel));\n  if (!channel) {\n    *channelptr = NULL;\n    return ARES_ENOMEM;\n  }\n\n  /* We are in a good state */\n  channel->sys_up = ARES_TRUE;\n\n  /* One option where zero is valid, so set default value here */\n  channel->ndots = 1;\n\n  status = ares_channel_threading_init(channel);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Generate random key */\n  channel->rand_state = ares_init_rand_state();\n  if (channel->rand_state == NULL) {\n    status = ARES_ENOMEM;\n    DEBUGF(fprintf(stderr, \"Error: init_id_key failed: %s\\n\",\n                   ares_strerror(status)));\n    goto done;\n  }\n\n  ares_set_socket_functions_def(channel);\n\n  /* Initialize Server List */\n  channel->servers =\n    ares_slist_create(channel->rand_state, server_sort_cb, server_destroy_cb);\n  if (channel->servers == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Initialize our lists of queries */\n  channel->all_queries = ares_llist_create(NULL);\n  if (channel->all_queries == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->queries_by_qid = ares_htable_szvp_create(NULL);\n  if (channel->queries_by_qid == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->queries_by_timeout =\n    ares_slist_create(channel->rand_state, ares_query_timeout_cmp_cb, NULL);\n  if (channel->queries_by_timeout == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->connnode_by_socket = ares_htable_asvp_create(NULL);\n  if (channel->connnode_by_socket == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Initialize configuration by each of the four sources, from highest\n   * precedence to lowest.\n   */\n\n  status = ares_init_by_options(channel, options, optmask);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_options failed: %s\\n\",\n                   ares_strerror(status)));\n    /* If we fail to apply user-specified options, fail the whole init process\n     */\n    goto done;\n  }\n\n  /* Go ahead and let it initialize the query cache even if the ttl is 0 and\n   * completely unused.  This reduces the number of different code paths that\n   * might be followed even if there is a minor performance hit. */\n  status = ares_qcache_create(channel->rand_state, channel->qcache_max_ttl,\n                              &channel->qcache);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (status == ARES_SUCCESS) {\n    status = ares_init_by_sysconfig(channel);\n    if (status != ARES_SUCCESS) {\n      DEBUGF(fprintf(stderr, \"Error: init_by_sysconfig failed: %s\\n\",\n                     ares_strerror(status)));\n    }\n  }\n\n  /*\n   * No matter what failed or succeeded, seed defaults to provide\n   * useful behavior for things that we missed.\n   */\n  status = init_by_defaults(channel);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_defaults failed: %s\\n\",\n                   ares_strerror(status)));\n    goto done;\n  }\n\n  /* Initialize the event thread */\n  if (channel->optmask & ARES_OPT_EVENT_THREAD) {\n    ares_event_thread_t *e = NULL;\n\n    status = ares_event_thread_init(channel);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: UntestablePath */\n    }\n\n    /* Initialize monitor for configuration changes.  In some rare cases,\n     * ARES_ENOTIMP may occur (OpenWatcom), ignore this. */\n    e      = channel->sock_state_cb_data;\n    status = ares_event_configchg_init(&e->configchg, e);\n    if (status != ARES_SUCCESS && status != ARES_ENOTIMP) {\n      DEBUGF(fprintf(stderr, \"Error: ares_event_configchg_init failed: %s\\n\",\n                     ares_strerror(status)));\n    }\n    status = ARES_SUCCESS;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_destroy(channel);\n    return (int)status;\n  }\n\n  *channelptr = channel;\n  return ARES_SUCCESS;\n}",
      "fn_code_pos": [
        [
          237,
          0
        ],
        [
          378,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_init_options",
        "parameters": {
          "channelptr": "ares_channel_t",
          "options": "struct ares_options",
          "optmask": "int"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "static void *ares_reinit_thread(void *arg)\n{\n  ares_channel_t *channel = arg;\n  ares_status_t   status;\n\n  /* ares_init_by_sysconfig() will lock when applying the config, but not\n   * when retrieving. */\n  status = ares_init_by_sysconfig(channel);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_sysconfig failed: %s\\n\",\n                   ares_strerror(status)));\n  }\n\n  ares_channel_lock(channel);\n\n  /* Flush cached queries on reinit */\n  if (status == ARES_SUCCESS && channel->qcache) {\n    ares_qcache_flush(channel->qcache);\n  }\n\n  channel->reinit_pending = ARES_FALSE;\n  ares_channel_unlock(channel);\n\n  return NULL;\n}",
      "fn_code_pos": [
        [
          380,
          0
        ],
        [
          404,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_reinit_thread",
        "parameters": {
          "arg": "void"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "ares_status_t ares_reinit(ares_channel_t *channel)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares_channel_lock(channel);\n\n  /* If a reinit is already in process, lets not do it again. Or if we are\n   * shutting down, skip. */\n  if (!channel->sys_up || channel->reinit_pending) {\n    ares_channel_unlock(channel);\n    return ARES_SUCCESS;\n  }\n  channel->reinit_pending = ARES_TRUE;\n  ares_channel_unlock(channel);\n\n  if (ares_threadsafety()) {\n    /* clean up the prior reinit process's thread.  We know the thread isn't\n     * running since reinit_pending was false */\n    if (channel->reinit_thread != NULL) {\n      void *rv;\n      ares_thread_join(channel->reinit_thread, &rv);\n      channel->reinit_thread = NULL;\n    }\n\n    /* Spawn a new thread */\n    status =\n      ares_thread_create(&channel->reinit_thread, ares_reinit_thread, channel);\n    if (status != ARES_SUCCESS) {\n      /* LCOV_EXCL_START: UntestablePath */\n      ares_channel_lock(channel);\n      channel->reinit_pending = ARES_FALSE;\n      ares_channel_unlock(channel);\n      /* LCOV_EXCL_STOP */\n    }\n  } else {\n    /* Threading support not available, call directly */\n    ares_reinit_thread(channel);\n  }\n\n  return status;\n}",
      "fn_code_pos": [
        [
          406,
          0
        ],
        [
          450,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_reinit",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "int ares_dup(ares_channel_t **dest, const ares_channel_t *src)\n{\n  struct ares_options opts;\n  ares_status_t       rc;\n  int                 optmask;\n\n  if (dest == NULL || src == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dest = NULL; /* in case of failure return NULL explicitly */\n\n  /* First get the options supported by the old ares_save_options() function,\n     which is most of them */\n  rc = (ares_status_t)ares_save_options(src, &opts, &optmask);\n  if (rc != ARES_SUCCESS) {\n    ares_destroy_options(&opts);\n    goto done;\n  }\n\n  /* Then create the new channel with those options */\n  rc = (ares_status_t)ares_init_options(dest, &opts, optmask);\n\n  /* destroy the options copy to not leak any memory */\n  ares_destroy_options(&opts);\n\n  if (rc != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ares_channel_lock(src);\n  /* Now clone the options that ares_save_options() doesn't support, but are\n   * user-provided */\n  (*dest)->sock_create_cb               = src->sock_create_cb;\n  (*dest)->sock_create_cb_data          = src->sock_create_cb_data;\n  (*dest)->sock_config_cb               = src->sock_config_cb;\n  (*dest)->sock_config_cb_data          = src->sock_config_cb_data;\n  memcpy(&(*dest)->sock_funcs, &(src->sock_funcs), sizeof((*dest)->sock_funcs));\n  (*dest)->sock_func_cb_data            = src->sock_func_cb_data;\n  (*dest)->legacy_sock_funcs            = src->legacy_sock_funcs;\n  (*dest)->legacy_sock_funcs_cb_data    = src->legacy_sock_funcs_cb_data;\n  (*dest)->server_state_cb              = src->server_state_cb;\n  (*dest)->server_state_cb_data         = src->server_state_cb_data;\n  (*dest)->notify_pending_write_cb      = src->notify_pending_write_cb;\n  (*dest)->notify_pending_write_cb_data = src->notify_pending_write_cb_data;\n  (*dest)->query_enqueue_cb             = src->query_enqueue_cb;\n  (*dest)->query_enqueue_cb_data        = src->query_enqueue_cb_data;\n\n  ares_strcpy((*dest)->local_dev_name, src->local_dev_name,\n              sizeof((*dest)->local_dev_name));\n  (*dest)->local_ip4 = src->local_ip4;\n  memcpy((*dest)->local_ip6, src->local_ip6, sizeof(src->local_ip6));\n  ares_channel_unlock(src);\n\n  /* Servers are a bit unique as ares_init_options() only allows ipv4 servers\n   * and not a port per server, but there are other user specified ways, that\n   * too will toggle the optmask ARES_OPT_SERVERS to let us know.  If that's\n   * the case, pull them in.\n   *\n   * We don't want to clone system-configuration servers though.\n   *\n   * We must use the \"csv\" format to get things like link-local address support\n   */\n\n  if (optmask & ARES_OPT_SERVERS) {\n    char *csv = ares_get_servers_csv(src);\n    if (csv == NULL) {\n      /* LCOV_EXCL_START: OutOfMemory */\n      ares_destroy(*dest);\n      *dest = NULL;\n      rc    = ARES_ENOMEM;\n      goto done;\n      /* LCOV_EXCL_STOP */\n    }\n\n    rc = (ares_status_t)ares_set_servers_ports_csv(*dest, csv);\n    ares_free_string(csv);\n    if (rc != ARES_SUCCESS) {\n      /* LCOV_EXCL_START: OutOfMemory */\n      ares_destroy(*dest);\n      *dest = NULL;\n      goto done;\n      /* LCOV_EXCL_STOP */\n    }\n  }\n\n  rc = ARES_SUCCESS;\ndone:\n  return (int)rc; /* everything went fine */\n}",
      "fn_code_pos": [
        [
          454,
          0
        ],
        [
          543,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dup",
        "parameters": {
          "dest": "ares_channel_t",
          "src": "ares_channel_t"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "void ares_set_local_ip4(ares_channel_t *channel, unsigned int local_ip)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares_channel_lock(channel);\n  channel->local_ip4 = local_ip;\n  ares_channel_unlock(channel);\n}",
      "fn_code_pos": [
        [
          545,
          0
        ],
        [
          553,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_set_local_ip4",
        "parameters": {
          "channel": "ares_channel_t",
          "local_ip": "unsigned int"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "void ares_set_local_ip6(ares_channel_t *channel, const unsigned char *local_ip6)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares_channel_lock(channel);\n  memcpy(&channel->local_ip6, local_ip6, sizeof(channel->local_ip6));\n  ares_channel_unlock(channel);\n}",
      "fn_code_pos": [
        [
          556,
          0
        ],
        [
          564,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_set_local_ip6",
        "parameters": {
          "channel": "ares_channel_t",
          "local_ip6": "unsigned char"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "void ares_set_local_dev(ares_channel_t *channel, const char *local_dev_name)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  ares_channel_lock(channel);\n  ares_strcpy(channel->local_dev_name, local_dev_name,\n              sizeof(channel->local_dev_name));\n  channel->local_dev_name[sizeof(channel->local_dev_name) - 1] = 0;\n  ares_channel_unlock(channel);\n}",
      "fn_code_pos": [
        [
          567,
          0
        ],
        [
          578,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_set_local_dev",
        "parameters": {
          "channel": "ares_channel_t",
          "local_dev_name": "char"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "int ares_set_sortlist(ares_channel_t *channel, const char *sortstr)\n{\n  size_t           nsort    = 0;\n  struct apattern *sortlist = NULL;\n  ares_status_t    status;\n\n  if (!channel) {\n    return ARES_ENODATA;\n  }\n  ares_channel_lock(channel);\n\n  status = ares_parse_sortlist(&sortlist, &nsort, sortstr);\n  if (status == ARES_SUCCESS && sortlist) {\n    if (channel->sortlist) {\n      ares_free(channel->sortlist);\n    }\n    channel->sortlist = sortlist;\n    channel->nsort    = nsort;\n\n    /* Save sortlist as if it was passed in as an option */\n    channel->optmask |= ARES_OPT_SORTLIST;\n  }\n  ares_channel_unlock(channel);\n  return (int)status;\n}",
      "fn_code_pos": [
        [
          580,
          0
        ],
        [
          604,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_set_sortlist",
        "parameters": {
          "channel": "ares_channel_t",
          "sortstr": "char"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "void ares_set_query_enqueue_cb(ares_channel_t       *channel,\n                               ares_query_enqueue_cb callback,\n                               void                 *user_data)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  channel->query_enqueue_cb      = callback;\n  channel->query_enqueue_cb_data = user_data;\n}",
      "fn_code_pos": [
        [
          606,
          0
        ],
        [
          616,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_set_query_enqueue_cb",
        "parameters": {
          "channel": "ares_channel_t",
          "callback": "ares_query_enqueue_cb",
          "user_data": "void"
        },
        "return_type": "void"
      }
    }
  ],
  "fn_declaraion": [
    {
      "fn_code": "ares_reinit_thread(void *arg)",
      "fn_dec_pos": [
        [
          380,
          13
        ],
        [
          380,
          42
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_reinit_thread",
        "parameters": {
          "arg": "void"
        },
        "return_type": null
      }
    }
  ],
  "class_node_list": {},
  "struct_node_list": [
    [
      "struct ares_addr",
      {},
      "",
      [
        128,
        2
      ],
      [
        128,
        18
      ]
    ],
    [
      "struct ares_options",
      {},
      "",
      [
        238,
        28
      ],
      [
        238,
        47
      ]
    ],
    [
      "struct ares_options",
      {},
      "",
      [
        456,
        2
      ],
      [
        456,
        21
      ]
    ],
    [
      "struct apattern",
      {},
      "",
      [
        583,
        2
      ],
      [
        583,
        17
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        27,
        0
      ],
      [
        28,
        0
      ]
    ],
    [
      "#  include <sys/param.h>\n",
      [
        30,
        0
      ],
      [
        31,
        0
      ]
    ],
    [
      "#  include <netinet/in.h>\n",
      [
        34,
        0
      ],
      [
        35,
        0
      ]
    ],
    [
      "#  include <netdb.h>\n",
      [
        38,
        0
      ],
      [
        39,
        0
      ]
    ],
    [
      "#  include <arpa/inet.h>\n",
      [
        42,
        0
      ],
      [
        43,
        0
      ]
    ],
    [
      "#include \"ares_nameser.h\"\n",
      [
        45,
        0
      ],
      [
        46,
        0
      ]
    ],
    [
      "#  include <sys/system_properties.h>\n",
      [
        48,
        0
      ],
      [
        49,
        0
      ]
    ],
    [
      "#  include \"ares_android.h\"\n",
      [
        49,
        0
      ],
      [
        50,
        0
      ]
    ],
    [
      "#  include <resolv.h>\n",
      [
        56,
        0
      ],
      [
        57,
        0
      ]
    ],
    [
      "#  include <iphlpapi.h>\n",
      [
        60,
        0
      ],
      [
        61,
        0
      ]
    ],
    [
      "#include \"ares_inet_net_pton.h\"\n",
      [
        63,
        0
      ],
      [
        64,
        0
      ]
    ],
    [
      "#include \"event/ares_event.h\"\n",
      [
        64,
        0
      ],
      [
        65,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}