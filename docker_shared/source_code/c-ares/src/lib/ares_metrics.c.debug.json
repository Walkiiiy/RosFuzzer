{
  "fn_def_list": [
    {
      "fn_code": "static time_t ares_metric_timestamp(ares_server_bucket_t  bucket,\n                                    const ares_timeval_t *now,\n                                    ares_bool_t           is_previous)\n{\n  time_t divisor = 1; /* Silence bogus MSVC warning by setting default value */\n\n  switch (bucket) {\n    case ARES_METRIC_1MINUTE:\n      divisor = 60;\n      break;\n    case ARES_METRIC_15MINUTES:\n      divisor = 15 * 60;\n      break;\n    case ARES_METRIC_1HOUR:\n      divisor = 60 * 60;\n      break;\n    case ARES_METRIC_1DAY:\n      divisor = 24 * 60 * 60;\n      break;\n    case ARES_METRIC_INCEPTION:\n      return is_previous ? 0 : 1;\n    case ARES_METRIC_COUNT:\n      return 0; /* Invalid! */\n  }\n\n  if (is_previous) {\n    if (divisor >= now->sec) {\n      return 0;\n    }\n    return (time_t)((now->sec - divisor) / divisor);\n  }\n\n  return (time_t)(now->sec / divisor);\n}",
      "fn_code_pos": [
        [
          112,
          0
        ],
        [
          145,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_metric_timestamp",
        "parameters": {
          "bucket": "ares_server_bucket_t",
          "now": "ares_timeval_t",
          "is_previous": "ares_bool_t"
        },
        "return_type": "time_t"
      }
    },
    {
      "fn_code": "void ares_metrics_record(const ares_query_t *query, ares_server_t *server,\n                         ares_status_t status, const ares_dns_record_t *dnsrec)\n{\n  ares_timeval_t       now;\n  ares_timeval_t       tvdiff;\n  unsigned int         query_ms;\n  ares_dns_rcode_t     rcode;\n  ares_server_bucket_t i;\n\n  if (status != ARES_SUCCESS) {\n    return;\n  }\n\n  if (server == NULL) {\n    return;\n  }\n\n  ares_tvnow(&now);\n\n  rcode = ares_dns_record_get_rcode(dnsrec);\n  if (rcode != ARES_RCODE_NOERROR && rcode != ARES_RCODE_NXDOMAIN) {\n    return;\n  }\n\n  ares_timeval_diff(&tvdiff, &query->ts, &now);\n  query_ms = (unsigned int)((tvdiff.sec * 1000) + (tvdiff.usec / 1000));\n  if (query_ms == 0) {\n    query_ms = 1;\n  }\n\n  /* Place in each bucket */\n  for (i = 0; i < ARES_METRIC_COUNT; i++) {\n    time_t ts = ares_metric_timestamp(i, &now, ARES_FALSE);\n\n    /* Copy metrics to prev and clear */\n    if (ts != server->metrics[i].ts) {\n      server->metrics[i].prev_ts          = server->metrics[i].ts;\n      server->metrics[i].prev_total_ms    = server->metrics[i].total_ms;\n      server->metrics[i].prev_total_count = server->metrics[i].total_count;\n      server->metrics[i].ts               = ts;\n      server->metrics[i].latency_min_ms   = 0;\n      server->metrics[i].latency_max_ms   = 0;\n      server->metrics[i].total_ms         = 0;\n      server->metrics[i].total_count      = 0;\n    }\n\n    if (server->metrics[i].latency_min_ms == 0 ||\n        server->metrics[i].latency_min_ms > query_ms) {\n      server->metrics[i].latency_min_ms = query_ms;\n    }\n\n    if (query_ms > server->metrics[i].latency_max_ms) {\n      server->metrics[i].latency_max_ms = query_ms;\n    }\n\n    server->metrics[i].total_count++;\n    server->metrics[i].total_ms += (ares_uint64_t)query_ms;\n  }\n}",
      "fn_code_pos": [
        [
          147,
          0
        ],
        [
          205,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_metrics_record",
        "parameters": {
          "query": "ares_query_t",
          "server": "ares_server_t",
          "status": "ares_status_t",
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "size_t ares_metrics_server_timeout(const ares_server_t  *server,\n                                   const ares_timeval_t *now)\n{\n  const ares_channel_t *channel = server->channel;\n  ares_server_bucket_t  i;\n  size_t                timeout_ms = 0;\n  size_t                max_timeout_ms;\n\n  for (i = 0; i < ARES_METRIC_COUNT; i++) {\n    time_t ts = ares_metric_timestamp(i, now, ARES_FALSE);\n\n    /* This ts has been invalidated, see if we should use the previous\n     * time period */\n    if (ts != server->metrics[i].ts ||\n        server->metrics[i].total_count < MIN_COUNT_FOR_AVERAGE) {\n      time_t prev_ts = ares_metric_timestamp(i, now, ARES_TRUE);\n      if (prev_ts != server->metrics[i].prev_ts ||\n          server->metrics[i].prev_total_count < MIN_COUNT_FOR_AVERAGE) {\n        /* Move onto next bucket */\n        continue;\n      }\n      /* Calculate average time for previous bucket */\n      timeout_ms = (size_t)(server->metrics[i].prev_total_ms /\n                            server->metrics[i].prev_total_count);\n    } else {\n      /* Calculate average time for current bucket*/\n      timeout_ms =\n        (size_t)(server->metrics[i].total_ms / server->metrics[i].total_count);\n    }\n\n    /* Multiply average by constant to get timeout value */\n    timeout_ms *= AVG_TIMEOUT_MULTIPLIER;\n    break;\n  }\n\n  /* If we're here, that means its the first query for the server, so we just\n   * use the initial default timeout */\n  if (timeout_ms == 0) {\n    timeout_ms = channel->timeout;\n  }\n\n  /* don't go below lower bounds */\n  if (timeout_ms < MIN_TIMEOUT_MS) {\n    timeout_ms = MIN_TIMEOUT_MS;\n  }\n\n  /* don't go above upper bounds */\n  max_timeout_ms = channel->maxtimeout ? channel->maxtimeout : MAX_TIMEOUT_MS;\n  if (timeout_ms > max_timeout_ms) {\n    timeout_ms = max_timeout_ms;\n  }\n\n  return timeout_ms;\n}",
      "fn_code_pos": [
        [
          207,
          0
        ],
        [
          260,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_metrics_server_timeout",
        "parameters": {
          "server": "ares_server_t",
          "now": "ares_timeval_t"
        },
        "return_type": "size_t"
      }
    }
  ],
  "fn_declaraion": [],
  "class_node_list": {},
  "struct_node_list": [],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        97,
        0
      ],
      [
        98,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}