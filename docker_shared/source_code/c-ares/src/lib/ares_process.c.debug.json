{
  "fn_def_list": [
    {
      "fn_code": "static void        ares_query_remove_from_conn(ares_query_t *query)\n{\n  /* If its not part of a connection, it can't be tracked for timeouts either */\n  ares_slist_node_destroy(query->node_queries_by_timeout);\n  ares_llist_node_destroy(query->node_queries_to_conn);\n  query->node_queries_by_timeout = NULL;\n  query->node_queries_to_conn    = NULL;\n  query->conn                    = NULL;\n}",
      "fn_code_pos": [
        [
          69,
          0
        ],
        [
          77,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_query_remove_from_conn",
        "parameters": {
          "query": "ares_query_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void invoke_server_state_cb(const ares_server_t *server,\n                                   ares_bool_t success, int flags)\n{\n  const ares_channel_t *channel = server->channel;\n  ares_buf_t           *buf;\n  ares_status_t         status;\n  char                 *server_string;\n\n  if (channel->server_state_cb == NULL) {\n    return;\n  }\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    return; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_get_server_addr(server, buf);\n  if (status != ARES_SUCCESS) {\n    ares_buf_destroy(buf); /* LCOV_EXCL_LINE: OutOfMemory */\n    return;                /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  server_string = ares_buf_finish_str(buf, NULL);\n  buf           = NULL;\n  if (server_string == NULL) {\n    return; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  channel->server_state_cb(server_string, success, flags,\n                           channel->server_state_cb_data);\n  ares_free(server_string);\n}",
      "fn_code_pos": [
        [
          80,
          0
        ],
        [
          112,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "invoke_server_state_cb",
        "parameters": {
          "server": "ares_server_t",
          "success": "ares_bool_t",
          "flags": "int"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void server_increment_failures(ares_server_t *server,\n                                      ares_bool_t    used_tcp)\n{\n  ares_slist_node_t    *node;\n  const ares_channel_t *channel = server->channel;\n  ares_timeval_t        next_retry_time;\n\n  node = ares_slist_node_find(channel->servers, server);\n  if (node == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  server->consec_failures++;\n  ares_slist_node_reinsert(node);\n\n  ares_tvnow(&next_retry_time);\n  timeadd(&next_retry_time, channel->server_retry_delay);\n  server->next_retry_time = next_retry_time;\n\n  invoke_server_state_cb(server, ARES_FALSE,\n                         used_tcp == ARES_TRUE ? ARES_SERV_STATE_TCP\n                                               : ARES_SERV_STATE_UDP);\n}",
      "fn_code_pos": [
        [
          114,
          0
        ],
        [
          136,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "server_increment_failures",
        "parameters": {
          "server": "ares_server_t",
          "used_tcp": "ares_bool_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void server_set_good(ares_server_t *server, ares_bool_t used_tcp)\n{\n  ares_slist_node_t    *node;\n  const ares_channel_t *channel = server->channel;\n\n  node = ares_slist_node_find(channel->servers, server);\n  if (node == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (server->consec_failures > 0) {\n    server->consec_failures = 0;\n    ares_slist_node_reinsert(node);\n  }\n\n  server->next_retry_time.sec  = 0;\n  server->next_retry_time.usec = 0;\n\n  invoke_server_state_cb(server, ARES_TRUE,\n                         used_tcp == ARES_TRUE ? ARES_SERV_STATE_TCP\n                                               : ARES_SERV_STATE_UDP);\n}",
      "fn_code_pos": [
        [
          138,
          0
        ],
        [
          159,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "server_set_good",
        "parameters": {
          "server": "ares_server_t",
          "used_tcp": "ares_bool_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "ares_bool_t ares_timedout(const ares_timeval_t *now,\n                          const ares_timeval_t *check)\n{\n  ares_int64_t secs = (now->sec - check->sec);\n\n  if (secs > 0) {\n    return ARES_TRUE; /* yes, timed out */\n  }\n  if (secs < 0) {\n    return ARES_FALSE; /* nope, not timed out */\n  }\n\n  /* if the full seconds were identical, check the sub second parts */\n  return ((ares_int64_t)now->usec - (ares_int64_t)check->usec) >= 0\n           ? ARES_TRUE\n           : ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          162,
          0
        ],
        [
          178,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_timedout",
        "parameters": {
          "now": "ares_timeval_t",
          "check": "ares_timeval_t"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static void timeadd(ares_timeval_t *now, size_t millisecs)\n{\n  now->sec  += (ares_int64_t)millisecs / 1000;\n  now->usec += (unsigned int)((millisecs % 1000) * 1000);\n\n  if (now->usec >= 1000000) {\n    now->sec  += now->usec / 1000000;\n    now->usec %= 1000000;\n  }\n}",
      "fn_code_pos": [
        [
          181,
          0
        ],
        [
          190,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "timeadd",
        "parameters": {
          "now": "ares_timeval_t",
          "millisecs": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_status_t ares_process_fds_nolock(ares_channel_t         *channel,\n                                             const ares_fd_events_t *events,\n                                             size_t nevents, unsigned int flags)\n{\n  ares_timeval_t now;\n  size_t         i;\n  ares_status_t  status = ARES_SUCCESS;\n\n  if (channel == NULL || (events == NULL && nevents != 0)) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_tvnow(&now);\n\n  /* Process write events */\n  for (i = 0; i < nevents; i++) {\n    if (events[i].fd == ARES_SOCKET_BAD ||\n        !(events[i].events & ARES_FD_EVENT_WRITE)) {\n      continue;\n    }\n    status = process_write(channel, events[i].fd);\n    /* We only care about ENOMEM, anything else is handled via connection\n     * retries, etc */\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n  }\n\n  /* Process read events */\n  for (i = 0; i < nevents; i++) {\n    if (events[i].fd == ARES_SOCKET_BAD ||\n        !(events[i].events & ARES_FD_EVENT_READ)) {\n      continue;\n    }\n    status = process_read(channel, events[i].fd, &now);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n  }\n\n  if (!(flags & ARES_PROCESS_FLAG_SKIP_NON_FD)) {\n    status = process_timeouts(channel, &now);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n\n    /* Cleanup should be done after processing timeouts as it may invalidate\n     * connections */\n    ares_check_cleanup_conns(channel);\n  }\n\ndone:\n  if (status == ARES_ENOMEM) {\n    return ARES_ENOMEM;\n  }\n  return ARES_SUCCESS;\n}",
      "fn_code_pos": [
        [
          192,
          0
        ],
        [
          248,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_process_fds_nolock",
        "parameters": {
          "channel": "ares_channel_t",
          "events": "ares_fd_events_t",
          "nevents": "size_t",
          "flags": "unsigned int"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_process_fds(ares_channel_t         *channel,\n                               const ares_fd_events_t *events, size_t nevents,\n                               unsigned int flags)\n{\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares_channel_lock(channel);\n  status = ares_process_fds_nolock(channel, events, nevents, flags);\n  ares_channel_unlock(channel);\n  return status;\n}",
      "fn_code_pos": [
        [
          250,
          0
        ],
        [
          264,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_process_fds",
        "parameters": {
          "channel": "ares_channel_t",
          "events": "ares_fd_events_t",
          "nevents": "size_t",
          "flags": "unsigned int"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "void ares_process_fd(ares_channel_t *channel, ares_socket_t read_fd,\n                     ares_socket_t write_fd)\n{\n  ares_fd_events_t events[2];\n  size_t           nevents = 0;\n\n  memset(events, 0, sizeof(events));\n\n  if (read_fd != ARES_SOCKET_BAD) {\n    nevents++;\n    events[nevents - 1].fd      = read_fd;\n    events[nevents - 1].events |= ARES_FD_EVENT_READ;\n  }\n\n  if (write_fd != ARES_SOCKET_BAD) {\n    if (write_fd != read_fd) {\n      nevents++;\n    }\n    events[nevents - 1].fd      = write_fd;\n    events[nevents - 1].events |= ARES_FD_EVENT_WRITE;\n  }\n\n  ares_process_fds(channel, events, nevents, ARES_PROCESS_FLAG_NONE);\n}",
      "fn_code_pos": [
        [
          266,
          0
        ],
        [
          289,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_process_fd",
        "parameters": {
          "channel": "ares_channel_t",
          "read_fd": "ares_socket_t",
          "write_fd": "ares_socket_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_socket_t *channel_socket_list(const ares_channel_t *channel,\n                                          size_t               *num)\n{\n  ares_slist_node_t *snode;\n  ares_array_t      *arr = ares_array_create(sizeof(ares_socket_t), NULL);\n\n  *num = 0;\n\n  if (arr == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (snode = ares_slist_node_first(channel->servers); snode != NULL;\n       snode = ares_slist_node_next(snode)) {\n    ares_server_t     *server = ares_slist_node_val(snode);\n    ares_llist_node_t *node;\n\n    for (node = ares_llist_node_first(server->connections); node != NULL;\n         node = ares_llist_node_next(node)) {\n      const ares_conn_t *conn = ares_llist_node_val(node);\n      ares_socket_t     *sptr;\n      ares_status_t      status;\n\n      if (conn->fd == ARES_SOCKET_BAD) {\n        continue;\n      }\n\n      status = ares_array_insert_last((void **)&sptr, arr);\n      if (status != ARES_SUCCESS) {\n        ares_array_destroy(arr); /* LCOV_EXCL_LINE: OutOfMemory */\n        return NULL;             /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      *sptr = conn->fd;\n    }\n  }\n\n  return ares_array_finish(arr, num);\n}",
      "fn_code_pos": [
        [
          291,
          0
        ],
        [
          328,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "channel_socket_list",
        "parameters": {
          "channel": "ares_channel_t",
          "num": "size_t"
        },
        "return_type": "ares_socket_t"
      }
    },
    {
      "fn_code": "void ares_process(ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)\n{\n  size_t            i;\n  size_t            num_sockets;\n  ares_socket_t    *socketlist;\n  ares_fd_events_t *events  = NULL;\n  size_t            nevents = 0;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  ares_channel_lock(channel);\n\n  /* There is no good way to iterate across an fd_set, instead we must pull a\n   * list of all known fds, and iterate across that checking against the fd_set.\n   */\n  socketlist = channel_socket_list(channel, &num_sockets);\n\n  /* Lets create an events array, maximum number is the number of sockets in\n   * the list, so we'll use that and just track entries with nevents */\n  if (num_sockets) {\n    events = ares_malloc_zero(sizeof(*events) * num_sockets);\n    if (events == NULL) {\n      goto done;\n    }\n  }\n\n  for (i = 0; i < num_sockets; i++) {\n    ares_bool_t had_read = ARES_FALSE;\n    if (read_fds && FD_ISSET(socketlist[i], read_fds)) {\n      nevents++;\n      events[nevents - 1].fd      = socketlist[i];\n      events[nevents - 1].events |= ARES_FD_EVENT_READ;\n      had_read                    = ARES_TRUE;\n    }\n    if (write_fds && FD_ISSET(socketlist[i], write_fds)) {\n      if (!had_read) {\n        nevents++;\n      }\n      events[nevents - 1].fd      = socketlist[i];\n      events[nevents - 1].events |= ARES_FD_EVENT_WRITE;\n    }\n  }\n\ndone:\n  ares_process_fds_nolock(channel, events, nevents, ARES_PROCESS_FLAG_NONE);\n  ares_free(events);\n  ares_free(socketlist);\n  ares_channel_unlock(channel);\n}",
      "fn_code_pos": [
        [
          333,
          0
        ],
        [
          383,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_process",
        "parameters": {
          "channel": "ares_channel_t",
          "read_fds": "fd_set",
          "write_fds": "fd_set"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_status_t process_write(ares_channel_t *channel,\n                                   ares_socket_t   write_fd)\n{\n  ares_conn_t  *conn = ares_conn_from_fd(channel, write_fd);\n  ares_status_t status;\n\n  if (conn == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* Mark as connected if we got here and TFO Initial not set */\n  if (!(conn->flags & ARES_CONN_FLAG_TFO_INITIAL)) {\n    conn->state_flags |= ARES_CONN_STATE_CONNECTED;\n  }\n\n  status = ares_conn_flush(conn);\n  if (status != ARES_SUCCESS) {\n    handle_conn_error(conn, ARES_TRUE, status);\n  }\n  return status;\n}",
      "fn_code_pos": [
        [
          385,
          0
        ],
        [
          405,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "process_write",
        "parameters": {
          "channel": "ares_channel_t",
          "write_fd": "ares_socket_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "void ares_process_pending_write(ares_channel_t *channel)\n{\n  ares_slist_node_t *node;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  ares_channel_lock(channel);\n  if (!channel->notify_pending_write) {\n    ares_channel_unlock(channel);\n    return;\n  }\n\n  /* Set as untriggerd before calling into ares_conn_flush(), this is\n   * because its possible ares_conn_flush() might cause additional data to\n   * be enqueued if there is some form of exception so it will need to recurse.\n   */\n  channel->notify_pending_write = ARES_FALSE;\n\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    ares_server_t *server = ares_slist_node_val(node);\n    ares_conn_t   *conn   = server->tcp_conn;\n    ares_status_t  status;\n\n    if (conn == NULL) {\n      continue;\n    }\n\n    /* Enqueue any pending data if there is any */\n    status = ares_conn_flush(conn);\n    if (status != ARES_SUCCESS) {\n      handle_conn_error(conn, ARES_TRUE, status);\n    }\n  }\n\n  ares_channel_unlock(channel);\n}",
      "fn_code_pos": [
        [
          407,
          0
        ],
        [
          445,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_process_pending_write",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_status_t read_conn_packets(ares_conn_t *conn)\n{\n  ares_bool_t           read_again;\n  ares_conn_err_t       err;\n  const ares_channel_t *channel = conn->server->channel;\n\n  do {\n    size_t         count;\n    size_t         len = 65535;\n    unsigned char *ptr;\n    size_t         start_len = ares_buf_len(conn->in_buf);\n\n    /* If UDP, lets write out a placeholder for the length indicator */\n    if (!(conn->flags & ARES_CONN_FLAG_TCP) &&\n        ares_buf_append_be16(conn->in_buf, 0) != ARES_SUCCESS) {\n      handle_conn_error(conn, ARES_FALSE /* not critical to connection */,\n                        ARES_SUCCESS);\n      return ARES_ENOMEM;\n    }\n\n    /* Get a buffer of sufficient size */\n    ptr = ares_buf_append_start(conn->in_buf, &len);\n\n    if (ptr == NULL) {\n      handle_conn_error(conn, ARES_FALSE /* not critical to connection */,\n                        ARES_SUCCESS);\n      return ARES_ENOMEM;\n    }\n\n    /* Read from socket */\n    err = ares_conn_read(conn, ptr, len, &count);\n\n    if (err != ARES_CONN_ERR_SUCCESS) {\n      ares_buf_append_finish(conn->in_buf, 0);\n      if (!(conn->flags & ARES_CONN_FLAG_TCP)) {\n        ares_buf_set_length(conn->in_buf, start_len);\n      }\n      break;\n    }\n\n    /* Record amount of data read */\n    ares_buf_append_finish(conn->in_buf, count);\n\n    /* Only loop if sockets support non-blocking operation, and are using UDP\n     * or are using TCP and read the maximum buffer size */\n    read_again = ARES_FALSE;\n    if (channel->sock_funcs.flags & ARES_SOCKFUNC_FLAG_NONBLOCKING &&\n        (!(conn->flags & ARES_CONN_FLAG_TCP) || count == len)) {\n      read_again = ARES_TRUE;\n    }\n\n    /* If UDP, overwrite length */\n    if (!(conn->flags & ARES_CONN_FLAG_TCP)) {\n      len = ares_buf_len(conn->in_buf);\n      ares_buf_set_length(conn->in_buf, start_len);\n      ares_buf_append_be16(conn->in_buf, (unsigned short)count);\n      ares_buf_set_length(conn->in_buf, len);\n    }\n    /* Try to read again only if *we* set up the socket, otherwise it may be\n     * a blocking socket and would cause recvfrom to hang. */\n  } while (read_again);\n\n  if (err != ARES_CONN_ERR_SUCCESS && err != ARES_CONN_ERR_WOULDBLOCK) {\n    handle_conn_error(conn, ARES_TRUE, ARES_ECONNREFUSED);\n    return ARES_ECONNREFUSED;\n  }\n\n  return ARES_SUCCESS;\n}",
      "fn_code_pos": [
        [
          447,
          0
        ],
        [
          515,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "read_conn_packets",
        "parameters": {
          "conn": "ares_conn_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_status_t ares_append_requeue_int(ares_array_t     **requeue,\n                                             requeue_type_t     type,\n                                             ares_query_t      *query,\n                                             ares_server_t     *server,\n                                             ares_status_t      status,\n                                             ares_dns_record_t *dnsrec)\n{\n  ares_requeue_t entry;\n\n  if (*requeue == NULL) {\n    *requeue = ares_array_create(sizeof(ares_requeue_t), NULL);\n    if (*requeue == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  ares_query_remove_from_conn(query);\n\n  entry.type   = type;\n  entry.qid    = query->qid;\n  entry.server = server;\n  entry.status = status;\n  entry.dnsrec = dnsrec;\n  return ares_array_insertdata_last(*requeue, &entry);\n}",
      "fn_code_pos": [
        [
          532,
          0
        ],
        [
          556,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_append_requeue_int",
        "parameters": {
          "requeue": "ares_array_t",
          "type": "requeue_type_t",
          "query": "ares_query_t",
          "server": "ares_server_t",
          "status": "ares_status_t",
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_status_t ares_append_requeue(ares_array_t **requeue,\n                                         ares_query_t  *query,\n                                         ares_server_t *server)\n{\n  return ares_append_requeue_int(requeue, REQUEUE_REQUEUE, query, server, 0,\n    NULL);\n}",
      "fn_code_pos": [
        [
          558,
          0
        ],
        [
          564,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_append_requeue",
        "parameters": {
          "requeue": "ares_array_t",
          "query": "ares_query_t",
          "server": "ares_server_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_status_t ares_append_endqueue(ares_array_t     **requeue,\n                                          ares_query_t      *query,\n                                          ares_status_t      status,\n                                          ares_dns_record_t *dnsrec)\n{\n  return ares_append_requeue_int(requeue, REQUEUE_ENDQUERY, query, NULL, status,\n    dnsrec);\n}",
      "fn_code_pos": [
        [
          566,
          0
        ],
        [
          573,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_append_endqueue",
        "parameters": {
          "requeue": "ares_array_t",
          "query": "ares_query_t",
          "status": "ares_status_t",
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_status_t read_answers(ares_conn_t *conn, const ares_timeval_t *now)\n{\n  ares_status_t   status;\n  ares_channel_t *channel  = conn->server->channel;\n  ares_array_t   *requeue  = NULL;\n\n  /* Process all queued answers */\n  while (1) {\n    unsigned short       dns_len  = 0;\n    const unsigned char *data     = NULL;\n    size_t               data_len = 0;\n\n    /* Tag so we can roll back */\n    ares_buf_tag(conn->in_buf);\n\n    /* Read length indicator */\n    status = ares_buf_fetch_be16(conn->in_buf, &dns_len);\n    if (status != ARES_SUCCESS) {\n      ares_buf_tag_rollback(conn->in_buf);\n      break;\n    }\n\n    /* Not enough data for a full response yet */\n    status = ares_buf_consume(conn->in_buf, dns_len);\n    if (status != ARES_SUCCESS) {\n      ares_buf_tag_rollback(conn->in_buf);\n      break;\n    }\n\n    /* Can't fail except for misuse */\n    data = ares_buf_tag_fetch(conn->in_buf, &data_len);\n    if (data == NULL || data_len < 2) {\n      ares_buf_tag_clear(conn->in_buf);\n      break;\n    }\n\n    /* Strip off 2 bytes length */\n    data     += 2;\n    data_len -= 2;\n\n    /* We finished reading this answer; process it */\n    status = process_answer(channel, data, data_len, conn, now, &requeue);\n    if (status != ARES_SUCCESS) {\n      handle_conn_error(conn, ARES_TRUE, status);\n      goto cleanup;\n    }\n\n    /* Since we processed the answer, clear the tag so space can be reclaimed */\n    ares_buf_tag_clear(conn->in_buf);\n  }\n\ncleanup:\n\n  /* Flush requeue */\n  while (ares_array_len(requeue) > 0) {\n    ares_query_t  *query;\n    ares_requeue_t entry;\n    ares_status_t  internal_status;\n\n    internal_status = ares_array_claim_at(&entry, sizeof(entry), requeue, 0);\n    if (internal_status != ARES_SUCCESS) {\n      break;\n    }\n\n    query = ares_htable_szvp_get_direct(channel->queries_by_qid, entry.qid);\n\n    if (entry.type == REQUEUE_REQUEUE) {\n      /* query disappeared */\n      if (query == NULL) {\n        continue;\n      }\n      internal_status = ares_send_query(entry.server, query, now);\n      /* We only care about ARES_ENOMEM */\n      if (internal_status == ARES_ENOMEM) {\n        status = ARES_ENOMEM;\n      }\n    } else { /* REQUEUE_ENDQUERY */\n      if (query != NULL) {\n        query->callback(query->arg, entry.status, query->timeouts, entry.dnsrec);\n        ares_free_query(query);\n      }\n      ares_dns_record_destroy(entry.dnsrec);\n    }\n  }\n  /* Don't forget to send notification if queue emptied */\n  if (requeue != NULL) {\n    ares_queue_notify_empty(channel);\n  }\n  ares_array_destroy(requeue);\n\n  return status;\n}",
      "fn_code_pos": [
        [
          575,
          0
        ],
        [
          666,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "read_answers",
        "parameters": {
          "conn": "ares_conn_t",
          "now": "ares_timeval_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_status_t process_read(ares_channel_t       *channel,\n                                  ares_socket_t         read_fd,\n                                  const ares_timeval_t *now)\n{\n  ares_conn_t  *conn = ares_conn_from_fd(channel, read_fd);\n  ares_status_t status;\n\n  if (conn == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* TODO: There might be a potential issue here where there was a read that\n   *       read some data, then looped and read again and got a disconnect.\n   *       Right now, that would cause a resend instead of processing the data\n   *       we have.  This is fairly unlikely to occur due to only looping if\n   *       a full buffer of 65535 bytes was read. */\n  status = read_conn_packets(conn);\n\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return read_answers(conn, now);\n}",
      "fn_code_pos": [
        [
          668,
          0
        ],
        [
          691,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "process_read",
        "parameters": {
          "channel": "ares_channel_t",
          "read_fd": "ares_socket_t",
          "now": "ares_timeval_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_status_t process_timeouts(ares_channel_t       *channel,\n                                      const ares_timeval_t *now)\n{\n  ares_slist_node_t *node;\n  ares_status_t      status = ARES_SUCCESS;\n\n  /* Just keep popping off the first as this list will re-sort as things come\n   * and go.  We don't want to try to rely on 'next' as some operation might\n   * cause a cleanup of that pointer and would become invalid */\n  while ((node = ares_slist_node_first(channel->queries_by_timeout)) != NULL) {\n    ares_query_t *query = ares_slist_node_val(node);\n    ares_conn_t  *conn;\n\n    /* Since this is sorted, as soon as we hit a query that isn't timed out,\n     * break */\n    if (!ares_timedout(now, &query->timeout)) {\n      break;\n    }\n\n    query->timeouts++;\n\n    conn = query->conn;\n    server_increment_failures(conn->server, query->using_tcp);\n    status = ares_requeue_query(query, now, ARES_ETIMEOUT, ARES_TRUE, NULL,\n      NULL);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n  }\ndone:\n  if (status == ARES_ENOMEM) {\n    return ARES_ENOMEM;\n  }\n  return ARES_SUCCESS;\n}",
      "fn_code_pos": [
        [
          694,
          0
        ],
        [
          728,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "process_timeouts",
        "parameters": {
          "channel": "ares_channel_t",
          "now": "ares_timeval_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_status_t rewrite_without_edns(ares_query_t *query)\n{\n  ares_status_t status = ARES_SUCCESS;\n  size_t        i;\n  ares_bool_t   found_opt_rr = ARES_FALSE;\n\n  /* Find and remove the OPT RR record */\n  for (i = 0; i < ares_dns_record_rr_cnt(query->query, ARES_SECTION_ADDITIONAL);\n       i++) {\n    const ares_dns_rr_t *rr;\n    rr = ares_dns_record_rr_get(query->query, ARES_SECTION_ADDITIONAL, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      ares_dns_record_rr_del(query->query, ARES_SECTION_ADDITIONAL, i);\n      found_opt_rr = ARES_TRUE;\n      break;\n    }\n  }\n\n  if (!found_opt_rr) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\ndone:\n  return status;\n}",
      "fn_code_pos": [
        [
          730,
          0
        ],
        [
          755,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "rewrite_without_edns",
        "parameters": {
          "query": "ares_query_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_bool_t issue_might_be_edns(const ares_dns_record_t *req,\n                                       const ares_dns_record_t *rsp)\n{\n  const ares_dns_rr_t *rr;\n\n  /* If we use EDNS and server answers with FORMERR without an OPT RR, the\n   * protocol extension is not understood by the responder. We must retry the\n   * query without EDNS enabled. */\n  if (ares_dns_record_get_rcode(rsp) != ARES_RCODE_FORMERR) {\n    return ARES_FALSE;\n  }\n\n  rr = ares_dns_get_opt_rr_const(req);\n  if (rr == NULL) {\n    /* We didn't send EDNS */\n    return ARES_FALSE;\n  }\n\n  if (ares_dns_get_opt_rr_const(rsp) == NULL) {\n    /* Spec says EDNS won't be echo'd back on non-supporting servers, so\n     * retry without EDNS */\n    return ARES_TRUE;\n  }\n\n  /* As per issue #911 some non-compliant servers that do indeed support EDNS\n   * but don't support unrecognized option codes exist.  At this point we\n   * expect them to have also returned an EDNS opt record, but we may remove\n   * that check in the future. Lets detect this situation if we're sending\n   * option codes */\n  if (ares_dns_rr_get_opt_cnt(rr, ARES_RR_OPT_OPTIONS) == 0) {\n    /* We didn't send any option codes */\n    return ARES_FALSE;\n  }\n\n  if (ares_dns_get_opt_rr_const(rsp) != NULL) {\n    /* At this time we're requiring the server to respond with EDNS opt\n     * records since that's what has been observed in the field.  We might\n     * find in the future we have to remove this, who knows. Lets go\n     * ahead and force a retry without EDNS*/\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          757,
          0
        ],
        [
          800,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "issue_might_be_edns",
        "parameters": {
          "req": "ares_dns_record_t",
          "rsp": "ares_dns_record_t"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_status_t process_answer(ares_channel_t      *channel,\n                                    const unsigned char *abuf, size_t alen,\n                                    ares_conn_t          *conn,\n                                    const ares_timeval_t *now,\n                                    ares_array_t        **requeue)\n{\n  ares_query_t      *query;\n  /* Cache these as once ares_send_query() gets called, it may end up\n   * invalidating the connection all-together */\n  ares_server_t     *server  = conn->server;\n  ares_dns_record_t *rdnsrec = NULL;\n  ares_status_t      status;\n  ares_bool_t        is_cached = ARES_FALSE;\n\n  /* UDP can have 0-byte messages, drop them to the ground */\n  if (alen == 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* Parse the response */\n  status = ares_dns_parse(abuf, alen, 0, &rdnsrec);\n  if (status != ARES_SUCCESS) {\n    /* Malformations are never accepted */\n    status = ARES_EBADRESP;\n    goto cleanup;\n  }\n\n  /* Find the query corresponding to this packet. The queries are\n   * hashed/bucketed by query id, so this lookup should be quick.\n   */\n  query = ares_htable_szvp_get_direct(channel->queries_by_qid,\n                                      ares_dns_record_get_id(rdnsrec));\n  if (!query) {\n    /* We may have stopped listening for this query, that's ok */\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* Both the query id and the questions must be the same. We will drop any\n   * replies that aren't for the same query as this is considered invalid. */\n  if (!same_questions(query, rdnsrec)) {\n    /* Possible qid conflict due to delayed response, that's ok */\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* Validate DNS cookie in response. This function may need to requeue the\n   * query. */\n  if (ares_cookie_validate(query, rdnsrec, conn, now, requeue)\n      != ARES_SUCCESS) {\n    /* Drop response and return */\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* At this point we know we've received an answer for this query, so we should\n   * remove it from the connection's queue so we can possibly invalidate the\n   * connection. Delay cleaning up the connection though as we may enqueue\n   * something new.  */\n  ares_llist_node_destroy(query->node_queries_to_conn);\n  query->node_queries_to_conn = NULL;\n\n  /* There are old servers that don't understand EDNS at all, then some servers\n   * that have non-compliant implementations.  Lets try to detect this sort\n   * of thing. */\n  if (issue_might_be_edns(query->query, rdnsrec)) {\n    status = rewrite_without_edns(query);\n    if (status != ARES_SUCCESS) {\n      end_query(channel, server, query, status, NULL, NULL);\n      goto cleanup;\n    }\n\n    /* Requeue to same server */\n    status = ares_append_requeue(requeue, query, server);\n    goto cleanup;\n  }\n\n  /* If we got a truncated UDP packet and are not ignoring truncation,\n   * don't accept the packet, and switch the query to TCP if we hadn't\n   * done so already.\n   */\n  if (ares_dns_record_get_flags(rdnsrec) & ARES_FLAG_TC &&\n      !(conn->flags & ARES_CONN_FLAG_TCP) &&\n      !(channel->flags & ARES_FLAG_IGNTC)) {\n    query->using_tcp = ARES_TRUE;\n    status = ares_append_requeue(requeue, query, NULL);\n    /* Status will reflect success except on memory error, which is good since\n     * requeuing to TCP is ok */\n    goto cleanup;\n  }\n\n  /* If we aren't passing through all error packets, discard packets\n   * with SERVFAIL, NOTIMP, or REFUSED response codes.\n   */\n  if (!(channel->flags & ARES_FLAG_NOCHECKRESP)) {\n    ares_dns_rcode_t rcode = ares_dns_record_get_rcode(rdnsrec);\n    if (rcode == ARES_RCODE_SERVFAIL || rcode == ARES_RCODE_NOTIMP ||\n        rcode == ARES_RCODE_REFUSED) {\n      switch (rcode) {\n        case ARES_RCODE_SERVFAIL:\n          status = ARES_ESERVFAIL;\n          break;\n        case ARES_RCODE_NOTIMP:\n          status = ARES_ENOTIMP;\n          break;\n        case ARES_RCODE_REFUSED:\n          status = ARES_EREFUSED;\n          break;\n        default:\n          break;\n      }\n\n      server_increment_failures(server, query->using_tcp);\n      status = ares_requeue_query(query, now, status, ARES_TRUE, rdnsrec,\n        requeue);\n      rdnsrec = NULL; /* Free'd by ares_requeue_query() */\n\n      if (status != ARES_ENOMEM) {\n        /* Should any of these cause a connection termination?\n         * Maybe SERVER_FAILURE? */\n        status = ARES_SUCCESS;\n      }\n      goto cleanup;\n    }\n  }\n\n  /* If cache insertion was successful, it took ownership.  We ignore\n   * other cache insertion failures. */\n  ares_qcache_insert(channel, now, query, rdnsrec);\n\n  server_set_good(server, query->using_tcp);\n  end_query(channel, server, query, ARES_SUCCESS, rdnsrec, requeue);\n  rdnsrec = NULL; /* Free'd by the requeue */\n\n  status = ARES_SUCCESS;\n\ncleanup:\n  /* Don't cleanup the cached pointer to the dns response */\n  if (!is_cached) {\n    ares_dns_record_destroy(rdnsrec);\n  }\n\n  return status;\n}",
      "fn_code_pos": [
        [
          805,
          0
        ],
        [
          948,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "process_answer",
        "parameters": {
          "channel": "ares_channel_t",
          "abuf": "unsigned char",
          "alen": "size_t",
          "conn": "ares_conn_t",
          "now": "ares_timeval_t",
          "requeue": "ares_array_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static void handle_conn_error(ares_conn_t *conn, ares_bool_t critical_failure,\n                              ares_status_t failure_status)\n{\n  ares_server_t *server = conn->server;\n\n  /* Increment failures first before requeue so it is unlikely to requeue\n   * to the same server */\n  if (critical_failure) {\n    server_increment_failures(\n      server, (conn->flags & ARES_CONN_FLAG_TCP) ? ARES_TRUE : ARES_FALSE);\n  }\n\n  /* This will requeue any connections automatically */\n  ares_close_connection(conn, failure_status);\n}",
      "fn_code_pos": [
        [
          950,
          0
        ],
        [
          964,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "handle_conn_error",
        "parameters": {
          "conn": "ares_conn_t",
          "critical_failure": "ares_bool_t",
          "failure_status": "ares_status_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "ares_status_t ares_requeue_query(ares_query_t *query, const ares_timeval_t *now,\n                                 ares_status_t            status,\n                                 ares_bool_t              inc_try_count,\n                                 ares_dns_record_t       *dnsrec,\n                                 ares_array_t           **requeue)\n{\n  ares_channel_t *channel   = query->channel;\n  size_t          max_tries = ares_slist_len(channel->servers) * channel->tries;\n\n  ares_query_remove_from_conn(query);\n\n  if (status != ARES_SUCCESS) {\n    query->error_status = status;\n  }\n\n  if (inc_try_count) {\n    query->try_count++;\n  }\n\n  if (query->try_count < max_tries && !query->no_retries) {\n    ares_dns_record_destroy(dnsrec);\n    if (requeue != NULL) {\n      return ares_append_requeue(requeue, query, NULL);\n    }\n    return ares_send_query(NULL, query, now);\n  }\n\n  /* If we are here, all attempts to perform query failed. */\n  if (query->error_status == ARES_SUCCESS) {\n    query->error_status = ARES_ETIMEOUT;\n  }\n\n  end_query(channel, NULL, query, query->error_status, dnsrec, requeue);\n  return ARES_ETIMEOUT;\n}",
      "fn_code_pos": [
        [
          969,
          0
        ],
        [
          1003,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_requeue_query",
        "parameters": {
          "query": "ares_query_t",
          "now": "ares_timeval_t",
          "status": "ares_status_t",
          "inc_try_count": "ares_bool_t",
          "dnsrec": "ares_dns_record_t",
          "requeue": "ares_array_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static size_t count_highest_prio_servers(const ares_channel_t *channel)\n{\n  ares_slist_node_t *node;\n  size_t             cnt                  = 0;\n  size_t             last_consec_failures = SIZE_MAX;\n\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    const ares_server_t *server = ares_slist_node_val(node);\n\n    if (last_consec_failures != SIZE_MAX &&\n        last_consec_failures < server->consec_failures) {\n      break;\n    }\n\n    last_consec_failures = server->consec_failures;\n    cnt++;\n  }\n\n  return cnt;\n}",
      "fn_code_pos": [
        [
          1009,
          0
        ],
        [
          1029,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "count_highest_prio_servers",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": "size_t"
      }
    },
    {
      "fn_code": "static ares_server_t *ares_random_server(ares_channel_t *channel)\n{\n  unsigned char      c;\n  size_t             cnt;\n  size_t             idx;\n  ares_slist_node_t *node;\n  size_t             num_servers = count_highest_prio_servers(channel);\n\n  /* Silence coverity, not possible */\n  if (num_servers == 0) {\n    return NULL;\n  }\n\n  ares_rand_bytes(channel->rand_state, &c, 1);\n\n  cnt = c;\n  idx = cnt % num_servers;\n\n  cnt = 0;\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    if (cnt == idx) {\n      return ares_slist_node_val(node);\n    }\n\n    cnt++;\n  }\n\n  return NULL;\n}",
      "fn_code_pos": [
        [
          1034,
          0
        ],
        [
          1063,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_random_server",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": "ares_server_t"
      }
    },
    {
      "fn_code": "static void server_probe_cb(void *arg, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)\n{\n  (void)arg;\n  (void)status;\n  (void)timeouts;\n  (void)dnsrec;\n  /* Nothing to do, the logic internally will handle success/fail of this */\n}",
      "fn_code_pos": [
        [
          1065,
          0
        ],
        [
          1073,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "server_probe_cb",
        "parameters": {
          "arg": "void",
          "status": "ares_status_t",
          "timeouts": "size_t",
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void ares_probe_failed_server(ares_channel_t      *channel,\n                                     const ares_server_t *server,\n                                     const ares_query_t  *query)\n{\n  const ares_server_t *last_server = ares_slist_last_val(channel->servers);\n  unsigned short       r;\n  ares_timeval_t       now;\n  ares_slist_node_t   *node;\n  ares_server_t       *probe_server = NULL;\n\n  /* If no servers have failures, or we're not configured with a server retry\n   * chance, then nothing to probe */\n  if ((last_server != NULL && last_server->consec_failures == 0) ||\n      channel->server_retry_chance == 0) {\n    return;\n  }\n\n  /* Generate a random value to decide whether to retry a failed server. The\n   * probability to use is 1/channel->server_retry_chance, rounded up to a\n   * precision of 1/2^B where B is the number of bits in the random value.\n   * We use an unsigned short for the random value for increased precision.\n   */\n  ares_rand_bytes(channel->rand_state, (unsigned char *)&r, sizeof(r));\n  if (r % channel->server_retry_chance != 0) {\n    return;\n  }\n\n  /* Select the first server with failures to retry that has passed the retry\n   * timeout and doesn't already have a pending probe */\n  ares_tvnow(&now);\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    ares_server_t *node_val = ares_slist_node_val(node);\n    if (node_val != NULL && node_val->consec_failures > 0 &&\n        !node_val->probe_pending &&\n        ares_timedout(&now, &node_val->next_retry_time)) {\n      probe_server = node_val;\n      break;\n    }\n  }\n\n  /* Either nothing to probe or the query was enqueud to the same server\n   * we were going to probe. Do nothing. */\n  if (probe_server == NULL || server == probe_server) {\n    return;\n  }\n\n  /* Enqueue an identical query onto the specified server without honoring\n   * the cache or allowing retries.  We want to make sure it only attempts to\n   * use the server in question */\n  probe_server->probe_pending = ARES_TRUE;\n  ares_send_nolock(channel, probe_server,\n                   ARES_SEND_FLAG_NOCACHE | ARES_SEND_FLAG_NORETRY,\n                   query->query, server_probe_cb, NULL, NULL);\n}",
      "fn_code_pos": [
        [
          1076,
          0
        ],
        [
          1130,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_probe_failed_server",
        "parameters": {
          "channel": "ares_channel_t",
          "server": "ares_server_t",
          "query": "ares_query_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static size_t ares_calc_query_timeout(const ares_query_t   *query,\n                                      const ares_server_t  *server,\n                                      const ares_timeval_t *now)\n{\n  const ares_channel_t *channel  = query->channel;\n  size_t                timeout  = ares_metrics_server_timeout(server, now);\n  size_t                timeplus = timeout;\n  size_t                rounds;\n  size_t                num_servers = ares_slist_len(channel->servers);\n\n  if (num_servers == 0) {\n    return 0; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* For each trip through the entire server list, we want to double the\n   * retry from the last retry */\n  rounds = (query->try_count / num_servers);\n  if (rounds > 0) {\n    timeplus <<= rounds;\n  }\n\n  if (channel->maxtimeout && timeplus > channel->maxtimeout) {\n    timeplus = channel->maxtimeout;\n  }\n\n  /* Add some jitter to the retry timeout.\n   *\n   * Jitter is needed in situation when resolve requests are performed\n   * simultaneously from multiple hosts and DNS server throttle these requests.\n   * Adding randomness allows to avoid synchronisation of retries.\n   *\n   * Value of timeplus adjusted randomly to the range [0.5 * timeplus,\n   * timeplus].\n   */\n  if (rounds > 0) {\n    unsigned short r;\n    float          delta_multiplier;\n\n    ares_rand_bytes(channel->rand_state, (unsigned char *)&r, sizeof(r));\n    delta_multiplier  = ((float)r / USHRT_MAX) * 0.5f;\n    timeplus         -= (size_t)((float)timeplus * delta_multiplier);\n  }\n\n  /* We want explicitly guarantee that timeplus is greater or equal to timeout\n   * specified in channel options. */\n  if (timeplus < timeout) {\n    timeplus = timeout;\n  }\n\n  return timeplus;\n}",
      "fn_code_pos": [
        [
          1132,
          0
        ],
        [
          1182,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_calc_query_timeout",
        "parameters": {
          "query": "ares_query_t",
          "server": "ares_server_t",
          "now": "ares_timeval_t"
        },
        "return_type": "size_t"
      }
    },
    {
      "fn_code": "static ares_conn_t *ares_fetch_connection(const ares_channel_t *channel,\n                                          ares_server_t        *server,\n                                          const ares_query_t   *query)\n{\n  ares_llist_node_t *node;\n  ares_conn_t       *conn;\n\n  if (query->using_tcp) {\n    return server->tcp_conn;\n  }\n\n  /* Fetch existing UDP connection */\n  node = ares_llist_node_first(server->connections);\n  if (node == NULL) {\n    return NULL;\n  }\n\n  conn = ares_llist_node_val(node);\n  /* Not UDP, skip */\n  if (conn->flags & ARES_CONN_FLAG_TCP) {\n    return NULL;\n  }\n\n  /* If the associated server has failures, don't use it.  It should be cleaned\n   * up later. */\n  if (conn->server->consec_failures > 0) {\n    return NULL;\n  }\n\n  /* Used too many times */\n  if (channel->udp_max_queries > 0 &&\n      conn->total_queries >= channel->udp_max_queries) {\n    return NULL;\n  }\n\n  return conn;\n}",
      "fn_code_pos": [
        [
          1184,
          0
        ],
        [
          1220,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_fetch_connection",
        "parameters": {
          "channel": "ares_channel_t",
          "server": "ares_server_t",
          "query": "ares_query_t"
        },
        "return_type": "ares_conn_t"
      }
    },
    {
      "fn_code": "static ares_status_t ares_conn_query_write(ares_conn_t          *conn,\n                                           ares_query_t         *query,\n                                           const ares_timeval_t *now)\n{\n  ares_server_t  *server  = conn->server;\n  ares_channel_t *channel = server->channel;\n  ares_status_t   status;\n\n  status = ares_cookie_apply(query->query, conn, now);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* We write using the TCP format even for UDP, we just strip the length\n   * before putting on the wire */\n  status = ares_dns_write_buf_tcp(query->query, conn->out_buf);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Not pending a TFO write and not connected, so we can't even try to\n   * write until we get a signal */\n  if (conn->flags & ARES_CONN_FLAG_TCP &&\n      !(conn->state_flags & ARES_CONN_STATE_CONNECTED) &&\n      !(conn->flags & ARES_CONN_FLAG_TFO_INITIAL)) {\n    return ARES_SUCCESS;\n  }\n\n  /* Delay actual write if possible (TCP only, and only if callback\n   * configured) */\n  if (channel->notify_pending_write_cb && !channel->notify_pending_write &&\n      conn->flags & ARES_CONN_FLAG_TCP) {\n    channel->notify_pending_write = ARES_TRUE;\n    channel->notify_pending_write_cb(channel->notify_pending_write_cb_data);\n    return ARES_SUCCESS;\n  }\n\n  /* Unfortunately we need to write right away and can't aggregate multiple\n   * queries into a single write. */\n  return ares_conn_flush(conn);\n}",
      "fn_code_pos": [
        [
          1222,
          0
        ],
        [
          1262,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_conn_query_write",
        "parameters": {
          "conn": "ares_conn_t",
          "query": "ares_query_t",
          "now": "ares_timeval_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_send_query(ares_server_t *requested_server,\n                              ares_query_t *query, const ares_timeval_t *now)\n{\n  ares_channel_t *channel = query->channel;\n  ares_server_t  *server;\n  ares_conn_t    *conn;\n  size_t          timeplus;\n  ares_status_t   status;\n  ares_bool_t     probe_downed_server = ARES_TRUE;\n\n  /* Choose the server to send the query to */\n  if (requested_server != NULL) {\n    server = requested_server;\n  } else {\n    /* If rotate is turned on, do a random selection */\n    if (channel->rotate) {\n      server = ares_random_server(channel);\n    } else {\n      /* First server in list */\n      server = ares_slist_first_val(channel->servers);\n    }\n  }\n\n  if (server == NULL) {\n    end_query(channel, server, query, ARES_ENOSERVER /* ? */, NULL, NULL);\n    return ARES_ENOSERVER;\n  }\n\n  /* If a query is directed to a specific query, or the server chosen has\n   * failures, or the query is being retried, don't probe for downed servers */\n  if (requested_server != NULL || server->consec_failures > 0 ||\n      query->try_count != 0) {\n    probe_downed_server = ARES_FALSE;\n  }\n\n  conn = ares_fetch_connection(channel, server, query);\n  if (conn == NULL) {\n    status = ares_open_connection(&conn, channel, server, query->using_tcp);\n    switch (status) {\n      /* Good result, continue on */\n      case ARES_SUCCESS:\n        break;\n\n      /* These conditions are retryable as they are server-specific\n       * error codes */\n      case ARES_ECONNREFUSED:\n      case ARES_EBADFAMILY:\n        server_increment_failures(server, query->using_tcp);\n        return ares_requeue_query(query, now, status, ARES_TRUE, NULL, NULL);\n\n      /* Anything else is not retryable, likely ENOMEM */\n      default:\n        end_query(channel, server, query, status, NULL, NULL);\n        return status;\n    }\n  }\n\n  /* Write the query */\n  status = ares_conn_query_write(conn, query, now);\n  switch (status) {\n    /* Good result, continue on */\n    case ARES_SUCCESS:\n      break;\n\n    case ARES_ENOMEM:\n      /* Not retryable */\n      end_query(channel, server, query, status, NULL, NULL);\n      return status;\n\n    /* These conditions are retryable as they are server-specific\n     * error codes */\n    case ARES_ECONNREFUSED:\n    case ARES_EBADFAMILY:\n      handle_conn_error(conn, ARES_TRUE, status);\n      status = ares_requeue_query(query, now, status, ARES_TRUE, NULL, NULL);\n      if (status == ARES_ETIMEOUT) {\n        status = ARES_ECONNREFUSED;\n      }\n      return status;\n\n    default:\n      server_increment_failures(server, query->using_tcp);\n      status = ares_requeue_query(query, now, status, ARES_TRUE, NULL, NULL);\n      return status;\n  }\n\n  timeplus = ares_calc_query_timeout(query, server, now);\n  /* Keep track of queries bucketed by timeout, so we can process\n   * timeout events quickly.\n   */\n  ares_slist_node_destroy(query->node_queries_by_timeout);\n  query->ts      = *now;\n  query->timeout = *now;\n  timeadd(&query->timeout, timeplus);\n  query->node_queries_by_timeout =\n    ares_slist_insert(channel->queries_by_timeout, query);\n  if (!query->node_queries_by_timeout) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    end_query(channel, server, query, ARES_ENOMEM, NULL, NULL);\n    return ARES_ENOMEM;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Keep track of queries bucketed by connection, so we can process errors\n   * quickly. */\n  ares_llist_node_destroy(query->node_queries_to_conn);\n  query->node_queries_to_conn =\n    ares_llist_insert_last(conn->queries_to_conn, query);\n\n  if (query->node_queries_to_conn == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    end_query(channel, server, query, ARES_ENOMEM, NULL, NULL);\n    return ARES_ENOMEM;\n    /* LCOV_EXCL_STOP */\n  }\n\n  query->conn = conn;\n  conn->total_queries++;\n\n  /* We just successfully enqueud a query, see if we should probe downed\n   * servers. */\n  if (probe_downed_server) {\n    ares_probe_failed_server(channel, server, query);\n  }\n\n  if (channel->query_enqueue_cb) {\n    channel->query_enqueue_cb(channel->query_enqueue_cb_data);\n  }\n\n  return ARES_SUCCESS;\n}",
      "fn_code_pos": [
        [
          1264,
          0
        ],
        [
          1394,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_send_query",
        "parameters": {
          "requested_server": "ares_server_t",
          "query": "ares_query_t",
          "now": "ares_timeval_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_bool_t same_questions(const ares_query_t      *query,\n                                  const ares_dns_record_t *arec)\n{\n  size_t                   i;\n  ares_bool_t              rv      = ARES_FALSE;\n  const ares_dns_record_t *qrec    = query->query;\n  const ares_channel_t    *channel = query->channel;\n\n\n  if (ares_dns_record_query_cnt(qrec) != ares_dns_record_query_cnt(arec)) {\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_query_cnt(qrec); i++) {\n    const char         *qname = NULL;\n    const char         *aname = NULL;\n    ares_dns_rec_type_t qtype;\n    ares_dns_rec_type_t atype;\n    ares_dns_class_t    qclass;\n    ares_dns_class_t    aclass;\n\n    if (ares_dns_record_query_get(qrec, i, &qname, &qtype, &qclass) !=\n          ARES_SUCCESS ||\n        qname == NULL) {\n      goto done;\n    }\n\n    if (ares_dns_record_query_get(arec, i, &aname, &atype, &aclass) !=\n          ARES_SUCCESS ||\n        aname == NULL) {\n      goto done;\n    }\n\n    if (qtype != atype || qclass != aclass) {\n      goto done;\n    }\n\n    if (channel->flags & ARES_FLAG_DNS0x20 && !query->using_tcp) {\n      /* NOTE: for DNS 0x20, part of the protection is to use a case-sensitive\n       *       comparison of the DNS query name.  This expects the upstream DNS\n       *       server to preserve the case of the name in the response packet.\n       *       https://datatracker.ietf.org/doc/html/draft-vixie-dnsext-dns0x20-00\n       */\n      if (!ares_streq(qname, aname)) {\n        goto done;\n      }\n    } else {\n      /* without DNS0x20 use case-insensitive matching */\n      if (!ares_strcaseeq(qname, aname)) {\n        goto done;\n      }\n    }\n  }\n\n  rv = ARES_TRUE;\n\ndone:\n  return rv;\n}",
      "fn_code_pos": [
        [
          1396,
          0
        ],
        [
          1454,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "same_questions",
        "parameters": {
          "query": "ares_query_t",
          "arec": "ares_dns_record_t"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static void ares_detach_query(ares_query_t *query)\n{\n  /* Remove the query from all the lists in which it is linked */\n  ares_query_remove_from_conn(query);\n  ares_htable_szvp_remove(query->channel->queries_by_qid, query->qid);\n  ares_llist_node_destroy(query->node_all_queries);\n  query->node_all_queries = NULL;\n}",
      "fn_code_pos": [
        [
          1456,
          0
        ],
        [
          1463,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_detach_query",
        "parameters": {
          "query": "ares_query_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void end_query(ares_channel_t *channel, ares_server_t *server,\n                      ares_query_t *query, ares_status_t status,\n                      ares_dns_record_t *dnsrec, ares_array_t **requeue)\n{\n  /* If we were probing for the server to come back online, lets mark it as\n   * no longer being probed */\n  if (server != NULL) {\n    server->probe_pending = ARES_FALSE;\n  }\n\n  ares_metrics_record(query, server, status, dnsrec);\n\n  /* Delay calling the query callback */\n  if (requeue != NULL) {\n    ares_append_endqueue(requeue, query, status, dnsrec);\n    return;\n  }\n\n  /* Invoke the callback. */\n  query->callback(query->arg, status, query->timeouts, dnsrec);\n  ares_free_query(query);\n\n  /* Check and notify if no other queries are enqueued on the channel.  This\n   * must come after the callback and freeing the query for 2 reasons.\n   *  1) The callback itself may enqueue a new query\n   *  2) Technically the current query isn't detached until it is free()'d.\n   */\n  ares_queue_notify_empty(channel);\n}",
      "fn_code_pos": [
        [
          1465,
          0
        ],
        [
          1493,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "end_query",
        "parameters": {
          "channel": "ares_channel_t",
          "server": "ares_server_t",
          "query": "ares_query_t",
          "status": "ares_status_t",
          "dnsrec": "ares_dns_record_t",
          "requeue": "ares_array_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "void ares_free_query(ares_query_t *query)\n{\n  ares_detach_query(query);\n  /* Zero out some important stuff, to help catch bugs */\n  query->callback = NULL;\n  query->arg      = NULL;\n  /* Deallocate the memory associated with the query */\n  ares_dns_record_destroy(query->query);\n\n  ares_free(query);\n}",
      "fn_code_pos": [
        [
          1495,
          0
        ],
        [
          1505,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_free_query",
        "parameters": {
          "query": "ares_query_t"
        },
        "return_type": "void"
      }
    }
  ],
  "fn_declaraion": [
    {
      "fn_code": "timeadd(ares_timeval_t *now, size_t millisecs)",
      "fn_dec_pos": [
        [
          47,
          21
        ],
        [
          47,
          67
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "timeadd",
        "parameters": {
          "now": "ares_timeval_t",
          "millisecs": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "process_write(ares_channel_t *channel,\n                                   ares_socket_t   write_fd)",
      "fn_dec_pos": [
        [
          48,
          21
        ],
        [
          49,
          60
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "process_write",
        "parameters": {
          "channel": "ares_channel_t",
          "write_fd": "ares_socket_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "process_read(ares_channel_t       *channel,\n                                  ares_socket_t         read_fd,\n                                  const ares_timeval_t *now)",
      "fn_dec_pos": [
        [
          50,
          21
        ],
        [
          52,
          60
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "process_read",
        "parameters": {
          "channel": "ares_channel_t",
          "read_fd": "ares_socket_t",
          "now": "ares_timeval_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "process_timeouts(ares_channel_t       *channel,\n                                      const ares_timeval_t *now)",
      "fn_dec_pos": [
        [
          53,
          21
        ],
        [
          54,
          64
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "process_timeouts",
        "parameters": {
          "channel": "ares_channel_t",
          "now": "ares_timeval_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "process_answer(ares_channel_t      *channel,\n                                    const unsigned char *abuf, size_t alen,\n                                    ares_conn_t          *conn,\n                                    const ares_timeval_t *now,\n                                    ares_array_t        **requeue)",
      "fn_dec_pos": [
        [
          55,
          21
        ],
        [
          59,
          66
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "process_answer",
        "parameters": {
          "channel": "ares_channel_t",
          "abuf": "unsigned char",
          "alen": "size_t",
          "conn": "ares_conn_t",
          "now": "ares_timeval_t",
          "requeue": "ares_array_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "handle_conn_error(ares_conn_t *conn, ares_bool_t critical_failure,\n                              ares_status_t failure_status)",
      "fn_dec_pos": [
        [
          60,
          12
        ],
        [
          61,
          59
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "handle_conn_error",
        "parameters": {
          "conn": "ares_conn_t",
          "critical_failure": "ares_bool_t",
          "failure_status": "ares_status_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "same_questions(const ares_query_t      *query,\n                                  const ares_dns_record_t *arec)",
      "fn_dec_pos": [
        [
          62,
          19
        ],
        [
          63,
          64
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "same_questions",
        "parameters": {
          "query": "ares_query_t",
          "arec": "ares_dns_record_t"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "end_query(ares_channel_t *channel, ares_server_t *server,\n                             ares_query_t *query, ares_status_t status,\n                             ares_dns_record_t *dnsrec,\n                             ares_array_t **requeue)",
      "fn_dec_pos": [
        [
          64,
          19
        ],
        [
          67,
          52
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "end_query",
        "parameters": {
          "channel": "ares_channel_t",
          "server": "ares_server_t",
          "query": "ares_query_t",
          "status": "ares_status_t",
          "dnsrec": "ares_dns_record_t",
          "requeue": "ares_array_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "channel_socket_list(const ares_channel_t *channel,\n                                          size_t               *num)",
      "fn_dec_pos": [
        [
          291,
          22
        ],
        [
          292,
          68
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "channel_socket_list",
        "parameters": {
          "channel": "ares_channel_t",
          "num": "size_t"
        },
        "return_type": null
      }
    },
    {
      "fn_code": "ares_random_server(ares_channel_t *channel)",
      "fn_dec_pos": [
        [
          1034,
          22
        ],
        [
          1034,
          65
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_random_server",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": null
      }
    },
    {
      "fn_code": "ares_fetch_connection(const ares_channel_t *channel,\n                                          ares_server_t        *server,\n                                          const ares_query_t   *query)",
      "fn_dec_pos": [
        [
          1184,
          20
        ],
        [
          1186,
          70
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_fetch_connection",
        "parameters": {
          "channel": "ares_channel_t",
          "server": "ares_server_t",
          "query": "ares_query_t"
        },
        "return_type": null
      }
    }
  ],
  "class_node_list": {},
  "struct_node_list": [
    [
      "typedef struct {\n  requeue_type_t     type;   /* type of entry, requeue or endquery */\n  unsigned short     qid;    /* query id */\n  ares_server_t     *server; /* requeue only: optional */\n  ares_status_t      status; /* endquery only */\n  ares_dns_record_t *dnsrec; /* endquery only: optional */\n} ares_requeue_t;",
      {
        "type": "requeue_type_t",
        "qid": "unsigned short",
        "*server": "ares_server_t",
        "status": "ares_status_t",
        "*dnsrec": "ares_dns_record_t"
      },
      "ares_requeue_t",
      [
        524,
        0
      ],
      [
        530,
        17
      ]
    ],
    [
      "typedef struct {\n  requeue_type_t     type;   /* type of entry, requeue or endquery */\n  unsigned short     qid;    /* query id */\n  ares_server_t     *server; /* requeue only: optional */\n  ares_status_t      status; /* endquery only */\n  ares_dns_record_t *dnsrec; /* endquery only: optional */\n} ares_requeue_t;",
      {
        "type": "requeue_type_t",
        "qid": "unsigned short",
        "*server": "ares_server_t",
        "status": "ares_status_t",
        "*dnsrec": "ares_dns_record_t"
      },
      "ares_requeue_t",
      [
        524,
        0
      ],
      [
        530,
        17
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        27,
        0
      ],
      [
        28,
        0
      ]
    ],
    [
      "#  include <strings.h>\n",
      [
        30,
        0
      ],
      [
        31,
        0
      ]
    ],
    [
      "#  include <sys/ioctl.h>\n",
      [
        33,
        0
      ],
      [
        34,
        0
      ]
    ],
    [
      "#  include <sys/filio.h>\n",
      [
        36,
        0
      ],
      [
        37,
        0
      ]
    ],
    [
      "#  include <stdint.h>\n",
      [
        39,
        0
      ],
      [
        40,
        0
      ]
    ],
    [
      "#include <assert.h>\n",
      [
        42,
        0
      ],
      [
        43,
        0
      ]
    ],
    [
      "#include <fcntl.h>\n",
      [
        43,
        0
      ],
      [
        44,
        0
      ]
    ],
    [
      "#include <limits.h>\n",
      [
        44,
        0
      ],
      [
        45,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": [
    [
      "typedef enum {\n  REQUEUE_REQUEUE  = 1,\n  REQUEUE_ENDQUERY = 2\n} requeue_type_t;",
      {
        "REQUEUE_REQUEUE": "",
        "REQUEUE_ENDQUERY": ""
      },
      "requeue_type_t",
      [
        517,
        0
      ],
      [
        520,
        17
      ]
    ]
  ]
}