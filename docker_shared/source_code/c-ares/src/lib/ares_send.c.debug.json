{
  "fn_def_list": [
    {
      "fn_code": "static unsigned short generate_unique_qid(ares_channel_t *channel)\n{\n  unsigned short id;\n\n  do {\n    id = ares_generate_new_id(channel->rand_state);\n  } while (ares_htable_szvp_get(channel->queries_by_qid, id, NULL));\n\n  return id;\n}",
      "fn_code_pos": [
        [
          34,
          0
        ],
        [
          43,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "generate_unique_qid",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": null
      }
    },
    {
      "fn_code": "static ares_status_t ares_apply_dns0x20(ares_channel_t    *channel,\n                                        ares_dns_record_t *dnsrec)\n{\n  ares_status_t status = ARES_SUCCESS;\n  const char   *name   = NULL;\n  char          dns0x20name[256];\n  unsigned char randdata[256 / 8];\n  size_t        len;\n  size_t        remaining_bits;\n  size_t        total_bits;\n  size_t        i;\n\n  status = ares_dns_record_query_get(dnsrec, 0, &name, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  len = ares_strlen(name);\n  if (len == 0) {\n    return ARES_SUCCESS;\n  }\n\n  if (len >= sizeof(dns0x20name)) {\n    status = ARES_EBADNAME;\n    goto done;\n  }\n\n  memset(dns0x20name, 0, sizeof(dns0x20name));\n\n  /* Fetch the minimum amount of random data we'd need for the string, which\n   * is 1 bit per byte */\n  total_bits     = ((len + 7) / 8) * 8;\n  remaining_bits = total_bits;\n  ares_rand_bytes(channel->rand_state, randdata, total_bits / 8);\n\n  /* Randomly apply 0x20 to name */\n  for (i = 0; i < len; i++) {\n    size_t bit;\n\n    /* Only apply 0x20 to alpha characters */\n    if (!ares_isalpha(name[i])) {\n      dns0x20name[i] = name[i];\n      continue;\n    }\n\n    /* coin flip */\n    bit = total_bits - remaining_bits;\n    if (randdata[bit / 8] & (1 << (bit % 8))) {\n      dns0x20name[i] = name[i] | 0x20;                          /* Set 0x20 */\n    } else {\n      dns0x20name[i] = (char)(((unsigned char)name[i]) & 0xDF); /* Unset 0x20 */\n    }\n    remaining_bits--;\n  }\n\n  status = ares_dns_record_query_set_name(dnsrec, 0, dns0x20name);\n\ndone:\n  return status;\n}",
      "fn_code_pos": [
        [
          46,
          0
        ],
        [
          105,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_apply_dns0x20",
        "parameters": {
          "channel": "ares_channel_t",
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_send_nolock(ares_channel_t *channel, ares_server_t *server,\n                               ares_send_flags_t        flags,\n                               const ares_dns_record_t *dnsrec,\n                               ares_callback_dnsrec callback, void *arg,\n                               unsigned short *qid)\n{\n  ares_query_t            *query;\n  ares_timeval_t           now;\n  ares_status_t            status;\n  unsigned short           id          = generate_unique_qid(channel);\n  const ares_dns_record_t *dnsrec_resp = NULL;\n\n  ares_tvnow(&now);\n\n  if (ares_slist_len(channel->servers) == 0) {\n    callback(arg, ARES_ENOSERVER, 0, NULL);\n    return ARES_ENOSERVER;\n  }\n\n  if (!(flags & ARES_SEND_FLAG_NOCACHE)) {\n    /* Check query cache */\n    status = ares_qcache_fetch(channel, &now, dnsrec, &dnsrec_resp);\n    if (status != ARES_ENOTFOUND) {\n      /* ARES_SUCCESS means we retrieved the cache, anything else is a critical\n       * failure, all result in termination */\n      callback(arg, status, 0, dnsrec_resp);\n      return status;\n    }\n  }\n\n  /* Allocate space for query and allocated fields. */\n  query = ares_malloc(sizeof(ares_query_t));\n  if (!query) {\n    callback(arg, ARES_ENOMEM, 0, NULL); /* LCOV_EXCL_LINE: OutOfMemory */\n    return ARES_ENOMEM;                  /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  memset(query, 0, sizeof(*query));\n\n  query->channel      = channel;\n  query->qid          = id;\n  query->timeout.sec  = 0;\n  query->timeout.usec = 0;\n  query->using_tcp =\n    (channel->flags & ARES_FLAG_USEVC) ? ARES_TRUE : ARES_FALSE;\n\n  /* Duplicate Query */\n  status = ares_dns_record_duplicate_ex(&query->query, dnsrec);\n  if (status != ARES_SUCCESS) {\n    /* Sometimes we might get a EBADRESP response from duplicate due to\n     * the way it works (write and parse), rewrite it to EBADQUERY. */\n    if (status == ARES_EBADRESP) {\n      status = ARES_EBADQUERY;\n    }\n    ares_free(query);\n    callback(arg, status, 0, NULL);\n    return status;\n  }\n\n  ares_dns_record_set_id(query->query, id);\n\n  if (channel->flags & ARES_FLAG_DNS0x20 && !query->using_tcp) {\n    status = ares_apply_dns0x20(channel, query->query);\n    if (status != ARES_SUCCESS) {\n      /* LCOV_EXCL_START: OutOfMemory */\n      callback(arg, status, 0, NULL);\n      ares_free_query(query);\n      return status;\n      /* LCOV_EXCL_STOP */\n    }\n  }\n\n  /* Fill in query arguments. */\n  query->callback = callback;\n  query->arg      = arg;\n\n  /* Initialize query status. */\n  query->try_count = 0;\n\n  if (flags & ARES_SEND_FLAG_NORETRY) {\n    query->no_retries = ARES_TRUE;\n  }\n\n  query->error_status = ARES_SUCCESS;\n  query->timeouts     = 0;\n\n  /* Initialize our list nodes. */\n  query->node_queries_by_timeout = NULL;\n  query->node_queries_to_conn    = NULL;\n\n  /* Chain the query into the list of all queries. */\n  query->node_all_queries = ares_llist_insert_last(channel->all_queries, query);\n  if (query->node_all_queries == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    ares_free_query(query);\n    return ARES_ENOMEM;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Keep track of queries bucketed by qid, so we can process DNS\n   * responses quickly.\n   */\n  if (!ares_htable_szvp_insert(channel->queries_by_qid, query->qid, query)) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    ares_free_query(query);\n    return ARES_ENOMEM;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Perform the first query action. */\n\n  status = ares_send_query(server, query, &now);\n  if (status == ARES_SUCCESS && qid) {\n    *qid = id;\n  }\n  return status;\n}",
      "fn_code_pos": [
        [
          107,
          0
        ],
        [
          224,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_send_nolock",
        "parameters": {
          "channel": "ares_channel_t",
          "server": "ares_server_t",
          "flags": "ares_send_flags_t",
          "dnsrec": "ares_dns_record_t",
          "callback": "ares_callback_dnsrec",
          "arg": "void",
          "qid": "unsigned short"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_send_dnsrec(ares_channel_t          *channel,\n                               const ares_dns_record_t *dnsrec,\n                               ares_callback_dnsrec callback, void *arg,\n                               unsigned short *qid)\n{\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_channel_lock(channel);\n\n  status = ares_send_nolock(channel, NULL, 0, dnsrec, callback, arg, qid);\n\n  ares_channel_unlock(channel);\n\n  return status;\n}",
      "fn_code_pos": [
        [
          226,
          0
        ],
        [
          244,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_send_dnsrec",
        "parameters": {
          "channel": "ares_channel_t",
          "dnsrec": "ares_dns_record_t",
          "callback": "ares_callback_dnsrec",
          "arg": "void",
          "qid": "unsigned short"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "void ares_send(ares_channel_t *channel, const unsigned char *qbuf, int qlen,\n               ares_callback callback, void *arg)\n{\n  ares_dns_record_t *dnsrec = NULL;\n  ares_status_t      status;\n  void              *carg = NULL;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  /* Verify that the query is at least long enough to hold the header. */\n  if (qlen < HFIXEDSZ || qlen >= (1 << 16)) {\n    callback(arg, ARES_EBADQUERY, 0, NULL, 0);\n    return;\n  }\n\n  status = ares_dns_parse(qbuf, (size_t)qlen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    callback(arg, (int)status, 0, NULL, 0);\n    return;\n  }\n\n  carg = ares_dnsrec_convert_arg(callback, arg);\n  if (carg == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    status = ARES_ENOMEM;\n    ares_dns_record_destroy(dnsrec);\n    callback(arg, (int)status, 0, NULL, 0);\n    return;\n    /* LCOV_EXCL_STOP */\n  }\n\n  ares_send_dnsrec(channel, dnsrec, ares_dnsrec_convert_cb, carg, NULL);\n\n  ares_dns_record_destroy(dnsrec);\n}",
      "fn_code_pos": [
        [
          246,
          0
        ],
        [
          282,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_send",
        "parameters": {
          "channel": "ares_channel_t",
          "qbuf": "unsigned char",
          "qlen": "int",
          "callback": "ares_callback",
          "arg": "void"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "size_t ares_queue_active_queries(const ares_channel_t *channel)\n{\n  size_t len;\n\n  if (channel == NULL) {\n    return 0;\n  }\n\n  ares_channel_lock(channel);\n\n  len = ares_llist_len(channel->all_queries);\n\n  ares_channel_unlock(channel);\n\n  return len;\n}",
      "fn_code_pos": [
        [
          284,
          0
        ],
        [
          299,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_queue_active_queries",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": "size_t"
      }
    }
  ],
  "fn_declaraion": [],
  "class_node_list": {},
  "struct_node_list": [],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        27,
        0
      ],
      [
        28,
        0
      ]
    ],
    [
      "#  include <netinet/in.h>\n",
      [
        30,
        0
      ],
      [
        31,
        0
      ]
    ],
    [
      "#include \"ares_nameser.h\"\n",
      [
        32,
        0
      ],
      [
        33,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}