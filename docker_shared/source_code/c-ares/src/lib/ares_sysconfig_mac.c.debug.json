{
  "fn_def_list": [
    {
      "fn_code": "static void dnsinfo_destroy(dnsinfo_t *dnsinfo)\n{\n  if (dnsinfo == NULL) {\n    return;\n  }\n\n  if (dnsinfo->handle) {\n    dlclose(dnsinfo->handle);\n  }\n\n  ares_free(dnsinfo);\n}",
      "fn_code_pos": [
        [
          72,
          0
        ],
        [
          83,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "dnsinfo_destroy",
        "parameters": {
          "dnsinfo": "dnsinfo_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_status_t dnsinfo_init(dnsinfo_t **dnsinfo_out)\n{\n  dnsinfo_t    *dnsinfo = NULL;\n  ares_status_t status  = ARES_SUCCESS;\n  size_t        i;\n  const char   *searchlibs[] = {\n    \"/usr/lib/libSystem.dylib\",\n    \"/System/Library/Frameworks/SystemConfiguration.framework/\"\n      \"SystemConfiguration\",\n    NULL\n  };\n\n  if (dnsinfo_out == NULL) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\n  *dnsinfo_out = NULL;\n\n  dnsinfo = ares_malloc_zero(sizeof(*dnsinfo));\n  if (dnsinfo == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  for (i = 0; searchlibs[i] != NULL; i++) {\n    dnsinfo->handle = dlopen(searchlibs[i], RTLD_LAZY /* | RTLD_NOLOAD */);\n    if (dnsinfo->handle == NULL) {\n      /* Fail, loop */\n      continue;\n    }\n\n    dnsinfo->dns_configuration_copy = (dns_config_t * (*)(void))\n      dlsym(dnsinfo->handle, \"dns_configuration_copy\");\n\n    dnsinfo->dns_configuration_free = (void (*)(dns_config_t *))dlsym(\n      dnsinfo->handle, \"dns_configuration_free\");\n\n    if (dnsinfo->dns_configuration_copy != NULL &&\n        dnsinfo->dns_configuration_free != NULL) {\n      break;\n    }\n\n    /* Fail, loop */\n    dlclose(dnsinfo->handle);\n    dnsinfo->handle = NULL;\n  }\n\n\n  if (dnsinfo->dns_configuration_copy == NULL ||\n      dnsinfo->dns_configuration_free == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n\ndone:\n  if (status == ARES_SUCCESS) {\n    *dnsinfo_out = dnsinfo;\n  } else {\n    dnsinfo_destroy(dnsinfo);\n  }\n\n  return status;\n}",
      "fn_code_pos": [
        [
          85,
          0
        ],
        [
          149,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "dnsinfo_init",
        "parameters": {
          "dnsinfo_out": "dnsinfo_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_bool_t search_is_duplicate(const ares_sysconfig_t *sysconfig,\n                                       const char             *name)\n{\n  size_t i;\n  for (i = 0; i < sysconfig->ndomains; i++) {\n    if (ares_strcaseeq(sysconfig->domains[i], name)) {\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          151,
          0
        ],
        [
          161,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "search_is_duplicate",
        "parameters": {
          "sysconfig": "ares_sysconfig_t",
          "name": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_status_t read_resolver(const ares_channel_t *channel,\n                                   const dns_resolver_t *resolver,\n                                   ares_sysconfig_t     *sysconfig)\n{\n  int            i;\n  unsigned short port   = 0;\n  ares_status_t  status = ARES_SUCCESS;\n\n#  if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080 /* MacOS 10.8 */\n  /* XXX: resolver->domain is for domain-specific servers.  When we implement\n   *      this support, we'll want to use this.  But for now, we're going to\n   *      skip any servers which set this since we can't properly route.\n   *      MacOS used to use this setting for a different purpose in the\n   *      past however, so on versions of MacOS < 10.8 just ignore this\n   *      completely. */\n  if (resolver->domain != NULL) {\n    return ARES_SUCCESS;\n  }\n#  endif\n\n#  if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080 /* MacOS 10.8 */\n  /* Check to see if DNS server should be used, base this on if the server is\n   * reachable or can be reachable automatically if we send traffic that\n   * direction. */\n  if (!(resolver->reach_flags &\n        (kSCNetworkFlagsReachable |\n         kSCNetworkReachabilityFlagsConnectionOnTraffic))) {\n    return ARES_SUCCESS;\n  }\n#  endif\n\n  /* NOTE: it doesn't look like resolver->flags is relevant */\n\n  /* If there's no nameservers, nothing to do */\n  if (resolver->n_nameserver <= 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* Default port */\n  port = resolver->port;\n\n  /* Append search list */\n  if (resolver->n_search > 0) {\n    char **new_domains = ares_realloc_zero(\n      sysconfig->domains, sizeof(*sysconfig->domains) * sysconfig->ndomains,\n      sizeof(*sysconfig->domains) *\n        (sysconfig->ndomains + (size_t)resolver->n_search));\n    if (new_domains == NULL) {\n      return ARES_ENOMEM;\n    }\n    sysconfig->domains = new_domains;\n\n    for (i = 0; i < resolver->n_search; i++) {\n      const char *search;\n      /* UBSAN: copy pointer using memcpy due to misalignment */\n      memcpy(&search, resolver->search + i, sizeof(search));\n\n      /* Skip duplicates */\n      if (search_is_duplicate(sysconfig, search)) {\n        continue;\n      }\n      sysconfig->domains[sysconfig->ndomains] = ares_strdup(search);\n      if (sysconfig->domains[sysconfig->ndomains] == NULL) {\n        return ARES_ENOMEM;\n      }\n      sysconfig->ndomains++;\n    }\n  }\n\n  /* NOTE: we're going to skip importing the sort addresses for now.  Its\n   *       likely not used, its not obvious how to even configure such a thing.\n   */\n#  if 0\n  for (i=0; i<resolver->n_sortaddr; i++) {\n    char val[256];\n    inet_ntop(AF_INET, &resolver->sortaddr[i]->address, val, sizeof(val));\n    printf(\"\\t\\t%s/\", val);\n    inet_ntop(AF_INET, &resolver->sortaddr[i]->mask, val, sizeof(val));\n    printf(\"%s\\n\", val);\n  }\n#  endif\n\n  if (resolver->options != NULL) {\n    status = ares_sysconfig_set_options(sysconfig, resolver->options);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* NOTE:\n   *   - resolver->timeout appears unused, always 0, so we ignore this\n   *   - resolver->service_identifier doesn't appear relevant to us\n   *   - resolver->cid also isn't relevant\n   *   - resolver->if_name we won't use since it isn't available in MacOS 10.8\n   *     or earlier, use resolver->if_index instead to then lookup the name.\n   */\n\n  /* XXX: resolver->search_order appears like it might be relevant, we might\n   * need to sort the resulting list by this metric if we find in the future we\n   * need to.  That said, due to the automatic re-sorting we do, I'm not sure it\n   * matters.  Here's an article on this search order stuff:\n   *      https://www.cnet.com/tech/computing/os-x-10-6-3-and-dns-server-priority-changes/\n   */\n\n  for (i = 0; i < resolver->n_nameserver; i++) {\n    struct ares_addr       addr;\n    unsigned short         addrport;\n    const struct sockaddr *sockaddr;\n    char                   if_name_str[256] = \"\";\n    const char            *if_name          = NULL;\n\n    /* UBSAN alignment workaround to fetch memory address */\n    memcpy(&sockaddr, resolver->nameserver + i, sizeof(sockaddr));\n\n    if (!ares_sockaddr_to_ares_addr(&addr, &addrport, sockaddr)) {\n      continue;\n    }\n\n    if (addrport == 0) {\n      addrport = port;\n    }\n\n    if (channel->sock_funcs.aif_indextoname != NULL) {\n      if_name = channel->sock_funcs.aif_indextoname(\n        resolver->if_index, if_name_str, sizeof(if_name_str),\n        channel->sock_func_cb_data);\n    }\n\n    status = ares_sconfig_append(channel, &sysconfig->sconfig, &addr, addrport,\n                                 addrport, if_name);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return status;\n}",
      "fn_code_pos": [
        [
          163,
          0
        ],
        [
          299,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "read_resolver",
        "parameters": {
          "channel": "ares_channel_t",
          "resolver": "dns_resolver_t",
          "sysconfig": "ares_sysconfig_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static ares_status_t read_resolvers(const ares_channel_t *channel,\n                                    dns_resolver_t **resolvers, int nresolvers,\n                                    ares_sysconfig_t *sysconfig)\n{\n  ares_status_t status = ARES_SUCCESS;\n  int           i;\n\n  for (i = 0; status == ARES_SUCCESS && i < nresolvers; i++) {\n    const dns_resolver_t *resolver_ptr;\n\n    /* UBSAN doesn't like that this is unaligned, lets use memcpy to get the\n     * address.  Equivalent to:\n     *   resolver = resolvers[i]\n     */\n    memcpy(&resolver_ptr, resolvers + i, sizeof(resolver_ptr));\n\n    status = read_resolver(channel, resolver_ptr, sysconfig);\n  }\n\n  return status;\n}",
      "fn_code_pos": [
        [
          301,
          0
        ],
        [
          321,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "read_resolvers",
        "parameters": {
          "channel": "ares_channel_t",
          "resolvers": "dns_resolver_t",
          "nresolvers": "int",
          "sysconfig": "ares_sysconfig_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_init_sysconfig_macos(const ares_channel_t *channel,\n                                        ares_sysconfig_t     *sysconfig)\n{\n  dnsinfo_t    *dnsinfo = NULL;\n  dns_config_t *sc_dns  = NULL;\n  ares_status_t status  = ARES_SUCCESS;\n\n  status = dnsinfo_init(&dnsinfo);\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  sc_dns = dnsinfo->dns_configuration_copy();\n  if (sc_dns == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  /* There are `resolver`, `scoped_resolver`, and `service_specific_resolver`\n   * settings. The `scoped_resolver` settings appear to be already available via\n   * the `resolver` settings and likely are only relevant to link-local dns\n   * servers which we can already detect via the address itself, so we'll ignore\n   * the `scoped_resolver` section.  It isn't clear what the\n   * `service_specific_resolver` is used for, I haven't personally seen it\n   * in use so we'll ignore this until at some point where we find we need it.\n   * Likely this wasn't available via `/etc/resolv.conf` nor `libresolv` anyhow\n   * so its not worse to prior configuration methods, worst case. */\n\n  status =\n    read_resolvers(channel, sc_dns->resolver, sc_dns->n_resolver, sysconfig);\n\ndone:\n  if (dnsinfo) {\n    dnsinfo->dns_configuration_free(sc_dns);\n    dnsinfo_destroy(dnsinfo);\n  }\n  return status;\n}",
      "fn_code_pos": [
        [
          323,
          0
        ],
        [
          361,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_init_sysconfig_macos",
        "parameters": {
          "channel": "ares_channel_t",
          "sysconfig": "ares_sysconfig_t"
        },
        "return_type": "ares_status_t"
      }
    }
  ],
  "fn_declaraion": [
    {
      "fn_code": "(*dns_configuration_copy)(void)",
      "fn_dec_pos": [
        [
          68,
          16
        ],
        [
          68,
          47
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "(*dns_configuration_free)(dns_config_t *config)",
      "fn_dec_pos": [
        [
          69,
          7
        ],
        [
          69,
          54
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "",
        "parameters": {
          "config": "dns_config_t"
        },
        "return_type": "void"
      }
    }
  ],
  "class_node_list": {},
  "struct_node_list": [
    [
      "typedef struct {\n  void *handle;\n  dns_config_t *(*dns_configuration_copy)(void);\n  void (*dns_configuration_free)(dns_config_t *config);\n} dnsinfo_t;",
      {
        "*handle": "void",
        "*(*dns_configuration_copy)(void)": "dns_config_t",
        "(*dns_configuration_free)(dns_config_t *config)": "void"
      },
      "dnsinfo_t",
      [
        66,
        0
      ],
      [
        70,
        12
      ]
    ],
    [
      "typedef struct {\n  void *handle;\n  dns_config_t *(*dns_configuration_copy)(void);\n  void (*dns_configuration_free)(dns_config_t *config);\n} dnsinfo_t;",
      {
        "*handle": "void",
        "*(*dns_configuration_copy)(void)": "dns_config_t",
        "(*dns_configuration_free)(dns_config_t *config)": "void"
      },
      "dnsinfo_t",
      [
        66,
        0
      ],
      [
        70,
        12
      ]
    ],
    [
      "struct ares_addr",
      {},
      "",
      [
        268,
        4
      ],
      [
        268,
        20
      ]
    ],
    [
      "struct sockaddr",
      {},
      "",
      [
        270,
        10
      ],
      [
        270,
        25
      ]
    ]
  ],
  "include_list": [
    [
      "#  include \"ares_private.h\"\n",
      [
        54,
        0
      ],
      [
        55,
        0
      ]
    ],
    [
      "#  include <stdio.h>\n",
      [
        55,
        0
      ],
      [
        56,
        0
      ]
    ],
    [
      "#  include <stdlib.h>\n",
      [
        56,
        0
      ],
      [
        57,
        0
      ]
    ],
    [
      "#  include <string.h>\n",
      [
        57,
        0
      ],
      [
        58,
        0
      ]
    ],
    [
      "#  include <dlfcn.h>\n",
      [
        58,
        0
      ],
      [
        59,
        0
      ]
    ],
    [
      "#  include <arpa/inet.h>\n",
      [
        59,
        0
      ],
      [
        60,
        0
      ]
    ],
    [
      "#  include \"thirdparty/apple/dnsinfo.h\"\n",
      [
        60,
        0
      ],
      [
        61,
        0
      ]
    ],
    [
      "#  include <AvailabilityMacros.h>\n",
      [
        61,
        0
      ],
      [
        62,
        0
      ]
    ],
    [
      "#    include <SystemConfiguration/SCNetworkConfiguration.h>\n",
      [
        63,
        0
      ],
      [
        64,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}