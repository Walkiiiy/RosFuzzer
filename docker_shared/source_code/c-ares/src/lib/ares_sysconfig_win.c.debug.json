{
  "fn_def_list": [
    {
      "fn_code": "static ares_bool_t get_REG_SZ(HKEY hKey, const WCHAR *leafKeyName, char **outptr)\n{\n  DWORD  size = 0;\n  int    res;\n  int    len;\n  WCHAR *val = NULL;\n\n  *outptr = NULL;\n\n  /* Find out size of string stored in registry */\n  res = RegQueryValueExW(hKey, leafKeyName, 0, NULL, NULL, &size);\n  if ((res != ERROR_SUCCESS && res != ERROR_MORE_DATA) || !size) {\n    return ARES_FALSE;\n  }\n\n  /* Allocate buffer of indicated size plus one given that string\n     might have been stored without null termination */\n  val = ares_malloc_zero(size + sizeof(WCHAR));\n  if (val == NULL) {\n    return ARES_FALSE;\n  }\n\n  /* Get the value for real */\n  res = RegQueryValueExW(hKey, leafKeyName, 0, NULL, (BYTE *)val, &size);\n  if (res != ERROR_SUCCESS || size == 1) {\n    ares_free(val);\n    return ARES_FALSE;\n  }\n\n  /* Convert to UTF8 */\n  len = WideCharToMultiByte(CP_UTF8, 0, val, -1, NULL, 0, NULL, NULL);\n  if (len == 0) {\n    return ARES_FALSE;\n  }\n  *outptr = ares_malloc_zero((size_t)len + 1);\n  if (WideCharToMultiByte(CP_UTF8, 0, val, -1, *outptr, len, NULL, NULL)\n    == 0) {\n    ares_free(*outptr);\n    *outptr = NULL;\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          84,
          0
        ],
        [
          127,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "get_REG_SZ",
        "parameters": {
          "hKey": "HKEY",
          "leafKeyName": "WCHAR",
          "outptr": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static void commanjoin(char **dst, const char * const src, const size_t len)\n{\n  char  *newbuf;\n  size_t newsize;\n\n  /* 1 for terminating 0 and 2 for , and terminating 0 */\n  newsize = len + (*dst ? (ares_strlen(*dst) + 2) : 1);\n  newbuf  = ares_realloc(*dst, newsize);\n  if (!newbuf) {\n    return;\n  }\n  if (*dst == NULL) {\n    *newbuf = '\\0';\n  }\n  *dst = newbuf;\n  if (ares_strlen(*dst) != 0) {\n    strcat(*dst, \",\");\n  }\n  strncat(*dst, src, len);\n}",
      "fn_code_pos": [
        [
          129,
          0
        ],
        [
          148,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "commanjoin",
        "parameters": {
          "dst": "char",
          "src": "char",
          "len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void commajoin(char **dst, const char *src)\n{\n  commanjoin(dst, src, ares_strlen(src));\n}",
      "fn_code_pos": [
        [
          155,
          0
        ],
        [
          158,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "commajoin",
        "parameters": {
          "dst": "char",
          "src": "char"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void commajoin_asciionly(char **dst, const char *src)\n{\n  if (!ares_str_isprint(src, ares_strlen(src))) {\n    return;\n  }\n  commanjoin(dst, src, ares_strlen(src));\n}",
      "fn_code_pos": [
        [
          160,
          0
        ],
        [
          166,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "commajoin_asciionly",
        "parameters": {
          "dst": "char",
          "src": "char"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static int compareAddresses(const void *arg1, const void *arg2)\n{\n  const Address * const left  = arg1;\n  const Address * const right = arg2;\n  /* Lower metric the more preferred */\n  if (left->metric < right->metric) {\n    return -1;\n  }\n  if (left->metric > right->metric) {\n    return 1;\n  }\n  /* If metrics are equal, lower original index more preferred */\n  if (left->orig_idx < right->orig_idx) {\n    return -1;\n  }\n  if (left->orig_idx > right->orig_idx) {\n    return 1;\n  }\n  return 0;\n}",
      "fn_code_pos": [
        [
          188,
          0
        ],
        [
          207,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "compareAddresses",
        "parameters": {
          "arg1": "void",
          "arg2": "void"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "static ULONG getBestRouteMetric(IF_LUID * const luid, /* Can't be const :( */\n                                const SOCKADDR_INET * const dest,\n                                const ULONG                 interfaceMetric)\n{\n  MIB_IPFORWARD_ROW2 row;\n  SOCKADDR_INET      ignored;\n  if (GetBestRoute2(/* The interface to use.  The index is ignored since we are\n                     * passing a LUID.\n                     */\n                    luid, 0,\n                    /* No specific source address. */\n                    NULL,\n                    /* Our destination address. */\n                    dest,\n                    /* No options. */\n                    0,\n                    /* The route row. */\n                    &row,\n                    /* The best source address, which we don't need. */\n                    &ignored) != NO_ERROR\n      /* If the metric is \"unused\" (-1) or too large for us to add the two\n       * metrics, use the worst possible, thus sorting this last.\n       */\n      || row.Metric == (ULONG)-1 ||\n      row.Metric > ((ULONG)-1) - interfaceMetric) {\n    /* Return the worst possible metric. */\n    return (ULONG)-1;\n  }\n\n  /* Return the metric value from that row, plus the interface metric.\n   *\n   * See\n   * http://msdn.microsoft.com/en-us/library/windows/desktop/aa814494(v=vs.85).aspx\n   * which describes the combination as a \"sum\".\n   */\n  return row.Metric + interfaceMetric;\n}",
      "fn_code_pos": [
        [
          243,
          0
        ],
        [
          279,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "getBestRouteMetric",
        "parameters": {
          "luid": "IF_LUID",
          "dest": "SOCKADDR_INET",
          "interfaceMetric": "ULONG"
        },
        "return_type": "ULONG"
      }
    },
    {
      "fn_code": "static ares_bool_t get_DNS_Windows(char **outptr)\n{\n  IP_ADAPTER_DNS_SERVER_ADDRESS *ipaDNSAddr;\n  IP_ADAPTER_ADDRESSES          *ipaa;\n  IP_ADAPTER_ADDRESSES          *newipaa;\n  IP_ADAPTER_ADDRESSES          *ipaaEntry;\n  ULONG                          ReqBufsz  = IPAA_INITIAL_BUF_SZ;\n  ULONG                          Bufsz     = IPAA_INITIAL_BUF_SZ;\n  ULONG                          AddrFlags = 0;\n  int                            trying    = IPAA_MAX_TRIES;\n  ULONG                          res;\n\n  /* The capacity of addresses, in elements. */\n  size_t                         addressesSize;\n  /* The number of elements in addresses. */\n  size_t                         addressesIndex = 0;\n  /* The addresses we will sort. */\n  Address                       *addresses;\n\n  union {\n    struct sockaddr     *sa;\n    struct sockaddr_in  *sa4;\n    struct sockaddr_in6 *sa6;\n  } namesrvr;\n\n  *outptr = NULL;\n\n  ipaa = ares_malloc(Bufsz);\n  if (!ipaa) {\n    return ARES_FALSE;\n  }\n\n  /* Start with enough room for a few DNS server addresses and we'll grow it\n   * as we encounter more.\n   */\n  addressesSize = 4;\n  addresses     = (Address *)ares_malloc(sizeof(Address) * addressesSize);\n  if (addresses == NULL) {\n    /* We need room for at least some addresses to function. */\n    ares_free(ipaa);\n    return ARES_FALSE;\n  }\n\n  /* Usually this call succeeds with initial buffer size */\n  res = GetAdaptersAddresses(AF_UNSPEC, AddrFlags, NULL, ipaa, &ReqBufsz);\n  if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS)) {\n    goto done;\n  }\n\n  while ((res == ERROR_BUFFER_OVERFLOW) && (--trying)) {\n    if (Bufsz < ReqBufsz) {\n      newipaa = ares_realloc(ipaa, ReqBufsz);\n      if (!newipaa) {\n        goto done;\n      }\n      Bufsz = ReqBufsz;\n      ipaa  = newipaa;\n    }\n    res = GetAdaptersAddresses(AF_UNSPEC, AddrFlags, NULL, ipaa, &ReqBufsz);\n    if (res == ERROR_SUCCESS) {\n      break;\n    }\n  }\n  if (res != ERROR_SUCCESS) {\n    goto done;\n  }\n\n  for (ipaaEntry = ipaa; ipaaEntry; ipaaEntry = ipaaEntry->Next) {\n    if (ipaaEntry->OperStatus != IfOperStatusUp) {\n      continue;\n    }\n\n    /* For each interface, find any associated DNS servers as IPv4 or IPv6\n     * addresses.  For each found address, find the best route to that DNS\n     * server address _on_ _that_ _interface_ (at this moment in time) and\n     * compute the resulting total metric, just as Windows routing will do.\n     * Then, sort all the addresses found by the metric.\n     */\n    for (ipaDNSAddr = ipaaEntry->FirstDnsServerAddress; ipaDNSAddr != NULL;\n         ipaDNSAddr = ipaDNSAddr->Next) {\n      char ipaddr[INET6_ADDRSTRLEN] = \"\";\n\n      namesrvr.sa = ipaDNSAddr->Address.lpSockaddr;\n\n      if (namesrvr.sa->sa_family == AF_INET) {\n        if ((namesrvr.sa4->sin_addr.S_un.S_addr == INADDR_ANY) ||\n            (namesrvr.sa4->sin_addr.S_un.S_addr == INADDR_NONE)) {\n          continue;\n        }\n\n        /* Allocate room for another address, if necessary, else skip. */\n        if (addressesIndex == addressesSize) {\n          const size_t    newSize = addressesSize + 4;\n          Address * const newMem =\n            (Address *)ares_realloc(addresses, sizeof(Address) * newSize);\n          if (newMem == NULL) {\n            continue;\n          }\n          addresses     = newMem;\n          addressesSize = newSize;\n        }\n\n#  if defined(HAVE_GETBESTROUTE2) && !defined(__WATCOMC__)\n        /* OpenWatcom's builtin Windows SDK does not have a definition for\n         * MIB_IPFORWARD_ROW2, and also does not allow the usage of SOCKADDR_INET\n         * as a variable. Let's work around this by returning the worst possible\n         * metric, but only when using the OpenWatcom compiler.\n         * It may be worth investigating using a different version of the Windows\n         * SDK with OpenWatcom in the future, though this may be fixed in OpenWatcom\n         * 2.0.\n         */\n        addresses[addressesIndex].metric = getBestRouteMetric(\n          &ipaaEntry->Luid, (SOCKADDR_INET *)((void *)(namesrvr.sa)),\n          ipaaEntry->Ipv4Metric);\n#  else\n        addresses[addressesIndex].metric = (ULONG)-1;\n#  endif\n\n        /* Record insertion index to make qsort stable */\n        addresses[addressesIndex].orig_idx = addressesIndex;\n\n        if (!ares_inet_ntop(AF_INET, &namesrvr.sa4->sin_addr, ipaddr,\n                            sizeof(ipaddr))) {\n          continue;\n        }\n        snprintf(addresses[addressesIndex].text,\n                 sizeof(addresses[addressesIndex].text), \"[%s]:%u\", ipaddr,\n                 ntohs(namesrvr.sa4->sin_port));\n        ++addressesIndex;\n      } else if (namesrvr.sa->sa_family == AF_INET6) {\n        unsigned int     ll_scope = 0;\n        struct ares_addr addr;\n\n        if (memcmp(&namesrvr.sa6->sin6_addr, &ares_in6addr_any,\n                   sizeof(namesrvr.sa6->sin6_addr)) == 0) {\n          continue;\n        }\n\n        /* Allocate room for another address, if necessary, else skip. */\n        if (addressesIndex == addressesSize) {\n          const size_t    newSize = addressesSize + 4;\n          Address * const newMem =\n            (Address *)ares_realloc(addresses, sizeof(Address) * newSize);\n          if (newMem == NULL) {\n            continue;\n          }\n          addresses     = newMem;\n          addressesSize = newSize;\n        }\n\n        /* See if its link-local */\n        memset(&addr, 0, sizeof(addr));\n        addr.family = AF_INET6;\n        memcpy(&addr.addr.addr6, &namesrvr.sa6->sin6_addr, 16);\n        if (ares_addr_is_linklocal(&addr)) {\n          ll_scope = ipaaEntry->Ipv6IfIndex;\n        }\n\n#  if defined(HAVE_GETBESTROUTE2) && !defined(__WATCOMC__)\n        addresses[addressesIndex].metric = getBestRouteMetric(\n          &ipaaEntry->Luid, (SOCKADDR_INET *)((void *)(namesrvr.sa)),\n          ipaaEntry->Ipv6Metric);\n#  else\n        addresses[addressesIndex].metric = (ULONG)-1;\n#  endif\n\n        /* Record insertion index to make qsort stable */\n        addresses[addressesIndex].orig_idx = addressesIndex;\n\n        if (!ares_inet_ntop(AF_INET6, &namesrvr.sa6->sin6_addr, ipaddr,\n                            sizeof(ipaddr))) {\n          continue;\n        }\n\n        if (ll_scope) {\n          snprintf(addresses[addressesIndex].text,\n                   sizeof(addresses[addressesIndex].text), \"[%s]:%u%%%u\",\n                   ipaddr, ntohs(namesrvr.sa6->sin6_port), ll_scope);\n        } else {\n          snprintf(addresses[addressesIndex].text,\n                   sizeof(addresses[addressesIndex].text), \"[%s]:%u\", ipaddr,\n                   ntohs(namesrvr.sa6->sin6_port));\n        }\n        ++addressesIndex;\n      } else {\n        /* Skip non-IPv4/IPv6 addresses completely. */\n        continue;\n      }\n    }\n  }\n\n  /* Sort all of the textual addresses by their metric (and original index if\n   * metrics are equal). */\n  qsort(addresses, addressesIndex, sizeof(*addresses), compareAddresses);\n\n  /* Join them all into a single string, removing duplicates. */\n  {\n    size_t i;\n    for (i = 0; i < addressesIndex; ++i) {\n      size_t j;\n      /* Look for this address text appearing previously in the results. */\n      for (j = 0; j < i; ++j) {\n        if (strcmp(addresses[j].text, addresses[i].text) == 0) {\n          break;\n        }\n      }\n      /* Iff we didn't emit this address already, emit it now. */\n      if (j == i) {\n        /* Add that to outptr (if we can). */\n        commajoin(outptr, addresses[i].text);\n      }\n    }\n  }\n\ndone:\n  ares_free(addresses);\n\n  if (ipaa) {\n    ares_free(ipaa);\n  }\n\n  if (!*outptr) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          299,
          0
        ],
        [
          525,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "get_DNS_Windows",
        "parameters": {
          "outptr": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t get_SuffixList_Windows(char **outptr)\n{\n  HKEY  hKey;\n  HKEY  hKeyEnum;\n  char  keyName[256];\n  DWORD keyNameBuffSize;\n  DWORD keyIdx = 0;\n  char *p      = NULL;\n\n  *outptr = NULL;\n\n  /* 1. Global DNS Suffix Search List */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    get_REG_SZ(hKey, SEARCHLIST_KEY, outptr);\n    if (get_REG_SZ(hKey, DOMAIN_KEY, &p)) {\n      commajoin_asciionly(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NT_DNSCLIENT, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    if (get_REG_SZ(hKey, SEARCHLIST_KEY, &p)) {\n      commajoin_asciionly(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  /* 2. Connection Specific Search List composed of:\n   *  a. Primary DNS Suffix */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_DNSCLIENT, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    if (get_REG_SZ(hKey, PRIMARYDNSSUFFIX_KEY, &p)) {\n      commajoin_asciionly(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  /*  b. Interface SearchList, Domain, DhcpDomain */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY \"\\\\\" INTERFACES_KEY, 0,\n                    KEY_READ, &hKey) == ERROR_SUCCESS) {\n    for (;;) {\n      keyNameBuffSize = sizeof(keyName);\n      if (RegEnumKeyExA(hKey, keyIdx++, keyName, &keyNameBuffSize, 0, NULL,\n                        NULL, NULL) != ERROR_SUCCESS) {\n        break;\n      }\n      if (RegOpenKeyExA(hKey, keyName, 0, KEY_QUERY_VALUE, &hKeyEnum) !=\n          ERROR_SUCCESS) {\n        continue;\n      }\n      /* p can be comma separated (SearchList) */\n      if (get_REG_SZ(hKeyEnum, SEARCHLIST_KEY, &p)) {\n        commajoin_asciionly(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      if (get_REG_SZ(hKeyEnum, DOMAIN_KEY, &p)) {\n        commajoin_asciionly(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      if (get_REG_SZ(hKeyEnum, DHCPDOMAIN_KEY, &p)) {\n        commajoin_asciionly(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      RegCloseKey(hKeyEnum);\n    }\n    RegCloseKey(hKey);\n  }\n\n  return *outptr != NULL ? ARES_TRUE : ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          540,
          0
        ],
        [
          620,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "get_SuffixList_Windows",
        "parameters": {
          "outptr": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_init_sysconfig_windows(const ares_channel_t *channel,\n                                          ares_sysconfig_t     *sysconfig)\n{\n  char         *line   = NULL;\n  ares_status_t status = ARES_SUCCESS;\n\n  if (get_DNS_Windows(&line)) {\n    status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, line,\n                                         ARES_TRUE);\n    ares_free(line);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  if (get_SuffixList_Windows(&line)) {\n    sysconfig->domains = ares_strsplit(line, \", \", &sysconfig->ndomains);\n    ares_free(line);\n    if (sysconfig->domains == NULL) {\n      status = ARES_EFILE;\n    }\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  return status;\n}",
      "fn_code_pos": [
        [
          622,
          0
        ],
        [
          650,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_init_sysconfig_windows",
        "parameters": {
          "channel": "ares_channel_t",
          "sysconfig": "ares_sysconfig_t"
        },
        "return_type": "ares_status_t"
      }
    }
  ],
  "fn_declaraion": [],
  "class_node_list": {},
  "struct_node_list": [
    [
      "typedef struct {\n  /* The metric we sort them by. */\n  ULONG  metric;\n\n  /* Original index of the item, used as a secondary sort parameter to make\n   * qsort() stable if the metrics are equal */\n  size_t orig_idx;\n\n  /* Room enough for the string form of any IPv4 or IPv6 address that\n   * ares_inet_ntop() will create.  Based on the existing c-ares practice.\n   */\n  char   text[INET6_ADDRSTRLEN + 8 + 64]; /* [%s]:NNNNN%iface */\n} Address;",
      {
        "metric": "ULONG",
        "orig_idx": "size_t",
        "text[INET6_ADDRSTRLEN + 8 + 64]": "char"
      },
      "Address",
      [
        171,
        0
      ],
      [
        183,
        10
      ]
    ],
    [
      "typedef struct {\n  /* The metric we sort them by. */\n  ULONG  metric;\n\n  /* Original index of the item, used as a secondary sort parameter to make\n   * qsort() stable if the metrics are equal */\n  size_t orig_idx;\n\n  /* Room enough for the string form of any IPv4 or IPv6 address that\n   * ares_inet_ntop() will create.  Based on the existing c-ares practice.\n   */\n  char   text[INET6_ADDRSTRLEN + 8 + 64]; /* [%s]:NNNNN%iface */\n} Address;",
      {
        "metric": "ULONG",
        "orig_idx": "size_t",
        "text[INET6_ADDRSTRLEN + 8 + 64]": "char"
      },
      "Address",
      [
        171,
        0
      ],
      [
        183,
        10
      ]
    ],
    [
      "struct sockaddr",
      {},
      "",
      [
        319,
        4
      ],
      [
        319,
        19
      ]
    ],
    [
      "struct sockaddr_in",
      {},
      "",
      [
        320,
        4
      ],
      [
        320,
        22
      ]
    ],
    [
      "struct sockaddr_in6",
      {},
      "",
      [
        321,
        4
      ],
      [
        321,
        23
      ]
    ],
    [
      "struct ares_addr",
      {},
      "",
      [
        430,
        8
      ],
      [
        430,
        24
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        27,
        0
      ],
      [
        28,
        0
      ]
    ],
    [
      "#  include <sys/param.h>\n",
      [
        30,
        0
      ],
      [
        31,
        0
      ]
    ],
    [
      "#  include <netinet/in.h>\n",
      [
        34,
        0
      ],
      [
        35,
        0
      ]
    ],
    [
      "#  include <netdb.h>\n",
      [
        38,
        0
      ],
      [
        39,
        0
      ]
    ],
    [
      "#  include <arpa/inet.h>\n",
      [
        42,
        0
      ],
      [
        43,
        0
      ]
    ],
    [
      "#    include <iphlpapi.h>\n",
      [
        47,
        0
      ],
      [
        48,
        0
      ]
    ],
    [
      "#    include <netioapi.h>\n",
      [
        50,
        0
      ],
      [
        51,
        0
      ]
    ],
    [
      "#include \"ares_inet_net_pton.h\"\n",
      [
        54,
        0
      ],
      [
        55,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}