{
  "fn_def_list": [
    {
      "fn_code": "ares_status_t ares_expand_name_validated(const unsigned char *encoded,\n                                         const unsigned char *abuf, size_t alen,\n                                         char **s, size_t *enclen,\n                                         ares_bool_t is_hostname)\n{\n  ares_status_t status;\n  ares_buf_t   *buf = NULL;\n  size_t        start_len;\n\n  if (encoded == NULL || abuf == NULL || alen == 0 || enclen == NULL) {\n    return ARES_EBADNAME; /* EFORMERR would be better */\n  }\n\n  if (encoded < abuf || encoded >= abuf + alen) {\n    return ARES_EBADNAME; /* EFORMERR would be better */\n  }\n\n  *enclen = 0;\n\n  /* NOTE: we allow 's' to be NULL to skip it */\n  if (s) {\n    *s = NULL;\n  }\n\n  buf = ares_buf_create_const(abuf, alen);\n\n  if (buf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_buf_set_position(buf, (size_t)(encoded - abuf));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  start_len = ares_buf_len(buf);\n  status    = ares_dns_name_parse(buf, s, is_hostname);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  *enclen = start_len - ares_buf_len(buf);\n\ndone:\n  ares_buf_destroy(buf);\n  return status;\n}",
      "fn_code_pos": [
        [
          35,
          0
        ],
        [
          81,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_expand_name_validated",
        "parameters": {
          "encoded": "unsigned char",
          "abuf": "unsigned char",
          "alen": "size_t",
          "s": "char",
          "enclen": "size_t",
          "is_hostname": "ares_bool_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "int ares_expand_name(const unsigned char *encoded, const unsigned char *abuf,\n                     int alen, char **s, long *enclen)\n{\n  /* Keep public API compatible */\n  size_t        enclen_temp = 0;\n  ares_status_t status;\n\n  if (encoded == NULL || abuf == NULL || alen <= 0 || enclen == NULL) {\n    return ARES_EBADNAME;\n  }\n\n  status  = ares_expand_name_validated(encoded, abuf, (size_t)alen, s,\n                                       &enclen_temp, ARES_FALSE);\n  *enclen = (long)enclen_temp;\n  return (int)status;\n}",
      "fn_code_pos": [
        [
          83,
          0
        ],
        [
          98,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_expand_name",
        "parameters": {
          "encoded": "unsigned char",
          "abuf": "unsigned char",
          "alen": "int",
          "s": "char",
          "enclen": "long"
        },
        "return_type": "int"
      }
    }
  ],
  "fn_declaraion": [],
  "class_node_list": {},
  "struct_node_list": [],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        27,
        0
      ],
      [
        28,
        0
      ]
    ],
    [
      "#  include <netinet/in.h>\n",
      [
        30,
        0
      ],
      [
        31,
        0
      ]
    ],
    [
      "#include \"ares_nameser.h\"\n",
      [
        33,
        0
      ],
      [
        34,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}