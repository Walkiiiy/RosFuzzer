{
  "fn_def_list": [
    {
      "fn_code": "ares_status_t ares_parse_ptr_reply_dnsrec(const ares_dns_record_t *dnsrec,\n                                          const void *addr, int addrlen,\n                                          int family, struct hostent **host)\n{\n  ares_status_t   status;\n  size_t          ptrcount = 0;\n  struct hostent *hostent  = NULL;\n  const char     *hostname = NULL;\n  const char     *ptrname  = NULL;\n  size_t          i;\n  size_t          ancount;\n\n  *host = NULL;\n\n  /* Fetch name from query as we will use it to compare later on.  Old code\n   * did this check, so we'll retain it. */\n  status = ares_dns_record_query_get(dnsrec, 0, &ptrname, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  if (ancount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  /* Response structure */\n  hostent = ares_malloc(sizeof(*hostent));\n  if (hostent == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  memset(hostent, 0, sizeof(*hostent));\n\n  hostent->h_addr_list = ares_malloc(2 * sizeof(*hostent->h_addr_list));\n  if (hostent->h_addr_list == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n  memset(hostent->h_addr_list, 0, 2 * sizeof(*hostent->h_addr_list));\n  if (addr != NULL && addrlen > 0) {\n    hostent->h_addr_list[0] = ares_malloc((size_t)addrlen);\n    if (hostent->h_addr_list[0] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    memcpy(hostent->h_addr_list[0], addr, (size_t)addrlen);\n  }\n  hostent->h_addrtype = (HOSTENT_ADDRTYPE_TYPE)family;\n  hostent->h_length   = (HOSTENT_LENGTH_TYPE)addrlen;\n\n  /* Preallocate the maximum number + 1 */\n  hostent->h_aliases = ares_malloc((ancount + 1) * sizeof(*hostent->h_aliases));\n  if (hostent->h_aliases == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n  memset(hostent->h_aliases, 0, (ancount + 1) * sizeof(*hostent->h_aliases));\n\n\n  /* Cycle through answers */\n  for (i = 0; i < ancount; i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get_const(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN) {\n      continue;\n    }\n\n    /* Any time we see a CNAME, replace our ptrname with its value */\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_CNAME) {\n      ptrname = ares_dns_rr_get_str(rr, ARES_RR_CNAME_CNAME);\n      if (ptrname == NULL) {\n        status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n        goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n      }\n    }\n\n    /* Handling for PTR records below this, otherwise skip */\n    if (ares_dns_rr_get_type(rr) != ARES_REC_TYPE_PTR) {\n      continue;\n    }\n\n    /* Issue #683\n     * Old code compared the name in the rr to the ptrname, but I think this\n     * is wrong since it was proven wrong for A & AAAA records.  Leaving\n     * this code commented out for future reference\n     *\n     * rname = ares_dns_rr_get_name(rr);\n     * if (rname == NULL) {\n     *   status = ARES_EBADRESP;\n     *   goto done;\n     * }\n     * if (!ares_strcaseeq(ptrname, rname)) {\n     *   continue;\n     * }\n     */\n\n    /* Save most recent PTR record as the hostname */\n    hostname = ares_dns_rr_get_str(rr, ARES_RR_PTR_DNAME);\n    if (hostname == NULL) {\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    /* Append as an alias */\n    hostent->h_aliases[ptrcount] = ares_strdup(hostname);\n    if (hostent->h_aliases[ptrcount] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    ptrcount++;\n  }\n\n  if (ptrcount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  } else {\n    status = ARES_SUCCESS;\n  }\n\n  /* Fill in hostname */\n  hostent->h_name = ares_strdup(hostname);\n  if (hostent->h_name == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_free_hostent(hostent);\n    /* Compatibility */\n    if (status == ARES_EBADNAME) {\n      status = ARES_EBADRESP;\n    }\n  } else {\n    *host = hostent;\n  }\n  return status;\n}",
      "fn_code_pos": [
        [
          36,
          0
        ],
        [
          183,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_parse_ptr_reply_dnsrec",
        "parameters": {
          "dnsrec": "ares_dns_record_t",
          "addr": "void",
          "addrlen": "int",
          "family": "int",
          "host": "struct hostent"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "int ares_parse_ptr_reply(const unsigned char *abuf, int alen_int,\n                         const void *addr, int addrlen, int family,\n                         struct hostent **host)\n{\n  size_t             alen;\n  ares_dns_record_t *dnsrec = NULL;\n  ares_status_t      status;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_parse_ptr_reply_dnsrec(dnsrec, addr, addrlen, family, host);\n\ndone:\n  ares_dns_record_destroy(dnsrec);\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n  return (int)status;\n}",
      "fn_code_pos": [
        [
          185,
          0
        ],
        [
          212,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_parse_ptr_reply",
        "parameters": {
          "abuf": "unsigned char",
          "alen_int": "int",
          "addr": "void",
          "addrlen": "int",
          "family": "int",
          "host": "struct hostent"
        },
        "return_type": "int"
      }
    }
  ],
  "fn_declaraion": [],
  "class_node_list": {},
  "struct_node_list": [
    [
      "struct hostent",
      {},
      "",
      [
        38,
        54
      ],
      [
        38,
        68
      ]
    ],
    [
      "struct hostent",
      {},
      "",
      [
        42,
        2
      ],
      [
        42,
        16
      ]
    ],
    [
      "struct hostent",
      {},
      "",
      [
        187,
        25
      ],
      [
        187,
        39
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        26,
        0
      ],
      [
        27,
        0
      ]
    ],
    [
      "#  include <netinet/in.h>\n",
      [
        29,
        0
      ],
      [
        30,
        0
      ]
    ],
    [
      "#  include <netdb.h>\n",
      [
        32,
        0
      ],
      [
        33,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}