{
  "fn_def_list": [
    {
      "fn_code": "static int ares_parse_txt_reply_int(const unsigned char *abuf, size_t alen,\n                                    ares_bool_t ex, void **txt_out)\n{\n  ares_status_t        status;\n  struct ares_txt_ext *txt_head = NULL;\n  struct ares_txt_ext *txt_last = NULL;\n  struct ares_txt_ext *txt_curr;\n  ares_dns_record_t   *dnsrec = NULL;\n  size_t               i;\n\n  *txt_out = NULL;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n    size_t j;\n    size_t cnt;\n\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    /* XXX: Why Chaos? */\n    if ((ares_dns_rr_get_class(rr) != ARES_CLASS_IN &&\n         ares_dns_rr_get_class(rr) != ARES_CLASS_CHAOS) ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_TXT) {\n      continue;\n    }\n\n    cnt = ares_dns_rr_get_abin_cnt(rr, ARES_RR_TXT_DATA);\n\n    for (j = 0; j < cnt; j++) {\n      const unsigned char *ptr;\n      size_t               ptr_len;\n\n      /* Allocate storage for this TXT answer appending it to the list */\n      txt_curr =\n        ares_malloc_data(ex ? ARES_DATATYPE_TXT_EXT : ARES_DATATYPE_TXT_REPLY);\n      if (txt_curr == NULL) {\n        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n\n      /* Link in the record */\n      if (txt_last) {\n        txt_last->next = txt_curr;\n      } else {\n        txt_head = txt_curr;\n      }\n      txt_last = txt_curr;\n\n      /* Tag start on first for each TXT record */\n      if (ex && j == 0) {\n        txt_curr->record_start = 1;\n      }\n\n      ptr = ares_dns_rr_get_abin(rr, ARES_RR_TXT_DATA, j, &ptr_len);\n\n      txt_curr->txt = ares_malloc(ptr_len + 1);\n      if (txt_curr->txt == NULL) {\n        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      memcpy(txt_curr->txt, ptr, ptr_len);\n      txt_curr->txt[ptr_len] = 0;\n      txt_curr->length       = ptr_len;\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (txt_head) {\n      ares_free_data(txt_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *txt_out = txt_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
      "fn_code_pos": [
        [
          29,
          0
        ],
        [
          123,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_parse_txt_reply_int",
        "parameters": {
          "abuf": "unsigned char",
          "alen": "size_t",
          "ex": "ares_bool_t",
          "txt_out": "void"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "int ares_parse_txt_reply(const unsigned char *abuf, int alen,\n                         struct ares_txt_reply **txt_out)\n{\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n  return ares_parse_txt_reply_int(abuf, (size_t)alen, ARES_FALSE,\n                                  (void **)txt_out);\n}",
      "fn_code_pos": [
        [
          125,
          0
        ],
        [
          133,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_parse_txt_reply",
        "parameters": {
          "abuf": "unsigned char",
          "alen": "int",
          "txt_out": "struct ares_txt_reply"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "int ares_parse_txt_reply_ext(const unsigned char *abuf, int alen,\n                             struct ares_txt_ext **txt_out)\n{\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n  return ares_parse_txt_reply_int(abuf, (size_t)alen, ARES_TRUE,\n                                  (void **)txt_out);\n}",
      "fn_code_pos": [
        [
          135,
          0
        ],
        [
          143,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_parse_txt_reply_ext",
        "parameters": {
          "abuf": "unsigned char",
          "alen": "int",
          "txt_out": "struct ares_txt_ext"
        },
        "return_type": "int"
      }
    }
  ],
  "fn_declaraion": [],
  "class_node_list": {},
  "struct_node_list": [
    [
      "struct ares_txt_ext",
      {},
      "",
      [
        33,
        2
      ],
      [
        33,
        21
      ]
    ],
    [
      "struct ares_txt_ext",
      {},
      "",
      [
        34,
        2
      ],
      [
        34,
        21
      ]
    ],
    [
      "struct ares_txt_ext",
      {},
      "",
      [
        35,
        2
      ],
      [
        35,
        21
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        126,
        25
      ],
      [
        126,
        46
      ]
    ],
    [
      "struct ares_txt_ext",
      {},
      "",
      [
        136,
        29
      ],
      [
        136,
        48
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        26,
        0
      ],
      [
        27,
        0
      ]
    ],
    [
      "#include \"ares_data.h\"\n",
      [
        27,
        0
      ],
      [
        28,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}