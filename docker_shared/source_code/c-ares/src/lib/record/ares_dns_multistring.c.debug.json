{
  "fn_def_list": [
    {
      "fn_code": "static void ares_dns_multistring_free_cb(void *arg)\n{\n  multistring_data_t *data = arg;\n  if (data == NULL) {\n    return;\n  }\n  ares_free(data->data);\n}",
      "fn_code_pos": [
        [
          44,
          0
        ],
        [
          51,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_free_cb",
        "parameters": {
          "arg": "void"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "ares_dns_multistring_t *ares_dns_multistring_create(void)\n{\n  ares_dns_multistring_t *strs = ares_malloc_zero(sizeof(*strs));\n  if (strs == NULL) {\n    return NULL;\n  }\n\n  strs->strs =\n    ares_array_create(sizeof(multistring_data_t), ares_dns_multistring_free_cb);\n  if (strs->strs == NULL) {\n    ares_free(strs);\n    return NULL;\n  }\n\n  return strs;\n}",
      "fn_code_pos": [
        [
          53,
          0
        ],
        [
          68,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_create",
        "parameters": {},
        "return_type": "ares_dns_multistring_t"
      }
    },
    {
      "fn_code": "void ares_dns_multistring_clear(ares_dns_multistring_t *strs)\n{\n  if (strs == NULL) {\n    return;\n  }\n\n  while (ares_array_len(strs->strs)) {\n    ares_array_remove_last(strs->strs);\n  }\n}",
      "fn_code_pos": [
        [
          70,
          0
        ],
        [
          79,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_clear",
        "parameters": {
          "strs": "ares_dns_multistring_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "void ares_dns_multistring_destroy(ares_dns_multistring_t *strs)\n{\n  if (strs == NULL) {\n    return;\n  }\n  ares_dns_multistring_clear(strs);\n  ares_array_destroy(strs->strs);\n  ares_free(strs->cache_str);\n  ares_free(strs);\n}",
      "fn_code_pos": [
        [
          81,
          0
        ],
        [
          90,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_destroy",
        "parameters": {
          "strs": "ares_dns_multistring_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "ares_status_t ares_dns_multistring_swap_own(ares_dns_multistring_t *strs,\n                                            size_t idx, unsigned char *str,\n                                            size_t len)\n{\n  multistring_data_t *data;\n\n  if (strs == NULL || str == NULL || len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  strs->cache_invalidated = ARES_TRUE;\n\n  data = ares_array_at(strs->strs, idx);\n  if (data == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares_free(data->data);\n  data->data = str;\n  data->len  = len;\n  return ARES_SUCCESS;\n}",
      "fn_code_pos": [
        [
          92,
          0
        ],
        [
          113,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_swap_own",
        "parameters": {
          "strs": "ares_dns_multistring_t",
          "idx": "size_t",
          "str": "unsigned char",
          "len": "size_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_dns_multistring_del(ares_dns_multistring_t *strs, size_t idx)\n{\n  if (strs == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  strs->cache_invalidated = ARES_TRUE;\n\n  return ares_array_remove_at(strs->strs, idx);\n}",
      "fn_code_pos": [
        [
          115,
          0
        ],
        [
          124,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_del",
        "parameters": {
          "strs": "ares_dns_multistring_t",
          "idx": "size_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "ares_status_t ares_dns_multistring_add_own(ares_dns_multistring_t *strs,\n                                           unsigned char *str, size_t len)\n{\n  multistring_data_t *data;\n  ares_status_t       status;\n\n  if (strs == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  strs->cache_invalidated = ARES_TRUE;\n\n  /* NOTE: its ok to have an empty string added */\n  if (str == NULL && len != 0) {\n    return ARES_EFORMERR;\n  }\n\n  status = ares_array_insert_last((void **)&data, strs->strs);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Issue #921, ares_dns_multistring_get() doesn't have a way to indicate\n   * success or fail on a zero-length string which is actually valid.  So we\n   * are going to allocate a 1-byte buffer to use as a placeholder in this\n   * case */\n  if (str == NULL) {\n    str = ares_malloc_zero(1);\n    if (str == NULL) {\n      ares_array_remove_last(strs->strs);\n      return ARES_ENOMEM;\n    }\n  }\n\n  data->data = str;\n  data->len  = len;\n\n  return ARES_SUCCESS;\n}",
      "fn_code_pos": [
        [
          126,
          0
        ],
        [
          164,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_add_own",
        "parameters": {
          "strs": "ares_dns_multistring_t",
          "str": "unsigned char",
          "len": "size_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "size_t ares_dns_multistring_cnt(const ares_dns_multistring_t *strs)\n{\n  if (strs == NULL) {\n    return 0;\n  }\n  return ares_array_len(strs->strs);\n}",
      "fn_code_pos": [
        [
          166,
          0
        ],
        [
          172,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_cnt",
        "parameters": {
          "strs": "ares_dns_multistring_t"
        },
        "return_type": "size_t"
      }
    },
    {
      "fn_code": "const unsigned char *\n  ares_dns_multistring_get(const ares_dns_multistring_t *strs, size_t idx,\n                           size_t *len)\n{\n  const multistring_data_t *data;\n\n  if (strs == NULL || len == NULL) {\n    return NULL;\n  }\n\n  data = ares_array_at_const(strs->strs, idx);\n  if (data == NULL) {\n    return NULL;\n  }\n\n  *len = data->len;\n  return data->data;\n}",
      "fn_code_pos": [
        [
          174,
          0
        ],
        [
          191,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_get",
        "parameters": {
          "strs": "ares_dns_multistring_t",
          "idx": "size_t",
          "len": "size_t"
        },
        "return_type": null
      }
    },
    {
      "fn_code": "const unsigned char *ares_dns_multistring_combined(ares_dns_multistring_t *strs,\n                                                   size_t                 *len)\n{\n  ares_buf_t *buf = NULL;\n  size_t      i;\n\n  if (strs == NULL || len == NULL) {\n    return NULL;\n  }\n\n  *len = 0;\n\n  /* Return cache if possible */\n  if (!strs->cache_invalidated) {\n    *len = strs->cache_str_len;\n    return strs->cache_str;\n  }\n\n  /* Clear cache */\n  ares_free(strs->cache_str);\n  strs->cache_str     = NULL;\n  strs->cache_str_len = 0;\n\n  buf = ares_buf_create();\n\n  for (i = 0; i < ares_array_len(strs->strs); i++) {\n    const multistring_data_t *data = ares_array_at_const(strs->strs, i);\n    if (data == NULL ||\n        ares_buf_append(buf, data->data, data->len) != ARES_SUCCESS) {\n      ares_buf_destroy(buf);\n      return NULL;\n    }\n  }\n\n  strs->cache_str =\n    (unsigned char *)ares_buf_finish_str(buf, &strs->cache_str_len);\n  if (strs->cache_str != NULL) {\n    strs->cache_invalidated = ARES_FALSE;\n  }\n  *len = strs->cache_str_len;\n  return strs->cache_str;\n}",
      "fn_code_pos": [
        [
          193,
          0
        ],
        [
          234,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_combined",
        "parameters": {
          "strs": "ares_dns_multistring_t",
          "len": "size_t"
        },
        "return_type": null
      }
    },
    {
      "fn_code": "ares_status_t ares_dns_multistring_parse_buf(ares_buf_t *buf,\n                                             size_t      remaining_len,\n                                             ares_dns_multistring_t **strs,\n                                             ares_bool_t validate_printable)\n{\n  unsigned char len;\n  ares_status_t status   = ARES_EBADRESP;\n  size_t        orig_len = ares_buf_len(buf);\n\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (remaining_len == 0) {\n    return ARES_EBADRESP;\n  }\n\n  if (strs != NULL) {\n    *strs = ares_dns_multistring_create();\n    if (*strs == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  while (orig_len - ares_buf_len(buf) < remaining_len) {\n    status = ares_buf_fetch_bytes(buf, &len, 1);\n    if (status != ARES_SUCCESS) {\n      break; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n\n    /* When used by the _str() parser, it really needs to be validated to\n     * be a valid printable ascii string.  Do that here */\n    if (len && validate_printable && ares_buf_len(buf) >= len) {\n      size_t      mylen;\n      const char *data = (const char *)ares_buf_peek(buf, &mylen);\n      if (!ares_str_isprint(data, len)) {\n        status = ARES_EBADSTR;\n        break;\n      }\n    }\n\n    if (strs != NULL) {\n      unsigned char *data = NULL;\n      if (len) {\n        status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &data);\n        if (status != ARES_SUCCESS) {\n          break;\n        }\n      }\n      status = ares_dns_multistring_add_own(*strs, data, len);\n      if (status != ARES_SUCCESS) {\n        ares_free(data);\n        break;\n      }\n    } else {\n      status = ares_buf_consume(buf, len);\n      if (status != ARES_SUCCESS) {\n        break;\n      }\n    }\n\n  }\n\n  if (status != ARES_SUCCESS && strs != NULL) {\n    ares_dns_multistring_destroy(*strs);\n    *strs = NULL;\n  }\n\n  return status;\n}",
      "fn_code_pos": [
        [
          236,
          0
        ],
        [
          306,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_parse_buf",
        "parameters": {
          "buf": "ares_buf_t",
          "remaining_len": "size_t",
          "strs": "ares_dns_multistring_t",
          "validate_printable": "ares_bool_t"
        },
        "return_type": "ares_status_t"
      }
    }
  ],
  "fn_declaraion": [
    {
      "fn_code": "ares_dns_multistring_create(void)",
      "fn_dec_pos": [
        [
          53,
          24
        ],
        [
          53,
          57
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_create",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "ares_dns_multistring_get(const ares_dns_multistring_t *strs, size_t idx,\n                           size_t *len)",
      "fn_dec_pos": [
        [
          175,
          2
        ],
        [
          176,
          39
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_get",
        "parameters": {
          "strs": "ares_dns_multistring_t",
          "idx": "size_t",
          "len": "size_t"
        },
        "return_type": null
      }
    },
    {
      "fn_code": "ares_dns_multistring_combined(ares_dns_multistring_t *strs,\n                                                   size_t                 *len)",
      "fn_dec_pos": [
        [
          193,
          21
        ],
        [
          194,
          79
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "ares_dns_multistring_combined",
        "parameters": {
          "strs": "ares_dns_multistring_t",
          "len": "size_t"
        },
        "return_type": null
      }
    }
  ],
  "class_node_list": {},
  "struct_node_list": [
    [
      "typedef struct {\n  unsigned char *data;\n  size_t         len;\n} multistring_data_t;",
      {
        "*data": "unsigned char",
        "len": "size_t"
      },
      "multistring_data_t",
      [
        28,
        0
      ],
      [
        31,
        21
      ]
    ],
    [
      "struct ares_dns_multistring {\n  /*! whether or not cached concatenated string is valid */\n  ares_bool_t    cache_invalidated;\n  /*! combined/concatenated string cache */\n  unsigned char *cache_str;\n  /*! length of combined/concatenated string */\n  size_t         cache_str_len;\n  /*! Data making up strings */\n  ares_array_t  *strs; /*!< multistring_data_t type */\n}",
      {
        "cache_invalidated": "ares_bool_t",
        "*cache_str": "unsigned char",
        "cache_str_len": "size_t",
        "*strs": "ares_array_t"
      },
      "ares_dns_multistring",
      [
        33,
        0
      ],
      [
        42,
        1
      ]
    ],
    [
      "typedef struct {\n  unsigned char *data;\n  size_t         len;\n} multistring_data_t;",
      {
        "*data": "unsigned char",
        "len": "size_t"
      },
      "multistring_data_t",
      [
        28,
        0
      ],
      [
        31,
        21
      ]
    ],
    [
      "struct ares_dns_multistring {\n  /*! whether or not cached concatenated string is valid */\n  ares_bool_t    cache_invalidated;\n  /*! combined/concatenated string cache */\n  unsigned char *cache_str;\n  /*! length of combined/concatenated string */\n  size_t         cache_str_len;\n  /*! Data making up strings */\n  ares_array_t  *strs; /*!< multistring_data_t type */\n}",
      {
        "cache_invalidated": "ares_bool_t",
        "*cache_str": "unsigned char",
        "cache_str_len": "size_t",
        "*strs": "ares_array_t"
      },
      "ares_dns_multistring",
      [
        33,
        0
      ],
      [
        42,
        1
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares_private.h\"\n",
      [
        25,
        0
      ],
      [
        26,
        0
      ]
    ],
    [
      "#include \"ares_dns_private.h\"\n",
      [
        26,
        0
      ],
      [
        27,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}