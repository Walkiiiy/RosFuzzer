{
  "fn_def_list": [
    {
      "fn_code": "static void free_config(void)\n{\n  free(global_config.servers);\n  free(global_config.name);\n  free(global_config.opts.search);\n  memset(&global_config, 0, sizeof(global_config));\n}",
      "fn_code_pos": [
        [
          189,
          0
        ],
        [
          195,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "free_config",
        "parameters": {},
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_help(void)\n{\n  size_t i;\n  printf(\"adig version %s\\n\\n\", ares_version(NULL));\n  for (i = 0; helpstr[i] != NULL; i++) {\n    printf(\"%s\\n\", helpstr[i]);\n  }\n}",
      "fn_code_pos": [
        [
          197,
          0
        ],
        [
          204,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_help",
        "parameters": {},
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_flags(ares_dns_flags_t flags)\n{\n  if (flags & ARES_FLAG_QR) {\n    printf(\" qr\");\n  }\n  if (flags & ARES_FLAG_AA) {\n    printf(\" aa\");\n  }\n  if (flags & ARES_FLAG_TC) {\n    printf(\" tc\");\n  }\n  if (flags & ARES_FLAG_RD) {\n    printf(\" rd\");\n  }\n  if (flags & ARES_FLAG_RA) {\n    printf(\" ra\");\n  }\n  if (flags & ARES_FLAG_AD) {\n    printf(\" ad\");\n  }\n  if (flags & ARES_FLAG_CD) {\n    printf(\" cd\");\n  }\n}",
      "fn_code_pos": [
        [
          206,
          0
        ],
        [
          229,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_flags",
        "parameters": {
          "flags": "ares_dns_flags_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_header(const ares_dns_record_t *dnsrec)\n{\n  printf(\";; ->>HEADER<<- opcode: %s, status: %s, id: %u\\n\",\n         ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)),\n         ares_dns_rcode_tostr(ares_dns_record_get_rcode(dnsrec)),\n         ares_dns_record_get_id(dnsrec));\n  printf(\";; flags:\");\n  print_flags(ares_dns_record_get_flags(dnsrec));\n  printf(\"; QUERY: %u, ANSWER: %u, AUTHORITY: %u, ADDITIONAL: %u\\n\\n\",\n         (unsigned int)ares_dns_record_query_cnt(dnsrec),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n}",
      "fn_code_pos": [
        [
          231,
          0
        ],
        [
          244,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_header",
        "parameters": {
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_question(const ares_dns_record_t *dnsrec)\n{\n  size_t i;\n\n  if (global_config.opts.display_comments) {\n    printf(\";; QUESTION SECTION:\\n\");\n  }\n\n  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    const char         *name;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n    size_t              len;\n    if (ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass) !=\n        ARES_SUCCESS) {\n      return;\n    }\n    if (name == NULL) {\n      return;\n    }\n    len = strlen(name);\n    printf(\";%s.\\t\", name);\n    if (len + 1 < 24) {\n      printf(\"\\t\");\n    }\n    if (len + 1 < 16) {\n      printf(\"\\t\");\n    }\n\n    if (global_config.opts.display_class) {\n      printf(\"%s\\t\", ares_dns_class_tostr(qclass));\n    }\n\n    printf(\"%s\\n\", ares_dns_rec_type_tostr(qtype));\n  }\n\n  if (global_config.opts.display_comments) {\n    printf(\"\\n\");\n  }\n}",
      "fn_code_pos": [
        [
          246,
          0
        ],
        [
          285,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_question",
        "parameters": {
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_none(const unsigned char *val, size_t val_len)\n{\n  (void)val;\n  if (val_len != 0) {\n    printf(\"INVALID!\");\n  }\n}",
      "fn_code_pos": [
        [
          287,
          0
        ],
        [
          293,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_none",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_addr_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len % 4 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 4) {\n    char buf[256] = \"\";\n    ares_inet_ntop(AF_INET, val + i, buf, sizeof(buf));\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%s\", buf);\n  }\n}",
      "fn_code_pos": [
        [
          295,
          0
        ],
        [
          310,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_addr_list",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_addr6_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len % 16 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 16) {\n    char buf[256] = \"\";\n\n    ares_inet_ntop(AF_INET6, val + i, buf, sizeof(buf));\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%s\", buf);\n  }\n}",
      "fn_code_pos": [
        [
          312,
          0
        ],
        [
          328,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_addr6_list",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_u8_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n\n  for (i = 0; i < val_len; i++) {\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", (unsigned int)val[i]);\n  }\n}",
      "fn_code_pos": [
        [
          330,
          0
        ],
        [
          340,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_u8_list",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_u16_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len < 2 || val_len % 2 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 2) {\n    unsigned short u16 = 0;\n    unsigned short c;\n    /* Jumping over backwards to try to avoid odd compiler warnings */\n    c    = (unsigned short)val[i];\n    u16 |= (unsigned short)((c << 8) & 0xFFFF);\n    c    = (unsigned short)val[i + 1];\n    u16 |= c;\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", (unsigned int)u16);\n  }\n}",
      "fn_code_pos": [
        [
          342,
          0
        ],
        [
          362,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_u16_list",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_u32_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len < 4 || val_len % 4 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 4) {\n    unsigned int u32 = 0;\n\n    u32 |= (unsigned int)(val[i] << 24);\n    u32 |= (unsigned int)(val[i + 1] << 16);\n    u32 |= (unsigned int)(val[i + 2] << 8);\n    u32 |= (unsigned int)(val[i + 3]);\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", u32);\n  }\n}",
      "fn_code_pos": [
        [
          364,
          0
        ],
        [
          383,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_u32_list",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_str_list(const unsigned char *val, size_t val_len)\n{\n  size_t cnt = 0;\n\n  printf(\"\\\"\");\n  while (val_len) {\n    long           read_len = 0;\n    unsigned char *str      = NULL;\n    ares_status_t  status;\n\n    if (cnt) {\n      printf(\",\");\n    }\n\n    status = (ares_status_t)ares_expand_string(val, val, (int)val_len, &str,\n                                               &read_len);\n    if (status != ARES_SUCCESS) {\n      printf(\"INVALID\");\n      break;\n    }\n    printf(\"%s\", str);\n    ares_free_string(str);\n    val_len -= (size_t)read_len;\n    val     += read_len;\n    cnt++;\n  }\n  printf(\"\\\"\");\n}",
      "fn_code_pos": [
        [
          385,
          0
        ],
        [
          412,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_str_list",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_name(const unsigned char *val, size_t val_len)\n{\n  char *str      = NULL;\n  long  read_len = 0;\n\n  if (ares_expand_name(val, val, (int)val_len, &str, &read_len) !=\n      ARES_SUCCESS) {\n    printf(\"INVALID!\");\n    return;\n  }\n\n  printf(\"%s.\", str);\n  ares_free_string(str);\n}",
      "fn_code_pos": [
        [
          414,
          0
        ],
        [
          427,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_name",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_bin(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n\n  for (i = 0; i < val_len; i++) {\n    printf(\"%02x\", (unsigned int)val[i]);\n  }\n}",
      "fn_code_pos": [
        [
          429,
          0
        ],
        [
          436,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_bin",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_bool_t adig_isprint(int ch)\n{\n  if (ch >= 0x20 && ch <= 0x7E) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          438,
          0
        ],
        [
          444,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "adig_isprint",
        "parameters": {
          "ch": "int"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static void print_opt_binp(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  printf(\"\\\"\");\n  for (i = 0; i < val_len; i++) {\n    if (adig_isprint(val[i])) {\n      printf(\"%c\", val[i]);\n    } else {\n      printf(\"\\\\%03d\", val[i]);\n    }\n  }\n  printf(\"\\\"\");\n}",
      "fn_code_pos": [
        [
          446,
          0
        ],
        [
          458,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_binp",
        "parameters": {
          "val": "unsigned char",
          "val_len": "size_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opts(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t i;\n\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, key); i++) {\n    size_t               val_len = 0;\n    const unsigned char *val     = NULL;\n    unsigned short       opt;\n    const char          *name;\n\n    if (i != 0) {\n      printf(\" \");\n    }\n\n    opt  = ares_dns_rr_get_opt(rr, key, i, &val, &val_len);\n    name = ares_dns_opt_get_name(key, opt);\n    if (name == NULL) {\n      printf(\"key%u\", (unsigned int)opt);\n    } else {\n      printf(\"%s\", name);\n    }\n    if (val_len == 0) {\n      return;\n    }\n\n    printf(\"=\");\n\n    switch (ares_dns_opt_get_datatype(key, opt)) {\n      case ARES_OPT_DATATYPE_NONE:\n        print_opt_none(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U8_LIST:\n        print_opt_u8_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_INADDR4_LIST:\n        print_opt_addr_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_INADDR6_LIST:\n        print_opt_addr6_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U16:\n      case ARES_OPT_DATATYPE_U16_LIST:\n        print_opt_u16_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U32:\n      case ARES_OPT_DATATYPE_U32_LIST:\n        print_opt_u32_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_STR_LIST:\n        print_opt_str_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_BIN:\n        print_opt_bin(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_NAME:\n        print_opt_name(val, val_len);\n        break;\n    }\n  }\n}",
      "fn_code_pos": [
        [
          460,
          0
        ],
        [
          519,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opts",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_addr(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const struct in_addr *addr     = ares_dns_rr_get_addr(rr, key);\n  char                  buf[256] = \"\";\n\n  ares_inet_ntop(AF_INET, addr, buf, sizeof(buf));\n  printf(\"%s\", buf);\n}",
      "fn_code_pos": [
        [
          521,
          0
        ],
        [
          528,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_addr",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_addr6(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const struct ares_in6_addr *addr     = ares_dns_rr_get_addr6(rr, key);\n  char                        buf[256] = \"\";\n\n  ares_inet_ntop(AF_INET6, addr, buf, sizeof(buf));\n  printf(\"%s\", buf);\n}",
      "fn_code_pos": [
        [
          530,
          0
        ],
        [
          537,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_addr6",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_u8(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned char u8 = ares_dns_rr_get_u8(rr, key);\n  printf(\"%u\", (unsigned int)u8);\n}",
      "fn_code_pos": [
        [
          539,
          0
        ],
        [
          543,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_u8",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_u16(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned short u16 = ares_dns_rr_get_u16(rr, key);\n  printf(\"%u\", (unsigned int)u16);\n}",
      "fn_code_pos": [
        [
          545,
          0
        ],
        [
          549,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_u16",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_u32(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned int u32 = ares_dns_rr_get_u32(rr, key);\n  printf(\"%u\", u32);\n}",
      "fn_code_pos": [
        [
          551,
          0
        ],
        [
          555,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_u32",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_name(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const char *str = ares_dns_rr_get_str(rr, key);\n  printf(\"%s.\", str);\n}",
      "fn_code_pos": [
        [
          557,
          0
        ],
        [
          561,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_name",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_str(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const char *str = ares_dns_rr_get_str(rr, key);\n  printf(\"\\\"%s\\\"\", str);\n}",
      "fn_code_pos": [
        [
          563,
          0
        ],
        [
          567,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_str",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_bin(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t               len  = 0;\n  const unsigned char *binp = ares_dns_rr_get_bin(rr, key, &len);\n  print_opt_bin(binp, len);\n}",
      "fn_code_pos": [
        [
          569,
          0
        ],
        [
          574,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_bin",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_binp(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t               len;\n  const unsigned char *binp = ares_dns_rr_get_bin(rr, key, &len);\n\n  print_opt_binp(binp, len);\n}",
      "fn_code_pos": [
        [
          576,
          0
        ],
        [
          582,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_binp",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_abinp(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t i;\n  size_t cnt = ares_dns_rr_get_abin_cnt(rr, key);\n\n  for (i = 0; i < cnt; i++) {\n    size_t               len;\n    const unsigned char *binp = ares_dns_rr_get_abin(rr, key, i, &len);\n    if (i != 0) {\n      printf(\" \");\n    }\n    print_opt_binp(binp, len);\n  }\n}",
      "fn_code_pos": [
        [
          584,
          0
        ],
        [
          597,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_abinp",
        "parameters": {
          "rr": "ares_dns_rr_t",
          "key": "ares_dns_rr_key_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_rr(const ares_dns_rr_t *rr)\n{\n  const char              *name     = ares_dns_rr_get_name(rr);\n  size_t                   len      = 0;\n  size_t                   keys_cnt = 0;\n  ares_dns_rec_type_t      rtype    = ares_dns_rr_get_type(rr);\n  const ares_dns_rr_key_t *keys     = ares_dns_rr_get_keys(rtype, &keys_cnt);\n  size_t                   i;\n\n  if (name == NULL) {\n    return;\n  }\n\n  len = strlen(name);\n\n  printf(\"%s.\\t\", name);\n  if (len < 24) {\n    printf(\"\\t\");\n  }\n\n  if (global_config.opts.display_ttl) {\n    printf(\"%u\\t\", ares_dns_rr_get_ttl(rr));\n  }\n\n  if (global_config.opts.display_class) {\n    printf(\"%s\\t\", ares_dns_class_tostr(ares_dns_rr_get_class(rr)));\n  }\n\n  printf(\"%s\\t\", ares_dns_rec_type_tostr(rtype));\n\n  /* Output params here */\n  for (i = 0; i < keys_cnt; i++) {\n    ares_dns_datatype_t datatype = ares_dns_rr_key_datatype(keys[i]);\n    if (i != 0) {\n      printf(\" \");\n    }\n\n    switch (datatype) {\n      case ARES_DATATYPE_INADDR:\n        print_addr(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_INADDR6:\n        print_addr6(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U8:\n        print_u8(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U16:\n        print_u16(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U32:\n        print_u32(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_NAME:\n        print_name(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_STR:\n        print_str(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_BIN:\n        print_bin(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_BINP:\n        print_binp(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_ABINP:\n        print_abinp(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_OPT:\n        print_opts(rr, keys[i]);\n        break;\n    }\n  }\n\n  printf(\"\\n\");\n}",
      "fn_code_pos": [
        [
          599,
          0
        ],
        [
          674,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_rr",
        "parameters": {
          "rr": "ares_dns_rr_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static const ares_dns_rr_t *has_opt(const ares_dns_record_t *dnsrec,\n                                    ares_dns_section_t       section)\n{\n  size_t i;\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {\n    const ares_dns_rr_t *rr = ares_dns_record_rr_get_const(dnsrec, section, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      return rr;\n    }\n  }\n  return NULL;\n}",
      "fn_code_pos": [
        [
          676,
          0
        ],
        [
          687,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "has_opt",
        "parameters": {
          "dnsrec": "ares_dns_record_t",
          "section": "ares_dns_section_t"
        },
        "return_type": "ares_dns_rr_t"
      }
    },
    {
      "fn_code": "static void print_section(const ares_dns_record_t *dnsrec,\n                          ares_dns_section_t       section)\n{\n  size_t i;\n\n  if (ares_dns_record_rr_cnt(dnsrec, section) == 0 ||\n      (ares_dns_record_rr_cnt(dnsrec, section) == 1 &&\n       has_opt(dnsrec, section) != NULL)) {\n    return;\n  }\n\n  if (global_config.opts.display_comments) {\n    printf(\";; %s SECTION:\\n\", ares_dns_section_tostr(section));\n  }\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {\n    const ares_dns_rr_t *rr = ares_dns_record_rr_get_const(dnsrec, section, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      continue;\n    }\n    print_rr(rr);\n  }\n  if (global_config.opts.display_comments) {\n    printf(\"\\n\");\n  }\n}",
      "fn_code_pos": [
        [
          689,
          0
        ],
        [
          713,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_section",
        "parameters": {
          "dnsrec": "ares_dns_record_t",
          "section": "ares_dns_section_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_opt_psuedosection(const ares_dns_record_t *dnsrec)\n{\n  const ares_dns_rr_t *rr         = has_opt(dnsrec, ARES_SECTION_ADDITIONAL);\n  const unsigned char *cookie     = NULL;\n  size_t               cookie_len = 0;\n\n  if (rr == NULL) {\n    return;\n  }\n\n  if (!ares_dns_rr_get_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE,\n                                &cookie, &cookie_len)) {\n    cookie = NULL;\n  }\n\n  printf(\";; OPT PSEUDOSECTION:\\n\");\n  printf(\"; EDNS: version: %u, flags: %u; udp: %u\\n\",\n         (unsigned int)ares_dns_rr_get_u8(rr, ARES_RR_OPT_VERSION),\n         (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_FLAGS),\n         (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_UDP_SIZE));\n\n  if (cookie) {\n    printf(\"; COOKIE: \");\n    print_opt_bin(cookie, cookie_len);\n    printf(\" (good)\\n\");\n  }\n}",
      "fn_code_pos": [
        [
          715,
          0
        ],
        [
          741,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_opt_psuedosection",
        "parameters": {
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void print_record(const ares_dns_record_t *dnsrec)\n{\n  if (global_config.opts.display_comments) {\n    print_header(dnsrec);\n    print_opt_psuedosection(dnsrec);\n  }\n\n  if (global_config.opts.display_question) {\n    print_question(dnsrec);\n  }\n\n  if (global_config.opts.display_answer) {\n    print_section(dnsrec, ARES_SECTION_ANSWER);\n  }\n\n  if (global_config.opts.display_additional) {\n    print_section(dnsrec, ARES_SECTION_ADDITIONAL);\n  }\n\n  if (global_config.opts.display_authority) {\n    print_section(dnsrec, ARES_SECTION_AUTHORITY);\n  }\n\n  if (global_config.opts.display_stats) {\n    unsigned char *abuf = NULL;\n    size_t         alen = 0;\n    ares_dns_write(dnsrec, &abuf, &alen);\n    printf(\";; MSG SIZE  rcvd: %d\\n\\n\", (int)alen);\n    ares_free_string(abuf);\n  }\n}",
      "fn_code_pos": [
        [
          743,
          0
        ],
        [
          773,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "print_record",
        "parameters": {
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void callback(void *arg, ares_status_t status, size_t timeouts,\n                     const ares_dns_record_t *dnsrec)\n{\n  (void)arg;\n  (void)timeouts;\n\n  if (status != ARES_SUCCESS) {\n    final_rv = RV_FAIL;\n  }\n\n  if (global_config.opts.display_comments) {\n    /* We got a \"Server status\" */\n    if (status >= ARES_SUCCESS && status <= ARES_EREFUSED) {\n      printf(\";; Got answer:\");\n    } else {\n      printf(\";;\");\n    }\n    if (status != ARES_SUCCESS) {\n      printf(\" %s\", ares_strerror((int)status));\n    }\n    printf(\"\\n\");\n  }\n\n  print_record(dnsrec);\n}",
      "fn_code_pos": [
        [
          775,
          0
        ],
        [
          799,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "callback",
        "parameters": {
          "arg": "void",
          "status": "ares_status_t",
          "timeouts": "size_t",
          "dnsrec": "ares_dns_record_t"
        },
        "return_type": "void"
      }
    },
    {
      "fn_code": "static ares_status_t enqueue_query(ares_channel_t *channel)\n{\n  ares_dns_record_t *dnsrec = NULL;\n  ares_dns_rr_t     *rr     = NULL;\n  ares_status_t      status;\n  unsigned short     flags    = 0;\n  char              *nametemp = NULL;\n  const char        *name     = global_config.name;\n\n  if (global_config.opts.aa_flag) {\n    flags |= ARES_FLAG_AA;\n  }\n\n  if (global_config.opts.ad_flag) {\n    flags |= ARES_FLAG_AD;\n  }\n\n  if (global_config.opts.cd_flag) {\n    flags |= ARES_FLAG_CD;\n  }\n\n  if (global_config.opts.rd_flag) {\n    flags |= ARES_FLAG_RD;\n  }\n\n  status = ares_dns_record_create(&dnsrec, 0, flags, ARES_OPCODE_QUERY,\n                                  ARES_RCODE_NOERROR);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* If it is a PTR record, convert from ip address into in-arpa form\n   * automatically */\n  if (global_config.qtype == ARES_REC_TYPE_PTR) {\n    struct ares_addr addr;\n    size_t           len;\n    addr.family = AF_UNSPEC;\n\n    if (ares_dns_pton(name, &addr, &len) != NULL) {\n      nametemp = ares_dns_addr_to_ptr(&addr);\n      name     = nametemp;\n    }\n  }\n\n  status = ares_dns_record_query_add(dnsrec, name, global_config.qtype,\n                                     global_config.qclass);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (global_config.opts.edns) {\n    status = ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n                                    ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n    ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE,\n                        (unsigned short)global_config.opts.udp_size);\n    ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0);\n  }\n\n  if (global_config.opts.display_query) {\n    printf(\";; Sending:\\n\");\n    print_record(dnsrec);\n  }\n\n  if (global_config.opts.do_search) {\n    status = ares_search_dnsrec(channel, dnsrec, callback, NULL);\n  } else {\n    status = ares_send_dnsrec(channel, dnsrec, callback, NULL, NULL);\n  }\n\ndone:\n  ares_free_string(nametemp);\n  ares_dns_record_destroy(dnsrec);\n  return status;\n}",
      "fn_code_pos": [
        [
          801,
          0
        ],
        [
          877,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "enqueue_query",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": "ares_status_t"
      }
    },
    {
      "fn_code": "static int event_loop(ares_channel_t *channel)\n{\n  while (1) {\n    fd_set          read_fds;\n    fd_set          write_fds;\n    int             nfds;\n    struct timeval  tv;\n    struct timeval *tvp;\n    int             count;\n\n    FD_ZERO(&read_fds);\n    FD_ZERO(&write_fds);\n    memset(&tv, 0, sizeof(tv));\n\n    nfds = ares_fds(channel, &read_fds, &write_fds);\n    if (nfds == 0) {\n      break;\n    }\n    tvp = ares_timeout(channel, NULL, &tv);\n    if (tvp == NULL) {\n      break;\n    }\n    count = select(nfds, &read_fds, &write_fds, NULL, tvp);\n    if (count < 0) {\n#ifdef USE_WINSOCK\n      int err = WSAGetLastError();\n#else\n      int err = errno;\n#endif\n      if (err != EAGAIN && err != EINTR) {\n        fprintf(stderr, \"select fail: %d\", err);\n        return 1;\n      }\n    }\n    ares_process(channel, &read_fds, &write_fds);\n  }\n  return 0;\n}",
      "fn_code_pos": [
        [
          879,
          0
        ],
        [
          916,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "event_loop",
        "parameters": {
          "channel": "ares_channel_t"
        },
        "return_type": "int"
      }
    },
    {
      "fn_code": "static ares_bool_t opt_class_cb(char prefix, const char *name,\n                                ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n\n  if (!ares_dns_class_fromstr(&global_config.qclass, value)) {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"unrecognized class %s\", value);\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          936,
          0
        ],
        [
          950,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "opt_class_cb",
        "parameters": {
          "prefix": "char",
          "name": "char",
          "is_true": "ares_bool_t",
          "value": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t opt_type_cb(char prefix, const char *name,\n                               ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n\n  if (!ares_dns_rec_type_fromstr(&global_config.qtype, value)) {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"unrecognized record type %s\", value);\n    return ARES_FALSE;\n  }\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          952,
          0
        ],
        [
          965,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "opt_type_cb",
        "parameters": {
          "prefix": "char",
          "name": "char",
          "is_true": "ares_bool_t",
          "value": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t opt_ptr_cb(char prefix, const char *name,\n                              ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n  global_config.qtype = ARES_REC_TYPE_PTR;\n  ares_free(global_config.name);\n  global_config.name = strdup(value);\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          967,
          0
        ],
        [
          977,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "opt_ptr_cb",
        "parameters": {
          "prefix": "char",
          "name": "char",
          "is_true": "ares_bool_t",
          "value": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t opt_all_cb(char prefix, const char *name,\n                              ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)value;\n\n  global_config.opts.display_command    = is_true;\n  global_config.opts.display_stats      = is_true;\n  global_config.opts.display_question   = is_true;\n  global_config.opts.display_answer     = is_true;\n  global_config.opts.display_authority  = is_true;\n  global_config.opts.display_additional = is_true;\n  global_config.opts.display_comments   = is_true;\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          979,
          0
        ],
        [
          994,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "opt_all_cb",
        "parameters": {
          "prefix": "char",
          "name": "char",
          "is_true": "ares_bool_t",
          "value": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t opt_edns_cb(char prefix, const char *name,\n                               ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n\n  global_config.opts.edns = is_true;\n  if (is_true && value != NULL && atoi(value) > 0) {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"edns 0 only supported\");\n    return ARES_FALSE;\n  }\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          996,
          0
        ],
        [
          1009,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "opt_edns_cb",
        "parameters": {
          "prefix": "char",
          "name": "char",
          "is_true": "ares_bool_t",
          "value": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t opt_retry_cb(char prefix, const char *name,\n                                ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n\n  if (!ares_str_isnum(value)) {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"value not numeric\");\n    return ARES_FALSE;\n  }\n\n  global_config.opts.tries = strtoul(value, NULL, 10) + 1;\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          1011,
          0
        ],
        [
          1026,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "opt_retry_cb",
        "parameters": {
          "prefix": "char",
          "name": "char",
          "is_true": "ares_bool_t",
          "value": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t opt_dig_bare_cb(char prefix, const char *name,\n                                   ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n\n  /* Handle @servers */\n  if (*value == '@') {\n    free(global_config.servers);\n    global_config.servers = strdup(value + 1);\n    return ARES_TRUE;\n  }\n\n  /* Make sure we don't pass options */\n  if (*value == '-' || *value == '+') {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"unrecognized argument %s\", value);\n    return ARES_FALSE;\n  }\n\n  /* See if it is a DNS class */\n  if (ares_dns_class_fromstr(&global_config.qclass, value)) {\n    return ARES_TRUE;\n  }\n\n  /* See if it is a DNS record type */\n  if (ares_dns_rec_type_fromstr(&global_config.qtype, value)) {\n    return ARES_TRUE;\n  }\n\n  /* See if it is a domain name */\n  if (ares_is_hostname(value)) {\n    free(global_config.name);\n    global_config.name = strdup(value);\n    return ARES_TRUE;\n  }\n\n  snprintf(global_config.error, sizeof(global_config.error),\n           \"unrecognized argument %s\", value);\n  return ARES_FALSE;\n}",
      "fn_code_pos": [
        [
          1028,
          0
        ],
        [
          1069,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "opt_dig_bare_cb",
        "parameters": {
          "prefix": "char",
          "name": "char",
          "is_true": "ares_bool_t",
          "value": "char"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t read_cmdline(int argc, const char * const *argv,\n                                int start_idx)\n{\n  int    arg;\n  size_t opt;\n\n  for (arg = start_idx; arg < argc; arg++) {\n    ares_bool_t option_handled = ARES_FALSE;\n\n    for (opt = 0; !option_handled &&\n                  (dig_options[opt].opt != NULL || dig_options[opt].cb != NULL);\n         opt++) {\n      ares_bool_t is_true = ARES_TRUE;\n      const char *value   = NULL;\n      const char *nameptr = NULL;\n      size_t      namelen;\n\n      /* Match prefix character */\n      if (dig_options[opt].prefix != 0 &&\n          dig_options[opt].prefix != *(argv[arg])) {\n        continue;\n      }\n\n      nameptr = argv[arg];\n\n      /* skip prefix */\n      if (dig_options[opt].prefix != 0) {\n        nameptr++;\n      }\n\n      /* Negated option if it has a 'no' prefix */\n      if (ares_streq_max(nameptr, \"no\", 2)) {\n        is_true  = ARES_FALSE;\n        nameptr += 2;\n      }\n\n      if (dig_options[opt].separator != 0) {\n        const char *ptr = strchr(nameptr, dig_options[opt].separator);\n        if (ptr == NULL) {\n          namelen = ares_strlen(nameptr);\n        } else {\n          namelen = (size_t)(ptr - nameptr);\n          value   = ptr + 1;\n        }\n      } else {\n        namelen = ares_strlen(nameptr);\n      }\n\n      /* Match name */\n      if (dig_options[opt].name != NULL &&\n          !ares_streq_max(nameptr, dig_options[opt].name, namelen)) {\n        continue;\n      }\n\n      if (dig_options[opt].name == NULL) {\n        value = nameptr;\n      }\n\n      /* We need another argument for the value */\n      if (dig_options[opt].type != OPT_TYPE_BOOL &&\n          dig_options[opt].prefix != 0 && dig_options[opt].separator == 0) {\n        if (arg == argc - 1) {\n          snprintf(global_config.error, sizeof(global_config.error),\n                   \"insufficient arguments for %c%s\", dig_options[opt].prefix,\n                   dig_options[opt].name);\n          return ARES_FALSE;\n        }\n        arg++;\n        value = argv[arg];\n      }\n\n      switch (dig_options[opt].type) {\n        case OPT_TYPE_BOOL:\n          {\n            ares_bool_t *b = dig_options[opt].opt;\n            if (b == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"invalid use for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            *b = is_true;\n          }\n          break;\n        case OPT_TYPE_STRING:\n          {\n            char **str = dig_options[opt].opt;\n            if (str == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"invalid use for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (value == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"missing value for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (*str != NULL) {\n              free(*str);\n            }\n            *str = strdup(value);\n            break;\n          }\n        case OPT_TYPE_SIZE_T:\n          {\n            size_t *s = dig_options[opt].opt;\n            if (s == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"invalid use for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (value == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"missing value for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (!ares_str_isnum(value)) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"%c%s is not a numeric value\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            *s = strtoul(value, NULL, 10);\n            break;\n          }\n        case OPT_TYPE_U16:\n          {\n            unsigned short *s = dig_options[opt].opt;\n            if (s == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"invalid use for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (value == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"missing value for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (!ares_str_isnum(value)) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"%c%s is not a numeric value\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            *s = (unsigned short)strtoul(value, NULL, 10);\n            break;\n          }\n        case OPT_TYPE_FUNC:\n          if (dig_options[opt].cb == NULL) {\n            snprintf(global_config.error, sizeof(global_config.error),\n                     \"missing callback\");\n            return ARES_FALSE;\n          }\n          if (!dig_options[opt].cb(dig_options[opt].prefix,\n                                   dig_options[opt].name, is_true, value)) {\n            return ARES_FALSE;\n          }\n          break;\n      }\n      option_handled = ARES_TRUE;\n    }\n\n    if (!option_handled) {\n      snprintf(global_config.error, sizeof(global_config.error),\n               \"unrecognized option %s\", argv[arg]);\n      return ARES_FALSE;\n    }\n  }\n\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          1146,
          0
        ],
        [
          1322,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "read_cmdline",
        "parameters": {
          "argc": "int",
          "argv": "char",
          "start_idx": "int"
        },
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static ares_bool_t read_rcfile(void)\n{\n  char         configdir[PATH_MAX];\n  unsigned int cdlen = 0;\n\n#if !defined(WIN32)\n#  if !defined(__APPLE__)\n  char *configdir_xdg;\n#  endif\n  char *homedir;\n#endif\n\n  char          rcfile[PATH_MAX];\n  unsigned int  rclen;\n\n  size_t        rcargc;\n  char        **rcargv;\n  ares_buf_t   *rcbuf;\n  ares_status_t rcstatus;\n\n#if defined(WIN32)\n  cdlen = (unsigned int)snprintf(configdir, sizeof(configdir), \"%s/%s\",\n                                 getenv(\"APPDATA\"), \"c-ares\");\n\n#elif defined(__APPLE__)\n  homedir = getenv(\"HOME\");\n  if (homedir != NULL) {\n    cdlen = (unsigned int)snprintf(configdir, sizeof(configdir), \"%s/%s/%s/%s\",\n                                   homedir, \"Library\", \"Application Support\",\n                                   \"c-ares\");\n  }\n\n#else\n  configdir_xdg = getenv(\"XDG_CONFIG_HOME\");\n\n  if (configdir_xdg == NULL) {\n    homedir = getenv(\"HOME\");\n    if (homedir != NULL) {\n      cdlen = (unsigned int)snprintf(configdir, sizeof(configdir), \"%s/%s\",\n                                     homedir, \".config\");\n    }\n  } else {\n    cdlen =\n      (unsigned int)snprintf(configdir, sizeof(configdir), \"%s\", configdir_xdg);\n  }\n\n#endif\n\n  DEBUGF(fprintf(stderr, \"read_cmdline() configdir: %s\\n\", configdir));\n\n  if (cdlen == 0 || cdlen > sizeof(configdir)) {\n    DEBUGF(\n      fprintf(stderr, \"read_cmdline() skipping rcfile parsing on directory\\n\"));\n    return ARES_TRUE;\n  }\n\n  rclen =\n    (unsigned int)snprintf(rcfile, sizeof(rcfile), \"%s/adigrc\", configdir);\n\n  if (rclen > sizeof(rcfile)) {\n    DEBUGF(fprintf(stderr, \"read_cmdline() skipping rcfile parsing on file\\n\"));\n    return ARES_TRUE;\n  }\n\n  rcbuf = ares_buf_create();\n  if (ares_buf_load_file(rcfile, rcbuf) == ARES_SUCCESS) {\n    rcstatus = ares_buf_split_str(rcbuf, (const unsigned char *)\"\\n \", 2,\n                                  ARES_BUF_SPLIT_TRIM, 0, &rcargv, &rcargc);\n\n    if (rcstatus == ARES_SUCCESS) {\n      read_cmdline((int)rcargc, (const char * const *)rcargv, 0);\n\n    } else {\n      snprintf(global_config.error, sizeof(global_config.error),\n               \"rcfile is invalid: %s\", ares_strerror((int)rcstatus));\n    }\n\n    ares_free_array(rcargv, rcargc, ares_free);\n\n    if (rcstatus != ARES_SUCCESS) {\n      ares_buf_destroy(rcbuf);\n      return ARES_FALSE;\n    }\n\n  } else {\n    DEBUGF(fprintf(stderr, \"read_cmdline() failed to load rcfile\"));\n  }\n  ares_buf_destroy(rcbuf);\n\n  return ARES_TRUE;\n}",
      "fn_code_pos": [
        [
          1324,
          0
        ],
        [
          1414,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "read_rcfile",
        "parameters": {},
        "return_type": "ares_bool_t"
      }
    },
    {
      "fn_code": "static void config_defaults(void)\n{\n  memset(&global_config, 0, sizeof(global_config));\n\n  global_config.opts.tries              = 3;\n  global_config.opts.ndots              = 1;\n  global_config.opts.rd_flag            = ARES_TRUE;\n  global_config.opts.edns               = ARES_TRUE;\n  global_config.opts.udp_size           = 1232;\n  global_config.opts.aliases            = ARES_TRUE;\n  global_config.opts.display_class      = ARES_TRUE;\n  global_config.opts.display_ttl        = ARES_TRUE;\n  global_config.opts.display_command    = ARES_TRUE;\n  global_config.opts.display_stats      = ARES_TRUE;\n  global_config.opts.display_question   = ARES_TRUE;\n  global_config.opts.display_answer     = ARES_TRUE;\n  global_config.opts.display_authority  = ARES_TRUE;\n  global_config.opts.display_additional = ARES_TRUE;\n  global_config.opts.display_comments   = ARES_TRUE;\n  global_config.qclass                  = ARES_CLASS_IN;\n  global_config.qtype                   = ARES_REC_TYPE_A;\n}",
      "fn_code_pos": [
        [
          1416,
          0
        ],
        [
          1437,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "config_defaults",
        "parameters": {},
        "return_type": "void"
      }
    },
    {
      "fn_code": "static void config_opts(void)\n{\n  global_config.optmask = ARES_OPT_FLAGS;\n  if (global_config.opts.tcp) {\n    global_config.options.flags |= ARES_FLAG_USEVC;\n  }\n  if (global_config.opts.primary) {\n    global_config.options.flags |= ARES_FLAG_PRIMARY;\n  }\n  if (global_config.opts.edns) {\n    global_config.options.flags |= ARES_FLAG_EDNS;\n  }\n  if (global_config.opts.stayopen) {\n    global_config.options.flags |= ARES_FLAG_STAYOPEN;\n  }\n  if (global_config.opts.dns0x20) {\n    global_config.options.flags |= ARES_FLAG_DNS0x20;\n  }\n  if (!global_config.opts.aliases) {\n    global_config.options.flags |= ARES_FLAG_NOALIASES;\n  }\n  if (!global_config.opts.rd_flag) {\n    global_config.options.flags |= ARES_FLAG_NORECURSE;\n  }\n  if (!global_config.opts.do_search) {\n    global_config.options.flags |= ARES_FLAG_NOSEARCH;\n  }\n  if (global_config.opts.ignore_tc) {\n    global_config.options.flags |= ARES_FLAG_IGNTC;\n  }\n  if (global_config.opts.port) {\n    global_config.optmask          |= ARES_OPT_UDP_PORT;\n    global_config.optmask          |= ARES_OPT_TCP_PORT;\n    global_config.options.udp_port  = global_config.opts.port;\n    global_config.options.tcp_port  = global_config.opts.port;\n  }\n\n  global_config.optmask       |= ARES_OPT_TRIES;\n  global_config.options.tries  = (int)global_config.opts.tries;\n\n  global_config.optmask       |= ARES_OPT_NDOTS;\n  global_config.options.ndots  = (int)global_config.opts.ndots;\n\n  global_config.optmask         |= ARES_OPT_EDNSPSZ;\n  global_config.options.ednspsz  = (int)global_config.opts.udp_size;\n\n  if (global_config.opts.search != NULL) {\n    global_config.optmask          |= ARES_OPT_DOMAINS;\n    global_config.options.domains   = &global_config.opts.search;\n    global_config.options.ndomains  = 1;\n  }\n}",
      "fn_code_pos": [
        [
          1439,
          0
        ],
        [
          1490,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "config_opts",
        "parameters": {},
        "return_type": "void"
      }
    },
    {
      "fn_code": "int main(int argc, char **argv)\n{\n  ares_channel_t *channel = NULL;\n  ares_status_t   status;\n\n#ifdef USE_WINSOCK\n  WORD    wVersionRequested = MAKEWORD(USE_WINSOCK, USE_WINSOCK);\n  WSADATA wsaData;\n  WSAStartup(wVersionRequested, &wsaData);\n#endif\n\n  status = (ares_status_t)ares_library_init(ARES_LIB_INIT_ALL);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_library_init: %s\\n\", ares_strerror((int)status));\n    return RV_SYSERR;\n  }\n\n  config_defaults();\n\n  if (!read_cmdline(argc, (const char * const *)argv, 1)) {\n    printf(\"\\n** ERROR: %s\\n\\n\", global_config.error);\n    print_help();\n    final_rv = RV_MISUSE;\n    goto done;\n  }\n\n  if (global_config.no_rcfile && !read_rcfile()) {\n    fprintf(stderr, \"\\n** ERROR: %s\\n\", global_config.error);\n  }\n\n  if (global_config.is_help) {\n    print_help();\n    goto done;\n  }\n\n  if (global_config.name == NULL) {\n    printf(\"missing query name\\n\");\n    print_help();\n    final_rv = RV_MISUSE;\n    goto done;\n  }\n\n  config_opts();\n\n  status = (ares_status_t)ares_init_options(&channel, &global_config.options,\n                                            global_config.optmask);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_init_options: %s\\n\", ares_strerror((int)status));\n    final_rv = RV_SYSERR;\n    goto done;\n  }\n\n  if (global_config.servers) {\n    status =\n      (ares_status_t)ares_set_servers_ports_csv(channel, global_config.servers);\n    if (status != ARES_SUCCESS) {\n      fprintf(stderr, \"ares_set_servers_ports_csv: %s: %s\\n\",\n              ares_strerror((int)status), global_config.servers);\n      final_rv = RV_MISUSE;\n      goto done;\n    }\n  }\n\n  /* Debug */\n  if (global_config.opts.display_command) {\n    printf(\"\\n; <<>> c-ares DiG %s <<>>\", ares_version(NULL));\n    printf(\" %s\", global_config.name);\n    printf(\"\\n\");\n  }\n\n  /* Enqueue a query for each separate name */\n  status = enqueue_query(channel);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"Failed to create query for %s: %s\\n\", global_config.name,\n            ares_strerror((int)status));\n    final_rv = RV_MISUSE;\n    goto done;\n  }\n\n  /* Process events */\n  if (event_loop(channel) != 0) {\n    final_rv = RV_SYSERR;\n  }\n\ndone:\n  free_config();\n  ares_destroy(channel);\n  ares_library_cleanup();\n\n#ifdef USE_WINSOCK\n  WSACleanup();\n#endif\n  return final_rv;\n}",
      "fn_code_pos": [
        [
          1492,
          0
        ],
        [
          1585,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "main",
        "parameters": {
          "argc": "int",
          "argv": "char"
        },
        "return_type": "int"
      }
    }
  ],
  "fn_declaraion": [
    {
      "fn_code": "has_opt(const ares_dns_record_t *dnsrec,\n                                    ares_dns_section_t       section)",
      "fn_dec_pos": [
        [
          676,
          28
        ],
        [
          677,
          69
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "has_opt",
        "parameters": {
          "dnsrec": "ares_dns_record_t",
          "section": "ares_dns_section_t"
        },
        "return_type": null
      }
    },
    {
      "fn_code": "(*dig_opt_cb_t)(char prefix, const char *name,\n                                    ares_bool_t is_true, const char *value)",
      "fn_dec_pos": [
        [
          933,
          20
        ],
        [
          934,
          75
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "",
        "parameters": {
          "prefix": "char",
          "name": "char",
          "is_true": "ares_bool_t",
          "value": "char"
        },
        "return_type": "ares_bool_t"
      }
    }
  ],
  "class_node_list": {},
  "struct_node_list": [
    [
      "typedef struct {\n  unsigned short port;\n  size_t         tries;\n  size_t         ndots;\n  ares_bool_t    tcp;\n  ares_bool_t    ignore_tc;\n  char          *search;\n  ares_bool_t    do_search;\n  ares_bool_t    aa_flag;\n  ares_bool_t    ad_flag;\n  ares_bool_t    cd_flag;\n  ares_bool_t    rd_flag;\n  /* ares_bool_t do_flag; */\n  ares_bool_t    edns;\n  size_t         udp_size;\n  ares_bool_t    primary;\n  ares_bool_t    aliases;\n  ares_bool_t    stayopen;\n  ares_bool_t    dns0x20;\n  ares_bool_t    display_class;\n  ares_bool_t    display_ttl;\n  ares_bool_t    display_command;\n  ares_bool_t    display_stats;\n  ares_bool_t    display_query;\n  ares_bool_t    display_question;\n  ares_bool_t    display_answer;\n  ares_bool_t    display_authority;\n  ares_bool_t    display_additional;\n  ares_bool_t    display_comments;\n} dns_options_t;",
      {
        "port": "unsigned short",
        "tries": "size_t",
        "ndots": "size_t",
        "tcp": "ares_bool_t",
        "ignore_tc": "ares_bool_t",
        "*search": "char",
        "do_search": "ares_bool_t",
        "aa_flag": "ares_bool_t",
        "ad_flag": "ares_bool_t",
        "cd_flag": "ares_bool_t",
        "rd_flag": "ares_bool_t",
        "edns": "ares_bool_t",
        "udp_size": "size_t",
        "primary": "ares_bool_t",
        "aliases": "ares_bool_t",
        "stayopen": "ares_bool_t",
        "dns0x20": "ares_bool_t",
        "display_class": "ares_bool_t",
        "display_ttl": "ares_bool_t",
        "display_command": "ares_bool_t",
        "display_stats": "ares_bool_t",
        "display_query": "ares_bool_t",
        "display_question": "ares_bool_t",
        "display_answer": "ares_bool_t",
        "display_authority": "ares_bool_t",
        "display_additional": "ares_bool_t",
        "display_comments": "ares_bool_t"
      },
      "dns_options_t",
      [
        64,
        0
      ],
      [
        93,
        16
      ]
    ],
    [
      "typedef struct {\n  dns_options_t       opts;\n  ares_bool_t         is_help;\n  ares_bool_t         no_rcfile;\n  struct ares_options options;\n  int                 optmask;\n  ares_dns_class_t    qclass;\n  ares_dns_rec_type_t qtype;\n  char               *name;\n  char               *servers;\n  char                error[256];\n} adig_config_t;",
      {
        "opts": "dns_options_t",
        "is_help": "ares_bool_t",
        "no_rcfile": "ares_bool_t",
        "options": "struct ares_options",
        "optmask": "int",
        "qclass": "ares_dns_class_t",
        "qtype": "ares_dns_rec_type_t",
        "*name": "char",
        "*servers": "char",
        "error[256]": "char"
      },
      "adig_config_t",
      [
        95,
        0
      ],
      [
        106,
        16
      ]
    ],
    [
      "struct {\n  /* Prefix for option.  If 0 then this param is a non-option and type must be\n   * OPT_TYPE_FUNC where the entire value for the param will be passed */\n  char         prefix;\n  /* Name of option.  If null, there is none and the value is expected to be\n   * immediately after the prefix character */\n  const char  *name;\n  /* Separator between key and value.  If 0 then uses the next argument as the\n   * value, otherwise splits on the separator. BOOL types won't ever use a\n   * separator and is ignored.*/\n  char         separator;\n  /* Type of parameter passed in.  If it is OPT_TYPE_FUNC, then it calls the\n   * dig_opt_cb_t callback */\n  opt_type_t   type;\n  /* Pointer to argument to fill in */\n  void        *opt;\n  /* Callback if OPT_TYPE_FUNC */\n  dig_opt_cb_t cb;\n}",
      {
        "prefix": "char",
        "char": "const",
        "separator": "char",
        "type": "opt_type_t",
        "*opt": "void",
        "cb": "dig_opt_cb_t"
      },
      "",
      [
        1071,
        13
      ],
      [
        1089,
        1
      ]
    ],
    [
      "typedef struct {\n  unsigned short port;\n  size_t         tries;\n  size_t         ndots;\n  ares_bool_t    tcp;\n  ares_bool_t    ignore_tc;\n  char          *search;\n  ares_bool_t    do_search;\n  ares_bool_t    aa_flag;\n  ares_bool_t    ad_flag;\n  ares_bool_t    cd_flag;\n  ares_bool_t    rd_flag;\n  /* ares_bool_t do_flag; */\n  ares_bool_t    edns;\n  size_t         udp_size;\n  ares_bool_t    primary;\n  ares_bool_t    aliases;\n  ares_bool_t    stayopen;\n  ares_bool_t    dns0x20;\n  ares_bool_t    display_class;\n  ares_bool_t    display_ttl;\n  ares_bool_t    display_command;\n  ares_bool_t    display_stats;\n  ares_bool_t    display_query;\n  ares_bool_t    display_question;\n  ares_bool_t    display_answer;\n  ares_bool_t    display_authority;\n  ares_bool_t    display_additional;\n  ares_bool_t    display_comments;\n} dns_options_t;",
      {
        "port": "unsigned short",
        "tries": "size_t",
        "ndots": "size_t",
        "tcp": "ares_bool_t",
        "ignore_tc": "ares_bool_t",
        "*search": "char",
        "do_search": "ares_bool_t",
        "aa_flag": "ares_bool_t",
        "ad_flag": "ares_bool_t",
        "cd_flag": "ares_bool_t",
        "rd_flag": "ares_bool_t",
        "edns": "ares_bool_t",
        "udp_size": "size_t",
        "primary": "ares_bool_t",
        "aliases": "ares_bool_t",
        "stayopen": "ares_bool_t",
        "dns0x20": "ares_bool_t",
        "display_class": "ares_bool_t",
        "display_ttl": "ares_bool_t",
        "display_command": "ares_bool_t",
        "display_stats": "ares_bool_t",
        "display_query": "ares_bool_t",
        "display_question": "ares_bool_t",
        "display_answer": "ares_bool_t",
        "display_authority": "ares_bool_t",
        "display_additional": "ares_bool_t",
        "display_comments": "ares_bool_t"
      },
      "dns_options_t",
      [
        64,
        0
      ],
      [
        93,
        16
      ]
    ],
    [
      "typedef struct {\n  dns_options_t       opts;\n  ares_bool_t         is_help;\n  ares_bool_t         no_rcfile;\n  struct ares_options options;\n  int                 optmask;\n  ares_dns_class_t    qclass;\n  ares_dns_rec_type_t qtype;\n  char               *name;\n  char               *servers;\n  char                error[256];\n} adig_config_t;",
      {
        "opts": "dns_options_t",
        "is_help": "ares_bool_t",
        "no_rcfile": "ares_bool_t",
        "options": "struct ares_options",
        "optmask": "int",
        "qclass": "ares_dns_class_t",
        "qtype": "ares_dns_rec_type_t",
        "*name": "char",
        "*servers": "char",
        "error[256]": "char"
      },
      "adig_config_t",
      [
        95,
        0
      ],
      [
        106,
        16
      ]
    ],
    [
      "struct ares_options",
      {},
      "",
      [
        99,
        2
      ],
      [
        99,
        21
      ]
    ],
    [
      "struct in_addr",
      {},
      "",
      [
        523,
        8
      ],
      [
        523,
        22
      ]
    ],
    [
      "struct ares_in6_addr",
      {},
      "",
      [
        532,
        8
      ],
      [
        532,
        28
      ]
    ],
    [
      "struct ares_addr",
      {},
      "",
      [
        835,
        4
      ],
      [
        835,
        20
      ]
    ],
    [
      "struct timeval",
      {},
      "",
      [
        885,
        4
      ],
      [
        885,
        18
      ]
    ],
    [
      "struct timeval",
      {},
      "",
      [
        886,
        4
      ],
      [
        886,
        18
      ]
    ],
    [
      "struct {\n  /* Prefix for option.  If 0 then this param is a non-option and type must be\n   * OPT_TYPE_FUNC where the entire value for the param will be passed */\n  char         prefix;\n  /* Name of option.  If null, there is none and the value is expected to be\n   * immediately after the prefix character */\n  const char  *name;\n  /* Separator between key and value.  If 0 then uses the next argument as the\n   * value, otherwise splits on the separator. BOOL types won't ever use a\n   * separator and is ignored.*/\n  char         separator;\n  /* Type of parameter passed in.  If it is OPT_TYPE_FUNC, then it calls the\n   * dig_opt_cb_t callback */\n  opt_type_t   type;\n  /* Pointer to argument to fill in */\n  void        *opt;\n  /* Callback if OPT_TYPE_FUNC */\n  dig_opt_cb_t cb;\n}",
      {
        "prefix": "char",
        "char": "const",
        "separator": "char",
        "type": "opt_type_t",
        "*opt": "void",
        "cb": "dig_opt_cb_t"
      },
      "",
      [
        1071,
        13
      ],
      [
        1089,
        1
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares_setup.h\"\n",
      [
        26,
        0
      ],
      [
        27,
        0
      ]
    ],
    [
      "#  include <netinet/in.h>\n",
      [
        29,
        0
      ],
      [
        30,
        0
      ]
    ],
    [
      "#  include <arpa/inet.h>\n",
      [
        32,
        0
      ],
      [
        33,
        0
      ]
    ],
    [
      "#  include <netdb.h>\n",
      [
        35,
        0
      ],
      [
        36,
        0
      ]
    ],
    [
      "#include \"ares_nameser.h\"\n",
      [
        38,
        0
      ],
      [
        39,
        0
      ]
    ],
    [
      "#  include <strings.h>\n",
      [
        41,
        0
      ],
      [
        42,
        0
      ]
    ],
    [
      "#include \"ares.h\"\n",
      [
        44,
        0
      ],
      [
        45,
        0
      ]
    ],
    [
      "#include \"ares_array.h\"\n",
      [
        45,
        0
      ],
      [
        46,
        0
      ]
    ],
    [
      "#include \"ares_buf.h\"\n",
      [
        46,
        0
      ],
      [
        47,
        0
      ]
    ],
    [
      "#include \"ares_dns.h\"\n",
      [
        47,
        0
      ],
      [
        48,
        0
      ]
    ],
    [
      "#include \"ares_getopt.h\"\n",
      [
        48,
        0
      ],
      [
        49,
        0
      ]
    ],
    [
      "#include \"ares_mem.h\"\n",
      [
        49,
        0
      ],
      [
        50,
        0
      ]
    ],
    [
      "#include \"ares_str.h\"\n",
      [
        50,
        0
      ],
      [
        51,
        0
      ]
    ],
    [
      "#include \"limits.h\"\n",
      [
        52,
        0
      ],
      [
        53,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": [
    [
      "typedef enum {\n  OPT_TYPE_BOOL,\n  OPT_TYPE_STRING,\n  OPT_TYPE_SIZE_T,\n  OPT_TYPE_U16,\n  OPT_TYPE_FUNC\n} opt_type_t;",
      {
        "OPT_TYPE_BOOL": "",
        "OPT_TYPE_STRING": "",
        "OPT_TYPE_SIZE_T": "",
        "OPT_TYPE_U16": "",
        "OPT_TYPE_FUNC": ""
      },
      "opt_type_t",
      [
        918,
        0
      ],
      [
        924,
        13
      ]
    ]
  ]
}