{
  "fn_def_list": [
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtReplyOK) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b(\"ABC\\0ABC\", 7);\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_NE(nullptr, txt);\n  EXPECT_EQ(std::vector<byte>(expected1.data(), expected1.data() + expected1.size()),\n            std::vector<byte>(txt->txt, txt->txt + txt->length));\n\n  struct ares_txt_reply* txt2 = txt->next;\n  ASSERT_NE(nullptr, txt2);\n  EXPECT_EQ(std::vector<byte>(expected2a.data(), expected2a.data() + expected2a.size()),\n            std::vector<byte>(txt2->txt, txt2->txt + txt2->length));\n\n  struct ares_txt_reply* txt3 = txt2->next;\n  ASSERT_NE(nullptr, txt3);\n  EXPECT_EQ(std::vector<byte>(expected2b.data(), expected2b.data() + expected2b.size()),\n            std::vector<byte>(txt3->txt, txt3->txt + txt3->length));\n  EXPECT_EQ(nullptr, txt3->next);\n  ares_free_data(txt);\n}",
      "fn_code_pos": [
        [
          34,
          0
        ],
        [
          62,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtExtReplyOK) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b(\"ABC\\0ABC\", 7);\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_txt_ext* txt = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_txt_reply_ext(data.data(), (int)data.size(), &txt));\n  ASSERT_NE(nullptr, txt);\n  EXPECT_EQ(std::vector<byte>(expected1.data(), expected1.data() + expected1.size()),\n            std::vector<byte>(txt->txt, txt->txt + txt->length));\n  EXPECT_EQ(1, txt->record_start);\n\n  struct ares_txt_ext* txt2 = txt->next;\n  ASSERT_NE(nullptr, txt2);\n  EXPECT_EQ(std::vector<byte>(expected2a.data(), expected2a.data() + expected2a.size()),\n            std::vector<byte>(txt2->txt, txt2->txt + txt2->length));\n  EXPECT_EQ(1, txt2->record_start);\n\n  struct ares_txt_ext* txt3 = txt2->next;\n  ASSERT_NE(nullptr, txt3);\n  EXPECT_EQ(std::vector<byte>(expected2b.data(), expected2b.data() + expected2b.size()),\n            std::vector<byte>(txt3->txt, txt3->txt + txt3->length));\n  EXPECT_EQ(nullptr, txt3->next);\n  EXPECT_EQ(0, txt3->record_start);\n  ares_free_data(txt);\n}",
      "fn_code_pos": [
        [
          64,
          0
        ],
        [
          95,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtEmpty) {\n  DNSPacket pkt;\n  std::string expected1 = \"\";\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}));\n  std::vector<byte> data = pkt.data();\n\n  ares_dns_record_t   *dnsrec = NULL;\n  ares_dns_rr_t       *rr     = NULL;\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_parse(data.data(), data.size(), 0, &dnsrec));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 0);\n  ASSERT_NE(nullptr, rr);\n  EXPECT_EQ(ARES_REC_TYPE_TXT, ares_dns_rr_get_type(rr));\n\n  size_t txtdata_len;\n  const unsigned char *txtdata;\n\n  /* Using array methodology */\n  EXPECT_EQ(1, ares_dns_rr_get_abin_cnt(rr, ARES_RR_TXT_DATA));\n  txtdata = ares_dns_rr_get_abin(rr, ARES_RR_TXT_DATA, 0, &txtdata_len);\n  EXPECT_EQ(txtdata_len, 0);\n  EXPECT_NE(nullptr, txtdata);\n\n  /* Using combined methodology */\n  txtdata = ares_dns_rr_get_bin(rr, ARES_RR_TXT_DATA, &txtdata_len);\n  EXPECT_EQ(txtdata_len, 0);\n  EXPECT_NE(nullptr, txtdata);\n\n  ares_dns_record_destroy(dnsrec); dnsrec = NULL;\n}",
      "fn_code_pos": [
        [
          97,
          0
        ],
        [
          128,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply1) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x03,  // rdata length\n    0x12, 'a', 'b',  // invalid length\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
      "fn_code_pos": [
        [
          130,
          0
        ],
        [
          159,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply2) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    // truncated\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
      "fn_code_pos": [
        [
          161,
          0
        ],
        [
          187,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply3) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x13,  // rdata length INVALID\n    0x02, 'a', 'b',\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
      "fn_code_pos": [
        [
          189,
          0
        ],
        [
          218,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply4) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, // TRUNCATED\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
      "fn_code_pos": [
        [
          220,
          0
        ],
        [
          240,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtReplyErrors) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b = \"txt2b\";\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n  struct ares_txt_reply* txt = nullptr;\n  struct ares_txt_ext* txt_ext = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_TXT));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}));\n\n  // Truncated packets.\n  for (size_t len = 1; len < data.size(); len++) {\n    txt = nullptr;\n    EXPECT_NE(ARES_SUCCESS, ares_parse_txt_reply(data.data(), (int)len, &txt));\n    EXPECT_EQ(nullptr, txt);\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), -1, &txt));\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply_ext(data.data(), -1, &txt_ext));\n}",
      "fn_code_pos": [
        [
          242,
          0
        ],
        [
          301,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    },
    {
      "fn_code": "TEST_F(LibraryTest, ParseTxtReplyAllocFail) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b = \"txt2b\";\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n  struct ares_txt_reply* txt = nullptr;\n\n  for (int ii = 1; ii <= 13; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_txt_reply(data.data(), (int)data.size(), &txt)) << ii;\n  }\n}",
      "fn_code_pos": [
        [
          303,
          0
        ],
        [
          322,
          1
        ]
      ],
      "class_code": "",
      "class_node_pos": [],
      "fn_meta": {
        "identifier": "TEST_F",
        "parameters": {},
        "return_type": null
      }
    }
  ],
  "fn_declaraion": [],
  "class_node_list": {},
  "struct_node_list": [
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        45,
        2
      ],
      [
        45,
        23
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        51,
        2
      ],
      [
        51,
        23
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        56,
        2
      ],
      [
        56,
        23
      ]
    ],
    [
      "struct ares_txt_ext",
      {},
      "",
      [
        75,
        2
      ],
      [
        75,
        21
      ]
    ],
    [
      "struct ares_txt_ext",
      {},
      "",
      [
        82,
        2
      ],
      [
        82,
        21
      ]
    ],
    [
      "struct ares_txt_ext",
      {},
      "",
      [
        88,
        2
      ],
      [
        88,
        21
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        156,
        2
      ],
      [
        156,
        23
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        184,
        2
      ],
      [
        184,
        23
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        215,
        2
      ],
      [
        215,
        23
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        237,
        2
      ],
      [
        237,
        23
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        253,
        2
      ],
      [
        253,
        23
      ]
    ],
    [
      "struct ares_txt_ext",
      {},
      "",
      [
        254,
        2
      ],
      [
        254,
        21
      ]
    ],
    [
      "struct ares_txt_reply",
      {},
      "",
      [
        315,
        2
      ],
      [
        315,
        23
      ]
    ]
  ],
  "include_list": [
    [
      "#include \"ares-test.h\"\n",
      [
        25,
        0
      ],
      [
        26,
        0
      ]
    ],
    [
      "#include \"dns-proto.h\"\n",
      [
        26,
        0
      ],
      [
        27,
        0
      ]
    ],
    [
      "#include <sstream>\n",
      [
        28,
        0
      ],
      [
        29,
        0
      ]
    ],
    [
      "#include <vector>\n",
      [
        29,
        0
      ],
      [
        30,
        0
      ]
    ]
  ],
  "global_variables": [],
  "enumerate_node_list": []
}