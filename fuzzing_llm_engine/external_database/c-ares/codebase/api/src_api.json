{
  "src": {
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_free_string.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_free_string(void *str)\n{\n  ares_free(str);\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              32,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_string",
            "parameters": {
              "str": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_getnameinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "static void  ares_getnameinfo_int(ares_channel_t        *channel,\n                                  const struct sockaddr *sa,\n                                  ares_socklen_t salen, int flags_int,\n                                  ares_nameinfo_callback callback, void *arg)\n{\n  const struct sockaddr_in  *addr  = NULL;\n  const struct sockaddr_in6 *addr6 = NULL;\n  struct nameinfo_query     *niquery;\n  unsigned short             port  = 0;\n  unsigned int               flags = (unsigned int)flags_int;\n\n  /* Validate socket address family and length */\n  if (sa && sa->sa_family == AF_INET &&\n      salen >= (ares_socklen_t)sizeof(struct sockaddr_in)) {\n    addr = CARES_INADDR_CAST(const struct sockaddr_in *, sa);\n    port = addr->sin_port;\n  } else if (sa && sa->sa_family == AF_INET6 &&\n             salen >= (ares_socklen_t)sizeof(struct sockaddr_in6)) {\n    addr6 = CARES_INADDR_CAST(const struct sockaddr_in6 *, sa);\n    port  = addr6->sin6_port;\n  } else {\n    callback(arg, ARES_ENOTIMP, 0, NULL, NULL);\n    return;\n  }\n\n  /* If neither, assume they want a host */\n  if (!(flags & ARES_NI_LOOKUPSERVICE) && !(flags & ARES_NI_LOOKUPHOST)) {\n    flags |= ARES_NI_LOOKUPHOST;\n  }\n\n  /* All they want is a service, no need for DNS */\n  if ((flags & ARES_NI_LOOKUPSERVICE) && !(flags & ARES_NI_LOOKUPHOST)) {\n    char  buf[33];\n    char *service;\n\n    service =\n      lookup_service((unsigned short)(port & 0xffff), flags, buf, sizeof(buf));\n    callback(arg, ARES_SUCCESS, 0, NULL, service);\n    return;\n  }\n\n  /* They want a host lookup */\n  if (flags & ARES_NI_LOOKUPHOST) {\n    /* A numeric host can be handled without DNS */\n    if (flags & ARES_NI_NUMERICHOST) {\n      char  ipbuf[IPBUFSIZ];\n      char  srvbuf[33];\n      char *service = NULL;\n      ipbuf[0]      = 0;\n\n      /* Specifying not to lookup a host, but then saying a host\n       * is required has to be illegal.\n       */\n      if (flags & ARES_NI_NAMEREQD) {\n        callback(arg, ARES_EBADFLAGS, 0, NULL, NULL);\n        return;\n      }\n      if (sa->sa_family == AF_INET6) {\n        ares_inet_ntop(AF_INET6, &addr6->sin6_addr, ipbuf, IPBUFSIZ);\n        /* If the system supports scope IDs, use it */\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n        append_scopeid(addr6, flags, ipbuf, sizeof(ipbuf));\n#endif\n      } else {\n        ares_inet_ntop(AF_INET, &addr->sin_addr, ipbuf, IPBUFSIZ);\n      }\n      /* They also want a service */\n      if (flags & ARES_NI_LOOKUPSERVICE) {\n        service = lookup_service((unsigned short)(port & 0xffff), flags, srvbuf,\n                                 sizeof(srvbuf));\n      }\n      callback(arg, ARES_SUCCESS, 0, ipbuf, service);\n      return;\n    } else {\n      /* This is where a DNS lookup becomes necessary */\n      niquery = ares_malloc(sizeof(struct nameinfo_query));\n      if (!niquery) {\n        callback(arg, ARES_ENOMEM, 0, NULL, NULL);\n        return;\n      }\n      niquery->callback = callback;\n      niquery->arg      = arg;\n      niquery->flags    = flags;\n      niquery->timeouts = 0;\n      if (sa->sa_family == AF_INET) {\n        niquery->family = AF_INET;\n        memcpy(&niquery->addr.addr4, addr, sizeof(niquery->addr.addr4));\n        ares_gethostbyaddr_nolock(channel, &addr->sin_addr,\n                                  sizeof(struct in_addr), AF_INET,\n                                  nameinfo_callback, niquery);\n      } else {\n        niquery->family = AF_INET6;\n        memcpy(&niquery->addr.addr6, addr6, sizeof(niquery->addr.addr6));\n        ares_gethostbyaddr_nolock(channel, &addr6->sin6_addr,\n                                  sizeof(struct ares_in6_addr), AF_INET6,\n                                  nameinfo_callback, niquery);\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getnameinfo_int",
            "parameters": {
              "channel": "ares_channel_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t",
              "flags_int": "int",
              "callback": "ares_nameinfo_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_getnameinfo(ares_channel_t *channel, const struct sockaddr *sa,\n                      ares_socklen_t salen, int flags_int,\n                      ares_nameinfo_callback callback, void *arg)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  ares_channel_lock(channel);\n  ares_getnameinfo_int(channel, sa, salen, flags_int, callback, arg);\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getnameinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t",
              "flags_int": "int",
              "callback": "ares_nameinfo_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void nameinfo_callback(void *arg, int status, int timeouts,\n                              struct hostent *host)\n{\n  struct nameinfo_query *niquery = (struct nameinfo_query *)arg;\n  char                   srvbuf[33];\n  char                  *service = NULL;\n\n  niquery->timeouts += (size_t)timeouts;\n  if (status == ARES_SUCCESS) {\n    /* They want a service too */\n    if (niquery->flags & ARES_NI_LOOKUPSERVICE) {\n      if (niquery->family == AF_INET) {\n        service = lookup_service(niquery->addr.addr4.sin_port, niquery->flags,\n                                 srvbuf, sizeof(srvbuf));\n      } else {\n        service = lookup_service(niquery->addr.addr6.sin6_port, niquery->flags,\n                                 srvbuf, sizeof(srvbuf));\n      }\n    }\n    /* NOFQDN means we have to strip off the domain name portion.  We do\n       this by determining our own domain name, then searching the string\n       for this domain name and removing it.\n     */\n#ifdef HAVE_GETHOSTNAME\n    if (niquery->flags & ARES_NI_NOFQDN) {\n      char        buf[255];\n      const char *domain;\n      gethostname(buf, 255);\n      if ((domain = strchr(buf, '.')) != NULL) {\n        char *end = ares_striendstr(host->h_name, domain);\n        if (end) {\n          *end = 0;\n        }\n      }\n    }\n#endif\n    niquery->callback(niquery->arg, ARES_SUCCESS, (int)niquery->timeouts,\n                      host->h_name, service);\n    ares_free(niquery);\n    return;\n  }\n  /* We couldn't find the host, but it's OK, we can use the IP */\n  else if (status == ARES_ENOTFOUND && !(niquery->flags & ARES_NI_NAMEREQD)) {\n    char ipbuf[IPBUFSIZ];\n    if (niquery->family == AF_INET) {\n      ares_inet_ntop(AF_INET, &niquery->addr.addr4.sin_addr, ipbuf, IPBUFSIZ);\n    } else {\n      ares_inet_ntop(AF_INET6, &niquery->addr.addr6.sin6_addr, ipbuf, IPBUFSIZ);\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n      append_scopeid(&niquery->addr.addr6, niquery->flags, ipbuf,\n                     sizeof(ipbuf));\n#endif\n    }\n    /* They want a service too */\n    if (niquery->flags & ARES_NI_LOOKUPSERVICE) {\n      if (niquery->family == AF_INET) {\n        service = lookup_service(niquery->addr.addr4.sin_port, niquery->flags,\n                                 srvbuf, sizeof(srvbuf));\n      } else {\n        service = lookup_service(niquery->addr.addr6.sin6_port, niquery->flags,\n                                 srvbuf, sizeof(srvbuf));\n      }\n    }\n    niquery->callback(niquery->arg, ARES_SUCCESS, (int)niquery->timeouts, ipbuf,\n                      service);\n    ares_free(niquery);\n    return;\n  }\n  niquery->callback(niquery->arg, status, (int)niquery->timeouts, NULL, NULL);\n  ares_free(niquery);\n}",
          "fn_code_pos": [
            [
              200,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nameinfo_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *lookup_service(unsigned short port, unsigned int flags, char *buf,\n                            size_t buflen)\n{\n  const char     *proto;\n  struct servent *sep;\n#ifdef HAVE_GETSERVBYPORT_R\n  struct servent se;\n#endif\n  char        tmpbuf[4096];\n  const char *name;\n  size_t      name_len;\n\n  if (port) {\n    if (flags & ARES_NI_NUMERICSERV) {\n      sep = NULL;\n    } else {\n      if (flags & ARES_NI_UDP) {\n        proto = \"udp\";\n      } else if (flags & ARES_NI_SCTP) {\n        proto = \"sctp\";\n      } else if (flags & ARES_NI_DCCP) {\n        proto = \"dccp\";\n      } else {\n        proto = \"tcp\";\n      }\n#ifdef HAVE_GETSERVBYPORT_R\n      memset(&se, 0, sizeof(se));\n      sep = &se;\n      memset(tmpbuf, 0, sizeof(tmpbuf));\n#  if GETSERVBYPORT_R_ARGS == 6\n      if (getservbyport_r(port, proto, &se, (void *)tmpbuf, sizeof(tmpbuf),\n                          &sep) != 0) {\n        sep = NULL; /* LCOV_EXCL_LINE: buffer large so this never fails */\n      }\n#  elif GETSERVBYPORT_R_ARGS == 5\n      sep = getservbyport_r(port, proto, &se, (void *)tmpbuf, sizeof(tmpbuf));\n#  elif GETSERVBYPORT_R_ARGS == 4\n      if (getservbyport_r(port, proto, &se, (void *)tmpbuf) != 0) {\n        sep = NULL;\n      }\n#  else\n      /* Lets just hope the OS uses TLS! */\n      sep = getservbyport(port, proto);\n#  endif\n#else\n      /* Lets just hope the OS uses TLS! */\n#  if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n      sep = getservbyport(port, (char *)proto);\n#  else\n      sep = getservbyport(port, proto);\n#  endif\n#endif\n    }\n    if (sep && sep->s_name) {\n      /* get service name */\n      name = sep->s_name;\n    } else {\n      /* get port as a string */\n      snprintf(tmpbuf, sizeof(tmpbuf), \"%u\", (unsigned int)ntohs(port));\n      name = tmpbuf;\n    }\n    name_len = ares_strlen(name);\n    if (name_len < buflen) {\n      /* return it if buffer big enough */\n      memcpy(buf, name, name_len + 1);\n    } else {\n      /* avoid reusing previous one */\n      buf[0] = '\\0'; /* LCOV_EXCL_LINE: no real service names are too big */\n    }\n    return buf;\n  }\n  buf[0] = '\\0';\n  return NULL;\n}",
          "fn_code_pos": [
            [
              272,
              0
            ],
            [
              345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_service",
            "parameters": {
              "port": "unsigned short",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void append_scopeid(const struct sockaddr_in6 *addr6, unsigned int flags,\n                           char *buf, size_t buflen)\n{\n#  ifdef HAVE_IF_INDEXTONAME\n  int is_ll;\n  int is_mcll;\n#  endif\n  char   tmpbuf[IF_NAMESIZE + 2];\n  size_t bufl;\n\n  tmpbuf[0] = '%';\n\n#  ifdef HAVE_IF_INDEXTONAME\n  is_ll   = IN6_IS_ADDR_LINKLOCAL(&addr6->sin6_addr);\n  is_mcll = IN6_IS_ADDR_MC_LINKLOCAL(&addr6->sin6_addr);\n  if ((flags & ARES_NI_NUMERICSCOPE) || (!is_ll && !is_mcll)) {\n    snprintf(&tmpbuf[1], sizeof(tmpbuf) - 1, \"%lu\",\n             (unsigned long)addr6->sin6_scope_id);\n  } else {\n    if (if_indextoname(addr6->sin6_scope_id, &tmpbuf[1]) == NULL) {\n      snprintf(&tmpbuf[1], sizeof(tmpbuf) - 1, \"%lu\",\n               (unsigned long)addr6->sin6_scope_id);\n    }\n  }\n#  else\n  snprintf(&tmpbuf[1], sizeof(tmpbuf) - 1, \"%lu\",\n           (unsigned long)addr6->sin6_scope_id);\n  (void)flags;\n#  endif\n  tmpbuf[IF_NAMESIZE + 1] = '\\0';\n  bufl                    = ares_strlen(buf);\n\n  if (bufl + ares_strlen(tmpbuf) < buflen) {\n    /* only append the scopeid string if it fits in the target buffer */\n    ares_strcpy(&buf[bufl], tmpbuf, buflen - bufl);\n  }\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_scopeid",
            "parameters": {
              "addr6": "struct sockaddr_in6",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *ares_striendstr(const char *s1, const char *s2)\n{\n  const char *c1;\n  const char *c2;\n  const char *c1_begin;\n  int         lo1;\n  int         lo2;\n  size_t      s1_len = ares_strlen(s1);\n  size_t      s2_len = ares_strlen(s2);\n\n  if (s1 == NULL || s2 == NULL) {\n    return NULL;\n  }\n\n  /* If the substr is longer than the full str, it can't match */\n  if (s2_len > s1_len) {\n    return NULL;\n  }\n\n  /* Jump to the end of s1 minus the length of s2 */\n  c1_begin = s1 + s1_len - s2_len;\n  c1       = c1_begin;\n  c2       = s2;\n  while (c2 < s2 + s2_len) {\n    lo1 = ares_tolower((unsigned char)*c1);\n    lo2 = ares_tolower((unsigned char)*c2);\n    if (lo1 != lo2) {\n      return NULL;\n    } else {\n      c1++;\n      c2++;\n    }\n  }\n  /* Cast off const */\n  return (char *)((size_t)c1_begin);\n}",
          "fn_code_pos": [
            [
              388,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_striendstr",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_bool_t ares_is_onion_domain(const char *name)\n{\n  if (ares_striendstr(name, \".onion\")) {\n    return ARES_TRUE;\n  }\n\n  if (ares_striendstr(name, \".onion.\")) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              425,
              0
            ],
            [
              436,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_is_onion_domain",
            "parameters": {
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "nameinfo_callback(void *arg, int status, int timeouts,\n                               struct hostent *host)",
          "fn_dec_pos": [
            [
              76,
              13
            ],
            [
              77,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nameinfo_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "lookup_service(unsigned short port, unsigned int flags, char *buf,\n                            size_t buflen)",
          "fn_dec_pos": [
            [
              78,
              13
            ],
            [
              79,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_service",
            "parameters": {
              "port": "unsigned short",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "append_scopeid(const struct sockaddr_in6 *addr6, unsigned int flags,\n                           char *buf, size_t buflen)",
          "fn_dec_pos": [
            [
              81,
              12
            ],
            [
              82,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_scopeid",
            "parameters": {
              "addr6": "struct sockaddr_in6",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_striendstr(const char *s1, const char *s2)",
          "fn_dec_pos": [
            [
              84,
              13
            ],
            [
              84,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_striendstr",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "lookup_service(unsigned short port, unsigned int flags, char *buf,\n                            size_t buflen)",
          "fn_dec_pos": [
            [
              272,
              13
            ],
            [
              273,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_service",
            "parameters": {
              "port": "unsigned short",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_striendstr(const char *s1, const char *s2)",
          "fn_dec_pos": [
            [
              388,
              13
            ],
            [
              388,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_striendstr",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct nameinfo_query {\n  ares_nameinfo_callback callback;\n  void                  *arg;\n\n  union {\n    struct sockaddr_in  addr4;\n    struct sockaddr_in6 addr6;\n  } addr;\n\n  int          family;\n  unsigned int flags;\n  size_t       timeouts;\n}",
          {
            "callback": "ares_nameinfo_callback",
            "*arg": "void",
            "addr": "union {\n    struct sockaddr_in  addr4;\n    struct sockaddr_in6 addr6;\n  }",
            "addr4": "struct sockaddr_in",
            "addr6": "struct sockaddr_in6",
            "family": "int",
            "flags": "unsigned int",
            "timeouts": "size_t"
          },
          "nameinfo_query",
          [
            55,
            0
          ],
          [
            67,
            1
          ]
        ],
        [
          "struct nameinfo_query {\n  ares_nameinfo_callback callback;\n  void                  *arg;\n\n  union {\n    struct sockaddr_in  addr4;\n    struct sockaddr_in6 addr6;\n  } addr;\n\n  int          family;\n  unsigned int flags;\n  size_t       timeouts;\n}",
          {
            "callback": "ares_nameinfo_callback",
            "*arg": "void",
            "addr": "union {\n    struct sockaddr_in  addr4;\n    struct sockaddr_in6 addr6;\n  }",
            "addr4": "struct sockaddr_in",
            "addr6": "struct sockaddr_in6",
            "family": "int",
            "flags": "unsigned int",
            "timeouts": "size_t"
          },
          "nameinfo_query",
          [
            55,
            0
          ],
          [
            67,
            1
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            60,
            4
          ],
          [
            60,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            61,
            4
          ],
          [
            61,
            23
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            77,
            31
          ],
          [
            77,
            45
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            81,
            33
          ],
          [
            81,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            87,
            40
          ],
          [
            87,
            55
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            91,
            8
          ],
          [
            91,
            26
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            92,
            8
          ],
          [
            92,
            27
          ]
        ],
        [
          "struct nameinfo_query",
          {},
          "",
          [
            93,
            2
          ],
          [
            93,
            23
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            99,
            38
          ],
          [
            99,
            56
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            103,
            45
          ],
          [
            103,
            64
          ]
        ],
        [
          "struct nameinfo_query",
          {},
          "",
          [
            161,
            35
          ],
          [
            161,
            56
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            174,
            41
          ],
          [
            174,
            55
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            180,
            41
          ],
          [
            180,
            61
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            187,
            53
          ],
          [
            187,
            68
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            201,
            30
          ],
          [
            201,
            44
          ]
        ],
        [
          "struct nameinfo_query",
          {},
          "",
          [
            203,
            2
          ],
          [
            203,
            23
          ]
        ],
        [
          "struct nameinfo_query",
          {},
          "",
          [
            203,
            36
          ],
          [
            203,
            57
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            276,
            2
          ],
          [
            276,
            16
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            278,
            2
          ],
          [
            278,
            16
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            348,
            33
          ],
          [
            348,
            52
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <net/if.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <iphlpapi.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_send.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned short generate_unique_qid(ares_channel_t *channel)\n{\n  unsigned short id;\n\n  do {\n    id = ares_generate_new_id(channel->rand_state);\n  } while (ares_htable_szvp_get(channel->queries_by_qid, id, NULL));\n\n  return id;\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "generate_unique_qid",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_status_t ares_apply_dns0x20(ares_channel_t    *channel,\n                                        ares_dns_record_t *dnsrec)\n{\n  ares_status_t status = ARES_SUCCESS;\n  const char   *name   = NULL;\n  char          dns0x20name[256];\n  unsigned char randdata[256 / 8];\n  size_t        len;\n  size_t        remaining_bits;\n  size_t        total_bits;\n  size_t        i;\n\n  status = ares_dns_record_query_get(dnsrec, 0, &name, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  len = ares_strlen(name);\n  if (len == 0) {\n    return ARES_SUCCESS;\n  }\n\n  if (len >= sizeof(dns0x20name)) {\n    status = ARES_EBADNAME;\n    goto done;\n  }\n\n  memset(dns0x20name, 0, sizeof(dns0x20name));\n\n  /* Fetch the minimum amount of random data we'd need for the string, which\n   * is 1 bit per byte */\n  total_bits     = ((len + 7) / 8) * 8;\n  remaining_bits = total_bits;\n  ares_rand_bytes(channel->rand_state, randdata, total_bits / 8);\n\n  /* Randomly apply 0x20 to name */\n  for (i = 0; i < len; i++) {\n    size_t bit;\n\n    /* Only apply 0x20 to alpha characters */\n    if (!ares_isalpha(name[i])) {\n      dns0x20name[i] = name[i];\n      continue;\n    }\n\n    /* coin flip */\n    bit = total_bits - remaining_bits;\n    if (randdata[bit / 8] & (1 << (bit % 8))) {\n      dns0x20name[i] = name[i] | 0x20;                          /* Set 0x20 */\n    } else {\n      dns0x20name[i] = (char)(((unsigned char)name[i]) & 0xDF); /* Unset 0x20 */\n    }\n    remaining_bits--;\n  }\n\n  status = ares_dns_record_query_set_name(dnsrec, 0, dns0x20name);\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_apply_dns0x20",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_send_nolock(ares_channel_t *channel, ares_server_t *server,\n                               ares_send_flags_t        flags,\n                               const ares_dns_record_t *dnsrec,\n                               ares_callback_dnsrec callback, void *arg,\n                               unsigned short *qid)\n{\n  ares_query_t            *query;\n  ares_timeval_t           now;\n  ares_status_t            status;\n  unsigned short           id          = generate_unique_qid(channel);\n  const ares_dns_record_t *dnsrec_resp = NULL;\n\n  ares_tvnow(&now);\n\n  if (ares_slist_len(channel->servers) == 0) {\n    callback(arg, ARES_ENOSERVER, 0, NULL);\n    return ARES_ENOSERVER;\n  }\n\n  if (!(flags & ARES_SEND_FLAG_NOCACHE)) {\n    /* Check query cache */\n    status = ares_qcache_fetch(channel, &now, dnsrec, &dnsrec_resp);\n    if (status != ARES_ENOTFOUND) {\n      /* ARES_SUCCESS means we retrieved the cache, anything else is a critical\n       * failure, all result in termination */\n      callback(arg, status, 0, dnsrec_resp);\n      return status;\n    }\n  }\n\n  /* Allocate space for query and allocated fields. */\n  query = ares_malloc(sizeof(ares_query_t));\n  if (!query) {\n    callback(arg, ARES_ENOMEM, 0, NULL); /* LCOV_EXCL_LINE: OutOfMemory */\n    return ARES_ENOMEM;                  /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  memset(query, 0, sizeof(*query));\n\n  query->channel      = channel;\n  query->qid          = id;\n  query->timeout.sec  = 0;\n  query->timeout.usec = 0;\n  query->using_tcp =\n    (channel->flags & ARES_FLAG_USEVC) ? ARES_TRUE : ARES_FALSE;\n\n  /* Duplicate Query */\n  status = ares_dns_record_duplicate_ex(&query->query, dnsrec);\n  if (status != ARES_SUCCESS) {\n    /* Sometimes we might get a EBADRESP response from duplicate due to\n     * the way it works (write and parse), rewrite it to EBADQUERY. */\n    if (status == ARES_EBADRESP) {\n      status = ARES_EBADQUERY;\n    }\n    ares_free(query);\n    callback(arg, status, 0, NULL);\n    return status;\n  }\n\n  ares_dns_record_set_id(query->query, id);\n\n  if (channel->flags & ARES_FLAG_DNS0x20 && !query->using_tcp) {\n    status = ares_apply_dns0x20(channel, query->query);\n    if (status != ARES_SUCCESS) {\n      /* LCOV_EXCL_START: OutOfMemory */\n      callback(arg, status, 0, NULL);\n      ares_free_query(query);\n      return status;\n      /* LCOV_EXCL_STOP */\n    }\n  }\n\n  /* Fill in query arguments. */\n  query->callback = callback;\n  query->arg      = arg;\n\n  /* Initialize query status. */\n  query->try_count = 0;\n\n  if (flags & ARES_SEND_FLAG_NORETRY) {\n    query->no_retries = ARES_TRUE;\n  }\n\n  query->error_status = ARES_SUCCESS;\n  query->timeouts     = 0;\n\n  /* Initialize our list nodes. */\n  query->node_queries_by_timeout = NULL;\n  query->node_queries_to_conn    = NULL;\n\n  /* Chain the query into the list of all queries. */\n  query->node_all_queries = ares_llist_insert_last(channel->all_queries, query);\n  if (query->node_all_queries == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    ares_free_query(query);\n    return ARES_ENOMEM;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Keep track of queries bucketed by qid, so we can process DNS\n   * responses quickly.\n   */\n  if (!ares_htable_szvp_insert(channel->queries_by_qid, query->qid, query)) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    ares_free_query(query);\n    return ARES_ENOMEM;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Perform the first query action. */\n\n  status = ares_send_query(server, query, &now);\n  if (status == ARES_SUCCESS && qid) {\n    *qid = id;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send_nolock",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "flags": "ares_send_flags_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_send_dnsrec(ares_channel_t          *channel,\n                               const ares_dns_record_t *dnsrec,\n                               ares_callback_dnsrec callback, void *arg,\n                               unsigned short *qid)\n{\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_channel_lock(channel);\n\n  status = ares_send_nolock(channel, NULL, 0, dnsrec, callback, arg, qid);\n\n  ares_channel_unlock(channel);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_send(ares_channel_t *channel, const unsigned char *qbuf, int qlen,\n               ares_callback callback, void *arg)\n{\n  ares_dns_record_t *dnsrec = NULL;\n  ares_status_t      status;\n  void              *carg = NULL;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  /* Verify that the query is at least long enough to hold the header. */\n  if (qlen < HFIXEDSZ || qlen >= (1 << 16)) {\n    callback(arg, ARES_EBADQUERY, 0, NULL, 0);\n    return;\n  }\n\n  status = ares_dns_parse(qbuf, (size_t)qlen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    callback(arg, (int)status, 0, NULL, 0);\n    return;\n  }\n\n  carg = ares_dnsrec_convert_arg(callback, arg);\n  if (carg == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    status = ARES_ENOMEM;\n    ares_dns_record_destroy(dnsrec);\n    callback(arg, (int)status, 0, NULL, 0);\n    return;\n    /* LCOV_EXCL_STOP */\n  }\n\n  ares_send_dnsrec(channel, dnsrec, ares_dnsrec_convert_cb, carg, NULL);\n\n  ares_dns_record_destroy(dnsrec);\n}",
          "fn_code_pos": [
            [
              246,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send",
            "parameters": {
              "channel": "ares_channel_t",
              "qbuf": "unsigned char",
              "qlen": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares_queue_active_queries(const ares_channel_t *channel)\n{\n  size_t len;\n\n  if (channel == NULL) {\n    return 0;\n  }\n\n  ares_channel_lock(channel);\n\n  len = ares_llist_len(channel->all_queries);\n\n  ares_channel_unlock(channel);\n\n  return len;\n}",
          "fn_code_pos": [
            [
              284,
              0
            ],
            [
              299,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_active_queries",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_close_sockets.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_requeue_queries(ares_conn_t  *conn,\n                                 ares_status_t requeue_status)\n{\n  ares_query_t  *query;\n  ares_timeval_t now;\n\n  ares_tvnow(&now);\n\n  while ((query = ares_llist_first_val(conn->queries_to_conn)) != NULL) {\n    ares_requeue_query(query, &now, requeue_status, ARES_TRUE, NULL, NULL);\n  }\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_requeue_queries",
            "parameters": {
              "conn": "ares_conn_t",
              "requeue_status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_close_connection(ares_conn_t *conn, ares_status_t requeue_status)\n{\n  ares_server_t  *server  = conn->server;\n  ares_channel_t *channel = server->channel;\n\n  /* Unlink */\n  ares_llist_node_claim(\n    ares_htable_asvp_get_direct(channel->connnode_by_socket, conn->fd));\n  ares_htable_asvp_remove(channel->connnode_by_socket, conn->fd);\n\n  if (conn->flags & ARES_CONN_FLAG_TCP) {\n    server->tcp_conn = NULL;\n  }\n\n  ares_buf_destroy(conn->in_buf);\n  ares_buf_destroy(conn->out_buf);\n\n  /* Requeue queries to other connections */\n  ares_requeue_queries(conn, requeue_status);\n\n  ares_llist_destroy(conn->queries_to_conn);\n\n  ares_conn_sock_state_cb_update(conn, ARES_CONN_STATE_NONE);\n\n  ares_socket_close(channel, conn->fd);\n\n  ares_free(conn);\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_close_connection",
            "parameters": {
              "conn": "ares_conn_t",
              "requeue_status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_close_sockets(ares_server_t *server)\n{\n  ares_llist_node_t *node;\n\n  while ((node = ares_llist_node_first(server->connections)) != NULL) {\n    ares_conn_t *conn = ares_llist_node_val(node);\n    ares_close_connection(conn, ARES_SUCCESS);\n  }\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_close_sockets",
            "parameters": {
              "server": "ares_server_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_check_cleanup_conns(const ares_channel_t *channel)\n{\n  ares_slist_node_t *snode;\n\n  if (channel == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Iterate across each server */\n  for (snode = ares_slist_node_first(channel->servers); snode != NULL;\n       snode = ares_slist_node_next(snode)) {\n    ares_server_t     *server = ares_slist_node_val(snode);\n    ares_llist_node_t *cnode;\n\n    /* Iterate across each connection */\n    cnode = ares_llist_node_first(server->connections);\n    while (cnode != NULL) {\n      ares_llist_node_t *next       = ares_llist_node_next(cnode);\n      ares_conn_t       *conn       = ares_llist_node_val(cnode);\n      ares_bool_t        do_cleanup = ARES_FALSE;\n      cnode                         = next;\n\n      /* Has connections, not eligible */\n      if (ares_llist_len(conn->queries_to_conn)) {\n        continue;\n      }\n\n      /* If we are configured not to stay open, close it out */\n      if (!(channel->flags & ARES_FLAG_STAYOPEN)) {\n        do_cleanup = ARES_TRUE;\n      }\n\n      /* If the associated server has failures, close it out. Resetting the\n       * connection (and specifically the source port number) can help resolve\n       * situations where packets are being dropped.\n       */\n      if (conn->server->consec_failures > 0) {\n        do_cleanup = ARES_TRUE;\n      }\n\n      /* If the udp connection hit its max queries, always close it */\n      if (!(conn->flags & ARES_CONN_FLAG_TCP) && channel->udp_max_queries > 0 &&\n          conn->total_queries >= channel->udp_max_queries) {\n        do_cleanup = ARES_TRUE;\n      }\n\n      if (!do_cleanup) {\n        continue;\n      }\n\n      /* Clean it up */\n      ares_close_connection(conn, ARES_SUCCESS);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_check_cleanup_conns",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_addrinfo_localhost.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t ares_ai_has_family(int aftype,\n                                      const struct ares_addrinfo_node *nodes)\n{\n  const struct ares_addrinfo_node *node;\n\n  for (node = nodes; node != NULL; node = node->ai_next) {\n    if (node->ai_family == aftype)\n      return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_ai_has_family",
            "parameters": {
              "aftype": "int",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_append_ai_node(int aftype, unsigned short port,\n                                  unsigned int ttl, const void *adata,\n                                  struct ares_addrinfo_node **nodes)\n{\n  struct ares_addrinfo_node *node;\n\n  node = ares_append_addrinfo_node(nodes);\n  if (!node) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  memset(node, 0, sizeof(*node));\n\n  if (aftype == AF_INET) {\n    struct sockaddr_in *sin = ares_malloc(sizeof(*sin));\n    if (!sin) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    memset(sin, 0, sizeof(*sin));\n    memcpy(&sin->sin_addr.s_addr, adata, sizeof(sin->sin_addr.s_addr));\n    sin->sin_family = AF_INET;\n    sin->sin_port   = htons(port);\n\n    node->ai_addr    = (struct sockaddr *)sin;\n    node->ai_family  = AF_INET;\n    node->ai_addrlen = sizeof(*sin);\n    node->ai_addr    = (struct sockaddr *)sin;\n    node->ai_ttl     = (int)ttl;\n  }\n\n  if (aftype == AF_INET6) {\n    struct sockaddr_in6 *sin6 = ares_malloc(sizeof(*sin6));\n    if (!sin6) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    memset(sin6, 0, sizeof(*sin6));\n    memcpy(&sin6->sin6_addr.s6_addr, adata, sizeof(sin6->sin6_addr.s6_addr));\n    sin6->sin6_family = AF_INET6;\n    sin6->sin6_port   = htons(port);\n\n    node->ai_addr    = (struct sockaddr *)sin6;\n    node->ai_family  = AF_INET6;\n    node->ai_addrlen = sizeof(*sin6);\n    node->ai_addr    = (struct sockaddr *)sin6;\n    node->ai_ttl     = (int)ttl;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_ai_node",
            "parameters": {
              "aftype": "int",
              "port": "unsigned short",
              "ttl": "unsigned int",
              "adata": "void",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_default_loopback_addrs(int aftype, unsigned short port,\n                              struct ares_addrinfo_node **nodes)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  if ((aftype == AF_UNSPEC || aftype == AF_INET6) &&\n      !ares_ai_has_family(AF_INET6, *nodes)) {\n    struct ares_in6_addr addr6;\n    ares_inet_pton(AF_INET6, \"::1\", &addr6);\n    status = ares_append_ai_node(AF_INET6, port, 0, &addr6, nodes);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  if ((aftype == AF_UNSPEC || aftype == AF_INET) &&\n      !ares_ai_has_family(AF_INET, *nodes)) {\n    struct in_addr addr4;\n    ares_inet_pton(AF_INET, \"127.0.0.1\", &addr4);\n    status = ares_append_ai_node(AF_INET, port, 0, &addr4, nodes);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_default_loopback_addrs",
            "parameters": {
              "aftype": "int",
              "port": "unsigned short",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_system_loopback_addrs(int aftype, unsigned short port,\n                             struct ares_addrinfo_node **nodes)\n{\n#if defined(USE_WINSOCK) && defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0600 && \\\n  !defined(__WATCOMC__)\n  PMIB_UNICASTIPADDRESS_TABLE table;\n  unsigned int                i;\n  ares_status_t               status = ARES_ENOTFOUND;\n\n  *nodes = NULL;\n\n  if (GetUnicastIpAddressTable((ADDRESS_FAMILY)aftype, &table) != NO_ERROR) {\n    return ARES_ENOTFOUND;\n  }\n\n  for (i = 0; i < table->NumEntries; i++) {\n    if (table->Table[i].InterfaceLuid.Info.IfType !=\n        IF_TYPE_SOFTWARE_LOOPBACK) {\n      continue;\n    }\n\n    if (table->Table[i].Address.si_family == AF_INET &&\n        !ares_ai_has_family(AF_INET, *nodes)) {\n      status =\n        ares_append_ai_node(table->Table[i].Address.si_family, port, 0,\n                            &table->Table[i].Address.Ipv4.sin_addr, nodes);\n    } else if (table->Table[i].Address.si_family == AF_INET6 &&\n               !ares_ai_has_family(AF_INET6, *nodes)) {\n      status =\n        ares_append_ai_node(table->Table[i].Address.si_family, port, 0,\n                            &table->Table[i].Address.Ipv6.sin6_addr, nodes);\n    } else {\n      /* Ignore any others */\n      continue;\n    }\n\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  if (*nodes == NULL) {\n    status = ARES_ENOTFOUND;\n  }\n\nfail:\n  FreeMibTable(table);\n\n  if (status != ARES_SUCCESS) {\n    ares_freeaddrinfo_nodes(*nodes);\n    *nodes = NULL;\n  }\n\n  return status;\n\n#else\n  (void)aftype;\n  (void)port;\n  (void)nodes;\n  /* Not supported on any other OS at this time */\n  return ARES_ENOTFOUND;\n#endif\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_system_loopback_addrs",
            "parameters": {
              "aftype": "int",
              "port": "unsigned short",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_addrinfo_localhost(const char *name, unsigned short port,\n                                      const struct ares_addrinfo_hints *hints,\n                                      struct ares_addrinfo             *ai)\n{\n  ares_status_t status;\n\n  /* Validate family */\n  switch (hints->ai_family) {\n    case AF_INET:\n    case AF_INET6:\n    case AF_UNSPEC:\n      break;\n    default:                  /* LCOV_EXCL_LINE: DefensiveCoding */\n      return ARES_EBADFAMILY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (ai->name != NULL) {\n    ares_free(ai->name);\n  }\n  ai->name = ares_strdup(name);\n  if (ai->name == NULL) {\n    status = ARES_ENOMEM;\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_system_loopback_addrs(hints->ai_family, port, &ai->nodes);\n  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  status = ares_default_loopback_addrs(hints->ai_family, port, &ai->nodes);\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo_localhost",
            "parameters": {
              "name": "char",
              "port": "unsigned short",
              "hints": "struct ares_addrinfo_hints",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            52,
            44
          ],
          [
            52,
            69
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            54,
            8
          ],
          [
            54,
            33
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            66,
            34
          ],
          [
            66,
            59
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            68,
            2
          ],
          [
            68,
            27
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            78,
            4
          ],
          [
            78,
            22
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            88,
            24
          ],
          [
            88,
            39
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            91,
            24
          ],
          [
            91,
            39
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            96,
            4
          ],
          [
            96,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            106,
            24
          ],
          [
            106,
            39
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            109,
            24
          ],
          [
            109,
            39
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            118,
            30
          ],
          [
            118,
            55
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            124,
            4
          ],
          [
            124,
            24
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            134,
            4
          ],
          [
            134,
            18
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            147,
            29
          ],
          [
            147,
            54
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            211,
            44
          ],
          [
            211,
            70
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            212,
            38
          ],
          [
            212,
            58
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#    include <ws2ipdef.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_sysconfig_win.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t get_REG_SZ(HKEY hKey, const WCHAR *leafKeyName, char **outptr)\n{\n  DWORD  size = 0;\n  int    res;\n  int    len;\n  WCHAR *val = NULL;\n\n  *outptr = NULL;\n\n  /* Find out size of string stored in registry */\n  res = RegQueryValueExW(hKey, leafKeyName, 0, NULL, NULL, &size);\n  if ((res != ERROR_SUCCESS && res != ERROR_MORE_DATA) || !size) {\n    return ARES_FALSE;\n  }\n\n  /* Allocate buffer of indicated size plus one given that string\n     might have been stored without null termination */\n  val = ares_malloc_zero(size + sizeof(WCHAR));\n  if (val == NULL) {\n    return ARES_FALSE;\n  }\n\n  /* Get the value for real */\n  res = RegQueryValueExW(hKey, leafKeyName, 0, NULL, (BYTE *)val, &size);\n  if (res != ERROR_SUCCESS || size == 1) {\n    ares_free(val);\n    return ARES_FALSE;\n  }\n\n  /* Convert to UTF8 */\n  len = WideCharToMultiByte(CP_UTF8, 0, val, -1, NULL, 0, NULL, NULL);\n  if (len == 0) {\n    return ARES_FALSE;\n  }\n  *outptr = ares_malloc_zero((size_t)len + 1);\n  if (WideCharToMultiByte(CP_UTF8, 0, val, -1, *outptr, len, NULL, NULL)\n    == 0) {\n    ares_free(*outptr);\n    *outptr = NULL;\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_REG_SZ",
            "parameters": {
              "hKey": "HKEY",
              "leafKeyName": "WCHAR",
              "outptr": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void commanjoin(char **dst, const char * const src, const size_t len)\n{\n  char  *newbuf;\n  size_t newsize;\n\n  /* 1 for terminating 0 and 2 for , and terminating 0 */\n  newsize = len + (*dst ? (ares_strlen(*dst) + 2) : 1);\n  newbuf  = ares_realloc(*dst, newsize);\n  if (!newbuf) {\n    return;\n  }\n  if (*dst == NULL) {\n    *newbuf = '\\0';\n  }\n  *dst = newbuf;\n  if (ares_strlen(*dst) != 0) {\n    strcat(*dst, \",\");\n  }\n  strncat(*dst, src, len);\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              148,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "commanjoin",
            "parameters": {
              "dst": "char",
              "src": "char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void commajoin(char **dst, const char *src)\n{\n  commanjoin(dst, src, ares_strlen(src));\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "commajoin",
            "parameters": {
              "dst": "char",
              "src": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void commajoin_asciionly(char **dst, const char *src)\n{\n  if (!ares_str_isprint(src, ares_strlen(src))) {\n    return;\n  }\n  commanjoin(dst, src, ares_strlen(src));\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "commajoin_asciionly",
            "parameters": {
              "dst": "char",
              "src": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int compareAddresses(const void *arg1, const void *arg2)\n{\n  const Address * const left  = arg1;\n  const Address * const right = arg2;\n  /* Lower metric the more preferred */\n  if (left->metric < right->metric) {\n    return -1;\n  }\n  if (left->metric > right->metric) {\n    return 1;\n  }\n  /* If metrics are equal, lower original index more preferred */\n  if (left->orig_idx < right->orig_idx) {\n    return -1;\n  }\n  if (left->orig_idx > right->orig_idx) {\n    return 1;\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compareAddresses",
            "parameters": {
              "arg1": "void",
              "arg2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ULONG getBestRouteMetric(IF_LUID * const luid, /* Can't be const :( */\n                                const SOCKADDR_INET * const dest,\n                                const ULONG                 interfaceMetric)\n{\n  MIB_IPFORWARD_ROW2 row;\n  SOCKADDR_INET      ignored;\n  if (GetBestRoute2(/* The interface to use.  The index is ignored since we are\n                     * passing a LUID.\n                     */\n                    luid, 0,\n                    /* No specific source address. */\n                    NULL,\n                    /* Our destination address. */\n                    dest,\n                    /* No options. */\n                    0,\n                    /* The route row. */\n                    &row,\n                    /* The best source address, which we don't need. */\n                    &ignored) != NO_ERROR\n      /* If the metric is \"unused\" (-1) or too large for us to add the two\n       * metrics, use the worst possible, thus sorting this last.\n       */\n      || row.Metric == (ULONG)-1 ||\n      row.Metric > ((ULONG)-1) - interfaceMetric) {\n    /* Return the worst possible metric. */\n    return (ULONG)-1;\n  }\n\n  /* Return the metric value from that row, plus the interface metric.\n   *\n   * See\n   * http://msdn.microsoft.com/en-us/library/windows/desktop/aa814494(v=vs.85).aspx\n   * which describes the combination as a \"sum\".\n   */\n  return row.Metric + interfaceMetric;\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getBestRouteMetric",
            "parameters": {
              "luid": "IF_LUID",
              "dest": "SOCKADDR_INET",
              "interfaceMetric": "ULONG"
            },
            "return_type": "ULONG"
          }
        },
        {
          "fn_code": "static ares_bool_t get_DNS_Windows(char **outptr)\n{\n  IP_ADAPTER_DNS_SERVER_ADDRESS *ipaDNSAddr;\n  IP_ADAPTER_ADDRESSES          *ipaa;\n  IP_ADAPTER_ADDRESSES          *newipaa;\n  IP_ADAPTER_ADDRESSES          *ipaaEntry;\n  ULONG                          ReqBufsz  = IPAA_INITIAL_BUF_SZ;\n  ULONG                          Bufsz     = IPAA_INITIAL_BUF_SZ;\n  ULONG                          AddrFlags = 0;\n  int                            trying    = IPAA_MAX_TRIES;\n  ULONG                          res;\n\n  /* The capacity of addresses, in elements. */\n  size_t                         addressesSize;\n  /* The number of elements in addresses. */\n  size_t                         addressesIndex = 0;\n  /* The addresses we will sort. */\n  Address                       *addresses;\n\n  union {\n    struct sockaddr     *sa;\n    struct sockaddr_in  *sa4;\n    struct sockaddr_in6 *sa6;\n  } namesrvr;\n\n  *outptr = NULL;\n\n  ipaa = ares_malloc(Bufsz);\n  if (!ipaa) {\n    return ARES_FALSE;\n  }\n\n  /* Start with enough room for a few DNS server addresses and we'll grow it\n   * as we encounter more.\n   */\n  addressesSize = 4;\n  addresses     = (Address *)ares_malloc(sizeof(Address) * addressesSize);\n  if (addresses == NULL) {\n    /* We need room for at least some addresses to function. */\n    ares_free(ipaa);\n    return ARES_FALSE;\n  }\n\n  /* Usually this call succeeds with initial buffer size */\n  res = GetAdaptersAddresses(AF_UNSPEC, AddrFlags, NULL, ipaa, &ReqBufsz);\n  if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS)) {\n    goto done;\n  }\n\n  while ((res == ERROR_BUFFER_OVERFLOW) && (--trying)) {\n    if (Bufsz < ReqBufsz) {\n      newipaa = ares_realloc(ipaa, ReqBufsz);\n      if (!newipaa) {\n        goto done;\n      }\n      Bufsz = ReqBufsz;\n      ipaa  = newipaa;\n    }\n    res = GetAdaptersAddresses(AF_UNSPEC, AddrFlags, NULL, ipaa, &ReqBufsz);\n    if (res == ERROR_SUCCESS) {\n      break;\n    }\n  }\n  if (res != ERROR_SUCCESS) {\n    goto done;\n  }\n\n  for (ipaaEntry = ipaa; ipaaEntry; ipaaEntry = ipaaEntry->Next) {\n    if (ipaaEntry->OperStatus != IfOperStatusUp) {\n      continue;\n    }\n\n    /* For each interface, find any associated DNS servers as IPv4 or IPv6\n     * addresses.  For each found address, find the best route to that DNS\n     * server address _on_ _that_ _interface_ (at this moment in time) and\n     * compute the resulting total metric, just as Windows routing will do.\n     * Then, sort all the addresses found by the metric.\n     */\n    for (ipaDNSAddr = ipaaEntry->FirstDnsServerAddress; ipaDNSAddr != NULL;\n         ipaDNSAddr = ipaDNSAddr->Next) {\n      char ipaddr[INET6_ADDRSTRLEN] = \"\";\n\n      namesrvr.sa = ipaDNSAddr->Address.lpSockaddr;\n\n      if (namesrvr.sa->sa_family == AF_INET) {\n        if ((namesrvr.sa4->sin_addr.S_un.S_addr == INADDR_ANY) ||\n            (namesrvr.sa4->sin_addr.S_un.S_addr == INADDR_NONE)) {\n          continue;\n        }\n\n        /* Allocate room for another address, if necessary, else skip. */\n        if (addressesIndex == addressesSize) {\n          const size_t    newSize = addressesSize + 4;\n          Address * const newMem =\n            (Address *)ares_realloc(addresses, sizeof(Address) * newSize);\n          if (newMem == NULL) {\n            continue;\n          }\n          addresses     = newMem;\n          addressesSize = newSize;\n        }\n\n#  if defined(HAVE_GETBESTROUTE2) && !defined(__WATCOMC__)\n        /* OpenWatcom's builtin Windows SDK does not have a definition for\n         * MIB_IPFORWARD_ROW2, and also does not allow the usage of SOCKADDR_INET\n         * as a variable. Let's work around this by returning the worst possible\n         * metric, but only when using the OpenWatcom compiler.\n         * It may be worth investigating using a different version of the Windows\n         * SDK with OpenWatcom in the future, though this may be fixed in OpenWatcom\n         * 2.0.\n         */\n        addresses[addressesIndex].metric = getBestRouteMetric(\n          &ipaaEntry->Luid, (SOCKADDR_INET *)((void *)(namesrvr.sa)),\n          ipaaEntry->Ipv4Metric);\n#  else\n        addresses[addressesIndex].metric = (ULONG)-1;\n#  endif\n\n        /* Record insertion index to make qsort stable */\n        addresses[addressesIndex].orig_idx = addressesIndex;\n\n        if (!ares_inet_ntop(AF_INET, &namesrvr.sa4->sin_addr, ipaddr,\n                            sizeof(ipaddr))) {\n          continue;\n        }\n        snprintf(addresses[addressesIndex].text,\n                 sizeof(addresses[addressesIndex].text), \"[%s]:%u\", ipaddr,\n                 ntohs(namesrvr.sa4->sin_port));\n        ++addressesIndex;\n      } else if (namesrvr.sa->sa_family == AF_INET6) {\n        unsigned int     ll_scope = 0;\n        struct ares_addr addr;\n\n        if (memcmp(&namesrvr.sa6->sin6_addr, &ares_in6addr_any,\n                   sizeof(namesrvr.sa6->sin6_addr)) == 0) {\n          continue;\n        }\n\n        /* Allocate room for another address, if necessary, else skip. */\n        if (addressesIndex == addressesSize) {\n          const size_t    newSize = addressesSize + 4;\n          Address * const newMem =\n            (Address *)ares_realloc(addresses, sizeof(Address) * newSize);\n          if (newMem == NULL) {\n            continue;\n          }\n          addresses     = newMem;\n          addressesSize = newSize;\n        }\n\n        /* See if its link-local */\n        memset(&addr, 0, sizeof(addr));\n        addr.family = AF_INET6;\n        memcpy(&addr.addr.addr6, &namesrvr.sa6->sin6_addr, 16);\n        if (ares_addr_is_linklocal(&addr)) {\n          ll_scope = ipaaEntry->Ipv6IfIndex;\n        }\n\n#  if defined(HAVE_GETBESTROUTE2) && !defined(__WATCOMC__)\n        addresses[addressesIndex].metric = getBestRouteMetric(\n          &ipaaEntry->Luid, (SOCKADDR_INET *)((void *)(namesrvr.sa)),\n          ipaaEntry->Ipv6Metric);\n#  else\n        addresses[addressesIndex].metric = (ULONG)-1;\n#  endif\n\n        /* Record insertion index to make qsort stable */\n        addresses[addressesIndex].orig_idx = addressesIndex;\n\n        if (!ares_inet_ntop(AF_INET6, &namesrvr.sa6->sin6_addr, ipaddr,\n                            sizeof(ipaddr))) {\n          continue;\n        }\n\n        if (ll_scope) {\n          snprintf(addresses[addressesIndex].text,\n                   sizeof(addresses[addressesIndex].text), \"[%s]:%u%%%u\",\n                   ipaddr, ntohs(namesrvr.sa6->sin6_port), ll_scope);\n        } else {\n          snprintf(addresses[addressesIndex].text,\n                   sizeof(addresses[addressesIndex].text), \"[%s]:%u\", ipaddr,\n                   ntohs(namesrvr.sa6->sin6_port));\n        }\n        ++addressesIndex;\n      } else {\n        /* Skip non-IPv4/IPv6 addresses completely. */\n        continue;\n      }\n    }\n  }\n\n  /* Sort all of the textual addresses by their metric (and original index if\n   * metrics are equal). */\n  qsort(addresses, addressesIndex, sizeof(*addresses), compareAddresses);\n\n  /* Join them all into a single string, removing duplicates. */\n  {\n    size_t i;\n    for (i = 0; i < addressesIndex; ++i) {\n      size_t j;\n      /* Look for this address text appearing previously in the results. */\n      for (j = 0; j < i; ++j) {\n        if (strcmp(addresses[j].text, addresses[i].text) == 0) {\n          break;\n        }\n      }\n      /* Iff we didn't emit this address already, emit it now. */\n      if (j == i) {\n        /* Add that to outptr (if we can). */\n        commajoin(outptr, addresses[i].text);\n      }\n    }\n  }\n\ndone:\n  ares_free(addresses);\n\n  if (ipaa) {\n    ares_free(ipaa);\n  }\n\n  if (!*outptr) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              525,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_DNS_Windows",
            "parameters": {
              "outptr": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t get_SuffixList_Windows(char **outptr)\n{\n  HKEY  hKey;\n  HKEY  hKeyEnum;\n  char  keyName[256];\n  DWORD keyNameBuffSize;\n  DWORD keyIdx = 0;\n  char *p      = NULL;\n\n  *outptr = NULL;\n\n  /* 1. Global DNS Suffix Search List */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    get_REG_SZ(hKey, SEARCHLIST_KEY, outptr);\n    if (get_REG_SZ(hKey, DOMAIN_KEY, &p)) {\n      commajoin_asciionly(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NT_DNSCLIENT, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    if (get_REG_SZ(hKey, SEARCHLIST_KEY, &p)) {\n      commajoin_asciionly(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  /* 2. Connection Specific Search List composed of:\n   *  a. Primary DNS Suffix */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_DNSCLIENT, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    if (get_REG_SZ(hKey, PRIMARYDNSSUFFIX_KEY, &p)) {\n      commajoin_asciionly(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  /*  b. Interface SearchList, Domain, DhcpDomain */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY \"\\\\\" INTERFACES_KEY, 0,\n                    KEY_READ, &hKey) == ERROR_SUCCESS) {\n    for (;;) {\n      keyNameBuffSize = sizeof(keyName);\n      if (RegEnumKeyExA(hKey, keyIdx++, keyName, &keyNameBuffSize, 0, NULL,\n                        NULL, NULL) != ERROR_SUCCESS) {\n        break;\n      }\n      if (RegOpenKeyExA(hKey, keyName, 0, KEY_QUERY_VALUE, &hKeyEnum) !=\n          ERROR_SUCCESS) {\n        continue;\n      }\n      /* p can be comma separated (SearchList) */\n      if (get_REG_SZ(hKeyEnum, SEARCHLIST_KEY, &p)) {\n        commajoin_asciionly(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      if (get_REG_SZ(hKeyEnum, DOMAIN_KEY, &p)) {\n        commajoin_asciionly(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      if (get_REG_SZ(hKeyEnum, DHCPDOMAIN_KEY, &p)) {\n        commajoin_asciionly(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      RegCloseKey(hKeyEnum);\n    }\n    RegCloseKey(hKey);\n  }\n\n  return *outptr != NULL ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              540,
              0
            ],
            [
              620,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_SuffixList_Windows",
            "parameters": {
              "outptr": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_init_sysconfig_windows(const ares_channel_t *channel,\n                                          ares_sysconfig_t     *sysconfig)\n{\n  char         *line   = NULL;\n  ares_status_t status = ARES_SUCCESS;\n\n  if (get_DNS_Windows(&line)) {\n    status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, line,\n                                         ARES_TRUE);\n    ares_free(line);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  if (get_SuffixList_Windows(&line)) {\n    sysconfig->domains = ares_strsplit(line, \", \", &sysconfig->ndomains);\n    ares_free(line);\n    if (sysconfig->domains == NULL) {\n      status = ARES_EFILE;\n    }\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              622,
              0
            ],
            [
              650,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_windows",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  /* The metric we sort them by. */\n  ULONG  metric;\n\n  /* Original index of the item, used as a secondary sort parameter to make\n   * qsort() stable if the metrics are equal */\n  size_t orig_idx;\n\n  /* Room enough for the string form of any IPv4 or IPv6 address that\n   * ares_inet_ntop() will create.  Based on the existing c-ares practice.\n   */\n  char   text[INET6_ADDRSTRLEN + 8 + 64]; /* [%s]:NNNNN%iface */\n} Address;",
          {
            "metric": "ULONG",
            "orig_idx": "size_t",
            "text[INET6_ADDRSTRLEN + 8 + 64]": "char"
          },
          "Address",
          [
            171,
            0
          ],
          [
            183,
            10
          ]
        ],
        [
          "typedef struct {\n  /* The metric we sort them by. */\n  ULONG  metric;\n\n  /* Original index of the item, used as a secondary sort parameter to make\n   * qsort() stable if the metrics are equal */\n  size_t orig_idx;\n\n  /* Room enough for the string form of any IPv4 or IPv6 address that\n   * ares_inet_ntop() will create.  Based on the existing c-ares practice.\n   */\n  char   text[INET6_ADDRSTRLEN + 8 + 64]; /* [%s]:NNNNN%iface */\n} Address;",
          {
            "metric": "ULONG",
            "orig_idx": "size_t",
            "text[INET6_ADDRSTRLEN + 8 + 64]": "char"
          },
          "Address",
          [
            171,
            0
          ],
          [
            183,
            10
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            319,
            4
          ],
          [
            319,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            320,
            4
          ],
          [
            320,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            321,
            4
          ],
          [
            321,
            23
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            430,
            8
          ],
          [
            430,
            24
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/param.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_version.c": {
      "fn_def_list": [
        {
          "fn_code": "const char *ares_version(int *version)\n{\n  if (version) {\n    *version = ARES_VERSION;\n  }\n\n  return ARES_VERSION_STR;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_version",
            "parameters": {
              "version": "int"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_version(int *version)",
          "fn_dec_pos": [
            [
              28,
              12
            ],
            [
              28,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_version",
            "parameters": {
              "version": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_strerror.c": {
      "fn_def_list": [
        {
          "fn_code": "const char *ares_strerror(int code)\n{\n  ares_status_t status = (ares_status_t)code;\n  switch (status) {\n    case ARES_SUCCESS:\n      return \"Successful completion\";\n    case ARES_ENODATA:\n      return \"DNS server returned answer with no data\";\n    case ARES_EFORMERR:\n      return \"DNS server claims query was misformatted\";\n    case ARES_ESERVFAIL:\n      return \"DNS server returned general failure\";\n    case ARES_ENOTFOUND:\n      return \"Domain name not found\";\n    case ARES_ENOTIMP:\n      return \"DNS server does not implement requested operation\";\n    case ARES_EREFUSED:\n      return \"DNS server refused query\";\n    case ARES_EBADQUERY:\n      return \"Misformatted DNS query\";\n    case ARES_EBADNAME:\n      return \"Misformatted domain name\";\n    case ARES_EBADFAMILY:\n      return \"Unsupported address family\";\n    case ARES_EBADRESP:\n      return \"Misformatted DNS reply\";\n    case ARES_ECONNREFUSED:\n      return \"Could not contact DNS servers\";\n    case ARES_ETIMEOUT:\n      return \"Timeout while contacting DNS servers\";\n    case ARES_EOF:\n      return \"End of file\";\n    case ARES_EFILE:\n      return \"Error reading file\";\n    case ARES_ENOMEM:\n      return \"Out of memory\";\n    case ARES_EDESTRUCTION:\n      return \"Channel is being destroyed\";\n    case ARES_EBADSTR:\n      return \"Misformatted string\";\n    case ARES_EBADFLAGS:\n      return \"Illegal flags specified\";\n    case ARES_ENONAME:\n      return \"Given hostname is not numeric\";\n    case ARES_EBADHINTS:\n      return \"Illegal hints flags specified\";\n    case ARES_ENOTINITIALIZED:\n      return \"c-ares library initialization not yet performed\";\n    case ARES_ELOADIPHLPAPI:\n      return \"Error loading iphlpapi.dll\";\n    case ARES_EADDRGETNETWORKPARAMS:\n      return \"Could not find GetNetworkParams function\";\n    case ARES_ECANCELLED:\n      return \"DNS query cancelled\";\n    case ARES_ESERVICE:\n      return \"Invalid service name or number\";\n    case ARES_ENOSERVER:\n      return \"No DNS servers were configured\";\n  }\n\n  return \"unknown\";\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strerror",
            "parameters": {
              "code": "int"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_strerror(int code)",
          "fn_dec_pos": [
            [
              29,
              12
            ],
            [
              29,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strerror",
            "parameters": {
              "code": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_init.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_init(ares_channel_t **channelptr)\n{\n  return ares_init_options(channelptr, NULL, 0);\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init",
            "parameters": {
              "channelptr": "ares_channel_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ares_query_timeout_cmp_cb(const void *arg1, const void *arg2)\n{\n  const ares_query_t *q1 = arg1;\n  const ares_query_t *q2 = arg2;\n\n  if (q1->timeout.sec > q2->timeout.sec) {\n    return 1;\n  }\n  if (q1->timeout.sec < q2->timeout.sec) {\n    return -1;\n  }\n\n  if (q1->timeout.usec > q2->timeout.usec) {\n    return 1;\n  }\n  if (q1->timeout.usec < q2->timeout.usec) {\n    return -1;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_timeout_cmp_cb",
            "parameters": {
              "arg1": "void",
              "arg2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int server_sort_cb(const void *data1, const void *data2)\n{\n  const ares_server_t *s1 = data1;\n  const ares_server_t *s2 = data2;\n\n  if (s1->consec_failures < s2->consec_failures) {\n    return -1;\n  }\n  if (s1->consec_failures > s2->consec_failures) {\n    return 1;\n  }\n  if (s1->idx < s2->idx) {\n    return -1;\n  }\n  if (s1->idx > s2->idx) {\n    return 1;\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_sort_cb",
            "parameters": {
              "data1": "void",
              "data2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void server_destroy_cb(void *data)\n{\n  if (data == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  ares_destroy_server(data);\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_destroy_cb",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t init_by_defaults(ares_channel_t *channel)\n{\n  char         *hostname = NULL;\n  ares_status_t rc       = ARES_SUCCESS;\n#ifdef HAVE_GETHOSTNAME\n  const char *dot;\n#endif\n  struct ares_addr addr;\n  ares_llist_t    *sconfig = NULL;\n\n  /* Enable EDNS by default */\n  if (!(channel->optmask & ARES_OPT_FLAGS)) {\n    channel->flags = ARES_FLAG_EDNS;\n  }\n  if (channel->ednspsz == 0) {\n    channel->ednspsz = EDNSPACKETSZ;\n  }\n\n  if (channel->timeout == 0) {\n    channel->timeout = DEFAULT_TIMEOUT;\n  }\n\n  if (channel->tries == 0) {\n    channel->tries = DEFAULT_TRIES;\n  }\n\n  if (ares_slist_len(channel->servers) == 0) {\n    /* Add a default local named server to the channel unless configured not\n     * to (in which case return an error).\n     */\n    if (channel->flags & ARES_FLAG_NO_DFLT_SVR) {\n      rc = ARES_ENOSERVER;\n      goto error;\n    }\n\n    addr.family            = AF_INET;\n    addr.addr.addr4.s_addr = htonl(INADDR_LOOPBACK);\n\n    rc = ares_sconfig_append(channel, &sconfig, &addr, 0, 0, NULL);\n    if (rc != ARES_SUCCESS) {\n      goto error; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    rc = ares_servers_update(channel, sconfig, ARES_FALSE);\n    ares_llist_destroy(sconfig);\n\n    if (rc != ARES_SUCCESS) {\n      goto error;\n    }\n  }\n\n  if (channel->ndomains == 0) {\n    /* Derive a default domain search list from the kernel hostname,\n     * or set it to empty if the hostname isn't helpful.\n     */\n#ifndef HAVE_GETHOSTNAME\n    channel->ndomains = 0; /* default to none */\n#else\n    size_t len        = 256;\n    channel->ndomains = 0; /* default to none */\n\n    hostname = ares_malloc(len);\n    if (!hostname) {\n      rc = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto error;       /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    if (gethostname(hostname, (GETHOSTNAME_TYPE_ARG2)len) != 0) {\n      /* Lets not treat a gethostname failure as critical, since we\n       * are ok if gethostname doesn't even exist */\n      *hostname = '\\0';\n    }\n\n    dot = strchr(hostname, '.');\n    if (dot) {\n      /* a dot was found */\n      channel->domains = ares_malloc(sizeof(char *));\n      if (!channel->domains) {\n        rc = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto error;       /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      channel->domains[0] = ares_strdup(dot + 1);\n      if (!channel->domains[0]) {\n        rc = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto error;       /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      channel->ndomains = 1;\n    }\n#endif\n  }\n\n  if (channel->nsort == 0) {\n    channel->sortlist = NULL;\n  }\n\n  if (!channel->lookups) {\n    channel->lookups = ares_strdup(\"fb\");\n    if (!channel->lookups) {\n      rc = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  /* Set default fields for server failover behavior */\n  if (!(channel->optmask & ARES_OPT_SERVER_FAILOVER)) {\n    channel->server_retry_chance = DEFAULT_SERVER_RETRY_CHANCE;\n    channel->server_retry_delay  = DEFAULT_SERVER_RETRY_DELAY;\n  }\n\nerror:\n  if (hostname) {\n    ares_free(hostname);\n  }\n\n  return rc;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_by_defaults",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_init_options(ares_channel_t           **channelptr,\n                      const struct ares_options *options, int optmask)\n{\n  ares_channel_t *channel;\n  ares_status_t   status = ARES_SUCCESS;\n\n  if (ares_library_initialized() != ARES_SUCCESS) {\n    return ARES_ENOTINITIALIZED; /* LCOV_EXCL_LINE: n/a on non-WinSock */\n  }\n\n  channel = ares_malloc_zero(sizeof(*channel));\n  if (!channel) {\n    *channelptr = NULL;\n    return ARES_ENOMEM;\n  }\n\n  /* We are in a good state */\n  channel->sys_up = ARES_TRUE;\n\n  /* One option where zero is valid, so set default value here */\n  channel->ndots = 1;\n\n  status = ares_channel_threading_init(channel);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Generate random key */\n  channel->rand_state = ares_init_rand_state();\n  if (channel->rand_state == NULL) {\n    status = ARES_ENOMEM;\n    DEBUGF(fprintf(stderr, \"Error: init_id_key failed: %s\\n\",\n                   ares_strerror(status)));\n    goto done;\n  }\n\n  ares_set_socket_functions_def(channel);\n\n  /* Initialize Server List */\n  channel->servers =\n    ares_slist_create(channel->rand_state, server_sort_cb, server_destroy_cb);\n  if (channel->servers == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Initialize our lists of queries */\n  channel->all_queries = ares_llist_create(NULL);\n  if (channel->all_queries == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->queries_by_qid = ares_htable_szvp_create(NULL);\n  if (channel->queries_by_qid == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->queries_by_timeout =\n    ares_slist_create(channel->rand_state, ares_query_timeout_cmp_cb, NULL);\n  if (channel->queries_by_timeout == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->connnode_by_socket = ares_htable_asvp_create(NULL);\n  if (channel->connnode_by_socket == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Initialize configuration by each of the four sources, from highest\n   * precedence to lowest.\n   */\n\n  status = ares_init_by_options(channel, options, optmask);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_options failed: %s\\n\",\n                   ares_strerror(status)));\n    /* If we fail to apply user-specified options, fail the whole init process\n     */\n    goto done;\n  }\n\n  /* Go ahead and let it initialize the query cache even if the ttl is 0 and\n   * completely unused.  This reduces the number of different code paths that\n   * might be followed even if there is a minor performance hit. */\n  status = ares_qcache_create(channel->rand_state, channel->qcache_max_ttl,\n                              &channel->qcache);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (status == ARES_SUCCESS) {\n    status = ares_init_by_sysconfig(channel);\n    if (status != ARES_SUCCESS) {\n      DEBUGF(fprintf(stderr, \"Error: init_by_sysconfig failed: %s\\n\",\n                     ares_strerror(status)));\n    }\n  }\n\n  /*\n   * No matter what failed or succeeded, seed defaults to provide\n   * useful behavior for things that we missed.\n   */\n  status = init_by_defaults(channel);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_defaults failed: %s\\n\",\n                   ares_strerror(status)));\n    goto done;\n  }\n\n  /* Initialize the event thread */\n  if (channel->optmask & ARES_OPT_EVENT_THREAD) {\n    ares_event_thread_t *e = NULL;\n\n    status = ares_event_thread_init(channel);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: UntestablePath */\n    }\n\n    /* Initialize monitor for configuration changes.  In some rare cases,\n     * ARES_ENOTIMP may occur (OpenWatcom), ignore this. */\n    e      = channel->sock_state_cb_data;\n    status = ares_event_configchg_init(&e->configchg, e);\n    if (status != ARES_SUCCESS && status != ARES_ENOTIMP) {\n      DEBUGF(fprintf(stderr, \"Error: ares_event_configchg_init failed: %s\\n\",\n                     ares_strerror(status)));\n    }\n    status = ARES_SUCCESS;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_destroy(channel);\n    return (int)status;\n  }\n\n  *channelptr = channel;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_options",
            "parameters": {
              "channelptr": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void *ares_reinit_thread(void *arg)\n{\n  ares_channel_t *channel = arg;\n  ares_status_t   status;\n\n  /* ares_init_by_sysconfig() will lock when applying the config, but not\n   * when retrieving. */\n  status = ares_init_by_sysconfig(channel);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_sysconfig failed: %s\\n\",\n                   ares_strerror(status)));\n  }\n\n  ares_channel_lock(channel);\n\n  /* Flush cached queries on reinit */\n  if (status == ARES_SUCCESS && channel->qcache) {\n    ares_qcache_flush(channel->qcache);\n  }\n\n  channel->reinit_pending = ARES_FALSE;\n  ares_channel_unlock(channel);\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_reinit_thread",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_reinit(ares_channel_t *channel)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares_channel_lock(channel);\n\n  /* If a reinit is already in process, lets not do it again. Or if we are\n   * shutting down, skip. */\n  if (!channel->sys_up || channel->reinit_pending) {\n    ares_channel_unlock(channel);\n    return ARES_SUCCESS;\n  }\n  channel->reinit_pending = ARES_TRUE;\n  ares_channel_unlock(channel);\n\n  if (ares_threadsafety()) {\n    /* clean up the prior reinit process's thread.  We know the thread isn't\n     * running since reinit_pending was false */\n    if (channel->reinit_thread != NULL) {\n      void *rv;\n      ares_thread_join(channel->reinit_thread, &rv);\n      channel->reinit_thread = NULL;\n    }\n\n    /* Spawn a new thread */\n    status =\n      ares_thread_create(&channel->reinit_thread, ares_reinit_thread, channel);\n    if (status != ARES_SUCCESS) {\n      /* LCOV_EXCL_START: UntestablePath */\n      ares_channel_lock(channel);\n      channel->reinit_pending = ARES_FALSE;\n      ares_channel_unlock(channel);\n      /* LCOV_EXCL_STOP */\n    }\n  } else {\n    /* Threading support not available, call directly */\n    ares_reinit_thread(channel);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              406,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_reinit",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_dup(ares_channel_t **dest, const ares_channel_t *src)\n{\n  struct ares_options opts;\n  ares_status_t       rc;\n  int                 optmask;\n\n  if (dest == NULL || src == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dest = NULL; /* in case of failure return NULL explicitly */\n\n  /* First get the options supported by the old ares_save_options() function,\n     which is most of them */\n  rc = (ares_status_t)ares_save_options(src, &opts, &optmask);\n  if (rc != ARES_SUCCESS) {\n    ares_destroy_options(&opts);\n    goto done;\n  }\n\n  /* Then create the new channel with those options */\n  rc = (ares_status_t)ares_init_options(dest, &opts, optmask);\n\n  /* destroy the options copy to not leak any memory */\n  ares_destroy_options(&opts);\n\n  if (rc != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ares_channel_lock(src);\n  /* Now clone the options that ares_save_options() doesn't support, but are\n   * user-provided */\n  (*dest)->sock_create_cb               = src->sock_create_cb;\n  (*dest)->sock_create_cb_data          = src->sock_create_cb_data;\n  (*dest)->sock_config_cb               = src->sock_config_cb;\n  (*dest)->sock_config_cb_data          = src->sock_config_cb_data;\n  memcpy(&(*dest)->sock_funcs, &(src->sock_funcs), sizeof((*dest)->sock_funcs));\n  (*dest)->sock_func_cb_data            = src->sock_func_cb_data;\n  (*dest)->legacy_sock_funcs            = src->legacy_sock_funcs;\n  (*dest)->legacy_sock_funcs_cb_data    = src->legacy_sock_funcs_cb_data;\n  (*dest)->server_state_cb              = src->server_state_cb;\n  (*dest)->server_state_cb_data         = src->server_state_cb_data;\n  (*dest)->notify_pending_write_cb      = src->notify_pending_write_cb;\n  (*dest)->notify_pending_write_cb_data = src->notify_pending_write_cb_data;\n  (*dest)->query_enqueue_cb             = src->query_enqueue_cb;\n  (*dest)->query_enqueue_cb_data        = src->query_enqueue_cb_data;\n\n  ares_strcpy((*dest)->local_dev_name, src->local_dev_name,\n              sizeof((*dest)->local_dev_name));\n  (*dest)->local_ip4 = src->local_ip4;\n  memcpy((*dest)->local_ip6, src->local_ip6, sizeof(src->local_ip6));\n  ares_channel_unlock(src);\n\n  /* Servers are a bit unique as ares_init_options() only allows ipv4 servers\n   * and not a port per server, but there are other user specified ways, that\n   * too will toggle the optmask ARES_OPT_SERVERS to let us know.  If that's\n   * the case, pull them in.\n   *\n   * We don't want to clone system-configuration servers though.\n   *\n   * We must use the \"csv\" format to get things like link-local address support\n   */\n\n  if (optmask & ARES_OPT_SERVERS) {\n    char *csv = ares_get_servers_csv(src);\n    if (csv == NULL) {\n      /* LCOV_EXCL_START: OutOfMemory */\n      ares_destroy(*dest);\n      *dest = NULL;\n      rc    = ARES_ENOMEM;\n      goto done;\n      /* LCOV_EXCL_STOP */\n    }\n\n    rc = (ares_status_t)ares_set_servers_ports_csv(*dest, csv);\n    ares_free_string(csv);\n    if (rc != ARES_SUCCESS) {\n      /* LCOV_EXCL_START: OutOfMemory */\n      ares_destroy(*dest);\n      *dest = NULL;\n      goto done;\n      /* LCOV_EXCL_STOP */\n    }\n  }\n\n  rc = ARES_SUCCESS;\ndone:\n  return (int)rc; /* everything went fine */\n}",
          "fn_code_pos": [
            [
              454,
              0
            ],
            [
              543,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dup",
            "parameters": {
              "dest": "ares_channel_t",
              "src": "ares_channel_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares_set_local_ip4(ares_channel_t *channel, unsigned int local_ip)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares_channel_lock(channel);\n  channel->local_ip4 = local_ip;\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              545,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_ip4",
            "parameters": {
              "channel": "ares_channel_t",
              "local_ip": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_local_ip6(ares_channel_t *channel, const unsigned char *local_ip6)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares_channel_lock(channel);\n  memcpy(&channel->local_ip6, local_ip6, sizeof(channel->local_ip6));\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              556,
              0
            ],
            [
              564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_ip6",
            "parameters": {
              "channel": "ares_channel_t",
              "local_ip6": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_local_dev(ares_channel_t *channel, const char *local_dev_name)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  ares_channel_lock(channel);\n  ares_strcpy(channel->local_dev_name, local_dev_name,\n              sizeof(channel->local_dev_name));\n  channel->local_dev_name[sizeof(channel->local_dev_name) - 1] = 0;\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              567,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_dev",
            "parameters": {
              "channel": "ares_channel_t",
              "local_dev_name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_set_sortlist(ares_channel_t *channel, const char *sortstr)\n{\n  size_t           nsort    = 0;\n  struct apattern *sortlist = NULL;\n  ares_status_t    status;\n\n  if (!channel) {\n    return ARES_ENODATA;\n  }\n  ares_channel_lock(channel);\n\n  status = ares_parse_sortlist(&sortlist, &nsort, sortstr);\n  if (status == ARES_SUCCESS && sortlist) {\n    if (channel->sortlist) {\n      ares_free(channel->sortlist);\n    }\n    channel->sortlist = sortlist;\n    channel->nsort    = nsort;\n\n    /* Save sortlist as if it was passed in as an option */\n    channel->optmask |= ARES_OPT_SORTLIST;\n  }\n  ares_channel_unlock(channel);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              604,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_sortlist",
            "parameters": {
              "channel": "ares_channel_t",
              "sortstr": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares_set_query_enqueue_cb(ares_channel_t       *channel,\n                               ares_query_enqueue_cb callback,\n                               void                 *user_data)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  channel->query_enqueue_cb      = callback;\n  channel->query_enqueue_cb_data = user_data;\n}",
          "fn_code_pos": [
            [
              606,
              0
            ],
            [
              616,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_query_enqueue_cb",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_query_enqueue_cb",
              "user_data": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_reinit_thread(void *arg)",
          "fn_dec_pos": [
            [
              380,
              13
            ],
            [
              380,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_reinit_thread",
            "parameters": {
              "arg": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addr",
          {},
          "",
          [
            128,
            2
          ],
          [
            128,
            18
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            238,
            28
          ],
          [
            238,
            47
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            456,
            2
          ],
          [
            456,
            21
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            583,
            2
          ],
          [
            583,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/param.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include <sys/system_properties.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#  include <resolv.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#  include <iphlpapi.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"event/ares_event.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_socket.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_conn_err_t ares_socket_deref_error(int err)\n{\n  switch (err) {\n#if defined(EWOULDBLOCK)\n    case EWOULDBLOCK:\n      return ARES_CONN_ERR_WOULDBLOCK;\n#endif\n#if defined(EAGAIN) && (!defined(EWOULDBLOCK) || EAGAIN != EWOULDBLOCK)\n    case EAGAIN:\n      return ARES_CONN_ERR_WOULDBLOCK;\n#endif\n    case EINPROGRESS:\n      return ARES_CONN_ERR_WOULDBLOCK;\n    case ENETDOWN:\n      return ARES_CONN_ERR_NETDOWN;\n    case ENETUNREACH:\n      return ARES_CONN_ERR_NETUNREACH;\n    case ECONNABORTED:\n      return ARES_CONN_ERR_CONNABORTED;\n    case ECONNRESET:\n      return ARES_CONN_ERR_CONNRESET;\n    case ECONNREFUSED:\n      return ARES_CONN_ERR_CONNREFUSED;\n    case ETIMEDOUT:\n      return ARES_CONN_ERR_CONNTIMEDOUT;\n    case EHOSTDOWN:\n      return ARES_CONN_ERR_HOSTDOWN;\n    case EHOSTUNREACH:\n      return ARES_CONN_ERR_HOSTUNREACH;\n    case EINTR:\n      return ARES_CONN_ERR_INTERRUPT;\n    case EAFNOSUPPORT:\n      return ARES_CONN_ERR_AFNOSUPPORT;\n    case EADDRNOTAVAIL:\n      return ARES_CONN_ERR_BADADDR;\n    default:\n      break;\n  }\n\n  return ARES_CONN_ERR_FAILURE;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_deref_error",
            "parameters": {
              "err": "int"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_sockaddr_addr_eq(const struct sockaddr  *sa,\n                                  const struct ares_addr *aa)\n{\n  const void *addr1;\n  const void *addr2;\n\n  if (sa->sa_family == aa->family) {\n    switch (aa->family) {\n      case AF_INET:\n        addr1 = &aa->addr.addr4;\n        addr2 = &(CARES_INADDR_CAST(const struct sockaddr_in *, sa))->sin_addr;\n        if (memcmp(addr1, addr2, sizeof(aa->addr.addr4)) == 0) {\n          return ARES_TRUE; /* match */\n        }\n        break;\n      case AF_INET6:\n        addr1 = &aa->addr.addr6;\n        addr2 =\n          &(CARES_INADDR_CAST(const struct sockaddr_in6 *, sa))->sin6_addr;\n        if (memcmp(addr1, addr2, sizeof(aa->addr.addr6)) == 0) {\n          return ARES_TRUE; /* match */\n        }\n        break;\n      default:\n        break; /* LCOV_EXCL_LINE */\n    }\n  }\n  return ARES_FALSE; /* different */\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sockaddr_addr_eq",
            "parameters": {
              "sa": "struct sockaddr",
              "aa": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_conn_err_t ares_socket_write(ares_channel_t *channel, ares_socket_t fd,\n                                  const void *data, size_t len, size_t *written,\n                                  const struct sockaddr *sa,\n                                  ares_socklen_t         salen)\n{\n  int             flags = 0;\n  ares_ssize_t    rv;\n  ares_conn_err_t err = ARES_CONN_ERR_SUCCESS;\n\n#ifdef HAVE_MSG_NOSIGNAL\n  flags |= MSG_NOSIGNAL;\n#endif\n\n  rv = channel->sock_funcs.asendto(fd, data, len, flags, sa, salen,\n                                   channel->sock_func_cb_data);\n  if (rv <= 0) {\n    err = ares_socket_deref_error(SOCKERRNO);\n  } else {\n    *written = (size_t)rv;\n  }\n  return err;\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_write",
            "parameters": {
              "channel": "ares_channel_t",
              "fd": "ares_socket_t",
              "data": "void",
              "len": "size_t",
              "written": "size_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_conn_err_t ares_socket_recv(ares_channel_t *channel, ares_socket_t s,\n                                 ares_bool_t is_tcp, void *data,\n                                 size_t data_len, size_t *read_bytes)\n{\n  ares_ssize_t rv;\n\n  *read_bytes = 0;\n\n  rv = channel->sock_funcs.arecvfrom(s, data, data_len, 0, NULL, 0,\n                                     channel->sock_func_cb_data);\n\n  if (rv > 0) {\n    *read_bytes = (size_t)rv;\n    return ARES_CONN_ERR_SUCCESS;\n  }\n\n  if (rv == 0) {\n    /* UDP allows 0-byte packets and is connectionless, so this is success */\n    if (!is_tcp) {\n      return ARES_CONN_ERR_SUCCESS;\n    } else {\n      return ARES_CONN_ERR_CONNCLOSED;\n    }\n  }\n\n  /* If we're here, rv<0 */\n  return ares_socket_deref_error(SOCKERRNO);\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_recv",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "is_tcp": "ares_bool_t",
              "data": "void",
              "data_len": "size_t",
              "read_bytes": "size_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_conn_err_t ares_socket_recvfrom(ares_channel_t *channel, ares_socket_t s,\n                                     ares_bool_t is_tcp, void *data,\n                                     size_t data_len, int flags,\n                                     struct sockaddr *from,\n                                     ares_socklen_t  *from_len,\n                                     size_t          *read_bytes)\n{\n  ares_ssize_t rv;\n\n  rv = channel->sock_funcs.arecvfrom(s, data, data_len, flags, from, from_len,\n                                     channel->sock_func_cb_data);\n\n  if (rv > 0) {\n    *read_bytes = (size_t)rv;\n    return ARES_CONN_ERR_SUCCESS;\n  }\n\n  if (rv == 0) {\n    /* UDP allows 0-byte packets and is connectionless, so this is success */\n    if (!is_tcp) {\n      return ARES_CONN_ERR_SUCCESS;\n    } else {\n      return ARES_CONN_ERR_CONNCLOSED;\n    }\n  }\n\n  /* If we're here, rv<0 */\n  return ares_socket_deref_error(SOCKERRNO);\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_recvfrom",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "is_tcp": "ares_bool_t",
              "data": "void",
              "data_len": "size_t",
              "flags": "int",
              "from": "struct sockaddr",
              "from_len": "ares_socklen_t",
              "read_bytes": "size_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_conn_err_t ares_socket_enable_tfo(const ares_channel_t *channel,\n                                       ares_socket_t         fd)\n{\n  ares_bool_t opt = ARES_TRUE;\n\n  if (channel->sock_funcs.asetsockopt(fd, ARES_SOCKET_OPT_TCP_FASTOPEN,\n                                      (void *)&opt, sizeof(opt),\n                                      channel->sock_func_cb_data) != 0) {\n    return ARES_CONN_ERR_NOTIMP;\n  }\n\n  return ARES_CONN_ERR_SUCCESS;\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_enable_tfo",
            "parameters": {
              "channel": "ares_channel_t",
              "fd": "ares_socket_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_socket_configure(ares_channel_t *channel, int family,\n                                    ares_bool_t is_tcp, ares_socket_t fd)\n{\n  union {\n    struct sockaddr     sa;\n    struct sockaddr_in  sa4;\n    struct sockaddr_in6 sa6;\n  } local;\n\n  ares_socklen_t bindlen = 0;\n  int            rv;\n  unsigned int   bind_flags = 0;\n\n  /* Set the socket's send and receive buffer sizes. */\n  if (channel->socket_send_buffer_size > 0) {\n    rv = channel->sock_funcs.asetsockopt(\n      fd, ARES_SOCKET_OPT_SENDBUF_SIZE,\n      (void *)&channel->socket_send_buffer_size,\n      sizeof(channel->socket_send_buffer_size), channel->sock_func_cb_data);\n    if (rv != 0 && SOCKERRNO != ENOSYS) {\n      return ARES_ECONNREFUSED; /* LCOV_EXCL_LINE: UntestablePath */\n    }\n  }\n\n  if (channel->socket_receive_buffer_size > 0) {\n    rv = channel->sock_funcs.asetsockopt(\n      fd, ARES_SOCKET_OPT_RECVBUF_SIZE,\n      (void *)&channel->socket_receive_buffer_size,\n      sizeof(channel->socket_receive_buffer_size), channel->sock_func_cb_data);\n    if (rv != 0 && SOCKERRNO != ENOSYS) {\n      return ARES_ECONNREFUSED; /* LCOV_EXCL_LINE: UntestablePath */\n    }\n  }\n\n  /* Bind to network interface if configured */\n  if (ares_strlen(channel->local_dev_name)) {\n    /* Prior versions silently ignored failure, so we need to maintain that\n     * compatibility */\n    (void)channel->sock_funcs.asetsockopt(\n      fd, ARES_SOCKET_OPT_BIND_DEVICE, channel->local_dev_name,\n      (ares_socklen_t)ares_strlen(channel->local_dev_name),\n      channel->sock_func_cb_data);\n  }\n\n  /* Bind to ip address if configured */\n  if (family == AF_INET && channel->local_ip4) {\n    memset(&local.sa4, 0, sizeof(local.sa4));\n    local.sa4.sin_family      = AF_INET;\n    local.sa4.sin_addr.s_addr = htonl(channel->local_ip4);\n    bindlen                   = sizeof(local.sa4);\n  } else if (family == AF_INET6 &&\n             memcmp(channel->local_ip6, ares_in6addr_any._S6_un._S6_u8,\n                    sizeof(channel->local_ip6)) != 0) {\n    /* Only if not link-local and an ip other than \"::\" is specified */\n    memset(&local.sa6, 0, sizeof(local.sa6));\n    local.sa6.sin6_family = AF_INET6;\n    memcpy(&local.sa6.sin6_addr, channel->local_ip6,\n           sizeof(channel->local_ip6));\n    bindlen = sizeof(local.sa6);\n  }\n\n\n  if (bindlen && channel->sock_funcs.abind != NULL) {\n    bind_flags |= ARES_SOCKET_BIND_CLIENT;\n    if (is_tcp) {\n      bind_flags |= ARES_SOCKET_BIND_TCP;\n    }\n    if (channel->sock_funcs.abind(fd, bind_flags, &local.sa, bindlen,\n                                  channel->sock_func_cb_data) != 0) {\n      return ARES_ECONNREFUSED;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              225,
              0
            ],
            [
              299,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_configure",
            "parameters": {
              "channel": "ares_channel_t",
              "family": "int",
              "is_tcp": "ares_bool_t",
              "fd": "ares_socket_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_sockaddr_to_ares_addr(struct ares_addr      *ares_addr,\n                                       unsigned short        *port,\n                                       const struct sockaddr *sockaddr)\n{\n  if (sockaddr->sa_family == AF_INET) {\n    /* NOTE: memcpy sockaddr_in due to alignment issues found by UBSAN due to\n     *       dnsinfo packing on MacOS */\n    struct sockaddr_in sockaddr_in;\n    memcpy(&sockaddr_in, sockaddr, sizeof(sockaddr_in));\n\n    ares_addr->family = AF_INET;\n    memcpy(&ares_addr->addr.addr4, &(sockaddr_in.sin_addr),\n           sizeof(ares_addr->addr.addr4));\n\n    if (port) {\n      *port = ntohs(sockaddr_in.sin_port);\n    }\n    return ARES_TRUE;\n  }\n\n  if (sockaddr->sa_family == AF_INET6) {\n    /* NOTE: memcpy sockaddr_in6 due to alignment issues found by UBSAN due to\n     *       dnsinfo packing on MacOS */\n    struct sockaddr_in6 sockaddr_in6;\n    memcpy(&sockaddr_in6, sockaddr, sizeof(sockaddr_in6));\n\n    ares_addr->family = AF_INET6;\n    memcpy(&ares_addr->addr.addr6, &(sockaddr_in6.sin6_addr),\n           sizeof(ares_addr->addr.addr6));\n    if (port) {\n      *port = ntohs(sockaddr_in6.sin6_port);\n    }\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sockaddr_to_ares_addr",
            "parameters": {
              "ares_addr": "struct ares_addr",
              "port": "unsigned short",
              "sockaddr": "struct sockaddr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_conn_err_t ares_socket_open(ares_socket_t *sock, ares_channel_t *channel,\n                                 int af, int type, int protocol)\n{\n  ares_socket_t s;\n\n  *sock = ARES_SOCKET_BAD;\n\n  s =\n    channel->sock_funcs.asocket(af, type, protocol, channel->sock_func_cb_data);\n\n  if (s == ARES_SOCKET_BAD) {\n    return ares_socket_deref_error(SOCKERRNO);\n  }\n\n  *sock = s;\n\n  return ARES_CONN_ERR_SUCCESS;\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_open",
            "parameters": {
              "sock": "ares_socket_t",
              "channel": "ares_channel_t",
              "af": "int",
              "type": "int",
              "protocol": "int"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_conn_err_t ares_socket_connect(ares_channel_t *channel,\n                                    ares_socket_t sockfd, ares_bool_t is_tfo,\n                                    const struct sockaddr *addr,\n                                    ares_socklen_t         addrlen)\n{\n  ares_conn_err_t err   = ARES_CONN_ERR_SUCCESS;\n  unsigned int    flags = 0;\n\n  if (is_tfo) {\n    flags |= ARES_SOCKET_CONN_TCP_FASTOPEN;\n  }\n\n  do {\n    int rv;\n\n    rv = channel->sock_funcs.aconnect(sockfd, addr, addrlen, flags,\n                                      channel->sock_func_cb_data);\n\n    if (rv < 0) {\n      err = ares_socket_deref_error(SOCKERRNO);\n    } else {\n      err = ARES_CONN_ERR_SUCCESS;\n    }\n  } while (err == ARES_CONN_ERR_INTERRUPT);\n\n  return err;\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_connect",
            "parameters": {
              "channel": "ares_channel_t",
              "sockfd": "ares_socket_t",
              "is_tfo": "ares_bool_t",
              "addr": "struct sockaddr",
              "addrlen": "ares_socklen_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "void ares_socket_close(ares_channel_t *channel, ares_socket_t s)\n{\n  if (channel == NULL || s == ARES_SOCKET_BAD) {\n    return;\n  }\n\n  channel->sock_funcs.aclose(s, channel->sock_func_cb_data);\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_close",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_socket_callback(ares_channel_t           *channel,\n                              ares_sock_create_callback cb, void *data)\n{\n  if (channel == NULL) {\n    return;\n  }\n  channel->sock_create_cb      = cb;\n  channel->sock_create_cb_data = data;\n}",
          "fn_code_pos": [
            [
              395,
              0
            ],
            [
              403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "cb": "ares_sock_create_callback",
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_socket_configure_callback(ares_channel_t           *channel,\n                                        ares_sock_config_callback cb,\n                                        void                     *data)\n{\n  if (channel == NULL || channel->optmask & ARES_OPT_EVENT_THREAD) {\n    return;\n  }\n  channel->sock_config_cb      = cb;\n  channel->sock_config_cb_data = data;\n}",
          "fn_code_pos": [
            [
              405,
              0
            ],
            [
              414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_configure_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "cb": "ares_sock_config_callback",
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_pending_write_cb(ares_channel_t       *channel,\n                               ares_pending_write_cb callback, void *user_data)\n{\n  if (channel == NULL || channel->optmask & ARES_OPT_EVENT_THREAD) {\n    return;\n  }\n  channel->notify_pending_write_cb      = callback;\n  channel->notify_pending_write_cb_data = user_data;\n}",
          "fn_code_pos": [
            [
              416,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_pending_write_cb",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_pending_write_cb",
              "user_data": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sockaddr",
          {},
          "",
          [
            99,
            40
          ],
          [
            99,
            55
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            100,
            40
          ],
          [
            100,
            56
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            109,
            42
          ],
          [
            109,
            60
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            117,
            36
          ],
          [
            117,
            55
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            131,
            40
          ],
          [
            131,
            55
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            184,
            37
          ],
          [
            184,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            229,
            4
          ],
          [
            229,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            230,
            4
          ],
          [
            230,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            231,
            4
          ],
          [
            231,
            23
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            301,
            39
          ],
          [
            301,
            55
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            303,
            45
          ],
          [
            303,
            60
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            308,
            4
          ],
          [
            308,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            324,
            4
          ],
          [
            324,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            360,
            42
          ],
          [
            360,
            57
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <sys/uio.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <netinet/tcp.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <sys/filio.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_android.c": {
      "fn_def_list": [
        {
          "fn_code": "static jclass    jni_get_class(JNIEnv *env, const char *path)\n{\n  jclass cls = NULL;\n\n  if (env == NULL || path == NULL || *path == '\\0') {\n    return NULL;\n  }\n\n  cls = (*env)->FindClass(env, path);\n  if ((*env)->ExceptionOccurred(env)) {\n    (*env)->ExceptionClear(env);\n    return NULL;\n  }\n  return cls;\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jni_get_class",
            "parameters": {
              "env": "JNIEnv",
              "path": "char"
            },
            "return_type": "jclass"
          }
        },
        {
          "fn_code": "static jmethodID jni_get_method_id(JNIEnv *env, jclass cls,\n                                   const char *func_name, const char *signature)\n{\n  jmethodID mid = NULL;\n\n  if (env == NULL || cls == NULL || func_name == NULL || *func_name == '\\0' ||\n      signature == NULL || *signature == '\\0') {\n    return NULL;\n  }\n\n  mid = (*env)->GetMethodID(env, cls, func_name, signature);\n  if ((*env)->ExceptionOccurred(env)) {\n    (*env)->ExceptionClear(env);\n    return NULL;\n  }\n\n  return mid;\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jni_get_method_id",
            "parameters": {
              "env": "JNIEnv",
              "cls": "jclass",
              "func_name": "char",
              "signature": "char"
            },
            "return_type": "jmethodID"
          }
        },
        {
          "fn_code": "static int jvm_attach(JNIEnv **env)\n{\n  char             name[17] = { 0 };\n\n  JavaVMAttachArgs args;\n\n  args.version = JNI_VERSION_1_6;\n  if (prctl(PR_GET_NAME, name) == 0) {\n    args.name = name;\n  } else {\n    args.name = NULL;\n  }\n  args.group = NULL;\n\n  return (*android_jvm)->AttachCurrentThread(android_jvm, env, &args);\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jvm_attach",
            "parameters": {
              "env": "JNIEnv"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares_library_init_jvm(JavaVM *jvm)\n{\n  android_jvm = jvm;\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_jvm",
            "parameters": {
              "jvm": "JavaVM"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_library_init_android(jobject connectivity_manager)\n{\n  JNIEnv       *env          = NULL;\n  int           need_detatch = 0;\n  int           res;\n  ares_status_t ret     = ARES_ENOTINITIALIZED;\n  jclass        obj_cls = NULL;\n\n  if (android_jvm == NULL) {\n    goto cleanup;\n  }\n\n  res = (*android_jvm)->GetEnv(android_jvm, (void **)&env, JNI_VERSION_1_6);\n  if (res == JNI_EDETACHED) {\n    env          = NULL;\n    res          = jvm_attach(&env);\n    need_detatch = 1;\n  }\n  if (res != JNI_OK || env == NULL) {\n    goto cleanup;\n  }\n\n  android_connectivity_manager =\n    (*env)->NewGlobalRef(env, connectivity_manager);\n  if (android_connectivity_manager == NULL) {\n    goto cleanup;\n  }\n\n  /* Initialization has succeeded. Now attempt to cache the methods that will be\n   * called by ares_get_android_server_list. */\n  ret = ARES_SUCCESS;\n\n  /* ConnectivityManager in API 1. */\n  obj_cls = jni_get_class(env, \"android/net/ConnectivityManager\");\n  if (obj_cls == NULL) {\n    goto cleanup;\n  }\n\n  /* ConnectivityManager.getActiveNetwork in API 23. */\n  android_cm_active_net_mid = jni_get_method_id(\n    env, obj_cls, \"getActiveNetwork\", \"()Landroid/net/Network;\");\n  if (android_cm_active_net_mid == NULL) {\n    goto cleanup;\n  }\n\n  /* ConnectivityManager.getLinkProperties in API 21. */\n  android_cm_link_props_mid =\n    jni_get_method_id(env, obj_cls, \"getLinkProperties\",\n                      \"(Landroid/net/Network;)Landroid/net/LinkProperties;\");\n  if (android_cm_link_props_mid == NULL) {\n    goto cleanup;\n  }\n\n  /* LinkProperties in API 21. */\n  (*env)->DeleteLocalRef(env, obj_cls);\n  obj_cls = jni_get_class(env, \"android/net/LinkProperties\");\n  if (obj_cls == NULL) {\n    goto cleanup;\n  }\n\n  /* getDnsServers in API 21. */\n  android_lp_dns_servers_mid =\n    jni_get_method_id(env, obj_cls, \"getDnsServers\", \"()Ljava/util/List;\");\n  if (android_lp_dns_servers_mid == NULL) {\n    goto cleanup;\n  }\n\n  /* getDomains in API 21. */\n  android_lp_domains_mid =\n    jni_get_method_id(env, obj_cls, \"getDomains\", \"()Ljava/lang/String;\");\n  if (android_lp_domains_mid == NULL) {\n    goto cleanup;\n  }\n\n  (*env)->DeleteLocalRef(env, obj_cls);\n  obj_cls = jni_get_class(env, \"java/util/List\");\n  if (obj_cls == NULL) {\n    goto cleanup;\n  }\n\n  android_list_size_mid = jni_get_method_id(env, obj_cls, \"size\", \"()I\");\n  if (android_list_size_mid == NULL) {\n    goto cleanup;\n  }\n\n  android_list_get_mid =\n    jni_get_method_id(env, obj_cls, \"get\", \"(I)Ljava/lang/Object;\");\n  if (android_list_get_mid == NULL) {\n    goto cleanup;\n  }\n\n  (*env)->DeleteLocalRef(env, obj_cls);\n  obj_cls = jni_get_class(env, \"java/net/InetAddress\");\n  if (obj_cls == NULL) {\n    goto cleanup;\n  }\n\n  android_ia_host_addr_mid =\n    jni_get_method_id(env, obj_cls, \"getHostAddress\", \"()Ljava/lang/String;\");\n  if (android_ia_host_addr_mid == NULL) {\n    goto cleanup;\n  }\n\n  (*env)->DeleteLocalRef(env, obj_cls);\n  goto done;\n\ncleanup:\n  if (obj_cls != NULL) {\n    (*env)->DeleteLocalRef(env, obj_cls);\n  }\n\n  android_cm_active_net_mid  = NULL;\n  android_cm_link_props_mid  = NULL;\n  android_lp_dns_servers_mid = NULL;\n  android_lp_domains_mid     = NULL;\n  android_list_size_mid      = NULL;\n  android_list_get_mid       = NULL;\n  android_ia_host_addr_mid   = NULL;\n\ndone:\n  if (need_detatch) {\n    (*android_jvm)->DetachCurrentThread(android_jvm);\n  }\n\n  return (int)ret;\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_android",
            "parameters": {
              "connectivity_manager": "jobject"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_library_android_initialized(void)\n{\n  if (android_jvm == NULL || android_connectivity_manager == NULL) {\n    return ARES_ENOTINITIALIZED;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              233,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_android_initialized",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares_library_cleanup_android(void)\n{\n  JNIEnv *env          = NULL;\n  int     need_detatch = 0;\n  int     res;\n\n  if (android_jvm == NULL || android_connectivity_manager == NULL) {\n    return;\n  }\n\n  res = (*android_jvm)->GetEnv(android_jvm, (void **)&env, JNI_VERSION_1_6);\n  if (res == JNI_EDETACHED) {\n    env          = NULL;\n    res          = jvm_attach(&env);\n    need_detatch = 1;\n  }\n  if (res != JNI_OK || env == NULL) {\n    return;\n  }\n\n  android_cm_active_net_mid  = NULL;\n  android_cm_link_props_mid  = NULL;\n  android_lp_dns_servers_mid = NULL;\n  android_lp_domains_mid     = NULL;\n  android_list_size_mid      = NULL;\n  android_list_get_mid       = NULL;\n  android_ia_host_addr_mid   = NULL;\n\n  (*env)->DeleteGlobalRef(env, android_connectivity_manager);\n  android_connectivity_manager = NULL;\n\n  if (need_detatch) {\n    (*android_jvm)->DetachCurrentThread(android_jvm);\n  }\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_cleanup_android",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "char **ares_get_android_server_list(size_t max_servers, size_t *num_servers)\n{\n  JNIEnv     *env             = NULL;\n  jobject     active_network  = NULL;\n  jobject     link_properties = NULL;\n  jobject     server_list     = NULL;\n  jobject     server          = NULL;\n  jstring     str             = NULL;\n  jint        nserv;\n  const char *ch_server_address;\n  int         res;\n  size_t      i;\n  char      **dns_list     = NULL;\n  int         need_detatch = 0;\n\n  if (android_jvm == NULL || android_connectivity_manager == NULL ||\n      max_servers == 0 || num_servers == NULL) {\n    return NULL;\n  }\n\n  if (android_cm_active_net_mid == NULL || android_cm_link_props_mid == NULL ||\n      android_lp_dns_servers_mid == NULL || android_list_size_mid == NULL ||\n      android_list_get_mid == NULL || android_ia_host_addr_mid == NULL) {\n    return NULL;\n  }\n\n  res = (*android_jvm)->GetEnv(android_jvm, (void **)&env, JNI_VERSION_1_6);\n  if (res == JNI_EDETACHED) {\n    env          = NULL;\n    res          = jvm_attach(&env);\n    need_detatch = 1;\n  }\n  if (res != JNI_OK || env == NULL) {\n    goto done;\n  }\n\n  /* JNI below is equivalent to this Java code.\n     import android.content.Context;\n     import android.net.ConnectivityManager;\n     import android.net.LinkProperties;\n     import android.net.Network;\n     import java.net.InetAddress;\n     import java.util.List;\n\n     ConnectivityManager cm = (ConnectivityManager)this.getApplicationContext()\n       .getSystemService(Context.CONNECTIVITY_SERVICE);\n     Network an = cm.getActiveNetwork();\n     LinkProperties lp = cm.getLinkProperties(an);\n     List<InetAddress> dns = lp.getDnsServers();\n     for (InetAddress ia: dns) {\n       String ha = ia.getHostAddress();\n     }\n\n     Note: The JNI ConnectivityManager object and all method IDs were previously\n           initialized in ares_library_init_android.\n   */\n\n  active_network = (*env)->CallObjectMethod(env, android_connectivity_manager,\n                                            android_cm_active_net_mid);\n  if (active_network == NULL) {\n    goto done;\n  }\n\n  link_properties =\n    (*env)->CallObjectMethod(env, android_connectivity_manager,\n                             android_cm_link_props_mid, active_network);\n  if (link_properties == NULL) {\n    goto done;\n  }\n\n  server_list =\n    (*env)->CallObjectMethod(env, link_properties, android_lp_dns_servers_mid);\n  if (server_list == NULL) {\n    goto done;\n  }\n\n  nserv = (*env)->CallIntMethod(env, server_list, android_list_size_mid);\n  if (nserv > (jint)max_servers) {\n    nserv = (jint)max_servers;\n  }\n  if (nserv <= 0) {\n    goto done;\n  }\n  *num_servers = (size_t)nserv;\n\n  dns_list = ares_malloc(sizeof(*dns_list) * (*num_servers));\n  for (i = 0; i < *num_servers; i++) {\n    size_t len = 64;\n    server =\n      (*env)->CallObjectMethod(env, server_list, android_list_get_mid, (jint)i);\n    dns_list[i]    = ares_malloc(len);\n    dns_list[i][0] = 0;\n    if (server == NULL) {\n      continue;\n    }\n    str = (*env)->CallObjectMethod(env, server, android_ia_host_addr_mid);\n    ch_server_address = (*env)->GetStringUTFChars(env, str, 0);\n    ares_strcpy(dns_list[i], ch_server_address, len);\n    (*env)->ReleaseStringUTFChars(env, str, ch_server_address);\n    (*env)->DeleteLocalRef(env, str);\n    (*env)->DeleteLocalRef(env, server);\n  }\n\ndone:\n  if ((*env)->ExceptionOccurred(env)) {\n    (*env)->ExceptionClear(env);\n  }\n\n  if (server_list != NULL) {\n    (*env)->DeleteLocalRef(env, server_list);\n  }\n  if (link_properties != NULL) {\n    (*env)->DeleteLocalRef(env, link_properties);\n  }\n  if (active_network != NULL) {\n    (*env)->DeleteLocalRef(env, active_network);\n  }\n\n  if (need_detatch) {\n    (*android_jvm)->DetachCurrentThread(android_jvm);\n  }\n  return dns_list;\n}",
          "fn_code_pos": [
            [
              277,
              0
            ],
            [
              399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "char *ares_get_android_search_domains_list(void)\n{\n  JNIEnv     *env             = NULL;\n  jobject     active_network  = NULL;\n  jobject     link_properties = NULL;\n  jstring     domains         = NULL;\n  const char *domain;\n  int         res;\n  char       *domain_list  = NULL;\n  int         need_detatch = 0;\n\n  if (android_jvm == NULL || android_connectivity_manager == NULL) {\n    return NULL;\n  }\n\n  if (android_cm_active_net_mid == NULL || android_cm_link_props_mid == NULL ||\n      android_lp_domains_mid == NULL) {\n    return NULL;\n  }\n\n  res = (*android_jvm)->GetEnv(android_jvm, (void **)&env, JNI_VERSION_1_6);\n  if (res == JNI_EDETACHED) {\n    env          = NULL;\n    res          = jvm_attach(&env);\n    need_detatch = 1;\n  }\n  if (res != JNI_OK || env == NULL) {\n    goto done;\n  }\n\n  /* JNI below is equivalent to this Java code.\n     import android.content.Context;\n     import android.net.ConnectivityManager;\n     import android.net.LinkProperties;\n\n     ConnectivityManager cm = (ConnectivityManager)this.getApplicationContext()\n       .getSystemService(Context.CONNECTIVITY_SERVICE);\n     Network an = cm.getActiveNetwork();\n     LinkProperties lp = cm.getLinkProperties(an);\n   String domains = lp.getDomains();\n     for (String domain: domains.split(\",\")) {\n       String d = domain;\n     }\n\n     Note: The JNI ConnectivityManager object and all method IDs were previously\n           initialized in ares_library_init_android.\n   */\n\n  active_network = (*env)->CallObjectMethod(env, android_connectivity_manager,\n                                            android_cm_active_net_mid);\n  if (active_network == NULL) {\n    goto done;\n  }\n\n  link_properties =\n    (*env)->CallObjectMethod(env, android_connectivity_manager,\n                             android_cm_link_props_mid, active_network);\n  if (link_properties == NULL) {\n    goto done;\n  }\n\n  /* Get the domains. It is a common separated list of domains to search. */\n  domains =\n    (*env)->CallObjectMethod(env, link_properties, android_lp_domains_mid);\n  if (domains == NULL) {\n    goto done;\n  }\n\n  /* Split on , */\n  domain      = (*env)->GetStringUTFChars(env, domains, 0);\n  domain_list = ares_strdup(domain);\n  (*env)->ReleaseStringUTFChars(env, domains, domain);\n  (*env)->DeleteLocalRef(env, domains);\n\ndone:\n  if ((*env)->ExceptionOccurred(env)) {\n    (*env)->ExceptionClear(env);\n  }\n\n  if (link_properties != NULL) {\n    (*env)->DeleteLocalRef(env, link_properties);\n  }\n  if (active_network != NULL) {\n    (*env)->DeleteLocalRef(env, active_network);\n  }\n\n  if (need_detatch) {\n    (*android_jvm)->DetachCurrentThread(android_jvm);\n  }\n  return domain_list;\n}",
          "fn_code_pos": [
            [
              401,
              0
            ],
            [
              491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_search_domains_list",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_get_android_server_list(size_t max_servers, size_t *num_servers)",
          "fn_dec_pos": [
            [
              277,
              7
            ],
            [
              277,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_server_list",
            "parameters": {
              "max_servers": "size_t",
              "num_servers": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_get_android_search_domains_list(void)",
          "fn_dec_pos": [
            [
              401,
              6
            ],
            [
              401,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_search_domains_list",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#  include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <jni.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/prctl.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/inet_ntop.c": {
      "fn_def_list": [
        {
          "fn_code": "const char        *ares_inet_ntop(int af, const void *src, char *dst,\n                                  ares_socklen_t size)\n{\n  switch (af) {\n    case AF_INET:\n      return inet_ntop4(src, dst, (size_t)size);\n    case AF_INET6:\n      return inet_ntop6(src, dst, (size_t)size);\n    default:\n      break;\n  }\n  SET_SOCKERRNO(EAFNOSUPPORT);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_ntop",
            "parameters": {
              "af": "int",
              "src": "void",
              "dst": "char",
              "size": "ares_socklen_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static const char *inet_ntop4(const unsigned char *src, char *dst, size_t size)\n{\n  static const char fmt[] = \"%u.%u.%u.%u\";\n  char              tmp[sizeof(\"255.255.255.255\")];\n\n  if (size < sizeof(tmp)) {\n    SET_SOCKERRNO(ENOSPC);\n    return NULL;\n  }\n\n  if ((size_t)snprintf(tmp, sizeof(tmp), fmt, src[0], src[1], src[2], src[3]) >=\n      size) {\n    SET_SOCKERRNO(ENOSPC);\n    return NULL;\n  }\n  ares_strcpy(dst, tmp, size);\n  return dst;\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop4",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static const char *inet_ntop6(const unsigned char *src, char *dst, size_t size)\n{\n  /*\n   * Note that int32_t and int16_t need only be \"at least\" large enough\n   * to contain a value of the specified size.  On some systems, like\n   * Crays, there is no such thing as an integer variable with 16 bits.\n   * Keep this in mind if you think this function should have been coded\n   * to use pointer overlays.  All the world's not a VAX.\n   */\n  char  tmp[sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")];\n  char *tp;\n\n  struct {\n    ares_ssize_t base;\n    size_t       len;\n  } best, cur;\n\n  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];\n  size_t       i;\n\n  /*\n   * Preprocess:\n   *  Copy the input (bytewise) array into a wordwise array.\n   *  Find the longest run of 0x00's in src[] for :: shorthanding.\n   */\n  memset(words, '\\0', sizeof(words));\n  for (i = 0; i < NS_IN6ADDRSZ; i++) {\n    words[i / 2] |= (unsigned int)(src[i] << ((1 - (i % 2)) << 3));\n  }\n  best.base = -1;\n  best.len  = 0;\n  cur.base  = -1;\n  cur.len   = 0;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n    if (words[i] == 0) {\n      if (cur.base == -1) {\n        cur.base = (ares_ssize_t)i;\n        cur.len  = 1;\n      } else {\n        cur.len++;\n      }\n    } else {\n      if (cur.base != -1) {\n        if (best.base == -1 || cur.len > best.len) {\n          best = cur;\n        }\n        cur.base = -1;\n      }\n    }\n  }\n  if (cur.base != -1) {\n    if (best.base == -1 || cur.len > best.len) {\n      best = cur;\n    }\n  }\n  if (best.base != -1 && best.len < 2) {\n    best.base = -1;\n  }\n\n  /*\n   * Format the result.\n   */\n  tp = tmp;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n    /* Are we inside the best run of 0x00's? */\n    if (best.base != -1 && i >= (size_t)best.base &&\n        i < ((size_t)best.base + best.len)) {\n      if (i == (size_t)best.base) {\n        *tp++ = ':';\n      }\n      continue;\n    }\n    /* Are we following an initial run of 0x00s or any real hex? */\n    if (i != 0) {\n      *tp++ = ':';\n    }\n    /* Is this address an encapsulated IPv4? */\n    if (i == 6 && best.base == 0 &&\n        (best.len == 6 || (best.len == 7 && words[7] != 0x0001) ||\n         (best.len == 5 && words[5] == 0xffff))) {\n      if (!inet_ntop4(src + 12, tp, sizeof(tmp) - (size_t)(tp - tmp))) {\n        return (NULL);\n      }\n      tp += ares_strlen(tp);\n      break;\n    }\n    tp += snprintf(tp, sizeof(tmp) - (size_t)(tp - tmp), \"%x\", words[i]);\n  }\n  /* Was it a trailing run of 0x00's? */\n  if (best.base != -1 &&\n      ((size_t)best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ)) {\n    *tp++ = ':';\n  }\n  *tp++ = '\\0';\n\n  /*\n   * Check for overflow, copy, and we're done.\n   */\n  if ((size_t)(tp - tmp) > size) {\n    SET_SOCKERRNO(ENOSPC);\n    return NULL;\n  }\n  ares_strcpy(dst, tmp, size);\n  return dst;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              218,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop6",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "inet_ntop4(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              52,
              19
            ],
            [
              52,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop4",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inet_ntop6(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              53,
              19
            ],
            [
              53,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop6",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_inet_ntop(int af, const void *src, char *dst,\n                                  ares_socklen_t size)",
          "fn_dec_pos": [
            [
              63,
              19
            ],
            [
              64,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_ntop",
            "parameters": {
              "af": "int",
              "src": "void",
              "dst": "char",
              "size": "ares_socklen_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inet_ntop4(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              89,
              19
            ],
            [
              89,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop4",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inet_ntop6(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              114,
              19
            ],
            [
              114,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop6",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n    ares_ssize_t base;\n    size_t       len;\n  }",
          {
            "base": "ares_ssize_t",
            "len": "size_t"
          },
          "",
          [
            126,
            2
          ],
          [
            129,
            3
          ]
        ],
        [
          "struct {\n    ares_ssize_t base;\n    size_t       len;\n  }",
          {
            "base": "ares_ssize_t",
            "len": "size_t"
          },
          "",
          [
            126,
            2
          ],
          [
            129,
            3
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/windows_port.c": {
      "fn_def_list": [
        {
          "fn_code": "BOOL WINAPI DllMain(HINSTANCE hnd, DWORD reason, LPVOID reserved)\n{\n  (void)hnd;\n  (void)reason;\n  (void)reserved;\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              19,
              0
            ],
            [
              25,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DllMain",
            "parameters": {
              "hnd": "HINSTANCE",
              "reason": "DWORD",
              "reserved": "LPVOID"
            },
            "return_type": "BOOL"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_sysconfig_files.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned char ip_natural_mask(const struct ares_addr *addr)\n{\n  const unsigned char *ptr = NULL;\n  /* This is an odd one.  If a raw ipv4 address is specified, then we take\n   * what is called a natural mask, which means we look at the first octet\n   * of the ip address and for values 0-127 we assume it is a class A (/8),\n   * for values 128-191 we assume it is a class B (/16), and for 192-223\n   * we assume it is a class C (/24).  223-239 is Class D which and 240-255 is\n   * Class E, however, there is no pre-defined mask for this, so we'll use\n   * /24 as well as that's what the old code did.\n   *\n   * For IPv6, we'll use /64.\n   */\n\n  if (addr->family == AF_INET6) {\n    return 64;\n  }\n\n  ptr = (const unsigned char *)&addr->addr.addr4;\n  if (*ptr < 128) {\n    return 8;\n  }\n\n  if (*ptr < 192) {\n    return 16;\n  }\n\n  return 24;\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ip_natural_mask",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_bool_t sortlist_append(struct apattern **sortlist, size_t *nsort,\n                                   const struct apattern *pat)\n{\n  struct apattern *newsort;\n\n  newsort = ares_realloc(*sortlist, (*nsort + 1) * sizeof(*newsort));\n  if (newsort == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  *sortlist = newsort;\n\n  memcpy(&(*sortlist)[*nsort], pat, sizeof(**sortlist));\n  (*nsort)++;\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sortlist_append",
            "parameters": {
              "sortlist": "struct apattern",
              "nsort": "size_t",
              "pat": "struct apattern"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_sort(ares_buf_t *buf, struct apattern *pat)\n{\n  ares_status_t       status;\n  const unsigned char ip_charset[]             = \"ABCDEFabcdef0123456789.:\";\n  char                ipaddr[INET6_ADDRSTRLEN] = \"\";\n  size_t              addrlen;\n\n  memset(pat, 0, sizeof(*pat));\n\n  /* Consume any leading whitespace */\n  ares_buf_consume_whitespace(buf, ARES_TRUE);\n\n  /* If no length, just ignore, return ENOTFOUND as an indicator */\n  if (ares_buf_len(buf) == 0) {\n    return ARES_ENOTFOUND;\n  }\n\n  ares_buf_tag(buf);\n\n  /* Consume ip address */\n  if (ares_buf_consume_charset(buf, ip_charset, sizeof(ip_charset) - 1) == 0) {\n    return ARES_EBADSTR;\n  }\n\n  /* Fetch ip address */\n  status = ares_buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Parse it to make sure its valid */\n  pat->addr.family = AF_UNSPEC;\n  if (ares_dns_pton(ipaddr, &pat->addr, &addrlen) == NULL) {\n    return ARES_EBADSTR;\n  }\n\n  /* See if there is a subnet mask */\n  if (ares_buf_begins_with(buf, (const unsigned char *)\"/\", 1)) {\n    char                maskstr[16];\n    const unsigned char ipv4_charset[] = \"0123456789.\";\n\n\n    /* Consume / */\n    ares_buf_consume(buf, 1);\n\n    ares_buf_tag(buf);\n\n    /* Consume mask */\n    if (ares_buf_consume_charset(buf, ipv4_charset, sizeof(ipv4_charset) - 1) ==\n        0) {\n      return ARES_EBADSTR;\n    }\n\n    /* Fetch mask */\n    status = ares_buf_tag_fetch_string(buf, maskstr, sizeof(maskstr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    if (ares_str_isnum(maskstr)) {\n      /* Numeric mask */\n      int mask = atoi(maskstr);\n      if (mask < 0 || mask > 128) {\n        return ARES_EBADSTR;\n      }\n      if (pat->addr.family == AF_INET && mask > 32) {\n        return ARES_EBADSTR;\n      }\n      pat->mask = (unsigned char)mask;\n    } else {\n      /* Ipv4 subnet style mask */\n      struct ares_addr     maskaddr;\n      const unsigned char *ptr;\n\n      memset(&maskaddr, 0, sizeof(maskaddr));\n      maskaddr.family = AF_INET;\n      if (ares_dns_pton(maskstr, &maskaddr, &addrlen) == NULL) {\n        return ARES_EBADSTR;\n      }\n      ptr       = (const unsigned char *)&maskaddr.addr.addr4;\n      pat->mask = (unsigned char)(ares_count_bits_u8(ptr[0]) +\n                                  ares_count_bits_u8(ptr[1]) +\n                                  ares_count_bits_u8(ptr[2]) +\n                                  ares_count_bits_u8(ptr[3]));\n    }\n  } else {\n    pat->mask = ip_natural_mask(&pat->addr);\n  }\n\n  /* Consume any trailing whitespace */\n  ares_buf_consume_whitespace(buf, ARES_TRUE);\n\n  /* If we have any trailing bytes other than whitespace, its a parse failure */\n  if (ares_buf_len(buf) != 0) {\n    return ARES_EBADSTR;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_sort",
            "parameters": {
              "buf": "ares_buf_t",
              "pat": "struct apattern"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_parse_sortlist(struct apattern **sortlist, size_t *nsort,\n                                  const char *str)\n{\n  ares_buf_t   *buf    = NULL;\n  ares_status_t status = ARES_SUCCESS;\n  ares_array_t *arr    = NULL;\n  size_t        num    = 0;\n  size_t        i;\n\n  if (sortlist == NULL || nsort == NULL || str == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (*sortlist != NULL) {\n    ares_free(*sortlist);\n  }\n\n  *sortlist = NULL;\n  *nsort    = 0;\n\n  buf = ares_buf_create_const((const unsigned char *)str, ares_strlen(str));\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Split on space or semicolon. It's not clear why the split on\n     semicolon is supported, but the user of this function is\n     ares_set_sortlist(), whose documentation does not mention\n     semicolons, only spaces as valid separation characters. It is\n     therefore unlikely that anyone uses semicolons.\n\n     The old parser behaved this way and this behavior of splitting in\n     semicolons was preserved in the parser rewrite on\n     e72ae094855a0aed44afadfb4de462065e144185 (see also #653).*/\n  status = ares_buf_split(buf, (const unsigned char *)\" ;\", 2,\n                          ARES_BUF_SPLIT_NONE, 0, &arr);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  num = ares_array_len(arr);\n  for (i = 0; i < num; i++) {\n    ares_buf_t    **bufptr = ares_array_at(arr, i);\n    ares_buf_t     *entry  = *bufptr;\n\n    struct apattern pat;\n\n    status = parse_sort(entry, &pat);\n    if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n      goto done;\n    }\n\n    if (status != ARES_SUCCESS) {\n      continue;\n    }\n\n    if (!sortlist_append(sortlist, nsort, &pat)) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares_buf_destroy(buf);\n  ares_array_destroy(arr);\n\n  if (status != ARES_SUCCESS) {\n    ares_free(*sortlist);\n    *sortlist = NULL;\n    *nsort    = 0;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_sortlist",
            "parameters": {
              "sortlist": "struct apattern",
              "nsort": "size_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t config_search(ares_sysconfig_t *sysconfig, const char *str,\n                                   size_t max_domains)\n{\n  if (sysconfig->domains && sysconfig->ndomains > 0) {\n    /* if we already have some domains present, free them first */\n    ares_strsplit_free(sysconfig->domains, sysconfig->ndomains);\n    sysconfig->domains  = NULL;\n    sysconfig->ndomains = 0;\n  }\n\n  sysconfig->domains = ares_strsplit(str, \", \", &sysconfig->ndomains);\n  if (sysconfig->domains == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  /* Truncate if necessary */\n  if (max_domains && sysconfig->ndomains > max_domains) {\n    size_t i;\n    for (i = max_domains; i < sysconfig->ndomains; i++) {\n      ares_free(sysconfig->domains[i]);\n      sysconfig->domains[i] = NULL;\n    }\n    sysconfig->ndomains = max_domains;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "config_search",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "str": "char",
              "max_domains": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t buf_fetch_string(ares_buf_t *buf, char *str,\n                                      size_t str_len)\n{\n  ares_status_t status;\n  ares_buf_tag(buf);\n  ares_buf_consume(buf, ares_buf_len(buf));\n\n  status = ares_buf_tag_fetch_string(buf, str, str_len);\n  return status;\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "buf_fetch_string",
            "parameters": {
              "buf": "ares_buf_t",
              "str": "char",
              "str_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t config_lookup(ares_sysconfig_t *sysconfig, ares_buf_t *buf,\n                                   const char *separators)\n{\n  ares_status_t status;\n  char          lookupstr[32];\n  size_t        lookupstr_cnt = 0;\n  char        **lookups       = NULL;\n  size_t        num           = 0;\n  size_t        i;\n  size_t        separators_len = ares_strlen(separators);\n\n  status =\n    ares_buf_split_str(buf, (const unsigned char *)separators, separators_len,\n                       ARES_BUF_SPLIT_TRIM, 0, &lookups, &num);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (i = 0; i < num; i++) {\n    const char *value = lookups[i];\n    char        ch;\n\n    if (ares_strcaseeq(value, \"dns\") || ares_strcaseeq(value, \"bind\") ||\n        ares_strcaseeq(value, \"resolv\") || ares_strcaseeq(value, \"resolve\")) {\n      ch = 'b';\n    } else if (ares_strcaseeq(value, \"files\") ||\n               ares_strcaseeq(value, \"file\") ||\n               ares_strcaseeq(value, \"local\")) {\n      ch = 'f';\n    } else {\n      continue;\n    }\n\n    /* Look for a duplicate and ignore */\n    if (memchr(lookupstr, ch, lookupstr_cnt) == NULL) {\n      lookupstr[lookupstr_cnt++] = ch;\n    }\n  }\n\n  if (lookupstr_cnt) {\n    lookupstr[lookupstr_cnt] = 0;\n    ares_free(sysconfig->lookups);\n    sysconfig->lookups = ares_strdup(lookupstr);\n    if (sysconfig->lookups == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  if (status != ARES_ENOMEM) {\n    status = ARES_SUCCESS;\n  }\n  ares_free_array(lookups, num, ares_free);\n  return status;\n}",
          "fn_code_pos": [
            [
              328,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "config_lookup",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "buf": "ares_buf_t",
              "separators": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t process_option(ares_sysconfig_t *sysconfig,\n                                    ares_buf_t       *option)\n{\n  char        **kv  = NULL;\n  size_t        num = 0;\n  const char   *key;\n  const char   *val;\n  unsigned int  valint = 0;\n  ares_status_t status;\n\n  /* Split on : */\n  status = ares_buf_split_str(option, (const unsigned char *)\":\", 1,\n                              ARES_BUF_SPLIT_TRIM, 2, &kv, &num);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (num < 1) {\n    status = ARES_EBADSTR;\n    goto done;\n  }\n\n  key = kv[0];\n  if (num == 2) {\n    val    = kv[1];\n    valint = (unsigned int)strtoul(val, NULL, 10);\n  }\n\n  if (ares_streq(key, \"ndots\")) {\n    sysconfig->ndots = valint;\n  } else if (ares_streq(key, \"retrans\") || ares_streq(key, \"timeout\")) {\n    if (valint == 0) {\n      return ARES_EFORMERR;\n    }\n    sysconfig->timeout_ms = valint * 1000;\n  } else if (ares_streq(key, \"retry\") || ares_streq(key, \"attempts\")) {\n    if (valint == 0) {\n      return ARES_EFORMERR;\n    }\n    sysconfig->tries = valint;\n  } else if (ares_streq(key, \"rotate\")) {\n    sysconfig->rotate = ARES_TRUE;\n  } else if (ares_streq(key, \"use-vc\") || ares_streq(key, \"usevc\")) {\n    sysconfig->usevc = ARES_TRUE;\n  }\n\ndone:\n  ares_free_array(kv, num, ares_free);\n  return status;\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              436,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_option",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "option": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_sysconfig_set_options(ares_sysconfig_t *sysconfig,\n                                         const char       *str)\n{\n  ares_buf_t   *buf     = NULL;\n  ares_array_t *options = NULL;\n  size_t        num;\n  size_t        i;\n  ares_status_t status;\n\n  buf = ares_buf_create_const((const unsigned char *)str, ares_strlen(str));\n  if (buf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_buf_split(buf, (const unsigned char *)\" \\t\", 2,\n                          ARES_BUF_SPLIT_TRIM, 0, &options);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  num = ares_array_len(options);\n  for (i = 0; i < num; i++) {\n    ares_buf_t **bufptr = ares_array_at(options, i);\n    ares_buf_t  *valbuf = *bufptr;\n\n    status = process_option(sysconfig, valbuf);\n    /* Out of memory is the only fatal condition */\n    if (status == ARES_ENOMEM) {\n      goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares_array_destroy(options);\n  ares_buf_destroy(buf);\n  return status;\n}",
          "fn_code_pos": [
            [
              438,
              0
            ],
            [
              476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_set_options",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_init_by_environment(ares_sysconfig_t *sysconfig)\n{\n  const char   *localdomain;\n  const char   *res_options;\n  ares_status_t status;\n\n  localdomain = getenv(\"LOCALDOMAIN\");\n  if (localdomain) {\n    char *temp = ares_strdup(localdomain);\n    if (temp == NULL) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    status = config_search(sysconfig, temp, 1);\n    ares_free(temp);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  res_options = getenv(\"RES_OPTIONS\");\n  if (res_options) {\n    status = ares_sysconfig_set_options(sysconfig, res_options);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              478,
              0
            ],
            [
              506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_by_environment",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_sysconfig_parse_resolv_line(const ares_channel_t *channel,\n                                               ares_sysconfig_t     *sysconfig,\n                                               ares_buf_t           *line)\n{\n  char          option[32];\n  char          value[512];\n  ares_status_t status = ARES_SUCCESS;\n\n  /* Ignore lines beginning with a comment */\n  if (ares_buf_begins_with(line, (const unsigned char *)\"#\", 1) ||\n      ares_buf_begins_with(line, (const unsigned char *)\";\", 1)) {\n    return ARES_SUCCESS;\n  }\n\n  ares_buf_tag(line);\n\n  /* Shouldn't be possible, but if it happens, ignore the line. */\n  if (ares_buf_consume_nonwhitespace(line) == 0) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares_buf_tag_fetch_string(line, option, sizeof(option));\n  if (status != ARES_SUCCESS) {\n    return ARES_SUCCESS;\n  }\n\n  ares_buf_consume_whitespace(line, ARES_TRUE);\n\n  status = buf_fetch_string(line, value, sizeof(value));\n  if (status != ARES_SUCCESS) {\n    return ARES_SUCCESS;\n  }\n\n  ares_str_trim(value);\n  if (*value == 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* At this point we have a string option and a string value, both trimmed\n   * of leading and trailing whitespace.  Lets try to evaluate them */\n  if (ares_streq(option, \"domain\")) {\n    /* Domain is legacy, don't overwrite an existing config set by search */\n    if (sysconfig->domains == NULL) {\n      status = config_search(sysconfig, value, 1);\n    }\n  } else if (ares_streq(option, \"lookup\") ||\n             ares_streq(option, \"hostresorder\")) {\n    ares_buf_tag_rollback(line);\n    status = config_lookup(sysconfig, line, \" \\t\");\n  } else if (ares_streq(option, \"search\")) {\n    status = config_search(sysconfig, value, 0);\n  } else if (ares_streq(option, \"nameserver\")) {\n    status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, value,\n                                         ARES_TRUE);\n  } else if (ares_streq(option, \"sortlist\")) {\n    /* Ignore all failures except ENOMEM.  If the sysadmin set a bad\n     * sortlist, just ignore the sortlist, don't cause an inoperable\n     * channel */\n    status =\n      ares_parse_sortlist(&sysconfig->sortlist, &sysconfig->nsortlist, value);\n    if (status != ARES_ENOMEM) {\n      status = ARES_SUCCESS;\n    }\n  } else if (ares_streq(option, \"options\")) {\n    status = ares_sysconfig_set_options(sysconfig, value);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              559,
              0
            ],
            [
              627,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_parse_resolv_line",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "line": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_nsswitch_line(const ares_channel_t *channel,\n                                         ares_sysconfig_t     *sysconfig,\n                                         ares_buf_t           *line)\n{\n  char          option[32];\n  ares_status_t status = ARES_SUCCESS;\n  ares_array_t *sects  = NULL;\n  ares_buf_t  **bufptr;\n  ares_buf_t   *buf;\n\n  (void)channel;\n\n  /* Ignore lines beginning with a comment */\n  if (ares_buf_begins_with(line, (const unsigned char *)\"#\", 1)) {\n    return ARES_SUCCESS;\n  }\n\n  /* database : values (space delimited) */\n  status = ares_buf_split(line, (const unsigned char *)\":\", 1,\n                          ARES_BUF_SPLIT_TRIM, 2, &sects);\n\n  if (status != ARES_SUCCESS || ares_array_len(sects) != 2) {\n    goto done;\n  }\n\n  bufptr = ares_array_at(sects, 0);\n  buf    = *bufptr;\n\n  status = buf_fetch_string(buf, option, sizeof(option));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Only support \"hosts:\" */\n  if (!ares_streq(option, \"hosts\")) {\n    goto done;\n  }\n\n  /* Values are space separated */\n  bufptr = ares_array_at(sects, 1);\n  buf    = *bufptr;\n  status = config_lookup(sysconfig, buf, \" \\t\");\n\ndone:\n  ares_array_destroy(sects);\n  if (status != ARES_ENOMEM) {\n    status = ARES_SUCCESS;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              632,
              0
            ],
            [
              681,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_nsswitch_line",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "line": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_svcconf_line(const ares_channel_t *channel,\n                                        ares_sysconfig_t     *sysconfig,\n                                        ares_buf_t           *line)\n{\n  char          option[32];\n  ares_buf_t  **bufptr;\n  ares_buf_t   *buf;\n  ares_status_t status = ARES_SUCCESS;\n  ares_array_t *sects  = NULL;\n\n  (void)channel;\n\n  /* Ignore lines beginning with a comment */\n  if (ares_buf_begins_with(line, (const unsigned char *)\"#\", 1)) {\n    return ARES_SUCCESS;\n  }\n\n  /* database = values (comma delimited)*/\n  status = ares_buf_split(line, (const unsigned char *)\"=\", 1,\n                          ARES_BUF_SPLIT_TRIM, 2, &sects);\n\n  if (status != ARES_SUCCESS || ares_array_len(sects) != 2) {\n    goto done;\n  }\n\n  bufptr = ares_array_at(sects, 0);\n  buf    = *bufptr;\n  status = buf_fetch_string(buf, option, sizeof(option));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Only support \"hosts=\" */\n  if (!ares_streq(option, \"hosts\")) {\n    goto done;\n  }\n\n  /* Values are comma separated */\n  bufptr = ares_array_at(sects, 1);\n  buf    = *bufptr;\n  status = config_lookup(sysconfig, buf, \",\");\n\ndone:\n  ares_array_destroy(sects);\n  if (status != ARES_ENOMEM) {\n    status = ARES_SUCCESS;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              686,
              0
            ],
            [
              734,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_svcconf_line",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "line": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_sysconfig_process_buf(const ares_channel_t    *channel,\n                                         ares_sysconfig_t        *sysconfig,\n                                         ares_buf_t              *buf,\n                                         ares_sysconfig_line_cb_t cb)\n{\n  ares_array_t *lines  = NULL;\n  size_t        num;\n  size_t        i;\n  ares_status_t status;\n\n  status = ares_buf_split(buf, (const unsigned char *)\"\\n\", 1,\n                          ARES_BUF_SPLIT_TRIM, 0, &lines);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  num = ares_array_len(lines);\n  for (i = 0; i < num; i++) {\n    ares_buf_t **bufptr = ares_array_at(lines, i);\n    ares_buf_t  *line   = *bufptr;\n\n    status = cb(channel, sysconfig, line);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  ares_array_destroy(lines);\n  return status;\n}",
          "fn_code_pos": [
            [
              737,
              0
            ],
            [
              767,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_process_buf",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "buf": "ares_buf_t",
              "cb": "ares_sysconfig_line_cb_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t process_config_lines(const ares_channel_t    *channel,\n                                          const char              *filename,\n                                          ares_sysconfig_t        *sysconfig,\n                                          ares_sysconfig_line_cb_t cb)\n{\n  ares_status_t status = ARES_SUCCESS;\n  ares_buf_t   *buf    = NULL;\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares_buf_load_file(filename, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_sysconfig_process_buf(channel, sysconfig, buf, cb);\n\ndone:\n  ares_buf_destroy(buf);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              776,
              0
            ],
            [
              801,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_config_lines",
            "parameters": {
              "channel": "ares_channel_t",
              "filename": "char",
              "sysconfig": "ares_sysconfig_t",
              "cb": "ares_sysconfig_line_cb_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_init_sysconfig_files(const ares_channel_t *channel,\n                                        ares_sysconfig_t     *sysconfig,\n                                        ares_bool_t process_resolvconf)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  /* Resolv.conf */\n  if (process_resolvconf) {\n    status = process_config_lines(channel,\n                                  (channel->resolvconf_path != NULL)\n                                    ? channel->resolvconf_path\n                                    : PATH_RESOLV_CONF,\n                                  sysconfig, ares_sysconfig_parse_resolv_line);\n    if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n      goto done;\n    }\n  }\n\n  /* Nsswitch.conf */\n  status = process_config_lines(channel, \"/etc/nsswitch.conf\", sysconfig,\n                                parse_nsswitch_line);\n  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  /* netsvc.conf */\n  status = process_config_lines(channel, \"/etc/netsvc.conf\", sysconfig,\n                                parse_svcconf_line);\n  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  /* svc.conf */\n  status = process_config_lines(channel, \"/etc/svc.conf\", sysconfig,\n                                parse_svcconf_line);\n  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              803,
              0
            ],
            [
              846,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_files",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "process_resolvconf": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addr",
          {},
          "",
          [
            63,
            43
          ],
          [
            63,
            59
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            93,
            35
          ],
          [
            93,
            50
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            94,
            41
          ],
          [
            94,
            56
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            96,
            2
          ],
          [
            96,
            17
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            111,
            49
          ],
          [
            111,
            64
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            182,
            6
          ],
          [
            182,
            22
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            211,
            34
          ],
          [
            211,
            49
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            257,
            4
          ],
          [
            257,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/param.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#  include <sys/system_properties.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <resolv.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#  include <iphlpapi.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_sysconfig_mac.c": {
      "fn_def_list": [
        {
          "fn_code": "static void dnsinfo_destroy(dnsinfo_t *dnsinfo)\n{\n  if (dnsinfo == NULL) {\n    return;\n  }\n\n  if (dnsinfo->handle) {\n    dlclose(dnsinfo->handle);\n  }\n\n  ares_free(dnsinfo);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dnsinfo_destroy",
            "parameters": {
              "dnsinfo": "dnsinfo_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t dnsinfo_init(dnsinfo_t **dnsinfo_out)\n{\n  dnsinfo_t    *dnsinfo = NULL;\n  ares_status_t status  = ARES_SUCCESS;\n  size_t        i;\n  const char   *searchlibs[] = {\n    \"/usr/lib/libSystem.dylib\",\n    \"/System/Library/Frameworks/SystemConfiguration.framework/\"\n      \"SystemConfiguration\",\n    NULL\n  };\n\n  if (dnsinfo_out == NULL) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\n  *dnsinfo_out = NULL;\n\n  dnsinfo = ares_malloc_zero(sizeof(*dnsinfo));\n  if (dnsinfo == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  for (i = 0; searchlibs[i] != NULL; i++) {\n    dnsinfo->handle = dlopen(searchlibs[i], RTLD_LAZY /* | RTLD_NOLOAD */);\n    if (dnsinfo->handle == NULL) {\n      /* Fail, loop */\n      continue;\n    }\n\n    dnsinfo->dns_configuration_copy = (dns_config_t * (*)(void))\n      dlsym(dnsinfo->handle, \"dns_configuration_copy\");\n\n    dnsinfo->dns_configuration_free = (void (*)(dns_config_t *))dlsym(\n      dnsinfo->handle, \"dns_configuration_free\");\n\n    if (dnsinfo->dns_configuration_copy != NULL &&\n        dnsinfo->dns_configuration_free != NULL) {\n      break;\n    }\n\n    /* Fail, loop */\n    dlclose(dnsinfo->handle);\n    dnsinfo->handle = NULL;\n  }\n\n\n  if (dnsinfo->dns_configuration_copy == NULL ||\n      dnsinfo->dns_configuration_free == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n\ndone:\n  if (status == ARES_SUCCESS) {\n    *dnsinfo_out = dnsinfo;\n  } else {\n    dnsinfo_destroy(dnsinfo);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dnsinfo_init",
            "parameters": {
              "dnsinfo_out": "dnsinfo_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t search_is_duplicate(const ares_sysconfig_t *sysconfig,\n                                       const char             *name)\n{\n  size_t i;\n  for (i = 0; i < sysconfig->ndomains; i++) {\n    if (ares_strcaseeq(sysconfig->domains[i], name)) {\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "search_is_duplicate",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t read_resolver(const ares_channel_t *channel,\n                                   const dns_resolver_t *resolver,\n                                   ares_sysconfig_t     *sysconfig)\n{\n  int            i;\n  unsigned short port   = 0;\n  ares_status_t  status = ARES_SUCCESS;\n\n#  if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080 /* MacOS 10.8 */\n  /* XXX: resolver->domain is for domain-specific servers.  When we implement\n   *      this support, we'll want to use this.  But for now, we're going to\n   *      skip any servers which set this since we can't properly route.\n   *      MacOS used to use this setting for a different purpose in the\n   *      past however, so on versions of MacOS < 10.8 just ignore this\n   *      completely. */\n  if (resolver->domain != NULL) {\n    return ARES_SUCCESS;\n  }\n#  endif\n\n#  if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080 /* MacOS 10.8 */\n  /* Check to see if DNS server should be used, base this on if the server is\n   * reachable or can be reachable automatically if we send traffic that\n   * direction. */\n  if (!(resolver->reach_flags &\n        (kSCNetworkFlagsReachable |\n         kSCNetworkReachabilityFlagsConnectionOnTraffic))) {\n    return ARES_SUCCESS;\n  }\n#  endif\n\n  /* NOTE: it doesn't look like resolver->flags is relevant */\n\n  /* If there's no nameservers, nothing to do */\n  if (resolver->n_nameserver <= 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* Default port */\n  port = resolver->port;\n\n  /* Append search list */\n  if (resolver->n_search > 0) {\n    char **new_domains = ares_realloc_zero(\n      sysconfig->domains, sizeof(*sysconfig->domains) * sysconfig->ndomains,\n      sizeof(*sysconfig->domains) *\n        (sysconfig->ndomains + (size_t)resolver->n_search));\n    if (new_domains == NULL) {\n      return ARES_ENOMEM;\n    }\n    sysconfig->domains = new_domains;\n\n    for (i = 0; i < resolver->n_search; i++) {\n      const char *search;\n      /* UBSAN: copy pointer using memcpy due to misalignment */\n      memcpy(&search, resolver->search + i, sizeof(search));\n\n      /* Skip duplicates */\n      if (search_is_duplicate(sysconfig, search)) {\n        continue;\n      }\n      sysconfig->domains[sysconfig->ndomains] = ares_strdup(search);\n      if (sysconfig->domains[sysconfig->ndomains] == NULL) {\n        return ARES_ENOMEM;\n      }\n      sysconfig->ndomains++;\n    }\n  }\n\n  /* NOTE: we're going to skip importing the sort addresses for now.  Its\n   *       likely not used, its not obvious how to even configure such a thing.\n   */\n#  if 0\n  for (i=0; i<resolver->n_sortaddr; i++) {\n    char val[256];\n    inet_ntop(AF_INET, &resolver->sortaddr[i]->address, val, sizeof(val));\n    printf(\"\\t\\t%s/\", val);\n    inet_ntop(AF_INET, &resolver->sortaddr[i]->mask, val, sizeof(val));\n    printf(\"%s\\n\", val);\n  }\n#  endif\n\n  if (resolver->options != NULL) {\n    status = ares_sysconfig_set_options(sysconfig, resolver->options);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* NOTE:\n   *   - resolver->timeout appears unused, always 0, so we ignore this\n   *   - resolver->service_identifier doesn't appear relevant to us\n   *   - resolver->cid also isn't relevant\n   *   - resolver->if_name we won't use since it isn't available in MacOS 10.8\n   *     or earlier, use resolver->if_index instead to then lookup the name.\n   */\n\n  /* XXX: resolver->search_order appears like it might be relevant, we might\n   * need to sort the resulting list by this metric if we find in the future we\n   * need to.  That said, due to the automatic re-sorting we do, I'm not sure it\n   * matters.  Here's an article on this search order stuff:\n   *      https://www.cnet.com/tech/computing/os-x-10-6-3-and-dns-server-priority-changes/\n   */\n\n  for (i = 0; i < resolver->n_nameserver; i++) {\n    struct ares_addr       addr;\n    unsigned short         addrport;\n    const struct sockaddr *sockaddr;\n    char                   if_name_str[256] = \"\";\n    const char            *if_name          = NULL;\n\n    /* UBSAN alignment workaround to fetch memory address */\n    memcpy(&sockaddr, resolver->nameserver + i, sizeof(sockaddr));\n\n    if (!ares_sockaddr_to_ares_addr(&addr, &addrport, sockaddr)) {\n      continue;\n    }\n\n    if (addrport == 0) {\n      addrport = port;\n    }\n\n    if (channel->sock_funcs.aif_indextoname != NULL) {\n      if_name = channel->sock_funcs.aif_indextoname(\n        resolver->if_index, if_name_str, sizeof(if_name_str),\n        channel->sock_func_cb_data);\n    }\n\n    status = ares_sconfig_append(channel, &sysconfig->sconfig, &addr, addrport,\n                                 addrport, if_name);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              299,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_resolver",
            "parameters": {
              "channel": "ares_channel_t",
              "resolver": "dns_resolver_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t read_resolvers(const ares_channel_t *channel,\n                                    dns_resolver_t **resolvers, int nresolvers,\n                                    ares_sysconfig_t *sysconfig)\n{\n  ares_status_t status = ARES_SUCCESS;\n  int           i;\n\n  for (i = 0; status == ARES_SUCCESS && i < nresolvers; i++) {\n    const dns_resolver_t *resolver_ptr;\n\n    /* UBSAN doesn't like that this is unaligned, lets use memcpy to get the\n     * address.  Equivalent to:\n     *   resolver = resolvers[i]\n     */\n    memcpy(&resolver_ptr, resolvers + i, sizeof(resolver_ptr));\n\n    status = read_resolver(channel, resolver_ptr, sysconfig);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_resolvers",
            "parameters": {
              "channel": "ares_channel_t",
              "resolvers": "dns_resolver_t",
              "nresolvers": "int",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_init_sysconfig_macos(const ares_channel_t *channel,\n                                        ares_sysconfig_t     *sysconfig)\n{\n  dnsinfo_t    *dnsinfo = NULL;\n  dns_config_t *sc_dns  = NULL;\n  ares_status_t status  = ARES_SUCCESS;\n\n  status = dnsinfo_init(&dnsinfo);\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  sc_dns = dnsinfo->dns_configuration_copy();\n  if (sc_dns == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  /* There are `resolver`, `scoped_resolver`, and `service_specific_resolver`\n   * settings. The `scoped_resolver` settings appear to be already available via\n   * the `resolver` settings and likely are only relevant to link-local dns\n   * servers which we can already detect via the address itself, so we'll ignore\n   * the `scoped_resolver` section.  It isn't clear what the\n   * `service_specific_resolver` is used for, I haven't personally seen it\n   * in use so we'll ignore this until at some point where we find we need it.\n   * Likely this wasn't available via `/etc/resolv.conf` nor `libresolv` anyhow\n   * so its not worse to prior configuration methods, worst case. */\n\n  status =\n    read_resolvers(channel, sc_dns->resolver, sc_dns->n_resolver, sysconfig);\n\ndone:\n  if (dnsinfo) {\n    dnsinfo->dns_configuration_free(sc_dns);\n    dnsinfo_destroy(dnsinfo);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_macos",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*dns_configuration_copy)(void)",
          "fn_dec_pos": [
            [
              68,
              16
            ],
            [
              68,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*dns_configuration_free)(dns_config_t *config)",
          "fn_dec_pos": [
            [
              69,
              7
            ],
            [
              69,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "config": "dns_config_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  void *handle;\n  dns_config_t *(*dns_configuration_copy)(void);\n  void (*dns_configuration_free)(dns_config_t *config);\n} dnsinfo_t;",
          {
            "*handle": "void",
            "*(*dns_configuration_copy)(void)": "dns_config_t",
            "(*dns_configuration_free)(dns_config_t *config)": "void"
          },
          "dnsinfo_t",
          [
            66,
            0
          ],
          [
            70,
            12
          ]
        ],
        [
          "typedef struct {\n  void *handle;\n  dns_config_t *(*dns_configuration_copy)(void);\n  void (*dns_configuration_free)(dns_config_t *config);\n} dnsinfo_t;",
          {
            "*handle": "void",
            "*(*dns_configuration_copy)(void)": "dns_config_t",
            "(*dns_configuration_free)(dns_config_t *config)": "void"
          },
          "dnsinfo_t",
          [
            66,
            0
          ],
          [
            70,
            12
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            268,
            4
          ],
          [
            268,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            270,
            10
          ],
          [
            270,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#  include \"ares_private.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#  include <stdio.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#  include <stdlib.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#  include <string.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#  include <dlfcn.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#  include \"thirdparty/apple/dnsinfo.h\"\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#  include <AvailabilityMacros.h>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#    include <SystemConfiguration/SCNetworkConfiguration.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_set_socket_functions.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t\n  ares_set_socket_functions_ex(ares_channel_t                        *channel,\n                               const struct ares_socket_functions_ex *funcs,\n                               void                                  *user_data)\n{\n  unsigned int known_versions[] = { 1 };\n  size_t       i;\n\n  if (channel == NULL || funcs == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Check to see if we know the version referenced */\n  for (i = 0; i < sizeof(known_versions) / sizeof(*known_versions); i++) {\n    if (funcs->version == known_versions[i]) {\n      break;\n    }\n  }\n  if (i == sizeof(known_versions) / sizeof(*known_versions)) {\n    return ARES_EFORMERR;\n  }\n\n  memset(&channel->sock_funcs, 0, sizeof(channel->sock_funcs));\n\n  /* Copy individually for ABI compliance.  memcpy() with a sizeof would do\n   * invalid reads */\n  if (funcs->version >= 1) {\n    if (funcs->asocket == NULL || funcs->aclose == NULL ||\n        funcs->asetsockopt == NULL || funcs->aconnect == NULL ||\n        funcs->arecvfrom == NULL || funcs->asendto == NULL) {\n      return ARES_EFORMERR;\n    }\n    channel->sock_funcs.version      = funcs->version;\n    channel->sock_funcs.flags        = funcs->flags;\n    channel->sock_funcs.asocket      = funcs->asocket;\n    channel->sock_funcs.aclose       = funcs->aclose;\n    channel->sock_funcs.asetsockopt  = funcs->asetsockopt;\n    channel->sock_funcs.aconnect     = funcs->aconnect;\n    channel->sock_funcs.arecvfrom    = funcs->arecvfrom;\n    channel->sock_funcs.asendto      = funcs->asendto;\n    channel->sock_funcs.agetsockname = funcs->agetsockname;\n    channel->sock_funcs.abind        = funcs->abind;\n    channel->sock_funcs.aif_nametoindex = funcs->aif_nametoindex;\n    channel->sock_funcs.aif_indextoname = funcs->aif_indextoname;\n  }\n\n  /* Implement newer versions here ...*/\n\n\n  channel->sock_func_cb_data = user_data;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_functions_ex",
            "parameters": {
              "channel": "ares_channel_t",
              "funcs": "struct ares_socket_functions_ex",
              "user_data": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static int setsocknonblock(ares_socket_t sockfd, /* operate on this */\n                           int           nonblock /* TRUE or FALSE */)\n{\n#if defined(HAVE_FCNTL_O_NONBLOCK)\n\n  /* most recent unix versions */\n  int flags;\n  flags = fcntl(sockfd, F_GETFL, 0);\n  if (nonblock) {\n    return fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n  } else {\n    return fcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK)); /* LCOV_EXCL_LINE */\n  }\n\n#elif defined(HAVE_IOCTL_FIONBIO)\n\n  /* older unix versions */\n  int flags = nonblock ? 1 : 0;\n  return ioctl(sockfd, FIONBIO, &flags);\n\n#elif defined(HAVE_IOCTLSOCKET_FIONBIO)\n\n#  ifdef WATT32\n  char flags = nonblock ? 1 : 0;\n#  else\n  /* Windows */\n  unsigned long flags = nonblock ? 1UL : 0UL;\n#  endif\n  return ioctlsocket(sockfd, (long)FIONBIO, &flags);\n\n#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)\n\n  /* Amiga */\n  long flags = nonblock ? 1L : 0L;\n  return IoctlSocket(sockfd, FIONBIO, flags);\n\n#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)\n\n  /* BeOS */\n  long b = nonblock ? 1L : 0L;\n  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));\n\n#else\n#  error \"no non-blocking method was found/used/set\"\n#endif\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setsocknonblock",
            "parameters": {
              "sockfd": "ares_socket_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int default_aclose(ares_socket_t sock, void *user_data)\n{\n  (void)user_data;\n\n#if defined(HAVE_CLOSESOCKET)\n  return closesocket(sock);\n#elif defined(HAVE_CLOSESOCKET_CAMEL)\n  return CloseSocket(sock);\n#elif defined(HAVE_CLOSE_S)\n  return close_s(sock);\n#else\n  return close(sock);\n#endif\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_aclose",
            "parameters": {
              "sock": "ares_socket_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_socket_t default_asocket(int domain, int type, int protocol,\n                                     void *user_data)\n{\n  ares_socket_t s;\n  (void)user_data;\n\n  s = socket(domain, type, protocol);\n  if (s == ARES_SOCKET_BAD) {\n    return s;\n  }\n\n  if (setsocknonblock(s, 1) != 0) {\n    goto fail; /* LCOV_EXCL_LINE */\n  }\n\n#if defined(FD_CLOEXEC) && !defined(MSDOS)\n  /* Configure the socket fd as close-on-exec. */\n  if (fcntl(s, F_SETFD, FD_CLOEXEC) != 0) {\n    goto fail; /* LCOV_EXCL_LINE */\n  }\n#endif\n\n  /* No need to emit SIGPIPE on socket errors */\n#if defined(SO_NOSIGPIPE)\n  {\n    int opt = 1;\n    (void)setsockopt(s, SOL_SOCKET, SO_NOSIGPIPE, (void *)&opt, sizeof(opt));\n  }\n#endif\n\n\n  if (type == SOCK_STREAM) {\n    int opt = 1;\n\n#ifdef TCP_NODELAY\n    /*\n     * Disable the Nagle algorithm (only relevant for TCP sockets, and thus not\n     * in configure_socket). In general, in DNS lookups we're pretty much\n     * interested in firing off a single request and then waiting for a reply,\n     * so batching isn't very interesting.\n     */\n    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (void *)&opt, sizeof(opt)) !=\n        0) {\n      goto fail;\n    }\n#endif\n  }\n\n#if defined(IPV6_V6ONLY) && defined(USE_WINSOCK)\n  /* Support for IPv4-mapped IPv6 addresses.\n   * Linux kernel, NetBSD, FreeBSD and Darwin: default is off;\n   * Windows Vista and later: default is on;\n   * DragonFly BSD: acts like off, and dummy setting;\n   * OpenBSD and earlier Windows: unsupported.\n   * Linux: controlled by /proc/sys/net/ipv6/bindv6only.\n   */\n  if (domain == PF_INET6) {\n    int on = 0;\n    (void)setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&on, sizeof(on));\n  }\n#endif\n\n  return s;\n\nfail:\n  default_aclose(s, user_data);\n  return ARES_SOCKET_BAD;\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_asocket",
            "parameters": {
              "domain": "int",
              "type": "int",
              "protocol": "int",
              "user_data": "void"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "static int default_asetsockopt(ares_socket_t sock, ares_socket_opt_t opt,\n                               const void *val, ares_socklen_t val_size,\n                               void *user_data)\n{\n  switch (opt) {\n    case ARES_SOCKET_OPT_SENDBUF_SIZE:\n      if (val_size != sizeof(int)) {\n        SET_SOCKERRNO(EINVAL);\n        return -1;\n      }\n      return setsockopt(sock, SOL_SOCKET, SO_SNDBUF, val, val_size);\n\n    case ARES_SOCKET_OPT_RECVBUF_SIZE:\n      if (val_size != sizeof(int)) {\n        SET_SOCKERRNO(EINVAL);\n        return -1;\n      }\n      return setsockopt(sock, SOL_SOCKET, SO_RCVBUF, val, val_size);\n\n    case ARES_SOCKET_OPT_BIND_DEVICE:\n      /* Count the number of characters before NULL terminator then\n       * validate those are all printable */\n      if (!ares_str_isprint(val, ares_strnlen(val, (size_t)val_size))) {\n        SET_SOCKERRNO(EINVAL);\n        return -1;\n      }\n#ifdef SO_BINDTODEVICE\n      return setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, val, val_size);\n#else\n      SET_SOCKERRNO(ENOSYS);\n      return -1;\n#endif\n\n    case ARES_SOCKET_OPT_TCP_FASTOPEN:\n      if (val_size != sizeof(ares_bool_t)) {\n        SET_SOCKERRNO(EINVAL);\n        return -1;\n      }\n#if defined(TFO_CLIENT_SOCKOPT)\n      {\n        int                oval;\n        const ares_bool_t *pval = val;\n        oval                    = (int)*pval;\n        return setsockopt(sock, IPPROTO_TCP, TFO_CLIENT_SOCKOPT, (void *)&oval,\n                          sizeof(oval));\n      }\n#elif TFO_SUPPORTED\n      return 0;\n#else\n      SET_SOCKERRNO(ENOSYS);\n      return -1;\n#endif\n  }\n\n  (void)user_data;\n  SET_SOCKERRNO(ENOSYS);\n  return -1;\n}",
          "fn_code_pos": [
            [
              272,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_asetsockopt",
            "parameters": {
              "sock": "ares_socket_t",
              "opt": "ares_socket_opt_t",
              "val": "void",
              "val_size": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int default_aconnect(ares_socket_t sock, const struct sockaddr *address,\n                            ares_socklen_t address_len, unsigned int flags,\n                            void *user_data)\n{\n  (void)user_data;\n\n#if defined(TFO_SKIP_CONNECT) && TFO_SKIP_CONNECT\n  if (flags & ARES_SOCKET_CONN_TCP_FASTOPEN) {\n    return 0;\n  }\n  return connect(sock, address, address_len);\n#elif defined(TFO_USE_CONNECTX) && TFO_USE_CONNECTX\n  if (flags & ARES_SOCKET_CONN_TCP_FASTOPEN) {\n    sa_endpoints_t endpoints;\n\n    memset(&endpoints, 0, sizeof(endpoints));\n    endpoints.sae_dstaddr    = address;\n    endpoints.sae_dstaddrlen = address_len;\n\n    return connectx(sock, &endpoints, SAE_ASSOCID_ANY,\n                    CONNECT_DATA_IDEMPOTENT | CONNECT_RESUME_ON_READ_WRITE,\n                    NULL, 0, NULL, NULL);\n  } else {\n    return connect(sock, address, address_len);\n  }\n#else\n  (void)flags;\n  return connect(sock, address, address_len);\n#endif\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              360,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_aconnect",
            "parameters": {
              "sock": "ares_socket_t",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "flags": "unsigned int",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_ssize_t default_arecvfrom(ares_socket_t sock, void *buffer,\n                                      size_t length, int flags,\n                                      struct sockaddr *address,\n                                      ares_socklen_t  *address_len,\n                                      void            *user_data)\n{\n  (void)user_data;\n\n#ifdef HAVE_RECVFROM\n  return (ares_ssize_t)recvfrom(sock, buffer, (RECVFROM_TYPE_ARG3)length, flags,\n                                address, address_len);\n#else\n  if (address != NULL && address_len != NULL) {\n    memset(address, 0, (size_t)*address_len);\n    address->sa_family = AF_UNSPEC;\n  }\n  return (ares_ssize_t)recv(sock, buffer, (RECVFROM_TYPE_ARG3)length, flags);\n#endif\n}",
          "fn_code_pos": [
            [
              362,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_arecvfrom",
            "parameters": {
              "sock": "ares_socket_t",
              "buffer": "void",
              "length": "size_t",
              "flags": "int",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "static ares_ssize_t default_asendto(ares_socket_t sock, const void *buffer,\n                                    size_t length, int flags,\n                                    const struct sockaddr *address,\n                                    ares_socklen_t address_len, void *user_data)\n{\n  (void)user_data;\n\n  if (address != NULL) {\n#ifdef HAVE_SENDTO\n    return (ares_ssize_t)sendto((SEND_TYPE_ARG1)sock, (SEND_TYPE_ARG2)buffer,\n                                (SEND_TYPE_ARG3)length, (SEND_TYPE_ARG4)flags,\n                                address, address_len);\n#else\n    (void)address_len;\n#endif\n  }\n\n  return (ares_ssize_t)send((SEND_TYPE_ARG1)sock, (SEND_TYPE_ARG2)buffer,\n                            (SEND_TYPE_ARG3)length, (SEND_TYPE_ARG4)flags);\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_asendto",
            "parameters": {
              "sock": "ares_socket_t",
              "buffer": "void",
              "length": "size_t",
              "flags": "int",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "static int default_agetsockname(ares_socket_t sock, struct sockaddr *address,\n                                ares_socklen_t *address_len, void *user_data)\n{\n  (void)user_data;\n  return getsockname(sock, address, address_len);\n}",
          "fn_code_pos": [
            [
              403,
              0
            ],
            [
              408,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_agetsockname",
            "parameters": {
              "sock": "ares_socket_t",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int default_abind(ares_socket_t sock, unsigned int flags,\n                         const struct sockaddr *address, socklen_t address_len,\n                         void *user_data)\n{\n  (void)user_data;\n\n#ifdef IP_BIND_ADDRESS_NO_PORT\n  if (flags & ARES_SOCKET_BIND_TCP && flags & ARES_SOCKET_BIND_CLIENT) {\n    int opt = 1;\n    (void)setsockopt(sock, SOL_IP, IP_BIND_ADDRESS_NO_PORT, &opt, sizeof(opt));\n  }\n#else\n  (void)flags;\n#endif\n\n  return bind(sock, address, address_len);\n}",
          "fn_code_pos": [
            [
              410,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_abind",
            "parameters": {
              "sock": "ares_socket_t",
              "flags": "unsigned int",
              "address": "struct sockaddr",
              "address_len": "socklen_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static unsigned int default_aif_nametoindex(const char *ifname, void *user_data)\n{\n  (void)user_data;\n  return ares_os_if_nametoindex(ifname);\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_aif_nametoindex",
            "parameters": {
              "ifname": "char",
              "user_data": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const char *default_aif_indextoname(unsigned int ifindex,\n                                           char        *ifname_buf,\n                                           size_t       ifname_buf_len,\n                                           void        *user_data)\n{\n  (void)user_data;\n  return ares_os_if_indextoname(ifindex, ifname_buf, ifname_buf_len);\n}",
          "fn_code_pos": [
            [
              434,
              0
            ],
            [
              441,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_aif_indextoname",
            "parameters": {
              "ifindex": "unsigned int",
              "ifname_buf": "char",
              "ifname_buf_len": "size_t",
              "user_data": "void"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void ares_set_socket_functions_def(ares_channel_t *channel)\n{\n  ares_set_socket_functions_ex(channel, &default_socket_functions, NULL);\n}",
          "fn_code_pos": [
            [
              458,
              0
            ],
            [
              461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_functions_def",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int legacycb_aclose(ares_socket_t sock, void *user_data)\n{\n  ares_channel_t *channel = user_data;\n\n  if (channel->legacy_sock_funcs != NULL &&\n      channel->legacy_sock_funcs->aclose != NULL) {\n    return channel->legacy_sock_funcs->aclose(\n      sock, channel->legacy_sock_funcs_cb_data);\n  }\n\n  return default_aclose(sock, NULL);\n}",
          "fn_code_pos": [
            [
              463,
              0
            ],
            [
              474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "legacycb_aclose",
            "parameters": {
              "sock": "ares_socket_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_socket_t legacycb_asocket(int domain, int type, int protocol,\n                                      void *user_data)\n{\n  ares_channel_t *channel = user_data;\n\n  if (channel->legacy_sock_funcs != NULL &&\n      channel->legacy_sock_funcs->asocket != NULL) {\n    return channel->legacy_sock_funcs->asocket(\n      domain, type, protocol, channel->legacy_sock_funcs_cb_data);\n  }\n\n  return default_asocket(domain, type, protocol, NULL);\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              488,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "legacycb_asocket",
            "parameters": {
              "domain": "int",
              "type": "int",
              "protocol": "int",
              "user_data": "void"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "static int legacycb_asetsockopt(ares_socket_t sock, ares_socket_opt_t opt,\n                                const void *val, ares_socklen_t val_size,\n                                void *user_data)\n{\n  (void)sock;\n  (void)opt;\n  (void)val;\n  (void)val_size;\n  (void)user_data;\n  SET_SOCKERRNO(ENOSYS);\n  return -1;\n}",
          "fn_code_pos": [
            [
              490,
              0
            ],
            [
              501,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "legacycb_asetsockopt",
            "parameters": {
              "sock": "ares_socket_t",
              "opt": "ares_socket_opt_t",
              "val": "void",
              "val_size": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int legacycb_aconnect(ares_socket_t sock, const struct sockaddr *address,\n                             ares_socklen_t address_len, unsigned int flags,\n                             void *user_data)\n{\n  ares_channel_t *channel = user_data;\n\n  if (channel->legacy_sock_funcs != NULL &&\n      channel->legacy_sock_funcs->aconnect != NULL) {\n    return channel->legacy_sock_funcs->aconnect(\n      sock, address, address_len, channel->legacy_sock_funcs_cb_data);\n  }\n\n  return default_aconnect(sock, address, address_len, flags, NULL);\n}",
          "fn_code_pos": [
            [
              503,
              0
            ],
            [
              516,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "legacycb_aconnect",
            "parameters": {
              "sock": "ares_socket_t",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "flags": "unsigned int",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_ssize_t legacycb_arecvfrom(ares_socket_t sock, void *buffer,\n                                       size_t length, int flags,\n                                       struct sockaddr *address,\n                                       ares_socklen_t  *address_len,\n                                       void            *user_data)\n{\n  ares_channel_t *channel = user_data;\n\n  if (channel->legacy_sock_funcs != NULL &&\n      channel->legacy_sock_funcs->arecvfrom != NULL) {\n    if (address != NULL && address_len != NULL) {\n      memset(address, 0, (size_t)*address_len);\n      address->sa_family = AF_UNSPEC;\n    }\n    return channel->legacy_sock_funcs->arecvfrom(\n      sock, buffer, length, flags, address, address_len,\n      channel->legacy_sock_funcs_cb_data);\n  }\n\n  return default_arecvfrom(sock, buffer, length, flags, address, address_len,\n                           NULL);\n}",
          "fn_code_pos": [
            [
              518,
              0
            ],
            [
              539,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "legacycb_arecvfrom",
            "parameters": {
              "sock": "ares_socket_t",
              "buffer": "void",
              "length": "size_t",
              "flags": "int",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "static ares_ssize_t legacycb_asendto(ares_socket_t sock, const void *buffer,\n                                     size_t length, int flags,\n                                     const struct sockaddr *address,\n                                     ares_socklen_t         address_len,\n                                     void                  *user_data)\n{\n  ares_channel_t *channel = user_data;\n\n  if (channel->legacy_sock_funcs != NULL &&\n      channel->legacy_sock_funcs->asendv != NULL) {\n    struct iovec vec;\n    vec.iov_base = (void *)((size_t)buffer); /* Cast off const */\n    vec.iov_len  = length;\n    return channel->legacy_sock_funcs->asendv(\n      sock, &vec, 1, channel->legacy_sock_funcs_cb_data);\n  }\n\n  return default_asendto(sock, buffer, length, flags, address, address_len,\n                         NULL);\n}",
          "fn_code_pos": [
            [
              541,
              0
            ],
            [
              560,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "legacycb_asendto",
            "parameters": {
              "sock": "ares_socket_t",
              "buffer": "void",
              "length": "size_t",
              "flags": "int",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "void ares_set_socket_functions(ares_channel_t                     *channel,\n                               const struct ares_socket_functions *funcs,\n                               void                               *data)\n{\n  if (channel == NULL || channel->optmask & ARES_OPT_EVENT_THREAD) {\n    return;\n  }\n\n  channel->legacy_sock_funcs         = funcs;\n  channel->legacy_sock_funcs_cb_data = data;\n  ares_set_socket_functions_ex(channel, &legacy_socket_functions, channel);\n}",
          "fn_code_pos": [
            [
              578,
              0
            ],
            [
              589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_functions",
            "parameters": {
              "channel": "ares_channel_t",
              "funcs": "struct ares_socket_functions",
              "data": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "default_aif_indextoname(unsigned int ifindex,\n                                           char        *ifname_buf,\n                                           size_t       ifname_buf_len,\n                                           void        *user_data)",
          "fn_dec_pos": [
            [
              434,
              19
            ],
            [
              437,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_aif_indextoname",
            "parameters": {
              "ifindex": "unsigned int",
              "ifname_buf": "char",
              "ifname_buf_len": "size_t",
              "user_data": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct iovec {\n  void  *iov_base; /* Pointer to data. */\n  size_t iov_len;  /* Length of data.  */\n}",
          {
            "*iov_base": "void",
            "iov_len": "size_t"
          },
          "iovec",
          [
            81,
            0
          ],
          [
            84,
            1
          ]
        ],
        [
          "struct iovec {\n  void  *iov_base; /* Pointer to data. */\n  size_t iov_len;  /* Length of data.  */\n}",
          {
            "*iov_base": "void",
            "iov_len": "size_t"
          },
          "iovec",
          [
            81,
            0
          ],
          [
            84,
            1
          ]
        ],
        [
          "struct ares_socket_functions_ex",
          {},
          "",
          [
            89,
            37
          ],
          [
            89,
            68
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            331,
            54
          ],
          [
            331,
            69
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            364,
            38
          ],
          [
            364,
            53
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            384,
            42
          ],
          [
            384,
            57
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            403,
            52
          ],
          [
            403,
            67
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            411,
            31
          ],
          [
            411,
            46
          ]
        ],
        [
          "struct ares_socket_functions_ex",
          {},
          "",
          [
            443,
            13
          ],
          [
            443,
            44
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            503,
            55
          ],
          [
            503,
            70
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            520,
            39
          ],
          [
            520,
            54
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            543,
            43
          ],
          [
            543,
            58
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            551,
            4
          ],
          [
            551,
            16
          ]
        ],
        [
          "struct ares_socket_functions_ex",
          {},
          "",
          [
            563,
            13
          ],
          [
            563,
            44
          ]
        ],
        [
          "struct ares_socket_functions",
          {},
          "",
          [
            579,
            37
          ],
          [
            579,
            65
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#  include <sys/uio.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/tcp.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#  include <sys/filio.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_free_hostent.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_free_hostent(struct hostent *host)\n{\n  char **p;\n\n  if (!host) {\n    return;\n  }\n\n  ares_free(host->h_name);\n  for (p = host->h_aliases; p && *p; p++) {\n    ares_free(*p);\n  }\n  ares_free(host->h_aliases);\n  if (host->h_addr_list) {\n    size_t i;\n    for (i=0; host->h_addr_list[i] != NULL; i++) {\n      ares_free(host->h_addr_list[i]);\n    }\n    ares_free(host->h_addr_list);\n  }\n  ares_free(host);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_hostent",
            "parameters": {
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            32,
            23
          ],
          [
            32,
            37
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_conn.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_conn_sock_state_cb_update(ares_conn_t            *conn,\n                                    ares_conn_state_flags_t flags)\n{\n  ares_channel_t *channel = conn->server->channel;\n\n  if ((conn->state_flags & ARES_CONN_STATE_CBFLAGS) != flags &&\n      channel->sock_state_cb) {\n    channel->sock_state_cb(channel->sock_state_cb_data, conn->fd,\n                           flags & ARES_CONN_STATE_READ ? 1 : 0,\n                           flags & ARES_CONN_STATE_WRITE ? 1 : 0);\n  }\n\n  conn->state_flags &= ~((unsigned int)ARES_CONN_STATE_CBFLAGS);\n  conn->state_flags |= flags;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_sock_state_cb_update",
            "parameters": {
              "conn": "ares_conn_t",
              "flags": "ares_conn_state_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_conn_err_t ares_conn_read(ares_conn_t *conn, void *data, size_t len,\n                               size_t *read_bytes)\n{\n  ares_channel_t *channel = conn->server->channel;\n  ares_conn_err_t err;\n\n  if (!(conn->flags & ARES_CONN_FLAG_TCP)) {\n    struct sockaddr_storage sa_storage;\n    ares_socklen_t          salen = sizeof(sa_storage);\n\n    memset(&sa_storage, 0, sizeof(sa_storage));\n\n    err =\n      ares_socket_recvfrom(channel, conn->fd, ARES_FALSE, data, len, 0,\n                           (struct sockaddr *)&sa_storage, &salen, read_bytes);\n\n#ifdef HAVE_RECVFROM\n    if (err == ARES_CONN_ERR_SUCCESS &&\n        !ares_sockaddr_addr_eq((struct sockaddr *)&sa_storage,\n                               &conn->server->addr)) {\n      err = ARES_CONN_ERR_WOULDBLOCK;\n    }\n#endif\n  } else {\n    err = ares_socket_recv(channel, conn->fd, ARES_TRUE, data, len, read_bytes);\n  }\n\n  /* Toggle connected state if needed */\n  if (err == ARES_CONN_ERR_SUCCESS) {\n    conn->state_flags |= ARES_CONN_STATE_CONNECTED;\n  }\n\n  return err;\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_read",
            "parameters": {
              "conn": "ares_conn_t",
              "data": "void",
              "len": "size_t",
              "read_bytes": "size_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_conn_set_sockaddr(const ares_conn_t *conn,\n                                            struct sockaddr   *sa,\n                                            ares_socklen_t    *salen)\n{\n  const ares_server_t *server = conn->server;\n  unsigned short       port =\n    conn->flags & ARES_CONN_FLAG_TCP ? server->tcp_port : server->udp_port;\n  struct sockaddr_in  *sin;\n  struct sockaddr_in6 *sin6;\n\n  switch (server->addr.family) {\n    case AF_INET:\n      sin = (struct sockaddr_in *)(void *)sa;\n      if (*salen < (ares_socklen_t)sizeof(*sin)) {\n        return ARES_EFORMERR;\n      }\n      *salen = sizeof(*sin);\n      memset(sin, 0, sizeof(*sin));\n      sin->sin_family = AF_INET;\n      sin->sin_port   = htons(port);\n      memcpy(&sin->sin_addr, &server->addr.addr.addr4, sizeof(sin->sin_addr));\n      return ARES_SUCCESS;\n    case AF_INET6:\n      sin6 = (struct sockaddr_in6 *)(void *)sa;\n      if (*salen < (ares_socklen_t)sizeof(*sin6)) {\n        return ARES_EFORMERR;\n      }\n      *salen = sizeof(*sin6);\n      memset(sin6, 0, sizeof(*sin6));\n      sin6->sin6_family = AF_INET6;\n      sin6->sin6_port   = htons(port);\n      memcpy(&sin6->sin6_addr, &server->addr.addr.addr6,\n             sizeof(sin6->sin6_addr));\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n      sin6->sin6_scope_id = server->ll_scope;\n#endif\n      return ARES_SUCCESS;\n    default:\n      break;\n  }\n\n  return ARES_EBADFAMILY;\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_set_sockaddr",
            "parameters": {
              "conn": "ares_conn_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_conn_set_self_ip(ares_conn_t *conn, ares_bool_t early)\n{\n  ares_channel_t         *channel = conn->server->channel;\n  struct sockaddr_storage sa_storage;\n  int                     rv;\n  ares_socklen_t          len = sizeof(sa_storage);\n\n  /* We call this twice on TFO, if we already have the IP we can go ahead and\n   * skip processing */\n  if (!early && conn->self_ip.family != AF_UNSPEC) {\n    return ARES_SUCCESS;\n  }\n\n  memset(&sa_storage, 0, sizeof(sa_storage));\n\n  if (channel->sock_funcs.agetsockname == NULL) {\n    /* Not specified, we can still use cookies cooked with an empty self_ip */\n    memset(&conn->self_ip, 0, sizeof(conn->self_ip));\n    return ARES_SUCCESS;\n  }\n  rv = channel->sock_funcs.agetsockname(conn->fd,\n                                        (struct sockaddr *)(void *)&sa_storage,\n                                        &len, channel->sock_func_cb_data);\n  if (rv != 0) {\n    /* During TCP FastOpen, we can't get the IP this early since connect()\n     * may not be called.  That's ok, we'll try again later */\n    if (early && conn->flags & ARES_CONN_FLAG_TCP &&\n        conn->flags & ARES_CONN_FLAG_TFO) {\n      memset(&conn->self_ip, 0, sizeof(conn->self_ip));\n      return ARES_SUCCESS;\n    }\n    return ARES_ECONNREFUSED;\n  }\n\n  if (!ares_sockaddr_to_ares_addr(&conn->self_ip, NULL,\n                                  (struct sockaddr *)(void *)&sa_storage)) {\n    return ARES_ECONNREFUSED;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_set_self_ip",
            "parameters": {
              "conn": "ares_conn_t",
              "early": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_conn_err_t ares_conn_write(ares_conn_t *conn, const void *data, size_t len,\n                                size_t *written)\n{\n  ares_channel_t         *channel = conn->server->channel;\n  ares_bool_t             is_tfo  = ARES_FALSE;\n  ares_conn_err_t         err     = ARES_CONN_ERR_SUCCESS;\n  struct sockaddr_storage sa_storage;\n  ares_socklen_t          salen = 0;\n  struct sockaddr        *sa    = NULL;\n\n  *written = 0;\n\n  /* Don't try to write if not doing initial TFO and not connected */\n  if (conn->flags & ARES_CONN_FLAG_TCP &&\n      !(conn->state_flags & ARES_CONN_STATE_CONNECTED) &&\n      !(conn->flags & ARES_CONN_FLAG_TFO_INITIAL)) {\n    return ARES_CONN_ERR_WOULDBLOCK;\n  }\n\n  /* On initial write during TFO we need to send an address */\n  if (conn->flags & ARES_CONN_FLAG_TFO_INITIAL) {\n    salen = sizeof(sa_storage);\n    sa    = (struct sockaddr *)&sa_storage;\n\n    conn->flags &= ~((unsigned int)ARES_CONN_FLAG_TFO_INITIAL);\n    is_tfo       = ARES_TRUE;\n\n    if (ares_conn_set_sockaddr(conn, sa, &salen) != ARES_SUCCESS) {\n      return ARES_CONN_ERR_FAILURE;\n    }\n  }\n\n  err = ares_socket_write(channel, conn->fd, data, len, written, sa, salen);\n  if (err != ARES_CONN_ERR_SUCCESS) {\n    goto done;\n  }\n\n  if (is_tfo) {\n    /* If using TFO, we might not have been able to get an IP earlier, since\n     * we hadn't informed the OS of the destination.  When using sendto()\n     * now we have so we should be able to fetch it */\n    ares_conn_set_self_ip(conn, ARES_FALSE);\n    goto done;\n  }\n\ndone:\n  if (err == ARES_CONN_ERR_SUCCESS && len == *written) {\n    /* Wrote all data, make sure we're not listening for write events unless\n     * using TFO, in which case we'll need a write event to know when\n     * we're connected. */\n    ares_conn_sock_state_cb_update(\n      conn, ARES_CONN_STATE_READ |\n              (is_tfo ? ARES_CONN_STATE_WRITE : ARES_CONN_STATE_NONE));\n  } else if (err == ARES_CONN_ERR_WOULDBLOCK) {\n    /* Need to wait on more buffer space to write */\n    ares_conn_sock_state_cb_update(conn, ARES_CONN_STATE_READ |\n                                           ARES_CONN_STATE_WRITE);\n  }\n\n  return err;\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_write",
            "parameters": {
              "conn": "ares_conn_t",
              "data": "void",
              "len": "size_t",
              "written": "size_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_conn_flush(ares_conn_t *conn)\n{\n  const unsigned char *data;\n  size_t               data_len;\n  size_t               count;\n  ares_conn_err_t      err;\n  ares_status_t        status;\n  ares_bool_t          tfo = ARES_FALSE;\n\n  if (conn == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (conn->flags & ARES_CONN_FLAG_TFO_INITIAL) {\n    tfo = ARES_TRUE;\n  }\n\n  do {\n    if (ares_buf_len(conn->out_buf) == 0) {\n      status = ARES_SUCCESS;\n      goto done;\n    }\n\n    if (conn->flags & ARES_CONN_FLAG_TCP) {\n      data = ares_buf_peek(conn->out_buf, &data_len);\n    } else {\n      unsigned short msg_len;\n\n      /* Read length, then provide buffer without length */\n      ares_buf_tag(conn->out_buf);\n      status = ares_buf_fetch_be16(conn->out_buf, &msg_len);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n      ares_buf_tag_rollback(conn->out_buf);\n\n      data = ares_buf_peek(conn->out_buf, &data_len);\n      if (data_len < (size_t)(msg_len + 2)) {\n        status = ARES_EFORMERR;\n        goto done;\n      }\n      data     += 2;\n      data_len  = msg_len;\n    }\n\n    err = ares_conn_write(conn, data, data_len, &count);\n    if (err != ARES_CONN_ERR_SUCCESS) {\n      if (err != ARES_CONN_ERR_WOULDBLOCK) {\n        status = ARES_ECONNREFUSED;\n        goto done;\n      }\n      status = ARES_SUCCESS;\n      goto done;\n    }\n\n    /* UDP didn't send the length prefix so augment that here */\n    if (!(conn->flags & ARES_CONN_FLAG_TCP)) {\n      count += 2;\n    }\n\n    /* Strip data written from the buffer */\n    ares_buf_consume(conn->out_buf, count);\n    status = ARES_SUCCESS;\n\n    /* Loop only for UDP since we have to send per-packet.  We already\n     * sent everything we could if using tcp */\n  } while (!(conn->flags & ARES_CONN_FLAG_TCP));\n\ndone:\n  if (status == ARES_SUCCESS) {\n    ares_conn_state_flags_t flags = ARES_CONN_STATE_READ;\n\n    /* When using TFO, the we need to enabling waiting on a write event to\n     * be notified of when a connection is actually established */\n    if (tfo) {\n      flags |= ARES_CONN_STATE_WRITE;\n    }\n\n    /* If using TCP and not all data was written (partial write), that means\n     * we need to also wait on a write event */\n    if (conn->flags & ARES_CONN_FLAG_TCP && ares_buf_len(conn->out_buf)) {\n      flags |= ARES_CONN_STATE_WRITE;\n    }\n\n    ares_conn_sock_state_cb_update(conn, flags);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              233,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_flush",
            "parameters": {
              "conn": "ares_conn_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_conn_connect(ares_conn_t           *conn,\n                                       const struct sockaddr *sa,\n                                       ares_socklen_t         salen)\n{\n  ares_conn_err_t err;\n\n  err = ares_socket_connect(\n    conn->server->channel, conn->fd,\n    (conn->flags & ARES_CONN_FLAG_TFO) ? ARES_TRUE : ARES_FALSE, sa, salen);\n\n  if (err != ARES_CONN_ERR_WOULDBLOCK && err != ARES_CONN_ERR_SUCCESS) {\n    return ARES_ECONNREFUSED;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_connect",
            "parameters": {
              "conn": "ares_conn_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_open_connection(ares_conn_t   **conn_out,\n                                   ares_channel_t *channel,\n                                   ares_server_t *server, ares_bool_t is_tcp)\n{\n  ares_status_t           status;\n  struct sockaddr_storage sa_storage;\n  ares_socklen_t          salen = sizeof(sa_storage);\n  struct sockaddr        *sa    = (struct sockaddr *)&sa_storage;\n  ares_conn_t            *conn;\n  ares_llist_node_t      *node  = NULL;\n  int                     stype = is_tcp ? SOCK_STREAM : SOCK_DGRAM;\n  ares_conn_state_flags_t state_flags;\n\n  *conn_out = NULL;\n\n  conn = ares_malloc(sizeof(*conn));\n  if (conn == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  memset(conn, 0, sizeof(*conn));\n  conn->fd              = ARES_SOCKET_BAD;\n  conn->server          = server;\n  conn->queries_to_conn = ares_llist_create(NULL);\n  conn->flags           = is_tcp ? ARES_CONN_FLAG_TCP : ARES_CONN_FLAG_NONE;\n  conn->out_buf         = ares_buf_create();\n  conn->in_buf          = ares_buf_create();\n\n  if (conn->queries_to_conn == NULL || conn->out_buf == NULL ||\n      conn->in_buf == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    status = ARES_ENOMEM;\n    goto done;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Try to enable TFO always if using TCP. it will fail later on if its\n   * really not supported when we try to enable it on the socket. */\n  if (conn->flags & ARES_CONN_FLAG_TCP) {\n    conn->flags |= ARES_CONN_FLAG_TFO;\n  }\n\n  /* Convert into the struct sockaddr structure needed by the OS */\n  status = ares_conn_set_sockaddr(conn, sa, &salen);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Acquire a socket. */\n  if (ares_socket_open(&conn->fd, channel, server->addr.family, stype, 0) !=\n      ARES_CONN_ERR_SUCCESS) {\n    status = ARES_ECONNREFUSED;\n    goto done;\n  }\n\n  /* Configure channel configured options */\n  status = ares_socket_configure(\n    channel, server->addr.family,\n    (conn->flags & ARES_CONN_FLAG_TCP) ? ARES_TRUE : ARES_FALSE, conn->fd);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Enable TFO if possible */\n  if (conn->flags & ARES_CONN_FLAG_TFO &&\n      ares_socket_enable_tfo(channel, conn->fd) != ARES_CONN_ERR_SUCCESS) {\n    conn->flags &= ~((unsigned int)ARES_CONN_FLAG_TFO);\n  }\n\n  if (channel->sock_config_cb) {\n    int err =\n      channel->sock_config_cb(conn->fd, stype, channel->sock_config_cb_data);\n    if (err < 0) {\n      status = ARES_ECONNREFUSED;\n      goto done;\n    }\n  }\n\n  /* Connect */\n  status = ares_conn_connect(conn, sa, salen);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (channel->sock_create_cb) {\n    int err =\n      channel->sock_create_cb(conn->fd, stype, channel->sock_create_cb_data);\n    if (err < 0) {\n      status = ARES_ECONNREFUSED;\n      goto done;\n    }\n  }\n\n  /* Let the connection know we haven't written our first packet yet for TFO */\n  if (conn->flags & ARES_CONN_FLAG_TFO) {\n    conn->flags |= ARES_CONN_FLAG_TFO_INITIAL;\n  }\n\n  /* Need to store our own ip for DNS cookie support */\n  status = ares_conn_set_self_ip(conn, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  /* TCP connections are thrown to the end as we don't spawn multiple TCP\n   * connections. UDP connections are put on front where the newest connection\n   * can be quickly pulled */\n  if (is_tcp) {\n    node = ares_llist_insert_last(server->connections, conn);\n  } else {\n    node = ares_llist_insert_first(server->connections, conn);\n  }\n  if (node == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    status = ARES_ENOMEM;\n    goto done;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Register globally to quickly map event on file descriptor to connection\n   * node object */\n  if (!ares_htable_asvp_insert(channel->connnode_by_socket, conn->fd, node)) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    status = ARES_ENOMEM;\n    goto done;\n    /* LCOV_EXCL_STOP */\n  }\n\n  state_flags = ARES_CONN_STATE_READ;\n\n  /* Get notified on connect if using TCP */\n  if (conn->flags & ARES_CONN_FLAG_TCP) {\n    state_flags |= ARES_CONN_STATE_WRITE;\n  }\n\n  /* Dot no attempt to update sock state callbacks on TFO until *after* the\n   * initial write is performed.  Due to the notification event, its possible\n   * an erroneous read can come in before the attempt to write the data which\n   * might be used to set the ip address */\n  if (!(conn->flags & ARES_CONN_FLAG_TFO_INITIAL)) {\n    ares_conn_sock_state_cb_update(conn, state_flags);\n  }\n\n  if (is_tcp) {\n    server->tcp_conn = conn;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_llist_node_claim(node);\n    ares_llist_destroy(conn->queries_to_conn);\n    ares_socket_close(channel, conn->fd);\n    ares_buf_destroy(conn->out_buf);\n    ares_buf_destroy(conn->in_buf);\n    ares_free(conn);\n  } else {\n    *conn_out = conn;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_open_connection",
            "parameters": {
              "conn_out": "ares_conn_t",
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "is_tcp": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_conn_t *ares_conn_from_fd(const ares_channel_t *channel, ares_socket_t fd)\n{\n  ares_llist_node_t *node;\n\n  node = ares_htable_asvp_get_direct(channel->connnode_by_socket, fd);\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return ares_llist_node_val(node);\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_from_fd",
            "parameters": {
              "channel": "ares_channel_t",
              "fd": "ares_socket_t"
            },
            "return_type": "ares_conn_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_conn_from_fd(const ares_channel_t *channel, ares_socket_t fd)",
          "fn_dec_pos": [
            [
              500,
              13
            ],
            [
              500,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_from_fd",
            "parameters": {
              "channel": "ares_channel_t",
              "fd": "ares_socket_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            51,
            4
          ],
          [
            51,
            27
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            58,
            28
          ],
          [
            58,
            43
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            62,
            32
          ],
          [
            62,
            47
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            86,
            44
          ],
          [
            86,
            59
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            92,
            2
          ],
          [
            92,
            20
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            93,
            2
          ],
          [
            93,
            21
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            97,
            13
          ],
          [
            97,
            31
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            108,
            14
          ],
          [
            108,
            33
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            132,
            2
          ],
          [
            132,
            25
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            150,
            41
          ],
          [
            150,
            56
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            164,
            35
          ],
          [
            164,
            50
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            177,
            2
          ],
          [
            177,
            25
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            179,
            2
          ],
          [
            179,
            17
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            193,
            13
          ],
          [
            193,
            28
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            324,
            45
          ],
          [
            324,
            60
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            344,
            2
          ],
          [
            344,
            25
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            346,
            2
          ],
          [
            346,
            17
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            346,
            35
          ],
          [
            346,
            50
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_hosts_file.c": {
      "fn_def_list": [
        {
          "fn_code": "const void *ares_dns_pton(const char *ipaddr, struct ares_addr *addr,\n                          size_t *out_len)\n{\n  const void *ptr     = NULL;\n  size_t      ptr_len = 0;\n\n  if (ipaddr == NULL || addr == NULL || out_len == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *out_len = 0;\n\n  if (addr->family == AF_INET &&\n      ares_inet_pton(AF_INET, ipaddr, &addr->addr.addr4) > 0) {\n    ptr     = &addr->addr.addr4;\n    ptr_len = sizeof(addr->addr.addr4);\n  } else if (addr->family == AF_INET6 &&\n             ares_inet_pton(AF_INET6, ipaddr, &addr->addr.addr6) > 0) {\n    ptr     = &addr->addr.addr6;\n    ptr_len = sizeof(addr->addr.addr6);\n  } else if (addr->family == AF_UNSPEC) {\n    if (ares_inet_pton(AF_INET, ipaddr, &addr->addr.addr4) > 0) {\n      addr->family = AF_INET;\n      ptr          = &addr->addr.addr4;\n      ptr_len      = sizeof(addr->addr.addr4);\n    } else if (ares_inet_pton(AF_INET6, ipaddr, &addr->addr.addr6) > 0) {\n      addr->family = AF_INET6;\n      ptr          = &addr->addr.addr6;\n      ptr_len      = sizeof(addr->addr.addr6);\n    }\n  }\n\n  *out_len = ptr_len;\n  return ptr;\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_pton",
            "parameters": {
              "ipaddr": "char",
              "addr": "struct ares_addr",
              "out_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_normalize_ipaddr(const char *ipaddr, char *out,\n                                         size_t out_len)\n{\n  struct ares_addr data;\n  const void      *addr;\n  size_t           addr_len = 0;\n\n  memset(&data, 0, sizeof(data));\n  data.family = AF_UNSPEC;\n\n  addr = ares_dns_pton(ipaddr, &data, &addr_len);\n  if (addr == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (!ares_inet_ntop(data.family, addr, out, (ares_socklen_t)out_len)) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_normalize_ipaddr",
            "parameters": {
              "ipaddr": "char",
              "out": "char",
              "out_len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_hosts_entry_destroy(ares_hosts_entry_t *entry)\n{\n  if (entry == NULL) {\n    return;\n  }\n\n  /* Honor reference counting */\n  if (entry->refcnt != 0) {\n    entry->refcnt--;\n  }\n\n  if (entry->refcnt > 0) {\n    return;\n  }\n\n  ares_llist_destroy(entry->hosts);\n  ares_llist_destroy(entry->ips);\n  ares_free(entry);\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_entry_destroy",
            "parameters": {
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_hosts_entry_destroy_cb(void *entry)\n{\n  ares_hosts_entry_destroy(entry);\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_entry_destroy_cb",
            "parameters": {
              "entry": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_hosts_file_destroy(ares_hosts_file_t *hf)\n{\n  if (hf == NULL) {\n    return;\n  }\n\n  ares_free(hf->filename);\n  ares_htable_strvp_destroy(hf->hosthash);\n  ares_htable_strvp_destroy(hf->iphash);\n  ares_free(hf);\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_file_destroy",
            "parameters": {
              "hf": "ares_hosts_file_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_hosts_file_t *ares_hosts_file_create(const char *filename)\n{\n  ares_hosts_file_t *hf = ares_malloc_zero(sizeof(*hf));\n  if (hf == NULL) {\n    goto fail;\n  }\n\n  hf->ts = time(NULL);\n\n  hf->filename = ares_strdup(filename);\n  if (hf->filename == NULL) {\n    goto fail;\n  }\n\n  hf->iphash = ares_htable_strvp_create(ares_hosts_entry_destroy_cb);\n  if (hf->iphash == NULL) {\n    goto fail;\n  }\n\n  hf->hosthash = ares_htable_strvp_create(NULL);\n  if (hf->hosthash == NULL) {\n    goto fail;\n  }\n\n  return hf;\n\nfail:\n  ares_hosts_file_destroy(hf);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              226,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_file_create",
            "parameters": {
              "filename": "char"
            },
            "return_type": "ares_hosts_file_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_hosts_file_merge_entry(\n  const ares_hosts_file_t *hf, ares_hosts_entry_t *existing,\n  ares_hosts_entry_t *entry, ares_hosts_file_match_t matchtype)\n{\n  ares_llist_node_t *node;\n\n  /* If we matched on IP address, we know there can only be 1, so there's no\n   * reason to do anything */\n  if (matchtype != ARES_MATCH_IPADDR) {\n    while ((node = ares_llist_node_first(entry->ips)) != NULL) {\n      const char *ipaddr = ares_llist_node_val(node);\n\n      if (ares_htable_strvp_get_direct(hf->iphash, ipaddr) != NULL) {\n        ares_llist_node_destroy(node);\n        continue;\n      }\n\n      ares_llist_node_mvparent_last(node, existing->ips);\n    }\n  }\n\n\n  while ((node = ares_llist_node_first(entry->hosts)) != NULL) {\n    const char *hostname = ares_llist_node_val(node);\n\n    if (ares_htable_strvp_get_direct(hf->hosthash, hostname) != NULL) {\n      ares_llist_node_destroy(node);\n      continue;\n    }\n\n    ares_llist_node_mvparent_last(node, existing->hosts);\n  }\n\n  ares_hosts_entry_destroy(entry);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_file_merge_entry",
            "parameters": {
              "hf": "ares_hosts_file_t",
              "existing": "ares_hosts_entry_t",
              "entry": "ares_hosts_entry_t",
              "matchtype": "ares_hosts_file_match_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_hosts_file_match_t\n  ares_hosts_file_match(const ares_hosts_file_t *hf, ares_hosts_entry_t *entry,\n                        ares_hosts_entry_t **match)\n{\n  ares_llist_node_t *node;\n  *match = NULL;\n\n  for (node = ares_llist_node_first(entry->ips); node != NULL;\n       node = ares_llist_node_next(node)) {\n    const char *ipaddr = ares_llist_node_val(node);\n    *match             = ares_htable_strvp_get_direct(hf->iphash, ipaddr);\n    if (*match != NULL) {\n      return ARES_MATCH_IPADDR;\n    }\n  }\n\n  for (node = ares_llist_node_first(entry->hosts); node != NULL;\n       node = ares_llist_node_next(node)) {\n    const char *host = ares_llist_node_val(node);\n    *match           = ares_htable_strvp_get_direct(hf->hosthash, host);\n    if (*match != NULL) {\n      return ARES_MATCH_HOST;\n    }\n  }\n\n  return ARES_MATCH_NONE;\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_file_match",
            "parameters": {
              "hf": "ares_hosts_file_t",
              "entry": "ares_hosts_entry_t",
              "match": "ares_hosts_entry_t"
            },
            "return_type": "ares_hosts_file_match_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_hosts_file_add(ares_hosts_file_t  *hosts,\n                                         ares_hosts_entry_t *entry)\n{\n  ares_hosts_entry_t     *match  = NULL;\n  ares_status_t           status = ARES_SUCCESS;\n  ares_llist_node_t      *node;\n  ares_hosts_file_match_t matchtype;\n  size_t                  num_hostnames;\n\n  /* Record the number of hostnames in this entry file.  If we merge into an\n   * existing record, these will be *appended* to the entry, so we'll count\n   * backwards when adding to the hosts hashtable */\n  num_hostnames = ares_llist_len(entry->hosts);\n\n  matchtype = ares_hosts_file_match(hosts, entry, &match);\n\n  if (matchtype != ARES_MATCH_NONE) {\n    status = ares_hosts_file_merge_entry(hosts, match, entry, matchtype);\n    if (status != ARES_SUCCESS) {\n      ares_hosts_entry_destroy(entry); /* LCOV_EXCL_LINE: DefensiveCoding */\n      return status;                   /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n    /* entry was invalidated above by merging */\n    entry = match;\n  }\n\n  if (matchtype != ARES_MATCH_IPADDR) {\n    const char *ipaddr = ares_llist_last_val(entry->ips);\n\n    if (!ares_htable_strvp_get(hosts->iphash, ipaddr, NULL)) {\n      if (!ares_htable_strvp_insert(hosts->iphash, ipaddr, entry)) {\n        ares_hosts_entry_destroy(entry);\n        return ARES_ENOMEM;\n      }\n      entry->refcnt++;\n    }\n  }\n\n  /* Go backwards, on a merge, hostnames are appended.  Breakout once we've\n   * consumed all the hosts that we appended */\n  for (node = ares_llist_node_last(entry->hosts); node != NULL;\n       node = ares_llist_node_prev(node)) {\n    const char *val = ares_llist_node_val(node);\n\n    if (num_hostnames == 0) {\n      break;\n    }\n\n    num_hostnames--;\n\n    /* first hostname match wins.  If we detect a duplicate hostname for another\n     * ip it will automatically be added to the same entry */\n    if (ares_htable_strvp_get(hosts->hosthash, val, NULL)) {\n      continue;\n    }\n\n    if (!ares_htable_strvp_insert(hosts->hosthash, val, entry)) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_file_add",
            "parameters": {
              "hosts": "ares_hosts_file_t",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_hosts_entry_isdup(ares_hosts_entry_t *entry,\n                                          const char         *host)\n{\n  ares_llist_node_t *node;\n\n  for (node = ares_llist_node_first(entry->ips); node != NULL;\n       node = ares_llist_node_next(node)) {\n    const char *myhost = ares_llist_node_val(node);\n    if (ares_strcaseeq(myhost, host)) {\n      return ARES_TRUE;\n    }\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_entry_isdup",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "host": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_parse_hosts_hostnames(ares_buf_t         *buf,\n                                                ares_hosts_entry_t *entry)\n{\n  entry->hosts = ares_llist_create(ares_free);\n  if (entry->hosts == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  /* Parse hostnames and aliases */\n  while (ares_buf_len(buf)) {\n    char          hostname[256];\n    char         *temp;\n    ares_status_t status;\n    unsigned char comment = '#';\n\n    ares_buf_consume_whitespace(buf, ARES_FALSE);\n\n    if (ares_buf_len(buf) == 0) {\n      break;\n    }\n\n    /* See if it is a comment, if so stop processing */\n    if (ares_buf_begins_with(buf, &comment, 1)) {\n      break;\n    }\n\n    ares_buf_tag(buf);\n\n    /* Must be at end of line */\n    if (ares_buf_consume_nonwhitespace(buf) == 0) {\n      break;\n    }\n\n    status = ares_buf_tag_fetch_string(buf, hostname, sizeof(hostname));\n    if (status != ARES_SUCCESS) {\n      /* Bad entry, just ignore as long as its not the first.  If its the first,\n       * it must be valid */\n      if (ares_llist_len(entry->hosts) == 0) {\n        return ARES_EBADSTR;\n      }\n\n      continue;\n    }\n\n    /* Validate it is a valid hostname characterset */\n    if (!ares_is_hostname(hostname)) {\n      continue;\n    }\n\n    /* Don't add a duplicate to the same entry */\n    if (ares_hosts_entry_isdup(entry, hostname)) {\n      continue;\n    }\n\n    /* Add to list */\n    temp = ares_strdup(hostname);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n\n    if (ares_llist_insert_last(entry->hosts, temp) == NULL) {\n      ares_free(temp);\n      return ARES_ENOMEM;\n    }\n  }\n\n  /* Must have at least 1 entry */\n  if (ares_llist_len(entry->hosts) == 0) {\n    return ARES_EBADSTR;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              452,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_hosts_hostnames",
            "parameters": {
              "buf": "ares_buf_t",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_parse_hosts_ipaddr(ares_buf_t          *buf,\n                                             ares_hosts_entry_t **entry_out)\n{\n  char                addr[INET6_ADDRSTRLEN];\n  char               *temp;\n  ares_hosts_entry_t *entry = NULL;\n  ares_status_t       status;\n\n  *entry_out = NULL;\n\n  ares_buf_tag(buf);\n  ares_buf_consume_nonwhitespace(buf);\n  status = ares_buf_tag_fetch_string(buf, addr, sizeof(addr));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Validate and normalize the ip address format */\n  if (!ares_normalize_ipaddr(addr, addr, sizeof(addr))) {\n    return ARES_EBADSTR;\n  }\n\n  entry = ares_malloc_zero(sizeof(*entry));\n  if (entry == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  entry->ips = ares_llist_create(ares_free);\n  if (entry->ips == NULL) {\n    ares_hosts_entry_destroy(entry);\n    return ARES_ENOMEM;\n  }\n\n  temp = ares_strdup(addr);\n  if (temp == NULL) {\n    ares_hosts_entry_destroy(entry);\n    return ARES_ENOMEM;\n  }\n\n  if (ares_llist_insert_first(entry->ips, temp) == NULL) {\n    ares_free(temp);\n    ares_hosts_entry_destroy(entry);\n    return ARES_ENOMEM;\n  }\n\n  *entry_out = entry;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              454,
              0
            ],
            [
              502,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_hosts_ipaddr",
            "parameters": {
              "buf": "ares_buf_t",
              "entry_out": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_parse_hosts(const char         *filename,\n                                      ares_hosts_file_t **out)\n{\n  ares_buf_t         *buf    = NULL;\n  ares_status_t       status = ARES_EBADRESP;\n  ares_hosts_file_t  *hf     = NULL;\n  ares_hosts_entry_t *entry  = NULL;\n\n  *out = NULL;\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares_buf_load_file(filename, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  hf = ares_hosts_file_create(filename);\n  if (hf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  while (ares_buf_len(buf)) {\n    unsigned char comment = '#';\n\n    /* -- Start of new line here -- */\n\n    /* Consume any leading whitespace */\n    ares_buf_consume_whitespace(buf, ARES_FALSE);\n\n    if (ares_buf_len(buf) == 0) {\n      break;\n    }\n\n    /* See if it is a comment, if so, consume remaining line */\n    if (ares_buf_begins_with(buf, &comment, 1)) {\n      ares_buf_consume_line(buf, ARES_TRUE);\n      continue;\n    }\n\n    /* Pull off ip address */\n    status = ares_parse_hosts_ipaddr(buf, &entry);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n    if (status != ARES_SUCCESS) {\n      /* Bad line, consume and go onto next */\n      ares_buf_consume_line(buf, ARES_TRUE);\n      continue;\n    }\n\n    /* Parse of the hostnames */\n    status = ares_parse_hosts_hostnames(buf, entry);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    } else if (status != ARES_SUCCESS) {\n      /* Bad line, consume and go onto next */\n      ares_hosts_entry_destroy(entry);\n      entry = NULL;\n      ares_buf_consume_line(buf, ARES_TRUE);\n      continue;\n    }\n\n    /* Append the successful entry to the hosts file */\n    status = ares_hosts_file_add(hf, entry);\n    entry  = NULL; /* is always invalidated by this function, even on error */\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    /* Go to next line */\n    ares_buf_consume_line(buf, ARES_TRUE);\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares_hosts_entry_destroy(entry);\n  ares_buf_destroy(buf);\n  if (status != ARES_SUCCESS) {\n    ares_hosts_file_destroy(hf);\n  } else {\n    *out = hf;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              504,
              0
            ],
            [
              594,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_hosts",
            "parameters": {
              "filename": "char",
              "out": "ares_hosts_file_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_hosts_expired(const char              *filename,\n                                      const ares_hosts_file_t *hf)\n{\n  time_t mod_ts = 0;\n\n#ifdef HAVE_STAT\n  struct stat st;\n  if (stat(filename, &st) == 0) {\n    mod_ts = st.st_mtime;\n  }\n#elif defined(_WIN32)\n  struct _stat st;\n  if (_stat(filename, &st) == 0) {\n    mod_ts = st.st_mtime;\n  }\n#else\n  (void)filename;\n#endif\n\n  if (hf == NULL) {\n    return ARES_TRUE;\n  }\n\n  /* Expire every 60s if we can't get a time */\n  if (mod_ts == 0) {\n    mod_ts =\n      time(NULL) - 60; /* LCOV_EXCL_LINE: only on systems without stat() */\n  }\n\n  /* If filenames are different, its expired */\n  if (!ares_strcaseeq(hf->filename, filename)) {\n    return ARES_TRUE;\n  }\n\n  if (hf->ts <= mod_ts) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              596,
              0
            ],
            [
              635,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_expired",
            "parameters": {
              "filename": "char",
              "hf": "ares_hosts_file_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_hosts_path(const ares_channel_t *channel,\n                                     ares_bool_t use_env, char **path)\n{\n  char *path_hosts = NULL;\n\n  *path = NULL;\n\n  if (channel->hosts_path) {\n    path_hosts = ares_strdup(channel->hosts_path);\n    if (!path_hosts) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  if (use_env) {\n    if (path_hosts) {\n      ares_free(path_hosts);\n    }\n\n    path_hosts = ares_strdup(getenv(\"CARES_HOSTS\"));\n    if (!path_hosts) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  if (!path_hosts) {\n#if defined(USE_WINSOCK)\n    char  PATH_HOSTS[MAX_PATH] = \"\";\n    char  tmp[MAX_PATH];\n    HKEY  hkeyHosts;\n    DWORD dwLength = sizeof(tmp);\n    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ,\n                      &hkeyHosts) != ERROR_SUCCESS) {\n      return ARES_ENOTFOUND;\n    }\n    RegQueryValueExA(hkeyHosts, DATABASEPATH, NULL, NULL, (LPBYTE)tmp,\n                     &dwLength);\n    ExpandEnvironmentStringsA(tmp, PATH_HOSTS, MAX_PATH);\n    RegCloseKey(hkeyHosts);\n    strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n#elif defined(WATT32)\n    const char *PATH_HOSTS = _w32_GetHostsFile();\n\n    if (!PATH_HOSTS) {\n      return ARES_ENOTFOUND;\n    }\n#endif\n    path_hosts = ares_strdup(PATH_HOSTS);\n    if (!path_hosts) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  *path = path_hosts;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              637,
              0
            ],
            [
              692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_path",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "path": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_hosts_update(ares_channel_t *channel,\n                                       ares_bool_t     use_env)\n{\n  ares_status_t status;\n  char         *filename = NULL;\n\n  status = ares_hosts_path(channel, use_env, &filename);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (!ares_hosts_expired(filename, channel->hf)) {\n    ares_free(filename);\n    return ARES_SUCCESS;\n  }\n\n  ares_hosts_file_destroy(channel->hf);\n  channel->hf = NULL;\n\n  status = ares_parse_hosts(filename, &channel->hf);\n  ares_free(filename);\n  return status;\n}",
          "fn_code_pos": [
            [
              694,
              0
            ],
            [
              716,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_update",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_hosts_search_ipaddr(ares_channel_t *channel,\n                                       ares_bool_t use_env, const char *ipaddr,\n                                       const ares_hosts_entry_t **entry)\n{\n  ares_status_t status;\n  char          addr[INET6_ADDRSTRLEN];\n\n  *entry = NULL;\n\n  status = ares_hosts_update(channel, use_env);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (channel->hf == NULL) {\n    return ARES_ENOTFOUND; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (!ares_normalize_ipaddr(ipaddr, addr, sizeof(addr))) {\n    return ARES_EBADNAME;\n  }\n\n  *entry = ares_htable_strvp_get_direct(channel->hf->iphash, addr);\n  if (*entry == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              718,
              0
            ],
            [
              746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_search_ipaddr",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "ipaddr": "char",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_hosts_search_host(ares_channel_t *channel,\n                                     ares_bool_t use_env, const char *host,\n                                     const ares_hosts_entry_t **entry)\n{\n  ares_status_t status;\n\n  *entry = NULL;\n\n  status = ares_hosts_update(channel, use_env);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (channel->hf == NULL) {\n    return ARES_ENOTFOUND; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *entry = ares_htable_strvp_get_direct(channel->hf->hosthash, host);\n  if (*entry == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              748,
              0
            ],
            [
              771,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_search_host",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "host": "char",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_hosts_ai_append_cnames(const ares_hosts_entry_t    *entry,\n                              struct ares_addrinfo_cname **cnames_out)\n{\n  struct ares_addrinfo_cname *cname  = NULL;\n  struct ares_addrinfo_cname *cnames = NULL;\n  const char                 *primaryhost;\n  ares_llist_node_t          *node;\n  ares_status_t               status;\n  size_t                      cnt = 0;\n\n  node        = ares_llist_node_first(entry->hosts);\n  primaryhost = ares_llist_node_val(node);\n  /* Skip to next node to start with aliases */\n  node = ares_llist_node_next(node);\n\n  while (node != NULL) {\n    const char *host = ares_llist_node_val(node);\n\n    /* Cap at 100 entries. , some people use\n     * https://github.com/StevenBlack/hosts and we don't need 200k+ aliases */\n    cnt++;\n    if (cnt > 100) {\n      break; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    cname = ares_append_addrinfo_cname(&cnames);\n    if (cname == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    cname->alias = ares_strdup(host);\n    if (cname->alias == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    cname->name = ares_strdup(primaryhost);\n    if (cname->name == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    node = ares_llist_node_next(node);\n  }\n\n  /* No entries, add only primary */\n  if (cnames == NULL) {\n    cname = ares_append_addrinfo_cname(&cnames);\n    if (cname == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    cname->name = ares_strdup(primaryhost);\n    if (cname->name == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n  status = ARES_SUCCESS;\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_freeaddrinfo_cnames(cnames); /* LCOV_EXCL_LINE: DefensiveCoding */\n    return status;                    /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *cnames_out = cnames;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              773,
              0
            ],
            [
              844,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_ai_append_cnames",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "cnames_out": "struct ares_addrinfo_cname"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_hosts_entry_to_addrinfo(const ares_hosts_entry_t *entry,\n                                           const char *name, int family,\n                                           unsigned short        port,\n                                           ares_bool_t           want_cnames,\n                                           struct ares_addrinfo *ai)\n{\n  ares_status_t               status  = ARES_ENOTFOUND;\n  struct ares_addrinfo_cname *cnames  = NULL;\n  struct ares_addrinfo_node  *ainodes = NULL;\n  ares_llist_node_t          *node;\n\n  switch (family) {\n    case AF_INET:\n    case AF_INET6:\n    case AF_UNSPEC:\n      break;\n    default:                  /* LCOV_EXCL_LINE: DefensiveCoding */\n      return ARES_EBADFAMILY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (name != NULL) {\n    ares_free(ai->name);\n    ai->name = ares_strdup(name);\n    if (ai->name == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  for (node = ares_llist_node_first(entry->ips); node != NULL;\n       node = ares_llist_node_next(node)) {\n    struct ares_addr addr;\n    const void      *ptr     = NULL;\n    size_t           ptr_len = 0;\n    const char      *ipaddr  = ares_llist_node_val(node);\n\n    memset(&addr, 0, sizeof(addr));\n    addr.family = family;\n    ptr         = ares_dns_pton(ipaddr, &addr, &ptr_len);\n\n    if (ptr == NULL) {\n      continue;\n    }\n\n    status = ares_append_ai_node(addr.family, port, 0, ptr, &ainodes);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n  }\n\n  /* Might be ARES_ENOTFOUND here if no ips matched requested address family */\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (want_cnames) {\n    status = ares_hosts_ai_append_cnames(entry, &cnames);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  if (status != ARES_SUCCESS) {\n    /* LCOV_EXCL_START: defensive coding */\n    ares_freeaddrinfo_cnames(cnames);\n    ares_freeaddrinfo_nodes(ainodes);\n    ares_free(ai->name);\n    ai->name = NULL;\n    return status;\n    /* LCOV_EXCL_STOP */\n  }\n  ares_addrinfo_cat_cnames(&ai->cnames, cnames);\n  ares_addrinfo_cat_nodes(&ai->nodes, ainodes);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              846,
              0
            ],
            [
              924,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_entry_to_addrinfo",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "name": "char",
              "family": "int",
              "port": "unsigned short",
              "want_cnames": "ares_bool_t",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_hosts_entry_to_hostent(const ares_hosts_entry_t *entry,\n                                          int family, struct hostent **hostent)\n{\n  ares_status_t         status;\n  struct ares_addrinfo *ai = ares_malloc_zero(sizeof(*ai));\n\n  *hostent = NULL;\n\n  if (ai == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_hosts_entry_to_addrinfo(entry, NULL, family, 0, ARES_TRUE, ai);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_addrinfo2hostent(ai, family, hostent);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_freeaddrinfo(ai);\n  if (status != ARES_SUCCESS) {\n    ares_free_hostent(*hostent);\n    *hostent = NULL;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              926,
              0
            ],
            [
              956,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_entry_to_hostent",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "family": "int",
              "hostent": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_pton(const char *ipaddr, struct ares_addr *addr,\n                          size_t *out_len)",
          "fn_dec_pos": [
            [
              102,
              12
            ],
            [
              103,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_pton",
            "parameters": {
              "ipaddr": "char",
              "addr": "struct ares_addr",
              "out_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_hosts_file_create(const char *filename)",
          "fn_dec_pos": [
            [
              197,
              26
            ],
            [
              197,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_file_create",
            "parameters": {
              "filename": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_hosts_file {\n  time_t               ts;\n  /*! cache the filename so we know if the filename changes it automatically\n   *  invalidates the cache */\n  char                *filename;\n  /*! iphash is the owner of the 'entry' object as there is only ever a single\n   *  match to the object. */\n  ares_htable_strvp_t *iphash;\n  /*! hosthash does not own the entry so won't free on destruction */\n  ares_htable_strvp_t *hosthash;\n}",
          {
            "ts": "time_t",
            "*filename": "char",
            "*iphash": "ares_htable_strvp_t",
            "*hosthash": "ares_htable_strvp_t"
          },
          "ares_hosts_file",
          [
            83,
            0
          ],
          [
            93,
            1
          ]
        ],
        [
          "struct ares_hosts_entry {\n  size_t        refcnt; /*! If the entry is stored multiple times in the\n                         *  ip address hash, we have to reference count it */\n  ares_llist_t *ips;\n  ares_llist_t *hosts;\n}",
          {
            "refcnt": "size_t",
            "*ips": "ares_llist_t",
            "*hosts": "ares_llist_t"
          },
          "ares_hosts_entry",
          [
            95,
            0
          ],
          [
            100,
            1
          ]
        ],
        [
          "struct ares_hosts_file {\n  time_t               ts;\n  /*! cache the filename so we know if the filename changes it automatically\n   *  invalidates the cache */\n  char                *filename;\n  /*! iphash is the owner of the 'entry' object as there is only ever a single\n   *  match to the object. */\n  ares_htable_strvp_t *iphash;\n  /*! hosthash does not own the entry so won't free on destruction */\n  ares_htable_strvp_t *hosthash;\n}",
          {
            "ts": "time_t",
            "*filename": "char",
            "*iphash": "ares_htable_strvp_t",
            "*hosthash": "ares_htable_strvp_t"
          },
          "ares_hosts_file",
          [
            83,
            0
          ],
          [
            93,
            1
          ]
        ],
        [
          "struct ares_hosts_entry {\n  size_t        refcnt; /*! If the entry is stored multiple times in the\n                         *  ip address hash, we have to reference count it */\n  ares_llist_t *ips;\n  ares_llist_t *hosts;\n}",
          {
            "refcnt": "size_t",
            "*ips": "ares_llist_t",
            "*hosts": "ares_llist_t"
          },
          "ares_hosts_entry",
          [
            95,
            0
          ],
          [
            100,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            102,
            46
          ],
          [
            102,
            62
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            141,
            2
          ],
          [
            141,
            18
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            602,
            2
          ],
          [
            602,
            13
          ]
        ],
        [
          "struct _stat",
          {},
          "",
          [
            607,
            2
          ],
          [
            607,
            14
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            775,
            30
          ],
          [
            775,
            56
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            777,
            2
          ],
          [
            777,
            28
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            778,
            2
          ],
          [
            778,
            28
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            850,
            43
          ],
          [
            850,
            63
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            853,
            2
          ],
          [
            853,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            854,
            2
          ],
          [
            854,
            27
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            877,
            4
          ],
          [
            877,
            20
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            927,
            54
          ],
          [
            927,
            68
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            930,
            2
          ],
          [
            930,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/stat.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_MATCH_NONE   = 0,\n  ARES_MATCH_IPADDR = 1,\n  ARES_MATCH_HOST   = 2\n} ares_hosts_file_match_t;",
          {
            "ARES_MATCH_NONE": "",
            "ARES_MATCH_IPADDR": "",
            "ARES_MATCH_HOST": ""
          },
          "ares_hosts_file_match_t",
          [
            228,
            0
          ],
          [
            232,
            26
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_cancel.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_cancel(ares_channel_t *channel)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  ares_channel_lock(channel);\n\n  if (ares_llist_len(channel->all_queries) > 0) {\n    ares_llist_node_t *node = NULL;\n    ares_llist_node_t *next = NULL;\n\n    /* Swap list heads, so that only those queries which were present on entry\n     * into this function are cancelled. New queries added by callbacks of\n     * queries being cancelled will not be cancelled themselves.\n     */\n    ares_llist_t      *list_copy = channel->all_queries;\n    channel->all_queries         = ares_llist_create(NULL);\n\n    /* Out of memory, this function doesn't return a result code though so we\n     * can't report to caller */\n    if (channel->all_queries == NULL) {\n      channel->all_queries = list_copy; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;                        /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    node = ares_llist_node_first(list_copy);\n    while (node != NULL) {\n      ares_query_t *query;\n\n      /* Cache next since this node is being deleted */\n      next = ares_llist_node_next(node);\n\n      query                   = ares_llist_node_claim(node);\n      query->node_all_queries = NULL;\n\n      /* NOTE: its possible this may enqueue new queries */\n      query->callback(query->arg, ARES_ECANCELLED, 0, NULL);\n      ares_free_query(query);\n\n      node = next;\n    }\n\n    ares_llist_destroy(list_copy);\n  }\n\n  /* See if the connections should be cleaned up */\n  ares_check_cleanup_conns(channel);\n\n  ares_queue_notify_empty(channel);\n\ndone:\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cancel",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/inet_net_pton.c": {
      "fn_def_list": [
        {
          "fn_code": "static int ares_inet_net_pton_ipv4(const char *src, unsigned char *dst,\n                                   size_t size)\n{\n  static const char    xdigits[] = \"0123456789abcdef\";\n  static const char    digits[]  = \"0123456789\";\n  int                  n;\n  int                  ch;\n  int                  tmp = 0;\n  int                  dirty;\n  int                  bits;\n  const unsigned char *odst = dst;\n\n  memset(dst, 0, size);\n  ch = *src++;\n  if (ch == '0' && (src[0] == 'x' || src[0] == 'X') && ares_isascii(src[1]) &&\n      ares_isxdigit(src[1])) {\n    /* Hexadecimal: Eat nybble string. */\n    if (!size) {\n      goto emsgsize;\n    }\n    dirty = 0;\n    src++; /* skip x or X. */\n    while ((ch = *src++) != '\\0' && ares_isascii(ch) && ares_isxdigit(ch)) {\n      if (ares_isupper(ch)) {\n        ch = ares_tolower((unsigned char)ch);\n      }\n      n = (int)(strchr(xdigits, ch) - xdigits);\n      if (dirty == 0) {\n        tmp = n;\n      } else {\n        tmp = (tmp << 4) | n;\n      }\n      if (++dirty == 2) {\n        if (!size--) {\n          goto emsgsize;\n        }\n        *dst++ = (unsigned char)tmp;\n        dirty  = 0;\n      }\n    }\n    if (dirty) { /* Odd trailing nybble? */\n      if (!size--) {\n        goto emsgsize;\n      }\n      *dst++ = (unsigned char)(tmp << 4);\n    }\n  } else if (ares_isascii(ch) && ares_isdigit(ch)) {\n    /* Decimal: eat dotted digit string. */\n    for (;;) {\n      tmp = 0;\n      do {\n        n    = (int)(strchr(digits, ch) - digits);\n        tmp *= 10;\n        tmp += n;\n        if (tmp > 255) {\n          goto enoent;\n        }\n      } while ((ch = *src++) != '\\0' && ares_isascii(ch) && ares_isdigit(ch));\n      if (!size--) {\n        goto emsgsize;\n      }\n      *dst++ = (unsigned char)tmp;\n      if (ch == '\\0' || ch == '/') {\n        break;\n      }\n      if (ch != '.') {\n        goto enoent;\n      }\n      ch = *src++;\n      if (!ares_isascii(ch) || !ares_isdigit(ch)) {\n        goto enoent;\n      }\n    }\n  } else {\n    goto enoent;\n  }\n\n  bits = -1;\n  if (ch == '/' && ares_isascii(src[0]) && ares_isdigit(src[0]) && dst > odst) {\n    /* CIDR width specifier.  Nothing can follow it. */\n    ch   = *src++; /* Skip over the /. */\n    bits = 0;\n    do {\n      n     = (int)(strchr(digits, ch) - digits);\n      bits *= 10;\n      bits += n;\n      if (bits > 32) {\n        goto enoent;\n      }\n    } while ((ch = *src++) != '\\0' && ares_isascii(ch) && ares_isdigit(ch));\n    if (ch != '\\0') {\n      goto enoent;\n    }\n  }\n\n  /* Firey death and destruction unless we prefetched EOS. */\n  if (ch != '\\0') {\n    goto enoent;\n  }\n\n  /* If nothing was written to the destination, we found no address. */\n  if (dst == odst) {\n    goto enoent; /* LCOV_EXCL_LINE: all valid paths above increment dst */\n  }\n  /* If no CIDR spec was given, infer width from net class. */\n  if (bits == -1) {\n    if (*odst >= 240) {        /* Class E */\n      bits = 32;\n    } else if (*odst >= 224) { /* Class D */\n      bits = 8;\n    } else if (*odst >= 192) { /* Class C */\n      bits = 24;\n    } else if (*odst >= 128) { /* Class B */\n      bits = 16;\n    } else {                   /* Class A */\n      bits = 8;\n    }\n    /* If imputed mask is narrower than specified octets, widen. */\n    if (bits < ((dst - odst) * 8)) {\n      bits = (int)(dst - odst) * 8;\n    }\n    /*\n     * If there are no additional bits specified for a class D\n     * address adjust bits to 4.\n     */\n    if (bits == 8 && *odst == 224) {\n      bits = 4;\n    }\n  }\n  /* Extend network to cover the actual mask. */\n  while (bits > ((dst - odst) * 8)) {\n    if (!size--) {\n      goto emsgsize;\n    }\n    *dst++ = '\\0';\n  }\n  return bits;\n\nenoent:\n  SET_SOCKERRNO(ENOENT);\n  return -1;\n\nemsgsize:\n  SET_SOCKERRNO(EMSGSIZE);\n  return -1;\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_net_pton_ipv4",
            "parameters": {
              "src": "char",
              "dst": "unsigned char",
              "size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int getbits(const char *src, size_t *bitsp)\n{\n  static const char digits[] = \"0123456789\";\n  size_t            n;\n  size_t            val;\n  char              ch;\n\n  val = 0;\n  n   = 0;\n  while ((ch = *src++) != '\\0') {\n    const char *pch;\n\n    pch = strchr(digits, ch);\n    if (pch != NULL) {\n      if (n++ != 0 && val == 0) { /* no leading zeros */\n        return 0;\n      }\n      val *= 10;\n      val += (size_t)(pch - digits);\n      if (val > 128) { /* range */\n        return 0;\n      }\n      continue;\n    }\n    return 0;\n  }\n  if (n == 0) {\n    return 0;\n  }\n  *bitsp = val;\n  return 1;\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getbits",
            "parameters": {
              "src": "char",
              "bitsp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ares_inet_pton6(const char *src, unsigned char *dst)\n{\n  static const char xdigits_l[] = \"0123456789abcdef\";\n  static const char xdigits_u[] = \"0123456789ABCDEF\";\n  unsigned char     tmp[NS_IN6ADDRSZ];\n  unsigned char    *tp;\n  unsigned char    *endp;\n  unsigned char    *colonp;\n  const char       *xdigits;\n  const char       *curtok;\n  int               ch;\n  int               saw_xdigit;\n  int               count_xdigit;\n  unsigned int      val;\n\n  memset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n  endp   = tp + NS_IN6ADDRSZ;\n  colonp = NULL;\n  /* Leading :: requires some special handling. */\n  if (*src == ':') {\n    if (*++src != ':') {\n      goto enoent;\n    }\n  }\n  curtok     = src;\n  saw_xdigit = count_xdigit = 0;\n  val                       = 0;\n  while ((ch = *src++) != '\\0') {\n    const char *pch;\n\n    if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL) {\n      pch = strchr((xdigits = xdigits_u), ch);\n    }\n    if (pch != NULL) {\n      if (count_xdigit >= 4) {\n        goto enoent;\n      }\n      val <<= 4;\n      val  |= (unsigned int)(pch - xdigits);\n      if (val > 0xffff) {\n        goto enoent;\n      }\n      saw_xdigit = 1;\n      count_xdigit++;\n      continue;\n    }\n    if (ch == ':') {\n      curtok = src;\n      if (!saw_xdigit) {\n        if (colonp) {\n          goto enoent;\n        }\n        colonp = tp;\n        continue;\n      } else if (*src == '\\0') {\n        goto enoent;\n      }\n      if (tp + NS_INT16SZ > endp) {\n        goto enoent;\n      }\n      *tp++        = (unsigned char)(val >> 8) & 0xff;\n      *tp++        = (unsigned char)val & 0xff;\n      saw_xdigit   = 0;\n      count_xdigit = 0;\n      val          = 0;\n      continue;\n    }\n    if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n        ares_inet_net_pton_ipv4(curtok, tp, NS_INADDRSZ) > 0) {\n      tp         += NS_INADDRSZ;\n      saw_xdigit  = 0;\n      break; /* '\\0' was seen by inet_pton4(). */\n    }\n    goto enoent;\n  }\n  if (saw_xdigit) {\n    if (tp + NS_INT16SZ > endp) {\n      goto enoent;\n    }\n    *tp++ = (unsigned char)(val >> 8) & 0xff;\n    *tp++ = (unsigned char)val & 0xff;\n  }\n  if (colonp != NULL) {\n    /*\n     * Since some memmove()'s erroneously fail to handle\n     * overlapping regions, we'll do the shift by hand.\n     */\n    const int n = (int)(tp - colonp);\n    int       i;\n\n    if (tp == endp) {\n      goto enoent;\n    }\n    for (i = 1; i <= n; i++) {\n      endp[-i]      = colonp[n - i];\n      colonp[n - i] = 0;\n    }\n    tp = endp;\n  }\n  if (tp != endp) {\n    goto enoent;\n  }\n\n  memcpy(dst, tmp, NS_IN6ADDRSZ);\n  return 1;\n\nenoent:\n  SET_SOCKERRNO(ENOENT);\n  return -1;\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_pton6",
            "parameters": {
              "src": "char",
              "dst": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ares_inet_net_pton_ipv6(const char *src, unsigned char *dst,\n                                   size_t size)\n{\n  struct ares_in6_addr in6;\n  int                  ret;\n  size_t               bits;\n  size_t               bytes;\n  char                 buf[INET6_ADDRSTRLEN + sizeof(\"/128\")];\n  char                *sep;\n\n  if (ares_strlen(src) >= sizeof buf) {\n    SET_SOCKERRNO(EMSGSIZE);\n    return -1;\n  }\n  ares_strcpy(buf, src, sizeof buf);\n\n  sep = strchr(buf, '/');\n  if (sep != NULL) {\n    *sep++ = '\\0';\n  }\n\n  ret = ares_inet_pton6(buf, (unsigned char *)&in6);\n  if (ret != 1) {\n    return -1;\n  }\n\n  if (sep == NULL) {\n    bits = 128;\n  } else {\n    if (!getbits(sep, &bits)) {\n      SET_SOCKERRNO(ENOENT);\n      return -1;\n    }\n  }\n\n  bytes = (bits + 7) / 8;\n  if (bytes > size) {\n    SET_SOCKERRNO(EMSGSIZE);\n    return -1;\n  }\n  memcpy(dst, &in6, bytes);\n  return (int)bits;\n}",
          "fn_code_pos": [
            [
              363,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_net_pton_ipv6",
            "parameters": {
              "src": "char",
              "dst": "unsigned char",
              "size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_inet_net_pton(int af, const char *src, void *dst, size_t size)\n{\n  switch (af) {\n    case AF_INET:\n      return ares_inet_net_pton_ipv4(src, dst, size);\n    case AF_INET6:\n      return ares_inet_net_pton_ipv6(src, dst, size);\n    default:\n      return -1;\n  }\n}",
          "fn_code_pos": [
            [
              421,
              0
            ],
            [
              431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_net_pton",
            "parameters": {
              "af": "int",
              "src": "char",
              "dst": "void",
              "size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_inet_pton(int af, const char *src, void *dst)\n{\n  int    result;\n  size_t size;\n\n  if (af == AF_INET) {\n    size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    size = sizeof(struct ares_in6_addr);\n  } else {\n    SET_SOCKERRNO(EAFNOSUPPORT);\n    return -1;\n  }\n  result = ares_inet_net_pton(af, src, dst, size);\n  if (result == -1 && SOCKERRNO == ENOENT) {\n    return 0;\n  }\n  return (result > -1) ? 1 : -1;\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_pton",
            "parameters": {
              "af": "int",
              "src": "char",
              "dst": "void"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            48,
            6
          ],
          [
            48,
            26
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            366,
            2
          ],
          [
            366,
            22
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            439,
            18
          ],
          [
            439,
            32
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            441,
            18
          ],
          [
            441,
            38
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_library_init.c": {
      "fn_def_list": [
        {
          "fn_code": "static void        *default_malloc(size_t size)\n{\n  if (size == 0) {\n    return NULL;\n  }\n  return malloc(size);\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void *default_realloc(void *p, size_t size)\n{\n  return realloc(p, size);\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_realloc",
            "parameters": {
              "p": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void default_free(void *p)\n{\n  free(p);\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_free",
            "parameters": {
              "p": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_malloc(size_t size)\n{\n  return __ares_malloc(size);\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_realloc(void *ptr, size_t size)\n{\n  return __ares_realloc(ptr, size);\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_free(void *ptr)\n{\n  __ares_free(ptr);\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_malloc_zero(size_t size)\n{\n  void *ptr = ares_malloc(size);\n  if (ptr != NULL) {\n    memset(ptr, 0, size);\n  }\n\n  return ptr;\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_zero",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_realloc_zero(void *ptr, size_t orig_size, size_t new_size)\n{\n  void *p = ares_realloc(ptr, new_size);\n  if (p == NULL) {\n    return NULL;\n  }\n\n  if (new_size > orig_size) {\n    memset((unsigned char *)p + orig_size, 0, new_size - orig_size);\n  }\n\n  return p;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc_zero",
            "parameters": {
              "ptr": "void",
              "orig_size": "size_t",
              "new_size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_library_init(int flags)\n{\n  if (ares_initialized) {\n    ares_initialized++;\n    return ARES_SUCCESS;\n  }\n  ares_initialized++;\n\n  /* NOTE: ARES_LIB_INIT_WIN32 flag no longer used */\n\n  ares_init_flags = flags;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init",
            "parameters": {
              "flags": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_library_init_mem(int flags, void *(*amalloc)(size_t size),\n                          void (*afree)(void *ptr),\n                          void *(*arealloc)(void *ptr, size_t size))\n{\n  if (amalloc) {\n    __ares_malloc = amalloc;\n  }\n  if (arealloc) {\n    __ares_realloc = arealloc;\n  }\n  if (afree) {\n    __ares_free = afree;\n  }\n  return ares_library_init(flags);\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_mem",
            "parameters": {
              "flags": "int",
              "amalloc": "void",
              "size": "size_t",
              "afree": "void",
              "ptr": "void",
              "arealloc": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares_library_cleanup(void)\n{\n  if (!ares_initialized) {\n    return;\n  }\n  ares_initialized--;\n  if (ares_initialized) {\n    return;\n  }\n\n  /* NOTE: ARES_LIB_INIT_WIN32 flag no longer used */\n\n#if defined(ANDROID) || defined(__ANDROID__)\n  ares_library_cleanup_android();\n#endif\n\n  ares_init_flags = ARES_LIB_INIT_NONE;\n  __ares_malloc   = default_malloc;\n  __ares_realloc  = default_realloc;\n  __ares_free     = default_free;\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_cleanup",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_library_initialized(void)\n{\n#ifdef USE_WINSOCK\n  if (!ares_initialized) {\n    return ARES_ENOTINITIALIZED;\n  }\n#endif\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_initialized",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "default_malloc(size_t size)",
          "fn_dec_pos": [
            [
              46,
              20
            ],
            [
              46,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "default_realloc(void *p, size_t size)",
          "fn_dec_pos": [
            [
              54,
              13
            ],
            [
              54,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_realloc",
            "parameters": {
              "p": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*__ares_malloc)(size_t size)",
          "fn_dec_pos": [
            [
              64,
              13
            ],
            [
              64,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*__ares_realloc)(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              65,
              13
            ],
            [
              65,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*__ares_free)(void *ptr)",
          "fn_dec_pos": [
            [
              66,
              12
            ],
            [
              66,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_malloc(size_t size)",
          "fn_dec_pos": [
            [
              68,
              6
            ],
            [
              68,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_realloc(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              73,
              6
            ],
            [
              73,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_malloc_zero(size_t size)",
          "fn_dec_pos": [
            [
              83,
              6
            ],
            [
              83,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_zero",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_realloc_zero(void *ptr, size_t orig_size, size_t new_size)",
          "fn_dec_pos": [
            [
              93,
              6
            ],
            [
              93,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc_zero",
            "parameters": {
              "ptr": "void",
              "orig_size": "size_t",
              "new_size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*amalloc)(size_t size)",
          "fn_dec_pos": [
            [
              122,
              43
            ],
            [
              122,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*afree)(void *ptr)",
          "fn_dec_pos": [
            [
              123,
              31
            ],
            [
              123,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*arealloc)(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              124,
              32
            ],
            [
              124,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_getenv.c": {
      "fn_def_list": [
        {
          "fn_code": "char *ares_getenv(const char *name)\n{\n  return NULL;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getenv",
            "parameters": {
              "name": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_getenv(const char *name)",
          "fn_dec_pos": [
            [
              32,
              6
            ],
            [
              32,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getenv",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_getenv.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_query.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_query_dnsrec_cb(void *arg, ares_status_t status,\n                                 size_t                   timeouts,\n                                 const ares_dns_record_t *dnsrec)\n{\n  ares_query_dnsrec_arg_t *qquery = arg;\n\n  if (status != ARES_SUCCESS) {\n    qquery->callback(qquery->arg, status, timeouts, dnsrec);\n  } else {\n    size_t           ancount;\n    ares_dns_rcode_t rcode;\n    /* Pull the response code and answer count from the packet and convert any\n     * errors.\n     */\n    rcode   = ares_dns_record_get_rcode(dnsrec);\n    ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n    status  = ares_dns_query_reply_tostatus(rcode, ancount);\n    qquery->callback(qquery->arg, status, timeouts, dnsrec);\n  }\n  ares_free(qquery);\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_dnsrec_cb",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_query_nolock(ares_channel_t *channel, const char *name,\n                                ares_dns_class_t     dnsclass,\n                                ares_dns_rec_type_t  type,\n                                ares_callback_dnsrec callback, void *arg,\n                                unsigned short *qid)\n{\n  ares_status_t            status;\n  ares_dns_record_t       *dnsrec = NULL;\n  ares_dns_flags_t         flags  = 0;\n  ares_query_dnsrec_arg_t *qquery = NULL;\n\n  if (channel == NULL || name == NULL || callback == NULL) {\n    /* LCOV_EXCL_START: DefensiveCoding */\n    status = ARES_EFORMERR;\n    if (callback != NULL) {\n      callback(arg, status, 0, NULL);\n    }\n    return status;\n    /* LCOV_EXCL_STOP */\n  }\n\n  if (!(channel->flags & ARES_FLAG_NORECURSE)) {\n    flags |= ARES_FLAG_RD;\n  }\n\n  status = ares_dns_record_create_query(\n    &dnsrec, name, dnsclass, type, 0, flags,\n    (size_t)(channel->flags & ARES_FLAG_EDNS) ? channel->ednspsz : 0);\n  if (status != ARES_SUCCESS) {\n    callback(arg, status, 0, NULL); /* LCOV_EXCL_LINE: OutOfMemory */\n    return status;                  /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  qquery = ares_malloc(sizeof(*qquery));\n  if (qquery == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    status = ARES_ENOMEM;\n    callback(arg, status, 0, NULL);\n    ares_dns_record_destroy(dnsrec);\n    return status;\n    /* LCOV_EXCL_STOP */\n  }\n\n  qquery->callback = callback;\n  qquery->arg      = arg;\n\n  /* Send it off.  qcallback will be called when we get an answer. */\n  status = ares_send_nolock(channel, NULL, 0, dnsrec, ares_query_dnsrec_cb,\n                            qquery, qid);\n\n  ares_dns_record_destroy(dnsrec);\n  return status;\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_nolock",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_query_dnsrec(ares_channel_t *channel, const char *name,\n                                ares_dns_class_t     dnsclass,\n                                ares_dns_rec_type_t  type,\n                                ares_callback_dnsrec callback, void *arg,\n                                unsigned short *qid)\n{\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares_channel_lock(channel);\n  status = ares_query_nolock(channel, name, dnsclass, type, callback, arg, qid);\n  ares_channel_unlock(channel);\n  return status;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_query(ares_channel_t *channel, const char *name, int dnsclass,\n                int type, ares_callback callback, void *arg)\n{\n  void *carg = NULL;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  carg = ares_dnsrec_convert_arg(callback, arg);\n  if (carg == NULL) {\n    callback(arg, ARES_ENOMEM, 0, NULL, 0); /* LCOV_EXCL_LINE: OutOfMemory */\n    return;                                 /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  ares_query_dnsrec(channel, name, (ares_dns_class_t)dnsclass,\n                    (ares_dns_rec_type_t)type, ares_dnsrec_convert_cb, carg,\n                    NULL);\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  ares_callback_dnsrec callback;\n  void                *arg;\n} ares_query_dnsrec_arg_t;",
          {
            "callback": "ares_callback_dnsrec",
            "*arg": "void"
          },
          "ares_query_dnsrec_arg_t",
          [
            33,
            0
          ],
          [
            36,
            26
          ]
        ],
        [
          "typedef struct {\n  ares_callback_dnsrec callback;\n  void                *arg;\n} ares_query_dnsrec_arg_t;",
          {
            "callback": "ares_callback_dnsrec",
            "*arg": "void"
          },
          "ares_query_dnsrec_arg_t",
          [
            33,
            0
          ],
          [
            36,
            26
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_timeout.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_timeval_remaining(ares_timeval_t       *remaining,\n                            const ares_timeval_t *now,\n                            const ares_timeval_t *tout)\n{\n  memset(remaining, 0, sizeof(*remaining));\n\n  /* Expired! */\n  if (tout->sec < now->sec ||\n      (tout->sec == now->sec && tout->usec < now->usec)) {\n    return;\n  }\n\n  remaining->sec = tout->sec - now->sec;\n  if (tout->usec < now->usec) {\n    remaining->sec  -= 1;\n    remaining->usec  = (tout->usec + 1000000) - now->usec;\n  } else {\n    remaining->usec = tout->usec - now->usec;\n  }\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeval_remaining",
            "parameters": {
              "remaining": "ares_timeval_t",
              "now": "ares_timeval_t",
              "tout": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_timeval_diff(ares_timeval_t *tvdiff, const ares_timeval_t *tvstart,\n                       const ares_timeval_t *tvstop)\n{\n  tvdiff->sec = tvstop->sec - tvstart->sec;\n  if (tvstop->usec > tvstart->usec) {\n    tvdiff->usec = tvstop->usec - tvstart->usec;\n  } else {\n    tvdiff->sec  -= 1;\n    tvdiff->usec  = tvstop->usec + 1000000 - tvstart->usec;\n  }\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeval_diff",
            "parameters": {
              "tvdiff": "ares_timeval_t",
              "tvstart": "ares_timeval_t",
              "tvstop": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_timeval_to_struct_timeval(struct timeval       *tv,\n                                           const ares_timeval_t *atv)\n{\n#ifdef USE_WINSOCK\n  tv->tv_sec = (long)atv->sec;\n#else\n  tv->tv_sec = (time_t)atv->sec;\n#endif\n\n  tv->tv_usec = (int)atv->usec;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeval_to_struct_timeval",
            "parameters": {
              "tv": "struct timeval",
              "atv": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void struct_timeval_to_ares_timeval(ares_timeval_t       *atv,\n                                           const struct timeval *tv)\n{\n  atv->sec  = (ares_int64_t)tv->tv_sec;\n  atv->usec = (unsigned int)tv->tv_usec;\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "struct_timeval_to_ares_timeval",
            "parameters": {
              "atv": "ares_timeval_t",
              "tv": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct timeval *ares_timeout_int(const ares_channel_t *channel,\n                                        struct timeval       *maxtv,\n                                        struct timeval       *tvbuf)\n{\n  const ares_query_t *query;\n  ares_slist_node_t  *node;\n  ares_timeval_t      now;\n  ares_timeval_t      atvbuf;\n  ares_timeval_t      amaxtv;\n\n  /* The minimum timeout of all queries is always the first entry in\n   * channel->queries_by_timeout */\n  node = ares_slist_node_first(channel->queries_by_timeout);\n  /* no queries/timeout */\n  if (node == NULL) {\n    return maxtv;\n  }\n\n  query = ares_slist_node_val(node);\n\n  ares_tvnow(&now);\n\n  ares_timeval_remaining(&atvbuf, &now, &query->timeout);\n\n  ares_timeval_to_struct_timeval(tvbuf, &atvbuf);\n\n  if (maxtv == NULL) {\n    return tvbuf;\n  }\n\n  /* Return the minimum time between maxtv and tvbuf */\n  struct_timeval_to_ares_timeval(&amaxtv, maxtv);\n\n  if (atvbuf.sec > amaxtv.sec) {\n    return maxtv;\n  }\n\n  if (atvbuf.sec < amaxtv.sec) {\n    return tvbuf;\n  }\n\n  if (atvbuf.usec > amaxtv.usec) {\n    return maxtv;\n  }\n\n  return tvbuf;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeout_int",
            "parameters": {
              "channel": "ares_channel_t",
              "maxtv": "struct timeval",
              "tvbuf": "struct timeval"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct timeval *ares_timeout(const ares_channel_t *channel,\n                             struct timeval *maxtv, struct timeval *tvbuf)\n{\n  struct timeval *rv;\n\n  if (channel == NULL || tvbuf == NULL) {\n    return NULL;\n  }\n\n  ares_channel_lock(channel);\n\n  rv = ares_timeout_int(channel, maxtv, tvbuf);\n\n  ares_channel_unlock(channel);\n\n  return rv;\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeout",
            "parameters": {
              "channel": "ares_channel_t",
              "maxtv": "struct timeval",
              "tvbuf": "struct timeval"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_timeout_int(const ares_channel_t *channel,\n                                        struct timeval       *maxtv,\n                                        struct timeval       *tvbuf)",
          "fn_dec_pos": [
            [
              86,
              23
            ],
            [
              88,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeout_int",
            "parameters": {
              "channel": "ares_channel_t",
              "maxtv": "struct timeval",
              "tvbuf": "struct timeval"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_timeout(const ares_channel_t *channel,\n                             struct timeval *maxtv, struct timeval *tvbuf)",
          "fn_dec_pos": [
            [
              134,
              16
            ],
            [
              135,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeout",
            "parameters": {
              "channel": "ares_channel_t",
              "maxtv": "struct timeval",
              "tvbuf": "struct timeval"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            67,
            43
          ],
          [
            67,
            57
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            80,
            49
          ],
          [
            80,
            63
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            86,
            7
          ],
          [
            86,
            21
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            87,
            40
          ],
          [
            87,
            54
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            88,
            40
          ],
          [
            88,
            54
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            134,
            0
          ],
          [
            134,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            135,
            29
          ],
          [
            135,
            43
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            135,
            52
          ],
          [
            135,
            66
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            137,
            2
          ],
          [
            137,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_gethostbyaddr.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_gethostbyaddr_nolock(ares_channel_t *channel, const void *addr,\n                               int addrlen, int family,\n                               ares_host_callback callback, void *arg)\n{\n  struct addr_query *aquery;\n\n  if (family != AF_INET && family != AF_INET6) {\n    callback(arg, ARES_ENOTIMP, 0, NULL);\n    return;\n  }\n\n  if ((family == AF_INET && addrlen != sizeof(aquery->addr.addr.addr4)) ||\n      (family == AF_INET6 && addrlen != sizeof(aquery->addr.addr.addr6))) {\n    callback(arg, ARES_ENOTIMP, 0, NULL);\n    return;\n  }\n\n  aquery = ares_malloc(sizeof(struct addr_query));\n  if (!aquery) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n  aquery->lookups = ares_strdup(channel->lookups);\n  if (aquery->lookups == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    ares_free(aquery);\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n    /* LCOV_EXCL_STOP */\n  }\n  aquery->channel = channel;\n  if (family == AF_INET) {\n    memcpy(&aquery->addr.addr.addr4, addr, sizeof(aquery->addr.addr.addr4));\n  } else {\n    memcpy(&aquery->addr.addr.addr6, addr, sizeof(aquery->addr.addr.addr6));\n  }\n  aquery->addr.family       = family;\n  aquery->callback          = callback;\n  aquery->arg               = arg;\n  aquery->remaining_lookups = aquery->lookups;\n  aquery->timeouts          = 0;\n\n  next_lookup(aquery);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyaddr_nolock",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_gethostbyaddr(ares_channel_t *channel, const void *addr, int addrlen,\n                        int family, ares_host_callback callback, void *arg)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares_channel_lock(channel);\n  ares_gethostbyaddr_nolock(channel, addr, addrlen, family, callback, arg);\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyaddr",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void next_lookup(struct addr_query *aquery)\n{\n  const char     *p;\n  ares_status_t   status;\n  struct hostent *host = NULL;\n  char           *name;\n\n  for (p = aquery->remaining_lookups; *p; p++) {\n    switch (*p) {\n      case 'b':\n        name = ares_dns_addr_to_ptr(&aquery->addr);\n        if (name == NULL) {\n          end_aquery(aquery, ARES_ENOMEM,\n                     NULL); /* LCOV_EXCL_LINE: OutOfMemory */\n          return;           /* LCOV_EXCL_LINE: OutOfMemory */\n        }\n        aquery->remaining_lookups = p + 1;\n        ares_query_nolock(aquery->channel, name, ARES_CLASS_IN,\n                          ARES_REC_TYPE_PTR, addr_callback, aquery, NULL);\n        ares_free(name);\n        return;\n      case 'f':\n        status = file_lookup(aquery->channel, &aquery->addr, &host);\n\n        /* this status check below previously checked for !ARES_ENOTFOUND,\n           but we should not assume that this single error code is the one\n           that can occur, as that is in fact no longer the case */\n        if (status == ARES_SUCCESS) {\n          end_aquery(aquery, status, host);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  end_aquery(aquery, ARES_ENOTFOUND, NULL);\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_lookup",
            "parameters": {
              "aquery": "struct addr_query"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void addr_callback(void *arg, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec)\n{\n  struct addr_query *aquery = (struct addr_query *)arg;\n  struct hostent    *host;\n  size_t             addrlen;\n\n  aquery->timeouts += timeouts;\n  if (status == ARES_SUCCESS) {\n    if (aquery->addr.family == AF_INET) {\n      addrlen = sizeof(aquery->addr.addr.addr4);\n      status  = ares_parse_ptr_reply_dnsrec(dnsrec, &aquery->addr.addr.addr4,\n                                            (int)addrlen, AF_INET, &host);\n    } else {\n      addrlen = sizeof(aquery->addr.addr.addr6);\n      status  = ares_parse_ptr_reply_dnsrec(dnsrec, &aquery->addr.addr.addr6,\n                                            (int)addrlen, AF_INET6, &host);\n    }\n    end_aquery(aquery, status, host);\n  } else if (status == ARES_EDESTRUCTION || status == ARES_ECANCELLED) {\n    end_aquery(aquery, status, NULL);\n  } else {\n    next_lookup(aquery);\n  }\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "addr_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void end_aquery(struct addr_query *aquery, ares_status_t status,\n                       struct hostent *host)\n{\n  aquery->callback(aquery->arg, (int)status, (int)aquery->timeouts, host);\n  if (host) {\n    ares_free_hostent(host);\n  }\n  ares_free(aquery->lookups);\n  ares_free(aquery);\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_aquery",
            "parameters": {
              "aquery": "struct addr_query",
              "status": "ares_status_t",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t file_lookup(ares_channel_t         *channel,\n                                 const struct ares_addr *addr,\n                                 struct hostent        **host)\n{\n  char                      ipaddr[INET6_ADDRSTRLEN];\n  const void               *ptr = NULL;\n  const ares_hosts_entry_t *entry;\n  ares_status_t             status;\n\n  if (addr->family == AF_INET) {\n    ptr = &addr->addr.addr4;\n  } else if (addr->family == AF_INET6) {\n    ptr = &addr->addr.addr6;\n  }\n\n  if (ptr == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  if (!ares_inet_ntop(addr->family, ptr, ipaddr, sizeof(ipaddr))) {\n    return ARES_ENOTFOUND;\n  }\n\n  status = ares_hosts_search_ipaddr(channel, ARES_FALSE, ipaddr, &entry);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_hosts_entry_to_hostent(entry, addr->family, host);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_lookup",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "struct ares_addr",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "next_lookup(struct addr_query *aquery)",
          "fn_dec_pos": [
            [
              53,
              12
            ],
            [
              53,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_lookup",
            "parameters": {
              "aquery": "struct addr_query"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "addr_callback(void *arg, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              54,
              12
            ],
            [
              55,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "addr_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "end_aquery(struct addr_query *aquery, ares_status_t status,\n                       struct hostent *host)",
          "fn_dec_pos": [
            [
              56,
              12
            ],
            [
              57,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_aquery",
            "parameters": {
              "aquery": "struct addr_query",
              "status": "ares_status_t",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "file_lookup(ares_channel_t         *channel,\n                                 const struct ares_addr *addr,\n                                 struct hostent        **host)",
          "fn_dec_pos": [
            [
              58,
              21
            ],
            [
              60,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_lookup",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "struct ares_addr",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct addr_query {\n  /* Arguments passed to ares_gethostbyaddr() */\n  ares_channel_t    *channel;\n  struct ares_addr   addr;\n  ares_host_callback callback;\n  void              *arg;\n  char       *lookups; /* duplicate memory from channel for ares_reinit() */\n  const char *remaining_lookups;\n  size_t      timeouts;\n}",
          {
            "*channel": "ares_channel_t",
            "addr": "struct ares_addr",
            "callback": "ares_host_callback",
            "*arg": "void",
            "*lookups": "char",
            "char": "const",
            "timeouts": "size_t"
          },
          "addr_query",
          [
            42,
            0
          ],
          [
            51,
            1
          ]
        ],
        [
          "struct addr_query {\n  /* Arguments passed to ares_gethostbyaddr() */\n  ares_channel_t    *channel;\n  struct ares_addr   addr;\n  ares_host_callback callback;\n  void              *arg;\n  char       *lookups; /* duplicate memory from channel for ares_reinit() */\n  const char *remaining_lookups;\n  size_t      timeouts;\n}",
          {
            "*channel": "ares_channel_t",
            "addr": "struct ares_addr",
            "callback": "ares_host_callback",
            "*arg": "void",
            "*lookups": "char",
            "char": "const",
            "timeouts": "size_t"
          },
          "addr_query",
          [
            42,
            0
          ],
          [
            51,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            45,
            2
          ],
          [
            45,
            18
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            53,
            24
          ],
          [
            53,
            41
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            56,
            23
          ],
          [
            56,
            40
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            57,
            23
          ],
          [
            57,
            37
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            59,
            39
          ],
          [
            59,
            55
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            60,
            33
          ],
          [
            60,
            47
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            66,
            2
          ],
          [
            66,
            19
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            79,
            30
          ],
          [
            79,
            47
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            118,
            24
          ],
          [
            118,
            41
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            122,
            2
          ],
          [
            122,
            16
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            160,
            2
          ],
          [
            160,
            19
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            160,
            31
          ],
          [
            160,
            48
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            161,
            2
          ],
          [
            161,
            16
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            183,
            23
          ],
          [
            183,
            40
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            184,
            23
          ],
          [
            184,
            37
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            195,
            39
          ],
          [
            195,
            55
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            196,
            33
          ],
          [
            196,
            47
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_sysconfig.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_status_t ares_init_sysconfig_mvs(const ares_channel_t *channel,\n                                             ares_sysconfig_t     *sysconfig)\n{\n  struct __res_state *res = 0;\n  size_t              count4;\n  size_t              count6;\n  int                 i;\n  __STATEEXTIPV6     *v6;\n  arse__llist_t      *sconfig = NULL;\n  ares_status_t       status;\n\n  if (0 == res) {\n    int rc = res_init();\n    while (rc == -1 && h_errno == TRY_AGAIN) {\n      rc = res_init();\n    }\n    if (rc == -1) {\n      return ARES_ENOMEM;\n    }\n    res = __res();\n  }\n\n  v6 = res->__res_extIPv6;\n  if (res->nscount > 0) {\n    count4 = (size_t)res->nscount;\n  }\n\n  if (v6 && v6->__stat_nscount > 0) {\n    count6 = (size_t)v6->__stat_nscount;\n  } else {\n    count6 = 0;\n  }\n\n  for (i = 0; i < count4; i++) {\n    struct sockaddr_in *addr_in = &(res->nsaddr_list[i]);\n    struct ares_addr    addr;\n\n    addr.addr.addr4.s_addr = addr_in->sin_addr.s_addr;\n    addr.family            = AF_INET;\n\n    status = ares_sconfig_append(channel, &sysconfig->sconfig, &addr,\n                                 htons(addr_in->sin_port),\n                                 htons(addr_in->sin_port), NULL);\n\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  for (i = 0; i < count6; i++) {\n    struct sockaddr_in6 *addr_in = &(v6->__stat_nsaddr_list[i]);\n    struct ares_addr     addr;\n\n    addr.family = AF_INET6;\n    memcpy(&(addr.addr.addr6), &(addr_in->sin6_addr),\n           sizeof(addr_in->sin6_addr));\n\n    status = ares_sconfig_append(channel, &sysconfig->sconfig, &addr,\n                                 htons(addr_in->sin_port),\n                                 htons(addr_in->sin_port), NULL);\n\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_mvs",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_init_sysconfig_riscos(const ares_channel_t *channel,\n                                                ares_sysconfig_t     *sysconfig)\n{\n  char         *line;\n  ares_status_t status = ARES_SUCCESS;\n\n  /* Under RISC OS, name servers are listed in the\n     system variable Inet$Resolvers, space separated. */\n  line = getenv(\"Inet$Resolvers\");\n  if (line) {\n    char *resolvers = ares_strdup(line);\n    char *pos;\n    char *space;\n\n    if (!resolvers) {\n      return ARES_ENOMEM;\n    }\n\n    pos = resolvers;\n    do {\n      space = strchr(pos, ' ');\n      if (space) {\n        *space = '\\0';\n      }\n      status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, pos,\n                                           ARES_TRUE);\n      if (status != ARES_SUCCESS) {\n        break;\n      }\n      pos = space + 1;\n    } while (space);\n\n    ares_free(resolvers);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_riscos",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_init_sysconfig_watt32(const ares_channel_t *channel,\n                                                ares_sysconfig_t     *sysconfig)\n{\n  size_t        i;\n  ares_status_t status;\n\n  sock_init();\n\n  for (i = 0; def_nameservers[i]; i++) {\n    struct ares_addr addr;\n\n    addr.family            = AF_INET;\n    addr.addr.addr4.s_addr = htonl(def_nameservers[i]);\n\n    status =\n      ares_sconfig_append(channel, &sysconfig->sconfig, &addr, 0, 0, NULL);\n\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_watt32",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_init_sysconfig_android(const ares_channel_t *channel,\n                                                 ares_sysconfig_t *sysconfig)\n{\n  size_t        i;\n  char        **dns_servers;\n  char         *domains;\n  size_t        num_servers;\n  ares_status_t status = ARES_EFILE;\n\n  /* Use the Android connectivity manager to get a list\n   * of DNS servers. As of Android 8 (Oreo) net.dns#\n   * system properties are no longer available. Google claims this\n   * improves privacy. Apps now need the ACCESS_NETWORK_STATE\n   * permission and must use the ConnectivityManager which\n   * is Java only. */\n  dns_servers = ares_get_android_server_list(MAX_DNS_PROPERTIES, &num_servers);\n  if (dns_servers != NULL) {\n    for (i = 0; i < num_servers; i++) {\n      status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig,\n                                           dns_servers[i], ARES_TRUE);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n    for (i = 0; i < num_servers; i++) {\n      ares_free(dns_servers[i]);\n    }\n    ares_free(dns_servers);\n  }\n\n  domains            = ares_get_android_search_domains_list();\n  sysconfig->domains = ares_strsplit(domains, \", \", &sysconfig->ndomains);\n  ares_free(domains);\n\n#  ifdef HAVE___SYSTEM_PROPERTY_GET\n  /* Old way using the system property still in place as\n   * a fallback. Older android versions can still use this.\n   * it's possible for older apps not not have added the new\n   * permission and we want to try to avoid breaking those.\n   *\n   * We'll only run this if we don't have any dns servers\n   * because this will get the same ones (if it works). */\n  if (sysconfig->sconfig == NULL) {\n    char propname[PROP_NAME_MAX];\n    char propvalue[PROP_VALUE_MAX] = \"\";\n    for (i = 1; i <= MAX_DNS_PROPERTIES; i++) {\n      snprintf(propname, sizeof(propname), \"%s%zu\", DNS_PROP_NAME_PREFIX, i);\n      if (__system_property_get(propname, propvalue) < 1) {\n        break;\n      }\n      status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig,\n                                           propvalue, ARES_TRUE);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n  }\n#  endif /* HAVE___SYSTEM_PROPERTY_GET */\n\n  return status;\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_android",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_init_sysconfig_qnx(const ares_channel_t *channel,\n                          ares_sysconfig_t     *sysconfig)\n{\n  /* QNX:\n   *   1. use confstr(_CS_RESOLVE, ...) as primary resolv.conf data, replacing\n   *      \"_\" with \" \".  If that is empty, then do normal /etc/resolv.conf\n   *      processing.\n   *   2. We want to process /etc/nsswitch.conf as normal.\n   *   3. if confstr(_CS_DOMAIN, ...) this is the domain name.  Use this as\n   *      preference over anything else found.\n   */\n  ares_buf_t    *buf                = ares_buf_create();\n  unsigned char *data               = NULL;\n  size_t         data_size          = 0;\n  ares_bool_t    process_resolvconf = ARES_TRUE;\n  ares_status_t  status             = ARES_SUCCESS;\n\n  /* Prefer confstr(_CS_RESOLVE, ...) */\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  data_size = 1024;\n  data      = ares_buf_append_start(buf, &data_size);\n  if (data == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  data_size = confstr(_CS_RESOLVE, (char *)data, data_size);\n  if (data_size > 1) {\n    /* confstr returns byte for NULL terminator, strip */\n    data_size--;\n\n    ares_buf_append_finish(buf, data_size);\n    /* Its odd, this uses _ instead of \" \" between keywords, otherwise the\n     * format is the same as resolv.conf, replace. */\n    ares_buf_replace(buf, (const unsigned char *)\"_\", 1,\n                     (const unsigned char *)\" \", 1);\n\n    status = ares_sysconfig_process_buf(channel, sysconfig, buf,\n                                        ares_sysconfig_parse_resolv_line);\n    if (status != ARES_SUCCESS) {\n      /* ENOMEM is really the only error we'll get here */\n      goto done;\n    }\n\n    /* don't read resolv.conf if we processed *any* nameservers */\n    if (ares_llist_len(sysconfig->sconfig) != 0) {\n      process_resolvconf = ARES_FALSE;\n    }\n  }\n\n  /* Process files */\n  status = ares_init_sysconfig_files(channel, sysconfig, process_resolvconf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Read confstr(_CS_DOMAIN, ...), but if we had a search path specified with\n   * more than one domain, lets prefer that instead.  Its not exactly clear\n   * the best way to handle this. */\n  if (sysconfig->ndomains <= 1) {\n    char   domain[256];\n    size_t domain_len;\n\n    domain_len = confstr(_CS_DOMAIN, domain, sizeof(domain_len));\n    if (domain_len != 0) {\n      ares_strsplit_free(sysconfig->domains, sysconfig->ndomains);\n      sysconfig->domains = ares_strsplit(domain, \", \", &sysconfig->ndomains);\n      if (sysconfig->domains == NULL) {\n        status = ARES_ENOMEM;\n        goto done;\n      }\n    }\n  }\n\ndone:\n  ares_buf_destroy(buf);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_qnx",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_init_sysconfig_libresolv(const ares_channel_t *channel,\n                                ares_sysconfig_t     *sysconfig)\n{\n  struct __res_state       res;\n  ares_status_t            status = ARES_SUCCESS;\n  union res_sockaddr_union addr[MAXNS];\n  int                      nscount;\n  size_t                   i;\n  size_t                   entries = 0;\n  ares_buf_t              *ipbuf   = NULL;\n\n  memset(&res, 0, sizeof(res));\n\n  if (res_ninit(&res) != 0 || !(res.options & RES_INIT)) {\n    return ARES_EFILE;\n  }\n\n  nscount = res_getservers(&res, addr, MAXNS);\n\n  for (i = 0; i < (size_t)nscount; ++i) {\n    char           ipaddr[INET6_ADDRSTRLEN] = \"\";\n    char          *ipstr                    = NULL;\n    unsigned short port                     = 0;\n    unsigned int   ll_scope                 = 0;\n\n    sa_family_t    family = addr[i].sin.sin_family;\n    if (family == AF_INET) {\n      ares_inet_ntop(family, &addr[i].sin.sin_addr, ipaddr, sizeof(ipaddr));\n      port = ntohs(addr[i].sin.sin_port);\n    } else if (family == AF_INET6) {\n      ares_inet_ntop(family, &addr[i].sin6.sin6_addr, ipaddr, sizeof(ipaddr));\n      port     = ntohs(addr[i].sin6.sin6_port);\n      ll_scope = addr[i].sin6.sin6_scope_id;\n    } else {\n      continue;\n    }\n\n\n    /* [ip]:port%iface */\n    ipbuf = ares_buf_create();\n    if (ipbuf == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    status = ares_buf_append_str(ipbuf, \"[\");\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_buf_append_str(ipbuf, ipaddr);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_buf_append_str(ipbuf, \"]\");\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    if (port) {\n      status = ares_buf_append_str(ipbuf, \":\");\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n      status = ares_buf_append_num_dec(ipbuf, port, 0);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    if (ll_scope) {\n      status = ares_buf_append_str(ipbuf, \"%\");\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n      status = ares_buf_append_num_dec(ipbuf, ll_scope, 0);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    ipstr = ares_buf_finish_str(ipbuf, NULL);\n    ipbuf = NULL;\n    if (ipstr == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, ipstr,\n                                         ARES_TRUE);\n\n    ares_free(ipstr);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  while ((entries < MAXDNSRCH) && res.dnsrch[entries]) {\n    entries++;\n  }\n\n  if (entries) {\n    sysconfig->domains = ares_malloc_zero(entries * sizeof(char *));\n    if (sysconfig->domains == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    } else {\n      sysconfig->ndomains = entries;\n      for (i = 0; i < sysconfig->ndomains; i++) {\n        sysconfig->domains[i] = ares_strdup(res.dnsrch[i]);\n        if (sysconfig->domains[i] == NULL) {\n          status = ARES_ENOMEM;\n          goto done;\n        }\n      }\n    }\n  }\n\n  if (res.ndots >= 0) {\n    sysconfig->ndots = (size_t)res.ndots;\n  }\n/* Apple does not allow configuration of retry, so this is a static dummy\n * value, ignore */\n#  ifndef __APPLE__\n  if (res.retry > 0) {\n    sysconfig->tries = (size_t)res.retry;\n  }\n#  endif\n  if (res.options & RES_ROTATE) {\n    sysconfig->rotate = ARES_TRUE;\n  }\n\n  if (res.retrans > 0) {\n/* Apple does not allow configuration of retrans, so this is a dummy value\n * that is extremely high (5s) */\n#  ifndef __APPLE__\n    if (res.retrans > 0) {\n      sysconfig->timeout_ms = (unsigned int)res.retrans * 1000;\n    }\n#  endif\n  }\n\ndone:\n  ares_buf_destroy(ipbuf);\n  res_ndestroy(&res);\n  return status;\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_libresolv",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void ares_sysconfig_free(ares_sysconfig_t *sysconfig)\n{\n  ares_llist_destroy(sysconfig->sconfig);\n  ares_strsplit_free(sysconfig->domains, sysconfig->ndomains);\n  ares_free(sysconfig->sortlist);\n  ares_free(sysconfig->lookups);\n  memset(sysconfig, 0, sizeof(*sysconfig));\n}",
          "fn_code_pos": [
            [
              502,
              0
            ],
            [
              509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_free",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_sysconfig_apply(ares_channel_t         *channel,\n                                          const ares_sysconfig_t *sysconfig)\n{\n  ares_status_t status;\n\n  if (sysconfig->sconfig && !(channel->optmask & ARES_OPT_SERVERS)) {\n    status = ares_servers_update(channel, sysconfig->sconfig, ARES_FALSE);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  if (sysconfig->domains && !(channel->optmask & ARES_OPT_DOMAINS)) {\n    /* Make sure we duplicate first then replace so even if there is\n     * ARES_ENOMEM, the channel stays in a good state */\n    char **temp =\n      ares_strsplit_duplicate(sysconfig->domains, sysconfig->ndomains);\n    if (temp == NULL) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    ares_strsplit_free(channel->domains, channel->ndomains);\n    channel->domains  = temp;\n    channel->ndomains = sysconfig->ndomains;\n  }\n\n  if (sysconfig->lookups && !(channel->optmask & ARES_OPT_LOOKUPS)) {\n    char *temp = ares_strdup(sysconfig->lookups);\n    if (temp == NULL) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    ares_free(channel->lookups);\n    channel->lookups = temp;\n  }\n\n  if (sysconfig->sortlist && !(channel->optmask & ARES_OPT_SORTLIST)) {\n    struct apattern *temp =\n      ares_malloc(sizeof(*channel->sortlist) * sysconfig->nsortlist);\n    if (temp == NULL) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    memcpy(temp, sysconfig->sortlist,\n           sizeof(*channel->sortlist) * sysconfig->nsortlist);\n\n    ares_free(channel->sortlist);\n    channel->sortlist = temp;\n    channel->nsort    = sysconfig->nsortlist;\n  }\n\n  if (!(channel->optmask & ARES_OPT_NDOTS)) {\n    channel->ndots = sysconfig->ndots;\n  }\n\n  if (sysconfig->tries && !(channel->optmask & ARES_OPT_TRIES)) {\n    channel->tries = sysconfig->tries;\n  }\n\n  if (sysconfig->timeout_ms && !(channel->optmask & ARES_OPT_TIMEOUTMS)) {\n    channel->timeout = sysconfig->timeout_ms;\n  }\n\n  if (!(channel->optmask & (ARES_OPT_ROTATE | ARES_OPT_NOROTATE))) {\n    channel->rotate = sysconfig->rotate;\n  }\n\n  if (sysconfig->usevc) {\n    channel->flags |= ARES_FLAG_USEVC;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              582,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_apply",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_init_by_sysconfig(ares_channel_t *channel)\n{\n  ares_status_t    status;\n  ares_sysconfig_t sysconfig;\n\n  memset(&sysconfig, 0, sizeof(sysconfig));\n  sysconfig.ndots = 1; /* Default value if not otherwise set */\n\n#if defined(USE_WINSOCK)\n  status = ares_init_sysconfig_windows(channel, &sysconfig);\n#elif defined(__MVS__)\n  status = ares_init_sysconfig_mvs(channel, &sysconfig);\n#elif defined(__riscos__)\n  status = ares_init_sysconfig_riscos(channel, &sysconfig);\n#elif defined(WATT32)\n  status = ares_init_sysconfig_watt32(channel, &sysconfig);\n#elif defined(ANDROID) || defined(__ANDROID__)\n  status = ares_init_sysconfig_android(channel, &sysconfig);\n#elif defined(__APPLE__)\n  status = ares_init_sysconfig_macos(channel, &sysconfig);\n#elif defined(CARES_USE_LIBRESOLV)\n  status = ares_init_sysconfig_libresolv(channel, &sysconfig);\n#elif defined(__QNX__)\n  status = ares_init_sysconfig_qnx(channel, &sysconfig);\n#else\n  status = ares_init_sysconfig_files(channel, &sysconfig, ARES_TRUE);\n#endif\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Environment is supposed to override sysconfig */\n  status = ares_init_by_environment(&sysconfig);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Lock when applying the configuration to the channel.  Don't need to\n   * lock prior to this. */\n\n  ares_channel_lock(channel);\n\n  status = ares_sysconfig_apply(channel, &sysconfig);\n  ares_channel_unlock(channel);\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_sysconfig_free(&sysconfig);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              584,
              0
            ],
            [
              638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_by_sysconfig",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct __res_state",
          {},
          "",
          [
            64,
            2
          ],
          [
            64,
            20
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            95,
            4
          ],
          [
            95,
            22
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            96,
            4
          ],
          [
            96,
            20
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            111,
            4
          ],
          [
            111,
            23
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            112,
            4
          ],
          [
            112,
            20
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            181,
            4
          ],
          [
            181,
            20
          ]
        ],
        [
          "struct __res_state",
          {},
          "",
          [
            355,
            2
          ],
          [
            355,
            20
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            548,
            4
          ],
          [
            548,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/param.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#  include <sys/system_properties.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <resolv.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_metrics.c": {
      "fn_def_list": [
        {
          "fn_code": "static time_t ares_metric_timestamp(ares_server_bucket_t  bucket,\n                                    const ares_timeval_t *now,\n                                    ares_bool_t           is_previous)\n{\n  time_t divisor = 1; /* Silence bogus MSVC warning by setting default value */\n\n  switch (bucket) {\n    case ARES_METRIC_1MINUTE:\n      divisor = 60;\n      break;\n    case ARES_METRIC_15MINUTES:\n      divisor = 15 * 60;\n      break;\n    case ARES_METRIC_1HOUR:\n      divisor = 60 * 60;\n      break;\n    case ARES_METRIC_1DAY:\n      divisor = 24 * 60 * 60;\n      break;\n    case ARES_METRIC_INCEPTION:\n      return is_previous ? 0 : 1;\n    case ARES_METRIC_COUNT:\n      return 0; /* Invalid! */\n  }\n\n  if (is_previous) {\n    if (divisor >= now->sec) {\n      return 0;\n    }\n    return (time_t)((now->sec - divisor) / divisor);\n  }\n\n  return (time_t)(now->sec / divisor);\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_metric_timestamp",
            "parameters": {
              "bucket": "ares_server_bucket_t",
              "now": "ares_timeval_t",
              "is_previous": "ares_bool_t"
            },
            "return_type": "time_t"
          }
        },
        {
          "fn_code": "void ares_metrics_record(const ares_query_t *query, ares_server_t *server,\n                         ares_status_t status, const ares_dns_record_t *dnsrec)\n{\n  ares_timeval_t       now;\n  ares_timeval_t       tvdiff;\n  unsigned int         query_ms;\n  ares_dns_rcode_t     rcode;\n  ares_server_bucket_t i;\n\n  if (status != ARES_SUCCESS) {\n    return;\n  }\n\n  if (server == NULL) {\n    return;\n  }\n\n  ares_tvnow(&now);\n\n  rcode = ares_dns_record_get_rcode(dnsrec);\n  if (rcode != ARES_RCODE_NOERROR && rcode != ARES_RCODE_NXDOMAIN) {\n    return;\n  }\n\n  ares_timeval_diff(&tvdiff, &query->ts, &now);\n  query_ms = (unsigned int)((tvdiff.sec * 1000) + (tvdiff.usec / 1000));\n  if (query_ms == 0) {\n    query_ms = 1;\n  }\n\n  /* Place in each bucket */\n  for (i = 0; i < ARES_METRIC_COUNT; i++) {\n    time_t ts = ares_metric_timestamp(i, &now, ARES_FALSE);\n\n    /* Copy metrics to prev and clear */\n    if (ts != server->metrics[i].ts) {\n      server->metrics[i].prev_ts          = server->metrics[i].ts;\n      server->metrics[i].prev_total_ms    = server->metrics[i].total_ms;\n      server->metrics[i].prev_total_count = server->metrics[i].total_count;\n      server->metrics[i].ts               = ts;\n      server->metrics[i].latency_min_ms   = 0;\n      server->metrics[i].latency_max_ms   = 0;\n      server->metrics[i].total_ms         = 0;\n      server->metrics[i].total_count      = 0;\n    }\n\n    if (server->metrics[i].latency_min_ms == 0 ||\n        server->metrics[i].latency_min_ms > query_ms) {\n      server->metrics[i].latency_min_ms = query_ms;\n    }\n\n    if (query_ms > server->metrics[i].latency_max_ms) {\n      server->metrics[i].latency_max_ms = query_ms;\n    }\n\n    server->metrics[i].total_count++;\n    server->metrics[i].total_ms += (ares_uint64_t)query_ms;\n  }\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_metrics_record",
            "parameters": {
              "query": "ares_query_t",
              "server": "ares_server_t",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares_metrics_server_timeout(const ares_server_t  *server,\n                                   const ares_timeval_t *now)\n{\n  const ares_channel_t *channel = server->channel;\n  ares_server_bucket_t  i;\n  size_t                timeout_ms = 0;\n  size_t                max_timeout_ms;\n\n  for (i = 0; i < ARES_METRIC_COUNT; i++) {\n    time_t ts = ares_metric_timestamp(i, now, ARES_FALSE);\n\n    /* This ts has been invalidated, see if we should use the previous\n     * time period */\n    if (ts != server->metrics[i].ts ||\n        server->metrics[i].total_count < MIN_COUNT_FOR_AVERAGE) {\n      time_t prev_ts = ares_metric_timestamp(i, now, ARES_TRUE);\n      if (prev_ts != server->metrics[i].prev_ts ||\n          server->metrics[i].prev_total_count < MIN_COUNT_FOR_AVERAGE) {\n        /* Move onto next bucket */\n        continue;\n      }\n      /* Calculate average time for previous bucket */\n      timeout_ms = (size_t)(server->metrics[i].prev_total_ms /\n                            server->metrics[i].prev_total_count);\n    } else {\n      /* Calculate average time for current bucket*/\n      timeout_ms =\n        (size_t)(server->metrics[i].total_ms / server->metrics[i].total_count);\n    }\n\n    /* Multiply average by constant to get timeout value */\n    timeout_ms *= AVG_TIMEOUT_MULTIPLIER;\n    break;\n  }\n\n  /* If we're here, that means its the first query for the server, so we just\n   * use the initial default timeout */\n  if (timeout_ms == 0) {\n    timeout_ms = channel->timeout;\n  }\n\n  /* don't go below lower bounds */\n  if (timeout_ms < MIN_TIMEOUT_MS) {\n    timeout_ms = MIN_TIMEOUT_MS;\n  }\n\n  /* don't go above upper bounds */\n  max_timeout_ms = channel->maxtimeout ? channel->maxtimeout : MAX_TIMEOUT_MS;\n  if (timeout_ms > max_timeout_ms) {\n    timeout_ms = max_timeout_ms;\n  }\n\n  return timeout_ms;\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_metrics_server_timeout",
            "parameters": {
              "server": "ares_server_t",
              "now": "ares_timeval_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            97,
            0
          ],
          [
            98,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_data.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_free_data(void *dataptr)\n{\n  while (dataptr != NULL) {\n    struct ares_data *ptr;\n    void             *next_data = NULL;\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(push)\n#  pragma warning(disable : 1684)\n    /* 1684: conversion from pointer to same-sized integral type */\n#endif\n\n    ptr = (void *)((char *)dataptr - offsetof(struct ares_data, data));\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(pop)\n#endif\n\n    if (ptr->mark != ARES_DATATYPE_MARK) {\n      return;\n    }\n\n    switch (ptr->type) {\n      case ARES_DATATYPE_MX_REPLY:\n        next_data = ptr->data.mx_reply.next;\n        ares_free(ptr->data.mx_reply.host);\n        break;\n\n      case ARES_DATATYPE_SRV_REPLY:\n        next_data = ptr->data.srv_reply.next;\n        ares_free(ptr->data.srv_reply.host);\n        break;\n\n      case ARES_DATATYPE_URI_REPLY:\n        next_data = ptr->data.uri_reply.next;\n        ares_free(ptr->data.uri_reply.uri);\n        break;\n\n      case ARES_DATATYPE_TXT_REPLY:\n      case ARES_DATATYPE_TXT_EXT:\n        next_data = ptr->data.txt_reply.next;\n        ares_free(ptr->data.txt_reply.txt);\n        break;\n\n      case ARES_DATATYPE_ADDR_NODE:\n        next_data = ptr->data.addr_node.next;\n        break;\n\n      case ARES_DATATYPE_ADDR_PORT_NODE:\n        next_data = ptr->data.addr_port_node.next;\n        break;\n\n      case ARES_DATATYPE_NAPTR_REPLY:\n        next_data = ptr->data.naptr_reply.next;\n        ares_free(ptr->data.naptr_reply.flags);\n        ares_free(ptr->data.naptr_reply.service);\n        ares_free(ptr->data.naptr_reply.regexp);\n        ares_free(ptr->data.naptr_reply.replacement);\n        break;\n\n      case ARES_DATATYPE_SOA_REPLY:\n        ares_free(ptr->data.soa_reply.nsname);\n        ares_free(ptr->data.soa_reply.hostmaster);\n        break;\n\n      case ARES_DATATYPE_CAA_REPLY:\n        next_data = ptr->data.caa_reply.next;\n        ares_free(ptr->data.caa_reply.property);\n        ares_free(ptr->data.caa_reply.value);\n        break;\n\n      default:\n        return;\n    }\n\n    ares_free(ptr);\n    dataptr = next_data;\n  }\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_data",
            "parameters": {
              "dataptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_malloc_data(ares_datatype type)\n{\n  struct ares_data *ptr;\n\n  ptr = ares_malloc_zero(sizeof(*ptr));\n  if (!ptr) {\n    return NULL;\n  }\n\n  switch (type) {\n    case ARES_DATATYPE_MX_REPLY:\n    case ARES_DATATYPE_SRV_REPLY:\n    case ARES_DATATYPE_URI_REPLY:\n    case ARES_DATATYPE_TXT_EXT:\n    case ARES_DATATYPE_TXT_REPLY:\n    case ARES_DATATYPE_CAA_REPLY:\n    case ARES_DATATYPE_ADDR_NODE:\n    case ARES_DATATYPE_ADDR_PORT_NODE:\n    case ARES_DATATYPE_NAPTR_REPLY:\n    case ARES_DATATYPE_SOA_REPLY:\n      break;\n\n    default:\n      ares_free(ptr);\n      return NULL;\n  }\n\n  ptr->mark = ARES_DATATYPE_MARK;\n  ptr->type = type;\n\n  return &ptr->data;\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_data",
            "parameters": {
              "type": "ares_datatype"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_malloc_data(ares_datatype type)",
          "fn_dec_pos": [
            [
              136,
              6
            ],
            [
              136,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_data",
            "parameters": {
              "type": "ares_datatype"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_data",
          {},
          "",
          [
            48,
            4
          ],
          [
            48,
            20
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            57,
            46
          ],
          [
            57,
            62
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            138,
            2
          ],
          [
            138,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_addrinfo2hostent.c": {
      "fn_def_list": [
        {
          "fn_code": "static size_t hostent_nalias(const struct hostent *host)\n{\n  size_t i;\n  for (i=0; host->h_aliases != NULL && host->h_aliases[i] != NULL; i++)\n    ;\n\n  return i;\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hostent_nalias",
            "parameters": {
              "host": "struct hostent"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static size_t ai_nalias(const struct ares_addrinfo *ai)\n{\n  const struct ares_addrinfo_cname *cname;\n  size_t                            i     = 0;\n\n  for (cname = ai->cnames; cname != NULL; cname=cname->next) {\n    i++;\n  }\n\n  return i;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ai_nalias",
            "parameters": {
              "ai": "struct ares_addrinfo"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static size_t hostent_naddr(const struct hostent *host)\n{\n  size_t i;\n  for (i=0; host->h_addr_list != NULL && host->h_addr_list[i] != NULL; i++)\n    ;\n\n  return i;\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hostent_naddr",
            "parameters": {
              "host": "struct hostent"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static size_t ai_naddr(const struct ares_addrinfo *ai, int af)\n{\n  const struct ares_addrinfo_node *node;\n  size_t                           i     = 0;\n\n  for (node = ai->nodes; node != NULL; node=node->ai_next) {\n    if (af != AF_UNSPEC && af != node->ai_family)\n      continue;\n    i++;\n  }\n\n  return i;\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ai_naddr",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "af": "int"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_addrinfo2hostent(const struct ares_addrinfo *ai, int family,\n                                    struct hostent **host)\n{\n  struct ares_addrinfo_node  *next;\n  char                      **aliases  = NULL;\n  char                      **addrs    = NULL;\n  size_t                      naliases = 0;\n  size_t                      naddrs   = 0;\n  size_t                      i;\n  size_t                      ealiases = 0;\n  size_t                      eaddrs   = 0;\n\n  if (ai == NULL || host == NULL) {\n    return ARES_EBADQUERY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Use either the host set in the passed in hosts to be filled in, or the\n   * first node of the response as the family, since hostent can only\n   * represent one family.  We assume getaddrinfo() returned a sorted list if\n   * the user requested AF_UNSPEC. */\n  if (family == AF_UNSPEC) {\n    if (*host != NULL && (*host)->h_addrtype != AF_UNSPEC) {\n      family = (*host)->h_addrtype;\n    } else if (ai->nodes != NULL) {\n      family = ai->nodes->ai_family;\n    }\n  }\n\n  if (family != AF_INET && family != AF_INET6) {\n    return ARES_EBADQUERY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (*host == NULL) {\n    *host = ares_malloc_zero(sizeof(**host));\n    if (!(*host)) {\n      goto enomem; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  (*host)->h_addrtype = (HOSTENT_ADDRTYPE_TYPE)family;\n  if (family == AF_INET) {\n    (*host)->h_length = sizeof(struct in_addr);\n  } else if (family == AF_INET6) {\n    (*host)->h_length = sizeof(struct ares_in6_addr);\n  }\n\n  if ((*host)->h_name == NULL) {\n    if (ai->cnames) {\n      (*host)->h_name = ares_strdup(ai->cnames->name);\n      if ((*host)->h_name == NULL && ai->cnames->name) {\n        goto enomem; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    } else {\n      (*host)->h_name = ares_strdup(ai->name);\n      if ((*host)->h_name == NULL && ai->name) {\n        goto enomem; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  naliases = ai_nalias(ai);\n  ealiases = hostent_nalias(*host);\n  aliases  = ares_realloc_zero((*host)->h_aliases,\n                               ealiases * sizeof(char *),\n                               (naliases + ealiases + 1) * sizeof(char *));\n  if (!aliases) {\n    goto enomem; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  (*host)->h_aliases = aliases;\n\n  if (naliases) {\n    const struct ares_addrinfo_cname *cname;\n    i = ealiases;\n    for (cname = ai->cnames; cname != NULL; cname = cname->next) {\n      if (cname->alias == NULL) {\n        continue;\n      }\n      (*host)->h_aliases[i] = ares_strdup(cname->alias);\n      if ((*host)->h_aliases[i] == NULL) {\n        goto enomem; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      i++;\n    }\n  }\n\n  naddrs = ai_naddr(ai, family);\n  eaddrs = hostent_naddr(*host);\n  addrs  = ares_realloc_zero((*host)->h_addr_list, eaddrs * sizeof(char *),\n                             (naddrs + eaddrs + 1) * sizeof(char *));\n  if (addrs == NULL) {\n    goto enomem; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  (*host)->h_addr_list = addrs;\n\n  if (naddrs) {\n    i = eaddrs;\n    for (next = ai->nodes; next != NULL; next = next->ai_next) {\n      if (next->ai_family != family) {\n        continue;\n      }\n      (*host)->h_addr_list[i] = ares_malloc_zero((size_t)(*host)->h_length);\n      if ((*host)->h_addr_list[i] == NULL) {\n        goto enomem; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      if (family == AF_INET6) {\n        memcpy((*host)->h_addr_list[i],\n               &(CARES_INADDR_CAST(const struct sockaddr_in6 *, next->ai_addr)\n                   ->sin6_addr),\n               (size_t)(*host)->h_length);\n      }\n      if (family == AF_INET) {\n        memcpy((*host)->h_addr_list[i],\n               &(CARES_INADDR_CAST(const struct sockaddr_in *, next->ai_addr)\n                   ->sin_addr),\n               (size_t)(*host)->h_length);\n      }\n      i++;\n    }\n  }\n\n  if (naddrs + eaddrs == 0 && naliases + ealiases == 0) {\n    ares_free_hostent(*host);\n    *host = NULL;\n    return ARES_ENODATA;\n  }\n\n  return ARES_SUCCESS;\n\n/* LCOV_EXCL_START: OutOfMemory */\nenomem:\n  ares_free_hostent(*host);\n  *host = NULL;\n  return ARES_ENOMEM;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo2hostent",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_addrinfo2addrttl(const struct ares_addrinfo *ai, int family,\n                                    size_t                req_naddrttls,\n                                    struct ares_addrttl  *addrttls,\n                                    struct ares_addr6ttl *addr6ttls,\n                                    size_t               *naddrttls)\n{\n  struct ares_addrinfo_node  *next;\n  struct ares_addrinfo_cname *next_cname;\n  int                         cname_ttl = INT_MAX;\n\n  if (family != AF_INET && family != AF_INET6) {\n    return ARES_EBADQUERY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (ai == NULL || naddrttls == NULL) {\n    return ARES_EBADQUERY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (family == AF_INET && addrttls == NULL) {\n    return ARES_EBADQUERY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (family == AF_INET6 && addr6ttls == NULL) {\n    return ARES_EBADQUERY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (req_naddrttls == 0) {\n    return ARES_EBADQUERY; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *naddrttls = 0;\n\n  next_cname = ai->cnames;\n  while (next_cname) {\n    if (next_cname->ttl < cname_ttl) {\n      cname_ttl = next_cname->ttl;\n    }\n    next_cname = next_cname->next;\n  }\n\n  for (next = ai->nodes; next != NULL; next = next->ai_next) {\n    if (next->ai_family != family) {\n      continue;\n    }\n\n    if (*naddrttls >= req_naddrttls) {\n      break;\n    }\n\n    if (family == AF_INET6) {\n      if (next->ai_ttl > cname_ttl) {\n        addr6ttls[*naddrttls].ttl = cname_ttl;\n      } else {\n        addr6ttls[*naddrttls].ttl = next->ai_ttl;\n      }\n\n      memcpy(&addr6ttls[*naddrttls].ip6addr,\n             &(CARES_INADDR_CAST(const struct sockaddr_in6 *, next->ai_addr)\n                 ->sin6_addr),\n             sizeof(struct ares_in6_addr));\n    } else {\n      if (next->ai_ttl > cname_ttl) {\n        addrttls[*naddrttls].ttl = cname_ttl;\n      } else {\n        addrttls[*naddrttls].ttl = next->ai_ttl;\n      }\n      memcpy(&addrttls[*naddrttls].ipaddr,\n             &(CARES_INADDR_CAST(const struct sockaddr_in *, next->ai_addr)\n                 ->sin_addr),\n             sizeof(struct in_addr));\n    }\n    (*naddrttls)++;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo2addrttl",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "family": "int",
              "req_naddrttls": "size_t",
              "addrttls": "struct ares_addrttl",
              "addr6ttls": "struct ares_addr6ttl",
              "naddrttls": "size_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            49,
            35
          ],
          [
            49,
            49
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            58,
            30
          ],
          [
            58,
            50
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            60,
            8
          ],
          [
            60,
            34
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            70,
            34
          ],
          [
            70,
            48
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            79,
            29
          ],
          [
            79,
            49
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            81,
            8
          ],
          [
            81,
            33
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            93,
            42
          ],
          [
            93,
            62
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            94,
            36
          ],
          [
            94,
            50
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            96,
            2
          ],
          [
            96,
            27
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            134,
            31
          ],
          [
            134,
            45
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            136,
            31
          ],
          [
            136,
            51
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            164,
            10
          ],
          [
            164,
            36
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            199,
            41
          ],
          [
            199,
            60
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            205,
            41
          ],
          [
            205,
            59
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            229,
            42
          ],
          [
            229,
            62
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            231,
            36
          ],
          [
            231,
            55
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            232,
            36
          ],
          [
            232,
            56
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            235,
            2
          ],
          [
            235,
            27
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            236,
            2
          ],
          [
            236,
            28
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            286,
            39
          ],
          [
            286,
            58
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            288,
            20
          ],
          [
            288,
            40
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            296,
            39
          ],
          [
            296,
            57
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            298,
            20
          ],
          [
            298,
            34
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_getaddrinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "struct ares_addrinfo_cname *\n  ares_append_addrinfo_cname(struct ares_addrinfo_cname **head)\n{\n  struct ares_addrinfo_cname *tail = ares_malloc_zero(sizeof(*tail));\n  struct ares_addrinfo_cname *last = *head;\n\n  if (tail == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (!last) {\n    *head = tail;\n    return tail;\n  }\n\n  while (last->next) {\n    last = last->next;\n  }\n\n  last->next = tail;\n  return tail;\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_addrinfo_cname",
            "parameters": {
              "head": "struct ares_addrinfo_cname"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void ares_addrinfo_cat_cnames(struct ares_addrinfo_cname **head,\n                              struct ares_addrinfo_cname  *tail)\n{\n  struct ares_addrinfo_cname *last = *head;\n  if (!last) {\n    *head = tail;\n    return;\n  }\n\n  while (last->next) {\n    last = last->next;\n  }\n\n  last->next = tail;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo_cat_cnames",
            "parameters": {
              "head": "struct ares_addrinfo_cname",
              "tail": "struct ares_addrinfo_cname"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "struct ares_addrinfo_node *\n  ares_append_addrinfo_node(struct ares_addrinfo_node **head)\n{\n  struct ares_addrinfo_node *tail = ares_malloc_zero(sizeof(*tail));\n  struct ares_addrinfo_node *last = *head;\n\n  if (tail == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (!last) {\n    *head = tail;\n    return tail;\n  }\n\n  while (last->ai_next) {\n    last = last->ai_next;\n  }\n\n  last->ai_next = tail;\n  return tail;\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_addrinfo_node",
            "parameters": {
              "head": "struct ares_addrinfo_node"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void ares_addrinfo_cat_nodes(struct ares_addrinfo_node **head,\n                             struct ares_addrinfo_node  *tail)\n{\n  struct ares_addrinfo_node *last = *head;\n  if (!last) {\n    *head = tail;\n    return;\n  }\n\n  while (last->ai_next) {\n    last = last->ai_next;\n  }\n\n  last->ai_next = tail;\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo_cat_nodes",
            "parameters": {
              "head": "struct ares_addrinfo_node",
              "tail": "struct ares_addrinfo_node"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned short lookup_service(const char *service, int flags)\n{\n  const char     *proto;\n  struct servent *sep;\n#ifdef HAVE_GETSERVBYNAME_R\n  struct servent se;\n  char           tmpbuf[4096];\n#endif\n\n  if (service) {\n    if (flags & ARES_NI_UDP) {\n      proto = \"udp\";\n    } else if (flags & ARES_NI_SCTP) {\n      proto = \"sctp\";\n    } else if (flags & ARES_NI_DCCP) {\n      proto = \"dccp\";\n    } else {\n      proto = \"tcp\";\n    }\n#ifdef HAVE_GETSERVBYNAME_R\n    memset(&se, 0, sizeof(se));\n    sep = &se;\n    memset(tmpbuf, 0, sizeof(tmpbuf));\n#  if GETSERVBYNAME_R_ARGS == 6\n    if (getservbyname_r(service, proto, &se, (void *)tmpbuf, sizeof(tmpbuf),\n                        &sep) != 0) {\n      sep = NULL; /* LCOV_EXCL_LINE: buffer large so this never fails */\n    }\n#  elif GETSERVBYNAME_R_ARGS == 5\n    sep = getservbyname_r(service, proto, &se, (void *)tmpbuf, sizeof(tmpbuf));\n#  elif GETSERVBYNAME_R_ARGS == 4\n    if (getservbyname_r(service, proto, &se, (void *)tmpbuf) != 0) {\n      sep = NULL;\n    }\n#  else\n    /* Lets just hope the OS uses TLS! */\n    sep = getservbyname(service, proto);\n#  endif\n#else\n    /* Lets just hope the OS uses TLS! */\n#  if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n    sep = getservbyname(service, (char *)proto);\n#  else\n    sep = getservbyname(service, proto);\n#  endif\n#endif\n    return (sep ? ntohs((unsigned short)sep->s_port) : 0);\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_service",
            "parameters": {
              "service": "char",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_bool_t fake_addrinfo(const char *name, unsigned short port,\n                                 const struct ares_addrinfo_hints *hints,\n                                 struct ares_addrinfo             *ai,\n                                 ares_addrinfo_callback callback, void *arg)\n{\n  struct ares_addrinfo_cname *cname;\n  ares_status_t               status = ARES_SUCCESS;\n  ares_bool_t                 result = ARES_FALSE;\n  int                         family = hints->ai_family;\n  if (family == AF_INET || family == AF_INET6 || family == AF_UNSPEC) {\n    /* It only looks like an IP address if it's all numbers and dots. */\n    size_t      numdots = 0;\n    ares_bool_t valid   = ARES_TRUE;\n    const char *p;\n    for (p = name; *p; p++) {\n      if (!ares_isdigit(*p) && *p != '.') {\n        valid = ARES_FALSE;\n        break;\n      } else if (*p == '.') {\n        numdots++;\n      }\n    }\n\n    /* if we don't have 3 dots, it is illegal\n     * (although inet_pton doesn't think so).\n     */\n    if (numdots != 3 || !valid) {\n      result = ARES_FALSE;\n    } else {\n      struct in_addr addr4;\n      result =\n        ares_inet_pton(AF_INET, name, &addr4) < 1 ? ARES_FALSE : ARES_TRUE;\n      if (result) {\n        status = ares_append_ai_node(AF_INET, port, 0, &addr4, &ai->nodes);\n        if (status != ARES_SUCCESS) {\n          callback(arg, (int)status, 0, NULL); /* LCOV_EXCL_LINE: OutOfMemory */\n          return ARES_TRUE;                    /* LCOV_EXCL_LINE: OutOfMemory */\n        }\n      }\n    }\n  }\n\n  if (!result && (family == AF_INET6 || family == AF_UNSPEC)) {\n    struct ares_in6_addr addr6;\n    result =\n      ares_inet_pton(AF_INET6, name, &addr6) < 1 ? ARES_FALSE : ARES_TRUE;\n    if (result) {\n      status = ares_append_ai_node(AF_INET6, port, 0, &addr6, &ai->nodes);\n      if (status != ARES_SUCCESS) {\n        callback(arg, (int)status, 0, NULL); /* LCOV_EXCL_LINE: OutOfMemory */\n        return ARES_TRUE;                    /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  if (!result) {\n    return ARES_FALSE;\n  }\n\n  if (hints->ai_flags & ARES_AI_CANONNAME) {\n    cname = ares_append_addrinfo_cname(&ai->cnames);\n    if (!cname) {\n      /* LCOV_EXCL_START: OutOfMemory */\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return ARES_TRUE;\n      /* LCOV_EXCL_STOP */\n    }\n\n    /* Duplicate the name, to avoid a constness violation. */\n    cname->name = ares_strdup(name);\n    if (!cname->name) {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return ARES_TRUE;\n    }\n  }\n\n  ai->nodes->ai_socktype = hints->ai_socktype;\n  ai->nodes->ai_protocol = hints->ai_protocol;\n\n  callback(arg, ARES_SUCCESS, 0, ai);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              318,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fake_addrinfo",
            "parameters": {
              "name": "char",
              "port": "unsigned short",
              "hints": "struct ares_addrinfo_hints",
              "ai": "struct ares_addrinfo",
              "callback": "ares_addrinfo_callback",
              "arg": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void hquery_free(struct host_query *hquery, ares_bool_t cleanup_ai)\n{\n  if (cleanup_ai) {\n    ares_freeaddrinfo(hquery->ai);\n  }\n  ares_strsplit_free(hquery->names, hquery->names_cnt);\n  ares_free(hquery->name);\n  ares_free(hquery->lookups);\n  ares_free(hquery);\n}",
          "fn_code_pos": [
            [
              320,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hquery_free",
            "parameters": {
              "hquery": "struct host_query",
              "cleanup_ai": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void end_hquery(struct host_query *hquery, ares_status_t status)\n{\n  struct ares_addrinfo_node  sentinel;\n  struct ares_addrinfo_node *next;\n\n  if (status == ARES_SUCCESS) {\n    if (!(hquery->hints.ai_flags & ARES_AI_NOSORT) && hquery->ai->nodes) {\n      sentinel.ai_next = hquery->ai->nodes;\n      ares_sortaddrinfo(hquery->channel, &sentinel);\n      hquery->ai->nodes = sentinel.ai_next;\n    }\n    next = hquery->ai->nodes;\n\n    while (next) {\n      next->ai_socktype = hquery->hints.ai_socktype;\n      next->ai_protocol = hquery->hints.ai_protocol;\n      next              = next->ai_next;\n    }\n  } else {\n    /* Clean up what we have collected by so far. */\n    ares_freeaddrinfo(hquery->ai);\n    hquery->ai = NULL;\n  }\n\n  hquery->callback(hquery->arg, (int)status, (int)hquery->timeouts, hquery->ai);\n  hquery_free(hquery, ARES_FALSE);\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_hquery",
            "parameters": {
              "hquery": "struct host_query",
              "status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares_is_localhost(const char *name)\n{\n  /* RFC6761 6.3 says : The domain \"localhost.\" and any names falling within\n   * \".localhost.\" */\n  size_t len;\n\n  if (name == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (ares_strcaseeq(name, \"localhost\")) {\n    return ARES_TRUE;\n  }\n\n  len = ares_strlen(name);\n  if (len < 10 /* strlen(\".localhost\") */) {\n    return ARES_FALSE;\n  }\n\n  if (ares_strcaseeq(name + (len - 10 /* strlen(\".localhost\") */),\n                     \".localhost\")) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              359,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_is_localhost",
            "parameters": {
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t file_lookup(struct host_query *hquery)\n{\n  const ares_hosts_entry_t *entry;\n  ares_status_t             status;\n\n  /* Per RFC 7686, reject queries for \".onion\" domain names with NXDOMAIN. */\n  if (ares_is_onion_domain(hquery->name)) {\n    return ARES_ENOTFOUND;\n  }\n\n  status = ares_hosts_search_host(\n    hquery->channel,\n    (hquery->hints.ai_flags & ARES_AI_ENVHOSTS) ? ARES_TRUE : ARES_FALSE,\n    hquery->name, &entry);\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_hosts_entry_to_addrinfo(\n    entry, hquery->name, hquery->hints.ai_family, hquery->port,\n    (hquery->hints.ai_flags & ARES_AI_CANONNAME) ? ARES_TRUE : ARES_FALSE,\n    hquery->ai);\n\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n\ndone:\n  /* RFC6761 section 6.3 #3 states that \"Name resolution APIs and libraries\n   * SHOULD recognize localhost names as special and SHOULD always return the\n   * IP loopback address for address queries\".\n   * We will also ignore ALL errors when trying to resolve localhost, such\n   * as permissions errors reading /etc/hosts or a malformed /etc/hosts.\n   *\n   * Also, just because the query itself returned success from /etc/hosts\n   * lookup doesn't mean it returned everything it needed to for all requested\n   * address families. As long as we're not on a critical out of memory\n   * condition pass it through to fill in any other address classes. */\n  if (status != ARES_ENOMEM && ares_is_localhost(hquery->name)) {\n    return ares_addrinfo_localhost(hquery->name, hquery->port, &hquery->hints,\n                                   hquery->ai);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_lookup",
            "parameters": {
              "hquery": "struct host_query"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void next_lookup(struct host_query *hquery, ares_status_t status)\n{\n  switch (*hquery->remaining_lookups) {\n    case 'b':\n      /* RFC6761 section 6.3 #3 says \"Name resolution APIs SHOULD NOT send\n       * queries for localhost names to their configured caching DNS\n       * server(s).\"\n       * Otherwise, DNS lookup. */\n      if (!ares_is_localhost(hquery->name) && next_dns_lookup(hquery)) {\n        break;\n      }\n\n      hquery->remaining_lookups++;\n      next_lookup(hquery, status);\n      break;\n\n    case 'f':\n      /* Host file lookup */\n      if (file_lookup(hquery) == ARES_SUCCESS) {\n        end_hquery(hquery, ARES_SUCCESS);\n        break;\n      }\n      hquery->remaining_lookups++;\n      next_lookup(hquery, status);\n      break;\n    default:\n      /* No lookup left */\n      end_hquery(hquery, status);\n      break;\n  }\n}",
          "fn_code_pos": [
            [
              434,
              0
            ],
            [
              464,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_lookup",
            "parameters": {
              "hquery": "struct host_query",
              "status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void terminate_retries(const struct host_query *hquery,\n                              unsigned short           qid)\n{\n  unsigned short term_qid =\n    (qid == hquery->qid_a) ? hquery->qid_aaaa : hquery->qid_a;\n  const ares_channel_t *channel = hquery->channel;\n  ares_query_t         *query   = NULL;\n\n  /* No other outstanding queries, nothing to do */\n  if (!hquery->remaining) {\n    return;\n  }\n\n  query = ares_htable_szvp_get_direct(channel->queries_by_qid, term_qid);\n  if (query == NULL) {\n    return;\n  }\n\n  query->no_retries = ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "terminate_retries",
            "parameters": {
              "hquery": "struct host_query",
              "qid": "unsigned short"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ai_has_ipv4(struct ares_addrinfo *ai)\n{\n  struct ares_addrinfo_node *node;\n\n  for (node = ai->nodes; node != NULL; node = node->ai_next) {\n    if (node->ai_family == AF_INET) {\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              487,
              0
            ],
            [
              497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ai_has_ipv4",
            "parameters": {
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void host_callback(void *arg, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec)\n{\n  struct host_query *hquery         = (struct host_query *)arg;\n  ares_status_t      addinfostatus  = ARES_SUCCESS;\n  hquery->timeouts                 += timeouts;\n  hquery->remaining--;\n\n  if (status == ARES_SUCCESS) {\n    if (dnsrec == NULL) {\n      addinfostatus = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n    } else {\n      addinfostatus =\n        ares_parse_into_addrinfo(dnsrec, ARES_TRUE, hquery->port, hquery->ai);\n    }\n\n    /* We sent out ipv4 and ipv6 requests simultaneously.  If we got a\n     * successful ipv4 response, we want to go ahead and tell the ipv6 request\n     * that if it fails or times out to not try again since we have the data\n     * we need.\n     *\n     * Our initial implementation of this would terminate retries if we got any\n     * successful response (ipv4 _or_ ipv6).  But we did get some user-reported\n     * issues with this that had bad system configs and odd behavior:\n     *  https://github.com/alpinelinux/docker-alpine/issues/366\n     *\n     * Essentially the ipv6 query succeeded but the ipv4 query failed or timed\n     * out, and so we only returned the ipv6 address, but the host couldn't\n     * use ipv6.  If we continued to allow ipv4 retries it would have found a\n     * server that worked and returned both address classes (this is clearly\n     * unexpected behavior).\n     *\n     * At some point down the road if ipv6 actually becomes required and\n     * reliable we can drop this ipv4 check.\n     */\n    if (addinfostatus == ARES_SUCCESS && ai_has_ipv4(hquery->ai)) {\n      terminate_retries(hquery, ares_dns_record_get_id(dnsrec));\n    }\n  }\n\n  if (!hquery->remaining) {\n    if (status == ARES_EDESTRUCTION || status == ARES_ECANCELLED) {\n      /* must make sure we don't do next_lookup() on destroy or cancel,\n       * and return the appropriate status.  We won't return a partial\n       * result in this case. */\n      end_hquery(hquery, status);\n    } else if (addinfostatus != ARES_SUCCESS && addinfostatus != ARES_ENODATA) {\n      /* error in parsing result e.g. no memory */\n      if (addinfostatus == ARES_EBADRESP && hquery->ai->nodes) {\n        /* We got a bad response from server, but at least one query\n         * ended with ARES_SUCCESS */\n        end_hquery(hquery, ARES_SUCCESS);\n      } else {\n        end_hquery(hquery, addinfostatus);\n      }\n    } else if (hquery->ai->nodes) {\n      /* at least one query ended with ARES_SUCCESS */\n      end_hquery(hquery, ARES_SUCCESS);\n    } else if (status == ARES_ENOTFOUND || status == ARES_ENODATA ||\n               addinfostatus == ARES_ENODATA) {\n      if (status == ARES_ENODATA || addinfostatus == ARES_ENODATA) {\n        hquery->nodata_cnt++;\n      }\n      next_lookup(hquery, hquery->nodata_cnt ? ARES_ENODATA : status);\n    } else if ((status == ARES_ESERVFAIL || status == ARES_EREFUSED) &&\n               ares_name_label_cnt(hquery->names[hquery->next_name_idx - 1]) ==\n                 1) {\n      /* Issue #852, systemd-resolved may return SERVFAIL or REFUSED on a\n       * single label domain name. */\n      next_lookup(hquery, hquery->nodata_cnt ? ARES_ENODATA : status);\n    } else {\n      end_hquery(hquery, status);\n    }\n  }\n\n  /* at this point we keep on waiting for the next query to finish */\n}",
          "fn_code_pos": [
            [
              499,
              0
            ],
            [
              575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "host_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t numeric_service_to_port(const char *service,\n                                           unsigned short *port)\n{\n  char *end;\n  unsigned long val;\n\n  errno = 0;\n  val   = strtoul(service, &end, 10);\n\n  if (errno == 0 && *end == '\\0' && val <= 65535) {\n    *port = (unsigned short)val;\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              577,
              0
            ],
            [
              592,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "numeric_service_to_port",
            "parameters": {
              "service": "char",
              "port": "unsigned short"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_getaddrinfo_int(ares_channel_t *channel, const char *name,\n                                 const char                       *service,\n                                 const struct ares_addrinfo_hints *hints,\n                                 ares_addrinfo_callback callback, void *arg)\n{\n  struct host_query    *hquery;\n  unsigned short        port = 0;\n  int                   family;\n  struct ares_addrinfo *ai;\n  ares_status_t         status;\n\n  if (!hints) {\n    hints = &default_hints;\n  }\n\n  family = hints->ai_family;\n\n  /* Right now we only know how to look up Internet addresses\n     and unspec means try both basically. */\n  if (family != AF_INET && family != AF_INET6 && family != AF_UNSPEC) {\n    callback(arg, ARES_ENOTIMP, 0, NULL);\n    return;\n  }\n\n  if (ares_is_onion_domain(name)) {\n    callback(arg, ARES_ENOTFOUND, 0, NULL);\n    return;\n  }\n\n  if (service) {\n    if (hints->ai_flags & ARES_AI_NUMERICSERV) {\n      if (!numeric_service_to_port(service, &port)) {\n        callback(arg, ARES_ESERVICE, 0, NULL);\n        return;\n      }\n    } else {\n      port = lookup_service(service, 0);\n      if (!port) {\n        if (!numeric_service_to_port(service, &port)) {\n          callback(arg, ARES_ESERVICE, 0, NULL);\n          return;\n        }\n      }\n    }\n  }\n\n  ai = ares_malloc_zero(sizeof(*ai));\n  if (!ai) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n\n  if (fake_addrinfo(name, port, hints, ai, callback, arg)) {\n    return;\n  }\n\n  /* Allocate and fill in the host query structure. */\n  hquery = ares_malloc_zero(sizeof(*hquery));\n  if (!hquery) {\n    ares_freeaddrinfo(ai);\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n\n  hquery->port        = port;\n  hquery->channel     = channel;\n  hquery->hints       = *hints;\n  hquery->sent_family = -1; /* nothing is sent yet */\n  hquery->callback    = callback;\n  hquery->arg         = arg;\n  hquery->ai          = ai;\n  hquery->name        = ares_strdup(name);\n  if (hquery->name == NULL) {\n    hquery_free(hquery, ARES_TRUE);\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n\n  status =\n    ares_search_name_list(channel, name, &hquery->names, &hquery->names_cnt);\n  if (status != ARES_SUCCESS) {\n    hquery_free(hquery, ARES_TRUE);\n    callback(arg, (int)status, 0, NULL);\n    return;\n  }\n  hquery->next_name_idx = 0;\n\n\n  hquery->lookups = ares_strdup(channel->lookups);\n  if (hquery->lookups == NULL) {\n    hquery_free(hquery, ARES_TRUE);\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n  hquery->remaining_lookups = hquery->lookups;\n\n  /* Start performing lookups according to channel->lookups. */\n  next_lookup(hquery, ARES_ECONNREFUSED /* initial error code */);\n}",
          "fn_code_pos": [
            [
              594,
              0
            ],
            [
              692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getaddrinfo_int",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "service": "char",
              "hints": "struct ares_addrinfo_hints",
              "callback": "ares_addrinfo_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_getaddrinfo(ares_channel_t *channel, const char *name,\n                      const char                       *service,\n                      const struct ares_addrinfo_hints *hints,\n                      ares_addrinfo_callback callback, void *arg)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares_channel_lock(channel);\n  ares_getaddrinfo_int(channel, name, service, hints, callback, arg);\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              694,
              0
            ],
            [
              705,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getaddrinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "service": "char",
              "hints": "struct ares_addrinfo_hints",
              "callback": "ares_addrinfo_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t next_dns_lookup(struct host_query *hquery)\n{\n  const char *name = NULL;\n\n  if (hquery->next_name_idx >= hquery->names_cnt) {\n    return ARES_FALSE;\n  }\n\n  name = hquery->names[hquery->next_name_idx++];\n\n  /* NOTE: hquery may be invalidated during the call to ares_query_qid(),\n   *       so should not be referenced after this point */\n  switch (hquery->hints.ai_family) {\n    case AF_INET:\n      hquery->remaining += 1;\n      ares_query_nolock(hquery->channel, name, ARES_CLASS_IN, ARES_REC_TYPE_A,\n                        host_callback, hquery, &hquery->qid_a);\n      break;\n    case AF_INET6:\n      hquery->remaining += 1;\n      ares_query_nolock(hquery->channel, name, ARES_CLASS_IN,\n                        ARES_REC_TYPE_AAAA, host_callback, hquery,\n                        &hquery->qid_aaaa);\n      break;\n    case AF_UNSPEC:\n      hquery->remaining += 2;\n      ares_query_nolock(hquery->channel, name, ARES_CLASS_IN, ARES_REC_TYPE_A,\n                        host_callback, hquery, &hquery->qid_a);\n      ares_query_nolock(hquery->channel, name, ARES_CLASS_IN,\n                        ARES_REC_TYPE_AAAA, host_callback, hquery,\n                        &hquery->qid_aaaa);\n      break;\n    default:\n      break;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              707,
              0
            ],
            [
              744,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_dns_lookup",
            "parameters": {
              "hquery": "struct host_query"
            },
            "return_type": "ares_bool_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "next_dns_lookup(struct host_query *hquery)",
          "fn_dec_pos": [
            [
              96,
              19
            ],
            [
              96,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_dns_lookup",
            "parameters": {
              "hquery": "struct host_query"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_append_addrinfo_cname(struct ares_addrinfo_cname **head)",
          "fn_dec_pos": [
            [
              99,
              2
            ],
            [
              99,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_addrinfo_cname",
            "parameters": {
              "head": "struct ares_addrinfo_cname"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_append_addrinfo_node(struct ares_addrinfo_node **head)",
          "fn_dec_pos": [
            [
              139,
              2
            ],
            [
              139,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_addrinfo_node",
            "parameters": {
              "head": "struct ares_addrinfo_node"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct host_query {\n  ares_channel_t            *channel;\n  char                      *name;\n  unsigned short             port; /* in host order */\n  ares_addrinfo_callback     callback;\n  void                      *arg;\n  struct ares_addrinfo_hints hints;\n  int    sent_family; /* this family is what was is being used */\n  size_t timeouts;    /* number of timeouts we saw for this request */\n  char  *lookups; /* Duplicate memory from channel because of ares_reinit() */\n  const char *remaining_lookups; /* types of lookup we need to perform (\"fb\" by\n                                    default, file and dns respectively) */\n\n  /* Search order for names */\n  char      **names;\n  size_t      names_cnt;\n  size_t      next_name_idx;       /* next name index being attempted */\n\n  struct ares_addrinfo *ai;        /* store results between lookups */\n  unsigned short        qid_a;     /* qid for A request */\n  unsigned short        qid_aaaa;  /* qid for AAAA request */\n\n  size_t                remaining; /* number of DNS answers waiting for */\n\n  /* Track nodata responses to possibly override final result */\n  size_t                nodata_cnt;\n}",
          {
            "*channel": "ares_channel_t",
            "*name": "char",
            "port": "unsigned short",
            "callback": "ares_addrinfo_callback",
            "*arg": "void",
            "hints": "struct ares_addrinfo_hints",
            "sent_family": "int",
            "timeouts": "size_t",
            "*lookups": "char",
            "char": "const",
            "**names": "char",
            "names_cnt": "size_t",
            "next_name_idx": "size_t",
            "*ai": "struct ares_addrinfo",
            "qid_a": "unsigned short",
            "qid_aaaa": "unsigned short",
            "remaining": "size_t",
            "nodata_cnt": "size_t"
          },
          "host_query",
          [
            60,
            0
          ],
          [
            86,
            1
          ]
        ],
        [
          "struct host_query {\n  ares_channel_t            *channel;\n  char                      *name;\n  unsigned short             port; /* in host order */\n  ares_addrinfo_callback     callback;\n  void                      *arg;\n  struct ares_addrinfo_hints hints;\n  int    sent_family; /* this family is what was is being used */\n  size_t timeouts;    /* number of timeouts we saw for this request */\n  char  *lookups; /* Duplicate memory from channel because of ares_reinit() */\n  const char *remaining_lookups; /* types of lookup we need to perform (\"fb\" by\n                                    default, file and dns respectively) */\n\n  /* Search order for names */\n  char      **names;\n  size_t      names_cnt;\n  size_t      next_name_idx;       /* next name index being attempted */\n\n  struct ares_addrinfo *ai;        /* store results between lookups */\n  unsigned short        qid_a;     /* qid for A request */\n  unsigned short        qid_aaaa;  /* qid for AAAA request */\n\n  size_t                remaining; /* number of DNS answers waiting for */\n\n  /* Track nodata responses to possibly override final result */\n  size_t                nodata_cnt;\n}",
          {
            "*channel": "ares_channel_t",
            "*name": "char",
            "port": "unsigned short",
            "callback": "ares_addrinfo_callback",
            "*arg": "void",
            "hints": "struct ares_addrinfo_hints",
            "sent_family": "int",
            "timeouts": "size_t",
            "*lookups": "char",
            "char": "const",
            "**names": "char",
            "names_cnt": "size_t",
            "next_name_idx": "size_t",
            "*ai": "struct ares_addrinfo",
            "qid_a": "unsigned short",
            "qid_aaaa": "unsigned short",
            "remaining": "size_t",
            "nodata_cnt": "size_t"
          },
          "host_query",
          [
            60,
            0
          ],
          [
            86,
            1
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            66,
            2
          ],
          [
            66,
            28
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            78,
            2
          ],
          [
            78,
            22
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            88,
            13
          ],
          [
            88,
            39
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            96,
            35
          ],
          [
            96,
            52
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            98,
            0
          ],
          [
            98,
            26
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            99,
            29
          ],
          [
            99,
            55
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            101,
            2
          ],
          [
            101,
            28
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            102,
            2
          ],
          [
            102,
            28
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            121,
            30
          ],
          [
            121,
            56
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            122,
            30
          ],
          [
            122,
            56
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            124,
            2
          ],
          [
            124,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            138,
            0
          ],
          [
            138,
            25
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            139,
            28
          ],
          [
            139,
            53
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            141,
            2
          ],
          [
            141,
            27
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            142,
            2
          ],
          [
            142,
            27
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            161,
            29
          ],
          [
            161,
            54
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            162,
            29
          ],
          [
            162,
            54
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            164,
            2
          ],
          [
            164,
            27
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            183,
            2
          ],
          [
            183,
            16
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            185,
            2
          ],
          [
            185,
            16
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            236,
            39
          ],
          [
            236,
            65
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            237,
            33
          ],
          [
            237,
            53
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            240,
            2
          ],
          [
            240,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            264,
            6
          ],
          [
            264,
            20
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            278,
            4
          ],
          [
            278,
            24
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            320,
            24
          ],
          [
            320,
            41
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            331,
            23
          ],
          [
            331,
            40
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            333,
            2
          ],
          [
            333,
            27
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            334,
            2
          ],
          [
            334,
            27
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            386,
            33
          ],
          [
            386,
            50
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            434,
            24
          ],
          [
            434,
            41
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            466,
            36
          ],
          [
            466,
            53
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            487,
            31
          ],
          [
            487,
            51
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            489,
            2
          ],
          [
            489,
            27
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            502,
            2
          ],
          [
            502,
            19
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            502,
            39
          ],
          [
            502,
            56
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            596,
            39
          ],
          [
            596,
            65
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            599,
            2
          ],
          [
            599,
            19
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            602,
            2
          ],
          [
            602,
            22
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            696,
            28
          ],
          [
            696,
            54
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            707,
            35
          ],
          [
            707,
            52
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_sortaddrinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "static int get_scope(const struct sockaddr *addr)\n{\n  if (addr->sa_family == AF_INET6) {\n    const struct sockaddr_in6 *addr6 =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);\n    if (IN6_IS_ADDR_MULTICAST(&addr6->sin6_addr)) {\n      return ARES_IPV6_ADDR_MC_SCOPE(&addr6->sin6_addr);\n    } else if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr) ||\n               IN6_IS_ADDR_LINKLOCAL(&addr6->sin6_addr)) {\n      /*\n       * RFC 4291 section 2.5.3 says loopback is to be treated as having\n       * link-local scope.\n       */\n      return ARES_IPV6_ADDR_SCOPE_LINKLOCAL;\n    } else if (IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr)) {\n      return ARES_IPV6_ADDR_SCOPE_SITELOCAL;\n    } else {\n      return ARES_IPV6_ADDR_SCOPE_GLOBAL;\n    }\n  } else if (addr->sa_family == AF_INET) {\n    const struct sockaddr_in *addr4 =\n      CARES_INADDR_CAST(const struct sockaddr_in *, addr);\n    unsigned long int na = ntohl(addr4->sin_addr.s_addr);\n    if (ARES_IN_LOOPBACK(na) ||          /* 127.0.0.0/8 */\n        (na & 0xffff0000) == 0xa9fe0000) /* 169.254.0.0/16 */\n    {\n      return ARES_IPV6_ADDR_SCOPE_LINKLOCAL;\n    } else {\n      /*\n       * RFC 6724 section 3.2. Other IPv4 addresses, including private\n       * addresses and shared addresses (100.64.0.0/10), are assigned global\n       * scope.\n       */\n      return ARES_IPV6_ADDR_SCOPE_GLOBAL;\n    }\n  } else {\n    /*\n     * This should never happen.\n     * Return a scope with low priority as a last resort.\n     */\n    return ARES_IPV6_ADDR_SCOPE_NODELOCAL;\n  }\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_scope",
            "parameters": {
              "addr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int get_label(const struct sockaddr *addr)\n{\n  if (addr->sa_family == AF_INET) {\n    return 4;\n  } else if (addr->sa_family == AF_INET6) {\n    const struct sockaddr_in6 *addr6 =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);\n    if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr)) {\n      return 0;\n    } else if (IN6_IS_ADDR_V4MAPPED(&addr6->sin6_addr)) {\n      return 4;\n    } else if (ARES_IN6_IS_ADDR_6TO4(&addr6->sin6_addr)) {\n      return 2;\n    } else if (ARES_IN6_IS_ADDR_TEREDO(&addr6->sin6_addr)) {\n      return 5;\n    } else if (ARES_IN6_IS_ADDR_ULA(&addr6->sin6_addr)) {\n      return 13;\n    } else if (IN6_IS_ADDR_V4COMPAT(&addr6->sin6_addr)) {\n      return 3;\n    } else if (IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr)) {\n      return 11;\n    } else if (ARES_IN6_IS_ADDR_6BONE(&addr6->sin6_addr)) {\n      return 12;\n    } else {\n      /* All other IPv6 addresses, including global unicast addresses. */\n      return 1;\n    }\n  } else {\n    /*\n     * This should never happen.\n     * Return a semi-random label as a last resort.\n     */\n    return 1;\n  }\n}",
          "fn_code_pos": [
            [
              131,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_label",
            "parameters": {
              "addr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int get_precedence(const struct sockaddr *addr)\n{\n  if (addr->sa_family == AF_INET) {\n    return 35;\n  } else if (addr->sa_family == AF_INET6) {\n    const struct sockaddr_in6 *addr6 =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);\n    if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr)) {\n      return 50;\n    } else if (IN6_IS_ADDR_V4MAPPED(&addr6->sin6_addr)) {\n      return 35;\n    } else if (ARES_IN6_IS_ADDR_6TO4(&addr6->sin6_addr)) {\n      return 30;\n    } else if (ARES_IN6_IS_ADDR_TEREDO(&addr6->sin6_addr)) {\n      return 5;\n    } else if (ARES_IN6_IS_ADDR_ULA(&addr6->sin6_addr)) {\n      return 3;\n    } else if (IN6_IS_ADDR_V4COMPAT(&addr6->sin6_addr) ||\n               IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr) ||\n               ARES_IN6_IS_ADDR_6BONE(&addr6->sin6_addr)) {\n      return 1;\n    } else {\n      /* All other IPv6 addresses, including global unicast addresses. */\n      return 40;\n    }\n  } else {\n    return 1;\n  }\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_precedence",
            "parameters": {
              "addr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static size_t common_prefix_len(const struct in6_addr *a1,\n                                const struct in6_addr *a2)\n{\n  const unsigned char *p1 = (const unsigned char *)a1;\n  const unsigned char *p2 = (const unsigned char *)a2;\n  size_t               i;\n  for (i = 0; i < sizeof(*a1); ++i) {\n    unsigned char x;\n    size_t        j;\n    if (p1[i] == p2[i]) {\n      continue;\n    }\n    x = p1[i] ^ p2[i];\n    for (j = 0; j < CHAR_BIT; ++j) {\n      if (x & (1 << (CHAR_BIT - 1))) {\n        return i * CHAR_BIT + j;\n      }\n      x <<= 1;\n    }\n  }\n  return sizeof(*a1) * CHAR_BIT;\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "common_prefix_len",
            "parameters": {
              "a1": "struct in6_addr",
              "a2": "struct in6_addr"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static int rfc6724_compare(const void *ptr1, const void *ptr2)\n{\n  const struct addrinfo_sort_elem *a1 = (const struct addrinfo_sort_elem *)ptr1;\n  const struct addrinfo_sort_elem *a2 = (const struct addrinfo_sort_elem *)ptr2;\n  int                              scope_src1;\n  int                              scope_dst1;\n  int                              scope_match1;\n  int                              scope_src2;\n  int                              scope_dst2;\n  int                              scope_match2;\n  int                              label_src1;\n  int                              label_dst1;\n  int                              label_match1;\n  int                              label_src2;\n  int                              label_dst2;\n  int                              label_match2;\n  int                              precedence1;\n  int                              precedence2;\n  size_t                           prefixlen1;\n  size_t                           prefixlen2;\n\n  /* Rule 1: Avoid unusable destinations. */\n  if (a1->has_src_addr != a2->has_src_addr) {\n    return ((int)a2->has_src_addr) - ((int)a1->has_src_addr);\n  }\n\n  /* Rule 2: Prefer matching scope. */\n  scope_src1 = ARES_IPV6_ADDR_SCOPE_NODELOCAL;\n  if (a1->has_src_addr) {\n    scope_src1 = get_scope(&a1->src_addr.sa);\n  }\n  scope_dst1   = get_scope(a1->ai->ai_addr);\n  scope_match1 = (scope_src1 == scope_dst1);\n\n  scope_src2 = ARES_IPV6_ADDR_SCOPE_NODELOCAL;\n  if (a2->has_src_addr) {\n    scope_src2 = get_scope(&a2->src_addr.sa);\n  }\n  scope_dst2   = get_scope(a2->ai->ai_addr);\n  scope_match2 = (scope_src2 == scope_dst2);\n\n  if (scope_match1 != scope_match2) {\n    return scope_match2 - scope_match1;\n  }\n\n  /* Rule 3: Avoid deprecated addresses.  */\n\n  /* Rule 4: Prefer home addresses.  */\n\n  /* Rule 5: Prefer matching label. */\n  label_src1 = 1;\n  if (a1->has_src_addr) {\n    label_src1 = get_label(&a1->src_addr.sa);\n  }\n  label_dst1   = get_label(a1->ai->ai_addr);\n  label_match1 = (label_src1 == label_dst1);\n\n  label_src2 = 1;\n  if (a2->has_src_addr) {\n    label_src2 = get_label(&a2->src_addr.sa);\n  }\n  label_dst2   = get_label(a2->ai->ai_addr);\n  label_match2 = (label_src2 == label_dst2);\n\n  if (label_match1 != label_match2) {\n    return label_match2 - label_match1;\n  }\n\n  /* Rule 6: Prefer higher precedence. */\n  precedence1 = get_precedence(a1->ai->ai_addr);\n  precedence2 = get_precedence(a2->ai->ai_addr);\n  if (precedence1 != precedence2) {\n    return precedence2 - precedence1;\n  }\n\n  /* Rule 7: Prefer native transport.  */\n\n  /* Rule 8: Prefer smaller scope. */\n  if (scope_dst1 != scope_dst2) {\n    return scope_dst1 - scope_dst2;\n  }\n\n  /* Rule 9: Use longest matching prefix. */\n  if (a1->has_src_addr && a1->ai->ai_addr->sa_family == AF_INET6 &&\n      a2->has_src_addr && a2->ai->ai_addr->sa_family == AF_INET6) {\n    const struct sockaddr_in6 *a1_src = &a1->src_addr.sa6;\n    const struct sockaddr_in6 *a1_dst =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, a1->ai->ai_addr);\n    const struct sockaddr_in6 *a2_src = &a2->src_addr.sa6;\n    const struct sockaddr_in6 *a2_dst =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, a2->ai->ai_addr);\n    prefixlen1 = common_prefix_len(&a1_src->sin6_addr, &a1_dst->sin6_addr);\n    prefixlen2 = common_prefix_len(&a2_src->sin6_addr, &a2_dst->sin6_addr);\n    if (prefixlen1 != prefixlen2) {\n      return (int)prefixlen2 - (int)prefixlen1;\n    }\n  }\n\n  /*\n   * Rule 10: Leave the order unchanged.\n   * We need this since qsort() is not necessarily stable.\n   */\n  return ((int)a1->original_order) - ((int)a2->original_order);\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rfc6724_compare",
            "parameters": {
              "ptr1": "void",
              "ptr2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int find_src_addr(ares_channel_t *channel, const struct sockaddr *addr,\n                         struct sockaddr *src_addr)\n{\n  ares_socket_t   sock;\n  ares_socklen_t  len;\n  ares_conn_err_t err;\n\n  switch (addr->sa_family) {\n    case AF_INET:\n      len = sizeof(struct sockaddr_in);\n      break;\n    case AF_INET6:\n      len = sizeof(struct sockaddr_in6);\n      break;\n    default:\n      /* No known usable source address for non-INET families. */\n      return 0;\n  }\n\n  err =\n    ares_socket_open(&sock, channel, addr->sa_family, SOCK_DGRAM, IPPROTO_UDP);\n  if (err == ARES_CONN_ERR_AFNOSUPPORT) {\n    return 0;\n  } else if (err != ARES_CONN_ERR_SUCCESS) {\n    return -1;\n  }\n\n  err = ares_socket_connect(channel, sock, ARES_FALSE, addr, len);\n  if (err != ARES_CONN_ERR_SUCCESS && err != ARES_CONN_ERR_WOULDBLOCK) {\n    ares_socket_close(channel, sock);\n    return 0;\n  }\n\n  if (channel->sock_funcs.agetsockname == NULL ||\n      channel->sock_funcs.agetsockname(sock, src_addr, &len,\n                                       channel->sock_func_cb_data) != 0) {\n    ares_socket_close(channel, sock);\n    return -1;\n  }\n  ares_socket_close(channel, sock);\n  return 1;\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_src_addr",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "struct sockaddr",
              "src_addr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_status_t ares_sortaddrinfo(ares_channel_t            *channel,\n                                struct ares_addrinfo_node *list_sentinel)\n{\n  struct ares_addrinfo_node *cur;\n  size_t                     nelem = 0;\n  size_t                     i;\n  int                        has_src_addr;\n  struct addrinfo_sort_elem *elems;\n\n  cur = list_sentinel->ai_next;\n  while (cur) {\n    ++nelem;\n    cur = cur->ai_next;\n  }\n\n  if (!nelem) {\n    return ARES_ENODATA;\n  }\n\n  elems = (struct addrinfo_sort_elem *)ares_malloc(\n    nelem * sizeof(struct addrinfo_sort_elem));\n  if (!elems) {\n    return ARES_ENOMEM;\n  }\n\n  /*\n   * Convert the linked list to an array that also contains the candidate\n   * source address for each destination address.\n   */\n  for (i = 0, cur = list_sentinel->ai_next; i < nelem;\n       ++i, cur   = cur->ai_next) {\n    assert(cur != NULL);\n    elems[i].ai             = cur;\n    elems[i].original_order = i;\n    has_src_addr = find_src_addr(channel, cur->ai_addr, &elems[i].src_addr.sa);\n    if (has_src_addr == -1) {\n      ares_free(elems);\n      return ARES_ENOTFOUND;\n    }\n    elems[i].has_src_addr = (has_src_addr == 1) ? ARES_TRUE : ARES_FALSE;\n  }\n\n  /* Sort the addresses, and rearrange the linked list so it matches the sorted\n   * order. */\n  qsort((void *)elems, nelem, sizeof(struct addrinfo_sort_elem),\n        rfc6724_compare);\n\n  list_sentinel->ai_next = elems[0].ai;\n  for (i = 0; i < nelem - 1; ++i) {\n    elems[i].ai->ai_next = elems[i + 1].ai;\n  }\n  elems[nelem - 1].ai->ai_next = NULL;\n\n  ares_free(elems);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sortaddrinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "list_sentinel": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct addrinfo_sort_elem {\n  struct ares_addrinfo_node *ai;\n  ares_bool_t                has_src_addr;\n  ares_sockaddr              src_addr;\n  size_t                     original_order;\n}",
          {
            "*ai": "struct ares_addrinfo_node",
            "has_src_addr": "ares_bool_t",
            "src_addr": "ares_sockaddr",
            "original_order": "size_t"
          },
          "addrinfo_sort_elem",
          [
            53,
            0
          ],
          [
            58,
            1
          ]
        ],
        [
          "struct addrinfo_sort_elem {\n  struct ares_addrinfo_node *ai;\n  ares_bool_t                has_src_addr;\n  ares_sockaddr              src_addr;\n  size_t                     original_order;\n}",
          {
            "*ai": "struct ares_addrinfo_node",
            "has_src_addr": "ares_bool_t",
            "src_addr": "ares_sockaddr",
            "original_order": "size_t"
          },
          "addrinfo_sort_elem",
          [
            53,
            0
          ],
          [
            58,
            1
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            54,
            2
          ],
          [
            54,
            27
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            87,
            27
          ],
          [
            87,
            42
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            90,
            10
          ],
          [
            90,
            29
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            107,
            10
          ],
          [
            107,
            28
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            131,
            27
          ],
          [
            131,
            42
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            136,
            10
          ],
          [
            136,
            29
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            171,
            32
          ],
          [
            171,
            47
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            176,
            10
          ],
          [
            176,
            29
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            204,
            38
          ],
          [
            204,
            53
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            205,
            38
          ],
          [
            205,
            53
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            233,
            8
          ],
          [
            233,
            33
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            233,
            47
          ],
          [
            233,
            72
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            234,
            8
          ],
          [
            234,
            33
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            234,
            47
          ],
          [
            234,
            72
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            316,
            10
          ],
          [
            316,
            29
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            317,
            10
          ],
          [
            317,
            29
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            319,
            10
          ],
          [
            319,
            29
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            320,
            10
          ],
          [
            320,
            29
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            344,
            56
          ],
          [
            344,
            71
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            345,
            25
          ],
          [
            345,
            40
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            353,
            19
          ],
          [
            353,
            37
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            356,
            19
          ],
          [
            356,
            38
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            392,
            32
          ],
          [
            392,
            57
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            394,
            2
          ],
          [
            394,
            27
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            398,
            2
          ],
          [
            398,
            27
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            410,
            11
          ],
          [
            410,
            36
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            411,
            19
          ],
          [
            411,
            44
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            435,
            37
          ],
          [
            435,
            62
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_destroy.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_destroy(ares_channel_t *channel)\n{\n  size_t             i;\n  ares_llist_node_t *node = NULL;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  /* Mark as being shutdown */\n  ares_channel_lock(channel);\n  channel->sys_up = ARES_FALSE;\n  ares_channel_unlock(channel);\n\n  /* Disable configuration change monitoring.  We can't hold a lock because\n   * some cleanup routines, such as on Windows, are synchronous operations.\n   * What we've observed is a system config change event was triggered right\n   * at shutdown time and it tries to take the channel lock and the destruction\n   * waits for that event to complete before it continues so we get a channel\n   * lock deadlock at shutdown if we hold a lock during this process. */\n  if (channel->optmask & ARES_OPT_EVENT_THREAD) {\n    ares_event_thread_t *e = channel->sock_state_cb_data;\n    if (e && e->configchg) {\n      ares_event_configchg_destroy(e->configchg);\n      e->configchg = NULL;\n    }\n  }\n\n  /* Wait for reinit thread to exit if there was one pending, can't be\n   * holding a lock as the thread may take locks. */\n  if (channel->reinit_thread != NULL) {\n    void *rv;\n    ares_thread_join(channel->reinit_thread, &rv);\n    channel->reinit_thread = NULL;\n  }\n\n  /* Lock because callbacks will be triggered, and any system-generated\n   * callbacks need to hold a channel lock. */\n  ares_channel_lock(channel);\n\n  /* Destroy all queries */\n  node = ares_llist_node_first(channel->all_queries);\n  while (node != NULL) {\n    ares_llist_node_t *next  = ares_llist_node_next(node);\n    ares_query_t      *query = ares_llist_node_claim(node);\n\n    query->node_all_queries = NULL;\n    query->callback(query->arg, ARES_EDESTRUCTION, 0, NULL);\n    ares_free_query(query);\n\n    node = next;\n  }\n\n  ares_queue_notify_empty(channel);\n\n#ifndef NDEBUG\n  /* Freeing the query should remove it from all the lists in which it sits,\n   * so all query lists should be empty now.\n   */\n  assert(ares_llist_len(channel->all_queries) == 0);\n  assert(ares_htable_szvp_num_keys(channel->queries_by_qid) == 0);\n  assert(ares_slist_len(channel->queries_by_timeout) == 0);\n#endif\n\n  ares_destroy_servers_state(channel);\n\n#ifndef NDEBUG\n  assert(ares_htable_asvp_num_keys(channel->connnode_by_socket) == 0);\n#endif\n\n  /* No more callbacks will be triggered after this point, unlock */\n  ares_channel_unlock(channel);\n\n  /* Shut down the event thread */\n  if (channel->optmask & ARES_OPT_EVENT_THREAD) {\n    ares_event_thread_destroy(channel);\n  }\n\n  if (channel->domains) {\n    for (i = 0; i < channel->ndomains; i++) {\n      ares_free(channel->domains[i]);\n    }\n    ares_free(channel->domains);\n  }\n\n  ares_llist_destroy(channel->all_queries);\n  ares_slist_destroy(channel->queries_by_timeout);\n  ares_htable_szvp_destroy(channel->queries_by_qid);\n  ares_htable_asvp_destroy(channel->connnode_by_socket);\n\n  ares_free(channel->sortlist);\n  ares_free(channel->lookups);\n  ares_free(channel->resolvconf_path);\n  ares_free(channel->hosts_path);\n  ares_destroy_rand_state(channel->rand_state);\n\n  ares_hosts_file_destroy(channel->hf);\n\n  ares_qcache_destroy(channel->qcache);\n\n  ares_channel_threading_destroy(channel);\n\n  ares_free(channel);\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_destroy_server(ares_server_t *server)\n{\n  if (server == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_close_sockets(server);\n  ares_llist_destroy(server->connections);\n  ares_free(server);\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_server",
            "parameters": {
              "server": "ares_server_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_destroy_servers_state(ares_channel_t *channel)\n{\n  ares_slist_node_t *node;\n\n  while ((node = ares_slist_node_first(channel->servers)) != NULL) {\n    ares_server_t *server = ares_slist_node_claim(node);\n    ares_destroy_server(server);\n  }\n\n  ares_slist_destroy(channel->servers);\n  channel->servers = NULL;\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_servers_state",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"event/ares_event.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_cookie.c": {
      "fn_def_list": [
        {
          "fn_code": "static const unsigned char *\n  ares_dns_cookie_fetch(const ares_dns_record_t *dnsrec, size_t *len)\n{\n  const ares_dns_rr_t *rr  = ares_dns_get_opt_rr_const(dnsrec);\n  const unsigned char *val = NULL;\n  *len                     = 0;\n\n  if (rr == NULL) {\n    return NULL;\n  }\n\n  if (!ares_dns_rr_get_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE,\n                                &val, len)) {\n    return NULL;\n  }\n\n  return val;\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_cookie_fetch",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_bool_t timeval_is_set(const ares_timeval_t *tv)\n{\n  if (tv->sec != 0 && tv->usec != 0) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "timeval_is_set",
            "parameters": {
              "tv": "ares_timeval_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t timeval_expired(const ares_timeval_t *tv,\n                                   const ares_timeval_t *now,\n                                   unsigned long         millsecs)\n{\n  ares_int64_t   tvdiff_ms;\n  ares_timeval_t tvdiff;\n  ares_timeval_diff(&tvdiff, tv, now);\n\n  tvdiff_ms = tvdiff.sec * 1000 + tvdiff.usec / 1000;\n  if (tvdiff_ms >= (ares_int64_t)millsecs) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              225,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "timeval_expired",
            "parameters": {
              "tv": "ares_timeval_t",
              "now": "ares_timeval_t",
              "millsecs": "unsigned long"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_cookie_clear(ares_cookie_t *cookie)\n{\n  memset(cookie, 0, sizeof(*cookie));\n  cookie->state = ARES_COOKIE_INITIAL;\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cookie_clear",
            "parameters": {
              "cookie": "ares_cookie_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_cookie_generate(ares_cookie_t *cookie, ares_conn_t *conn,\n                                 const ares_timeval_t *now)\n{\n  ares_channel_t *channel = conn->server->channel;\n\n  ares_rand_bytes(channel->rand_state, cookie->client, sizeof(cookie->client));\n  memcpy(&cookie->client_ts, now, sizeof(cookie->client_ts));\n  memcpy(&cookie->client_ip, &conn->self_ip, sizeof(cookie->client_ip));\n}",
          "fn_code_pos": [
            [
              246,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cookie_generate",
            "parameters": {
              "cookie": "ares_cookie_t",
              "conn": "ares_conn_t",
              "now": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_cookie_clear_server(ares_cookie_t *cookie)\n{\n  memset(cookie->server, 0, sizeof(cookie->server));\n  cookie->server_len = 0;\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cookie_clear_server",
            "parameters": {
              "cookie": "ares_cookie_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_addr_equal(const struct ares_addr *addr1,\n                                   const struct ares_addr *addr2)\n{\n  if (addr1->family != addr2->family) {\n    return ARES_FALSE;\n  }\n\n  switch (addr1->family) {\n    case AF_INET:\n      if (memcmp(&addr1->addr.addr4, &addr2->addr.addr4,\n                 sizeof(addr1->addr.addr4)) == 0) {\n        return ARES_TRUE;\n      }\n      break;\n    case AF_INET6:\n      /* This structure is weird, and due to padding SonarCloud complains if\n       * you don't punch all the way down.  At some point we should rework\n       * this structure */\n      if (memcmp(&addr1->addr.addr6._S6_un._S6_u8,\n                 &addr2->addr.addr6._S6_un._S6_u8,\n                 sizeof(addr1->addr.addr6._S6_un._S6_u8)) == 0) {\n        return ARES_TRUE;\n      }\n      break;\n    default:\n      break; /* LCOV_EXCL_LINE */\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              291,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addr_equal",
            "parameters": {
              "addr1": "struct ares_addr",
              "addr2": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_cookie_apply(ares_dns_record_t *dnsrec, ares_conn_t *conn,\n                                const ares_timeval_t *now)\n{\n  ares_server_t *server = conn->server;\n  ares_cookie_t *cookie = &server->cookie;\n  ares_dns_rr_t *rr     = ares_dns_get_opt_rr(dnsrec);\n  unsigned char  c[40];\n  size_t         c_len;\n\n  /* If there is no OPT record, then EDNS isn't supported, and therefore\n   * cookies can't be supported */\n  if (rr == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* No cookies on TCP, make sure we remove one if one is present */\n  if (conn->flags & ARES_CONN_FLAG_TCP) {\n    ares_dns_rr_del_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE);\n    return ARES_SUCCESS;\n  }\n\n  /* Look for regression */\n  if (cookie->state == ARES_COOKIE_SUPPORTED &&\n      timeval_is_set(&cookie->unsupported_ts) &&\n      timeval_expired(&cookie->unsupported_ts, now,\n                      COOKIE_REGRESSION_TIMEOUT_MS)) {\n    ares_cookie_clear(cookie);\n  }\n\n  /* Handle unsupported state */\n  if (cookie->state == ARES_COOKIE_UNSUPPORTED) {\n    /* If timer hasn't expired, just delete any possible cookie and return */\n    if (!timeval_expired(&cookie->unsupported_ts, now,\n                         COOKIE_REGRESSION_TIMEOUT_MS)) {\n      ares_dns_rr_del_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE);\n      return ARES_SUCCESS;\n    }\n\n    /* We want to try to \"learn\" again */\n    ares_cookie_clear(cookie);\n  }\n\n  /* Generate a new cookie */\n  if (cookie->state == ARES_COOKIE_INITIAL) {\n    ares_cookie_generate(cookie, conn, now);\n    cookie->state = ARES_COOKIE_GENERATED;\n  }\n\n  /* Regenerate the cookie and clear the server cookie if the client ip has\n   * changed */\n  if ((cookie->state == ARES_COOKIE_GENERATED ||\n       cookie->state == ARES_COOKIE_SUPPORTED) &&\n      !ares_addr_equal(&conn->self_ip, &cookie->client_ip)) {\n    ares_cookie_clear_server(cookie);\n    ares_cookie_generate(cookie, conn, now);\n  }\n\n  /* If the client cookie has reached its maximum time, refresh it */\n  if (cookie->state == ARES_COOKIE_SUPPORTED &&\n      timeval_expired(&cookie->client_ts, now, COOKIE_CLIENT_TIMEOUT_MS)) {\n    ares_cookie_clear_server(cookie);\n    ares_cookie_generate(cookie, conn, now);\n  }\n\n  /* Generate the full cookie which is the client cookie concatenated with the\n   * server cookie (if there is one) and apply it. */\n  memcpy(c, cookie->client, sizeof(cookie->client));\n  if (cookie->server_len) {\n    memcpy(c + sizeof(cookie->client), cookie->server, cookie->server_len);\n  }\n  c_len = sizeof(cookie->client) + cookie->server_len;\n\n  return ares_dns_rr_set_opt(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE, c,\n                             c_len);\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cookie_apply",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "conn": "ares_conn_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_cookie_validate(ares_query_t            *query,\n                                   const ares_dns_record_t *dnsresp,\n                                   ares_conn_t *conn, const ares_timeval_t *now,\n                                   ares_array_t **requeue)\n{\n  ares_server_t           *server = conn->server;\n  ares_cookie_t           *cookie = &server->cookie;\n  const ares_dns_record_t *dnsreq = query->query;\n  const unsigned char     *resp_cookie;\n  size_t                   resp_cookie_len;\n  const unsigned char     *req_cookie;\n  size_t                   req_cookie_len;\n\n  resp_cookie = ares_dns_cookie_fetch(dnsresp, &resp_cookie_len);\n\n  /* Invalid cookie length, drop */\n  if (resp_cookie && (resp_cookie_len < 8 || resp_cookie_len > 40)) {\n    return ARES_EBADRESP;\n  }\n\n  req_cookie = ares_dns_cookie_fetch(dnsreq, &req_cookie_len);\n\n  /* Didn't request cookies, so we can stop evaluating */\n  if (req_cookie == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* If 8-byte prefix for returned cookie doesn't match the requested cookie,\n   * drop for spoofing */\n  if (resp_cookie && memcmp(req_cookie, resp_cookie, 8) != 0) {\n    return ARES_EBADRESP;\n  }\n\n  if (resp_cookie && resp_cookie_len > 8) {\n    /* Make sure we record that we successfully received a cookie response */\n    cookie->state = ARES_COOKIE_SUPPORTED;\n    memset(&cookie->unsupported_ts, 0, sizeof(cookie->unsupported_ts));\n\n    /* If client cookie hasn't been rotated, save the returned server cookie */\n    if (memcmp(cookie->client, req_cookie, sizeof(cookie->client)) == 0) {\n      cookie->server_len = resp_cookie_len - 8;\n      memcpy(cookie->server, resp_cookie + 8, cookie->server_len);\n    }\n  }\n\n  if (ares_dns_record_get_rcode(dnsresp) == ARES_RCODE_BADCOOKIE) {\n    /* Illegal to return BADCOOKIE but no cookie, drop */\n    if (resp_cookie == NULL) {\n      return ARES_EBADRESP;\n    }\n\n    /* If we have too many attempts to send a cookie, we need to requeue as\n     * tcp */\n    query->cookie_try_count++;\n    if (query->cookie_try_count >= COOKIE_RESEND_MAX) {\n      query->using_tcp = ARES_TRUE;\n    }\n\n    /* Resend the request, hopefully it will work the next time as we should\n     * have recorded a server cookie */\n    ares_requeue_query(query, now, ARES_SUCCESS,\n                       ARES_FALSE /* Don't increment try count */, NULL,\n                       requeue);\n\n    /* Parent needs to drop this response */\n    return ARES_EBADRESP;\n  }\n\n  /* We've got a response with a server cookie, and we've done all the\n   * evaluation we can, return success */\n  if (resp_cookie_len > 8) {\n    return ARES_SUCCESS;\n  }\n\n  if (cookie->state == ARES_COOKIE_SUPPORTED) {\n    /* If we're not currently tracking an error time yet, start */\n    if (!timeval_is_set(&cookie->unsupported_ts)) {\n      memcpy(&cookie->unsupported_ts, now, sizeof(cookie->unsupported_ts));\n    }\n    /* Drop it since we expected a cookie */\n    return ARES_EBADRESP;\n  }\n\n  if (cookie->state == ARES_COOKIE_GENERATED) {\n    ares_cookie_clear(cookie);\n    cookie->state = ARES_COOKIE_UNSUPPORTED;\n    memcpy(&cookie->unsupported_ts, now, sizeof(cookie->unsupported_ts));\n  }\n\n  /* Cookie state should be UNSUPPORTED if we're here */\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cookie_validate",
            "parameters": {
              "query": "ares_query_t",
              "dnsresp": "ares_dns_record_t",
              "conn": "ares_conn_t",
              "now": "ares_timeval_t",
              "requeue": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_cookie_fetch(const ares_dns_record_t *dnsrec, size_t *len)",
          "fn_dec_pos": [
            [
              199,
              2
            ],
            [
              199,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_cookie_fetch",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addr",
          {},
          "",
          [
            262,
            41
          ],
          [
            262,
            57
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            263,
            41
          ],
          [
            263,
            57
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            185,
            0
          ],
          [
            186,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_parse_into_addrinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_parse_into_addrinfo(const ares_dns_record_t *dnsrec,\n                                       ares_bool_t    cname_only_is_enodata,\n                                       unsigned short port,\n                                       struct ares_addrinfo *ai)\n{\n  ares_status_t               status;\n  size_t                      i;\n  size_t                      ancount;\n  const char                 *hostname  = NULL;\n  ares_bool_t                 got_a     = ARES_FALSE;\n  ares_bool_t                 got_aaaa  = ARES_FALSE;\n  ares_bool_t                 got_cname = ARES_FALSE;\n  struct ares_addrinfo_cname *cnames    = NULL;\n  struct ares_addrinfo_node  *nodes     = NULL;\n\n  /* Save question hostname */\n  status = ares_dns_record_query_get(dnsrec, 0, &hostname, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  if (ancount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ancount; i++) {\n    ares_dns_rec_type_t  rtype;\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get_const(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN) {\n      continue;\n    }\n\n    rtype = ares_dns_rr_get_type(rr);\n\n    /* Issue #683\n     * Old code did this hostname sanity check, however it appears this is\n     * flawed logic.  Other resolvers don't do this sanity check.  Leaving\n     * this code commented out for future reference.\n     *\n     * rname = ares_dns_rr_get_name(rr);\n     * if ((rtype == ARES_REC_TYPE_A || rtype == ARES_REC_TYPE_AAAA) &&\n     *     !ares_strcaseeq(rname, hostname)) {\n     *   continue;\n     * }\n     */\n\n    if (rtype == ARES_REC_TYPE_CNAME) {\n      struct ares_addrinfo_cname *cname;\n\n      got_cname = ARES_TRUE;\n      /* replace hostname with data from cname */\n      hostname = ares_dns_rr_get_str(rr, ARES_RR_CNAME_CNAME);\n\n      cname = ares_append_addrinfo_cname(&cnames);\n      if (cname == NULL) {\n        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      cname->ttl   = (int)ares_dns_rr_get_ttl(rr);\n      cname->alias = ares_strdup(ares_dns_rr_get_name(rr));\n      if (cname->alias == NULL) {\n        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      cname->name = ares_strdup(hostname);\n      if (cname->name == NULL) {\n        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    } else if (rtype == ARES_REC_TYPE_A) {\n      got_a = ARES_TRUE;\n      status =\n        ares_append_ai_node(AF_INET, port, ares_dns_rr_get_ttl(rr),\n                            ares_dns_rr_get_addr(rr, ARES_RR_A_ADDR), &nodes);\n      if (status != ARES_SUCCESS) {\n        goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    } else if (rtype == ARES_REC_TYPE_AAAA) {\n      got_aaaa = ARES_TRUE;\n      status   = ares_append_ai_node(AF_INET6, port, ares_dns_rr_get_ttl(rr),\n                                     ares_dns_rr_get_addr6(rr, ARES_RR_AAAA_ADDR),\n                                     &nodes);\n      if (status != ARES_SUCCESS) {\n        goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    } else {\n      continue;\n    }\n  }\n\n  if (!got_a && !got_aaaa &&\n      (!got_cname || (got_cname && cname_only_is_enodata))) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  /* save the hostname as ai->name */\n  if (ai->name == NULL || !ares_strcaseeq(ai->name, hostname)) {\n    ares_free(ai->name);\n    ai->name = ares_strdup(hostname);\n    if (ai->name == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  if (got_a || got_aaaa) {\n    ares_addrinfo_cat_nodes(&ai->nodes, nodes);\n    nodes = NULL;\n  }\n\n  if (got_cname) {\n    ares_addrinfo_cat_cnames(&ai->cnames, cnames);\n    cnames = NULL;\n  }\n\ndone:\n  ares_freeaddrinfo_cnames(cnames);\n  ares_freeaddrinfo_nodes(nodes);\n\n  /* compatibility */\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_into_addrinfo",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "cname_only_is_enodata": "ares_bool_t",
              "port": "unsigned short",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            50,
            39
          ],
          [
            50,
            59
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            59,
            2
          ],
          [
            59,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            60,
            2
          ],
          [
            60,
            27
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            98,
            6
          ],
          [
            98,
            32
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_qcache.c": {
      "fn_def_list": [
        {
          "fn_code": "static char *ares_qcache_calc_key(const ares_dns_record_t *dnsrec)\n{\n  ares_buf_t      *buf = ares_buf_create();\n  size_t           i;\n  ares_status_t    status;\n  ares_dns_flags_t flags;\n\n  if (dnsrec == NULL || buf == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Format is OPCODE|FLAGS[|QTYPE1|QCLASS1|QNAME1]... */\n\n  status = ares_buf_append_str(\n    buf, ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)));\n  if (status != ARES_SUCCESS) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_buf_append_byte(buf, '|');\n  if (status != ARES_SUCCESS) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  flags = ares_dns_record_get_flags(dnsrec);\n  /* Only care about RD and CD */\n  if (flags & ARES_FLAG_RD) {\n    status = ares_buf_append_str(buf, \"rd\");\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n  if (flags & ARES_FLAG_CD) {\n    status = ares_buf_append_str(buf, \"cd\");\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    const char         *name;\n    size_t              name_len;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n\n    status = ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass);\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    status = ares_buf_append_byte(buf, '|');\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    status = ares_buf_append_str(buf, ares_dns_rec_type_tostr(qtype));\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    status = ares_buf_append_byte(buf, '|');\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    status = ares_buf_append_str(buf, ares_dns_class_tostr(qclass));\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    status = ares_buf_append_byte(buf, '|');\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* On queries, a '.' may be appended to the name to indicate an explicit\n     * name lookup without performing a search.  Strip this since its not part\n     * of a cached response. */\n    name_len = ares_strlen(name);\n    if (name_len && name[name_len - 1] == '.') {\n      name_len--;\n    }\n\n    if (name_len > 0) {\n      status = ares_buf_append(buf, (const unsigned char *)name, name_len);\n      if (status != ARES_SUCCESS) {\n        goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  return ares_buf_finish_str(buf, NULL);\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  ares_buf_destroy(buf);\n  return NULL;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_calc_key",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void ares_qcache_expire(ares_qcache_t *cache, const ares_timeval_t *now)\n{\n  ares_slist_node_t *node;\n\n  if (cache == NULL) {\n    return;\n  }\n\n  while ((node = ares_slist_node_first(cache->expire)) != NULL) {\n    const ares_qcache_entry_t *entry = ares_slist_node_val(node);\n\n    /* If now is NULL, we're flushing everything, so don't break */\n    if (now != NULL && entry->expire_ts > now->sec) {\n      break;\n    }\n\n    ares_htable_strvp_remove(cache->cache, entry->key);\n    ares_slist_node_destroy(node);\n  }\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_expire",
            "parameters": {
              "cache": "ares_qcache_t",
              "now": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_qcache_flush(ares_qcache_t *cache)\n{\n  ares_qcache_expire(cache, NULL /* flush all */);\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_flush",
            "parameters": {
              "cache": "ares_qcache_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_qcache_destroy(ares_qcache_t *cache)\n{\n  if (cache == NULL) {\n    return;\n  }\n\n  ares_htable_strvp_destroy(cache->cache);\n  ares_slist_destroy(cache->expire);\n  ares_free(cache);\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_destroy",
            "parameters": {
              "cache": "ares_qcache_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int ares_qcache_entry_sort_cb(const void *arg1, const void *arg2)\n{\n  const ares_qcache_entry_t *entry1 = arg1;\n  const ares_qcache_entry_t *entry2 = arg2;\n\n  if (entry1->expire_ts > entry2->expire_ts) {\n    return 1;\n  }\n\n  if (entry1->expire_ts < entry2->expire_ts) {\n    return -1;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_entry_sort_cb",
            "parameters": {
              "arg1": "void",
              "arg2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void ares_qcache_entry_destroy_cb(void *arg)\n{\n  ares_qcache_entry_t *entry = arg;\n  if (entry == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_free(entry->key);\n  ares_dns_record_destroy(entry->dnsrec);\n  ares_free(entry);\n}",
          "fn_code_pos": [
            [
              193,
              0
            ],
            [
              203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_entry_destroy_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_qcache_create(ares_rand_state *rand_state,\n                                 unsigned int     max_ttl,\n                                 ares_qcache_t  **cache_out)\n{\n  ares_status_t  status = ARES_SUCCESS;\n  ares_qcache_t *cache;\n\n  cache = ares_malloc_zero(sizeof(*cache));\n  if (cache == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  cache->cache = ares_htable_strvp_create(NULL);\n  if (cache->cache == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  cache->expire = ares_slist_create(rand_state, ares_qcache_entry_sort_cb,\n                                    ares_qcache_entry_destroy_cb);\n  if (cache->expire == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  cache->max_ttl = max_ttl;\n\ndone:\n  if (status != ARES_SUCCESS) {\n    *cache_out = NULL;\n    ares_qcache_destroy(cache);\n    return status;\n  }\n\n  *cache_out = cache;\n  return status;\n}",
          "fn_code_pos": [
            [
              205,
              0
            ],
            [
              242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "max_ttl": "unsigned int",
              "cache_out": "ares_qcache_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static unsigned int ares_qcache_calc_minttl(ares_dns_record_t *dnsrec)\n{\n  unsigned int minttl = 0xFFFFFFFF;\n  size_t       sect;\n\n  for (sect = ARES_SECTION_ANSWER; sect <= ARES_SECTION_ADDITIONAL; sect++) {\n    size_t i;\n    for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, (ares_dns_section_t)sect);\n         i++) {\n      const ares_dns_rr_t *rr =\n        ares_dns_record_rr_get(dnsrec, (ares_dns_section_t)sect, i);\n      ares_dns_rec_type_t type = ares_dns_rr_get_type(rr);\n      unsigned int        ttl  = ares_dns_rr_get_ttl(rr);\n\n      /* TTL is meaningless on these record types */\n      if (type == ARES_REC_TYPE_OPT || type == ARES_REC_TYPE_SOA ||\n          type == ARES_REC_TYPE_SIG) {\n        continue;\n      }\n\n      if (ttl < minttl) {\n        minttl = ttl;\n      }\n    }\n  }\n\n  return minttl;\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_calc_minttl",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned int ares_qcache_soa_minimum(ares_dns_record_t *dnsrec)\n{\n  size_t i;\n\n  /* RFC 2308 Section 5 says its the minimum of MINIMUM and the TTL of the\n   * record. */\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_AUTHORITY, i);\n    ares_dns_rec_type_t type = ares_dns_rr_get_type(rr);\n    unsigned int        ttl;\n    unsigned int        minimum;\n\n    if (type != ARES_REC_TYPE_SOA) {\n      continue;\n    }\n\n    minimum = ares_dns_rr_get_u32(rr, ARES_RR_SOA_MINIMUM);\n    ttl     = ares_dns_rr_get_ttl(rr);\n\n    if (ttl > minimum) {\n      return minimum;\n    }\n    return ttl;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_soa_minimum",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_status_t ares_qcache_insert_int(ares_qcache_t           *qcache,\n                                            ares_dns_record_t       *qresp,\n                                            const ares_dns_record_t *qreq,\n                                            const ares_timeval_t    *now)\n{\n  ares_qcache_entry_t *entry;\n  unsigned int         ttl;\n  ares_dns_rcode_t     rcode = ares_dns_record_get_rcode(qresp);\n  ares_dns_flags_t     flags = ares_dns_record_get_flags(qresp);\n\n  if (qcache == NULL || qresp == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Only save NOERROR or NXDOMAIN */\n  if (rcode != ARES_RCODE_NOERROR && rcode != ARES_RCODE_NXDOMAIN) {\n    return ARES_ENOTIMP;\n  }\n\n  /* Don't save truncated queries */\n  if (flags & ARES_FLAG_TC) {\n    return ARES_ENOTIMP;\n  }\n\n  /* Look at SOA for NXDOMAIN for minimum */\n  if (rcode == ARES_RCODE_NXDOMAIN) {\n    ttl = ares_qcache_soa_minimum(qresp);\n  } else {\n    ttl = ares_qcache_calc_minttl(qresp);\n  }\n\n  if (ttl > qcache->max_ttl) {\n    ttl = qcache->max_ttl;\n  }\n\n  /* Don't cache something that is already expired */\n  if (ttl == 0) {\n    return ARES_EREFUSED;\n  }\n\n  entry = ares_malloc_zero(sizeof(*entry));\n  if (entry == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  entry->dnsrec    = qresp;\n  entry->expire_ts = (time_t)now->sec + (time_t)ttl;\n  entry->insert_ts = (time_t)now->sec;\n\n  /* We can't guarantee the server responded with the same flags as the\n   * request had, so we have to re-parse the request in order to generate the\n   * key for caching, but we'll only do this once we know for sure we really\n   * want to cache it */\n  entry->key = ares_qcache_calc_key(qreq);\n  if (entry->key == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (!ares_htable_strvp_insert(qcache->cache, entry->key, entry)) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (ares_slist_insert(qcache->expire, entry) == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_SUCCESS;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  if (entry != NULL && entry->key != NULL) {\n    ares_htable_strvp_remove(qcache->cache, entry->key);\n    ares_free(entry->key);\n    ares_free(entry);\n  }\n  return ARES_ENOMEM;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              303,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_insert_int",
            "parameters": {
              "qcache": "ares_qcache_t",
              "qresp": "ares_dns_record_t",
              "qreq": "ares_dns_record_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_qcache_fetch(ares_channel_t           *channel,\n                                const ares_timeval_t     *now,\n                                const ares_dns_record_t  *dnsrec,\n                                const ares_dns_record_t **dnsrec_resp)\n{\n  char                *key = NULL;\n  ares_qcache_entry_t *entry;\n  ares_status_t        status = ARES_SUCCESS;\n\n  if (channel == NULL || dnsrec == NULL || dnsrec_resp == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (channel->qcache == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  ares_qcache_expire(channel->qcache, now);\n\n  key = ares_qcache_calc_key(dnsrec);\n  if (key == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  entry = ares_htable_strvp_get_direct(channel->qcache->cache, key);\n  if (entry == NULL) {\n    status = ARES_ENOTFOUND;\n    goto done;\n  }\n\n  ares_dns_record_ttl_decrement(entry->dnsrec,\n                                (unsigned int)(now->sec - entry->insert_ts));\n\n  *dnsrec_resp = entry->dnsrec;\n\ndone:\n  ares_free(key);\n  return status;\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_fetch",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "ares_timeval_t",
              "dnsrec": "ares_dns_record_t",
              "dnsrec_resp": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_qcache_insert(ares_channel_t          *channel,\n                                 const ares_timeval_t    *now,\n                                 const ares_query_t      *query,\n                                 const ares_dns_record_t *dnsrec)\n{\n  ares_dns_record_t *dupdns = ares_dns_record_duplicate(dnsrec);\n  ares_status_t      status;\n\n  if (dupdns == NULL) {\n    return ARES_ENOMEM;\n  }\n  status = ares_qcache_insert_int(channel->qcache, dupdns, query->query, now);\n  if (status != ARES_SUCCESS) {\n    ares_dns_record_destroy(dupdns);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              423,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_insert",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "ares_timeval_t",
              "query": "ares_query_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_qcache_calc_key(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              40,
              13
            ],
            [
              40,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_calc_key",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_qcache {\n  ares_htable_strvp_t *cache;\n  ares_slist_t        *expire;\n  unsigned int         max_ttl;\n}",
          {
            "*cache": "ares_htable_strvp_t",
            "*expire": "ares_slist_t",
            "max_ttl": "unsigned int"
          },
          "ares_qcache",
          [
            27,
            0
          ],
          [
            31,
            1
          ]
        ],
        [
          "typedef struct {\n  char              *key;\n  ares_dns_record_t *dnsrec;\n  time_t             expire_ts;\n  time_t             insert_ts;\n} ares_qcache_entry_t;",
          {
            "*key": "char",
            "*dnsrec": "ares_dns_record_t",
            "expire_ts": "time_t",
            "insert_ts": "time_t"
          },
          "ares_qcache_entry_t",
          [
            33,
            0
          ],
          [
            38,
            22
          ]
        ],
        [
          "struct ares_qcache {\n  ares_htable_strvp_t *cache;\n  ares_slist_t        *expire;\n  unsigned int         max_ttl;\n}",
          {
            "*cache": "ares_htable_strvp_t",
            "*expire": "ares_slist_t",
            "max_ttl": "unsigned int"
          },
          "ares_qcache",
          [
            27,
            0
          ],
          [
            31,
            1
          ]
        ],
        [
          "typedef struct {\n  char              *key;\n  ares_dns_record_t *dnsrec;\n  time_t             expire_ts;\n  time_t             insert_ts;\n} ares_qcache_entry_t;",
          {
            "*key": "char",
            "*dnsrec": "ares_dns_record_t",
            "expire_ts": "time_t",
            "insert_ts": "time_t"
          },
          "ares_qcache_entry_t",
          [
            33,
            0
          ],
          [
            38,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_update_servers.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t ares_addr_match(const struct ares_addr *addr1,\n                                   const struct ares_addr *addr2)\n{\n  if (addr1 == NULL && addr2 == NULL) {\n    return ARES_TRUE; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (addr1 == NULL || addr2 == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (addr1->family != addr2->family) {\n    return ARES_FALSE;\n  }\n\n  if (addr1->family == AF_INET && memcmp(&addr1->addr.addr4, &addr2->addr.addr4,\n                                         sizeof(addr1->addr.addr4)) == 0) {\n    return ARES_TRUE;\n  }\n\n  if (addr1->family == AF_INET6 &&\n      memcmp(&addr1->addr.addr6._S6_un._S6_u8, &addr2->addr.addr6._S6_un._S6_u8,\n             sizeof(addr1->addr.addr6._S6_un._S6_u8)) == 0) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addr_match",
            "parameters": {
              "addr1": "struct ares_addr",
              "addr2": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_subnet_match(const struct ares_addr *addr,\n                              const struct ares_addr *subnet,\n                              unsigned char           netmask)\n{\n  const unsigned char *addr_ptr;\n  const unsigned char *subnet_ptr;\n  size_t               len;\n  size_t               i;\n\n  if (addr == NULL || subnet == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (addr->family != subnet->family) {\n    return ARES_FALSE;\n  }\n\n  if (addr->family == AF_INET) {\n    addr_ptr   = (const unsigned char *)&addr->addr.addr4;\n    subnet_ptr = (const unsigned char *)&subnet->addr.addr4;\n    len        = 4;\n\n    if (netmask > 32) {\n      return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n  } else if (addr->family == AF_INET6) {\n    addr_ptr   = (const unsigned char *)&addr->addr.addr6;\n    subnet_ptr = (const unsigned char *)&subnet->addr.addr6;\n    len        = 16;\n\n    if (netmask > 128) {\n      return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n  } else {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  for (i = 0; i < len && netmask > 0; i++) {\n    unsigned char mask = 0xff;\n    if (netmask < 8) {\n      mask    <<= (8 - netmask);\n      netmask   = 0;\n    } else {\n      netmask -= 8;\n    }\n\n    if ((addr_ptr[i] & mask) != (subnet_ptr[i] & mask)) {\n      return ARES_FALSE;\n    }\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_subnet_match",
            "parameters": {
              "addr": "struct ares_addr",
              "subnet": "struct ares_addr",
              "netmask": "unsigned char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_addr_is_linklocal(const struct ares_addr *addr)\n{\n  struct ares_addr    subnet;\n  const unsigned char subnetaddr[16] = { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00,\n                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                         0x00, 0x00, 0x00, 0x00 };\n\n  /* fe80::/10 */\n  subnet.family = AF_INET6;\n  memcpy(&subnet.addr.addr6, subnetaddr, 16);\n\n  return ares_subnet_match(addr, &subnet, 10);\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addr_is_linklocal",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_server_blacklisted(const struct ares_addr *addr)\n{\n  /* A list of blacklisted IPv6 subnets. */\n  const struct {\n    const unsigned char netbase[16];\n    unsigned char       netmask;\n  } blacklist_v6[] = {\n    /* fec0::/10 was deprecated by [RFC3879] in September 2004. Formerly a\n     * Site-Local scoped address prefix.  These are never valid DNS servers,\n     * but are known to be returned at least sometimes on Windows and Android.\n     */\n    { { 0xfe, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00 },\n     10 }\n  };\n\n  size_t i;\n\n  if (addr->family != AF_INET6) {\n    return ARES_FALSE;\n  }\n\n  /* See if ipaddr matches any of the entries in the blacklist. */\n  for (i = 0; i < sizeof(blacklist_v6) / sizeof(*blacklist_v6); i++) {\n    struct ares_addr subnet;\n    subnet.family = AF_INET6;\n    memcpy(&subnet.addr.addr6, blacklist_v6[i].netbase, 16);\n    if (ares_subnet_match(addr, &subnet, blacklist_v6[i].netmask)) {\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_server_blacklisted",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_nameserver_uri(ares_buf_t     *buf,\n                                          ares_sconfig_t *sconfig)\n{\n  ares_uri_t   *uri    = NULL;\n  ares_status_t status = ARES_SUCCESS;\n  const char   *port;\n  char         *ll_scope;\n  char          hoststr[256];\n  size_t        addrlen;\n\n  status = ares_uri_parse_buf(&uri, buf);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (!ares_streq(\"dns\", ares_uri_get_scheme(uri))) {\n    status = ARES_EBADSTR;\n    goto done;\n  }\n\n  ares_strcpy(hoststr, ares_uri_get_host(uri), sizeof(hoststr));\n  ll_scope = strchr(hoststr, '%');\n  if (ll_scope != NULL) {\n    *ll_scope = 0;\n    ll_scope++;\n    ares_strcpy(sconfig->ll_iface, ll_scope, sizeof(sconfig->ll_iface));\n  }\n\n  /* Convert ip address from string to network byte order */\n  sconfig->addr.family = AF_UNSPEC;\n  if (ares_dns_pton(hoststr, &sconfig->addr, &addrlen) == NULL) {\n    status = ARES_EBADSTR;\n    goto done;\n  }\n\n  sconfig->udp_port = ares_uri_get_port(uri);\n  sconfig->tcp_port = sconfig->udp_port;\n  port              = ares_uri_get_query_key(uri, \"tcpport\");\n  if (port != NULL) {\n    sconfig->tcp_port = (unsigned short)atoi(port);\n  }\n\ndone:\n  ares_uri_destroy(uri);\n  return status;\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_nameserver_uri",
            "parameters": {
              "buf": "ares_buf_t",
              "sconfig": "ares_sconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_nameserver(ares_buf_t *buf, ares_sconfig_t *sconfig)\n{\n  ares_status_t status;\n  char          ipaddr[INET6_ADDRSTRLEN] = \"\";\n  size_t        addrlen;\n\n  memset(sconfig, 0, sizeof(*sconfig));\n\n  /* Consume any leading whitespace */\n  ares_buf_consume_whitespace(buf, ARES_TRUE);\n\n  /* pop off IP address.  If it is in [ ] then it can be ipv4 or ipv6.  If\n   * not, ipv4 only */\n  if (ares_buf_begins_with(buf, (const unsigned char *)\"[\", 1)) {\n    /* Consume [ */\n    ares_buf_consume(buf, 1);\n\n    ares_buf_tag(buf);\n\n    /* Consume until ] */\n    if (ares_buf_consume_until_charset(buf, (const unsigned char *)\"]\", 1,\n                                       ARES_TRUE) == SIZE_MAX) {\n      return ARES_EBADSTR;\n    }\n\n    status = ares_buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Skip over ] */\n    ares_buf_consume(buf, 1);\n  } else {\n    size_t offset;\n\n    /* Not in [ ], see if '.' is in first 4 characters, if it is, then its ipv4,\n     * otherwise treat as ipv6 */\n    ares_buf_tag(buf);\n\n    offset = ares_buf_consume_until_charset(buf, (const unsigned char *)\".\", 1,\n                                            ARES_TRUE);\n    ares_buf_tag_rollback(buf);\n    ares_buf_tag(buf);\n\n    if (offset > 0 && offset < 4) {\n      /* IPv4 */\n      if (ares_buf_consume_charset(buf, (const unsigned char *)\"0123456789.\",\n                                   11) == 0) {\n        return ARES_EBADSTR;\n      }\n    } else {\n      /* IPv6 */\n      const unsigned char ipv6_charset[] = \"ABCDEFabcdef0123456789.:\";\n      if (ares_buf_consume_charset(buf, ipv6_charset,\n                                   sizeof(ipv6_charset) - 1) == 0) {\n        return ARES_EBADSTR;\n      }\n    }\n\n    status = ares_buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* Convert ip address from string to network byte order */\n  sconfig->addr.family = AF_UNSPEC;\n  if (ares_dns_pton(ipaddr, &sconfig->addr, &addrlen) == NULL) {\n    return ARES_EBADSTR;\n  }\n\n  /* Pull off port */\n  if (ares_buf_begins_with(buf, (const unsigned char *)\":\", 1)) {\n    char portstr[6];\n\n    /* Consume : */\n    ares_buf_consume(buf, 1);\n\n    ares_buf_tag(buf);\n\n    /* Read numbers */\n    if (ares_buf_consume_charset(buf, (const unsigned char *)\"0123456789\",\n                                 10) == 0) {\n      return ARES_EBADSTR;\n    }\n\n    status = ares_buf_tag_fetch_string(buf, portstr, sizeof(portstr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    sconfig->udp_port = (unsigned short)atoi(portstr);\n    sconfig->tcp_port = sconfig->udp_port;\n  }\n\n  /* Pull off interface modifier */\n  if (ares_buf_begins_with(buf, (const unsigned char *)\"%\", 1)) {\n    const unsigned char iface_charset[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                                          \"abcdefghijklmnopqrstuvwxyz\"\n                                          \"0123456789.-_\\\\:{}\";\n    /* Consume % */\n    ares_buf_consume(buf, 1);\n\n    ares_buf_tag(buf);\n\n    if (ares_buf_consume_charset(buf, iface_charset,\n                                 sizeof(iface_charset) - 1) == 0) {\n      return ARES_EBADSTR;\n    }\n\n    status = ares_buf_tag_fetch_string(buf, sconfig->ll_iface,\n                                       sizeof(sconfig->ll_iface));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* Consume any trailing whitespace so we can bail out if there is something\n   * after we didn't read */\n  ares_buf_consume_whitespace(buf, ARES_TRUE);\n\n  if (ares_buf_len(buf) != 0) {\n    return ARES_EBADSTR;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_nameserver",
            "parameters": {
              "buf": "ares_buf_t",
              "sconfig": "ares_sconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_sconfig_linklocal(const ares_channel_t *channel,\n                                            ares_sconfig_t       *s,\n                                            const char           *ll_iface)\n{\n  unsigned int ll_scope = 0;\n\n\n  if (ares_str_isnum(ll_iface)) {\n    char ifname[IF_NAMESIZE] = \"\";\n    ll_scope                 = (unsigned int)atoi(ll_iface);\n    if (channel->sock_funcs.aif_indextoname == NULL ||\n        channel->sock_funcs.aif_indextoname(ll_scope, ifname, sizeof(ifname),\n                                            channel->sock_func_cb_data) ==\n          NULL) {\n      DEBUGF(fprintf(stderr, \"Interface %s for ipv6 Link Local not found\\n\",\n                     ll_iface));\n      return ARES_ENOTFOUND;\n    }\n    ares_strcpy(s->ll_iface, ifname, sizeof(s->ll_iface));\n    s->ll_scope = ll_scope;\n    return ARES_SUCCESS;\n  }\n\n  if (channel->sock_funcs.aif_nametoindex != NULL) {\n    ll_scope =\n      channel->sock_funcs.aif_nametoindex(ll_iface, channel->sock_func_cb_data);\n  }\n  if (ll_scope == 0) {\n    DEBUGF(fprintf(stderr, \"Interface %s for ipv6 Link Local not found\\n\",\n                   ll_iface));\n    return ARES_ENOTFOUND;\n  }\n  ares_strcpy(s->ll_iface, ll_iface, sizeof(s->ll_iface));\n  s->ll_scope = ll_scope;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sconfig_linklocal",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_sconfig_t",
              "ll_iface": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_sconfig_append(const ares_channel_t   *channel,\n                                  ares_llist_t          **sconfig,\n                                  const struct ares_addr *addr,\n                                  unsigned short          udp_port,\n                                  unsigned short tcp_port, const char *ll_iface)\n{\n  ares_sconfig_t *s;\n  ares_status_t   status;\n\n  if (sconfig == NULL || addr == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Silently skip blacklisted IPv6 servers. */\n  if (ares_server_blacklisted(addr)) {\n    return ARES_SUCCESS;\n  }\n\n  s = ares_malloc_zero(sizeof(*s));\n  if (s == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (*sconfig == NULL) {\n    *sconfig = ares_llist_create(ares_free);\n    if (*sconfig == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  memcpy(&s->addr, addr, sizeof(s->addr));\n  s->udp_port = udp_port;\n  s->tcp_port = tcp_port;\n\n  /* Handle link-local enumeration. If an interface is specified on a\n   * non-link-local address, we'll simply end up ignoring that */\n  if (ares_addr_is_linklocal(&s->addr)) {\n    if (ares_strlen(ll_iface) == 0) {\n      /* Silently ignore this entry, we require an interface */\n      status = ARES_SUCCESS;\n      goto fail;\n    }\n    status = ares_sconfig_linklocal(channel, s, ll_iface);\n    /* Silently ignore this entry, we can't validate the interface */\n    if (status != ARES_SUCCESS) {\n      status = ARES_SUCCESS;\n      goto fail;\n    }\n  }\n\n  if (ares_llist_insert_last(*sconfig, s) == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  ares_free(s);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sconfig_append",
            "parameters": {
              "channel": "ares_channel_t",
              "sconfig": "ares_llist_t",
              "addr": "struct ares_addr",
              "udp_port": "unsigned short",
              "tcp_port": "unsigned short",
              "ll_iface": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_sconfig_append_fromstr(const ares_channel_t *channel,\n                                          ares_llist_t        **sconfig,\n                                          const char           *str,\n                                          ares_bool_t           ignore_invalid)\n{\n  ares_status_t status = ARES_SUCCESS;\n  ares_buf_t   *buf    = NULL;\n  ares_array_t *list   = NULL;\n  size_t        num;\n  size_t        i;\n\n  /* On Windows, there may be more than one nameserver specified in the same\n   * registry key, so we parse input as a space or comma separated list.\n   */\n  buf = ares_buf_create_const((const unsigned char *)str, ares_strlen(str));\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares_buf_split(buf, (const unsigned char *)\" ,\", 2,\n                          ARES_BUF_SPLIT_NONE, 0, &list);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  num = ares_array_len(list);\n  for (i = 0; i < num; i++) {\n    ares_buf_t   **bufptr = ares_array_at(list, i);\n    ares_buf_t    *entry  = *bufptr;\n    ares_sconfig_t s;\n\n    status = parse_nameserver_uri(entry, &s);\n    if (status != ARES_SUCCESS) {\n      status = parse_nameserver(entry, &s);\n    }\n\n    if (status != ARES_SUCCESS) {\n      if (ignore_invalid) {\n        continue;\n      } else {\n        goto done;\n      }\n    }\n\n    status = ares_sconfig_append(channel, sconfig, &s.addr, s.udp_port,\n                                 s.tcp_port, s.ll_iface);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares_array_destroy(list);\n  ares_buf_destroy(buf);\n  return status;\n}",
          "fn_code_pos": [
            [
              508,
              0
            ],
            [
              566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sconfig_append_fromstr",
            "parameters": {
              "channel": "ares_channel_t",
              "sconfig": "ares_llist_t",
              "str": "char",
              "ignore_invalid": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static unsigned short ares_sconfig_get_port(const ares_channel_t *channel,\n                                            const ares_sconfig_t *s,\n                                            ares_bool_t           is_tcp)\n{\n  unsigned short port = is_tcp ? s->tcp_port : s->udp_port;\n\n  if (port == 0) {\n    port = is_tcp ? channel->tcp_port : channel->udp_port;\n  }\n\n  if (port == 0) {\n    port = 53;\n  }\n\n  return port;\n}",
          "fn_code_pos": [
            [
              568,
              0
            ],
            [
              583,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sconfig_get_port",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_sconfig_t",
              "is_tcp": "ares_bool_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_slist_node_t *ares_server_find(const ares_channel_t *channel,\n                                           const ares_sconfig_t *s)\n{\n  ares_slist_node_t *node;\n\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    const ares_server_t *server = ares_slist_node_val(node);\n\n    if (!ares_addr_match(&server->addr, &s->addr)) {\n      continue;\n    }\n\n    if (server->tcp_port != ares_sconfig_get_port(channel, s, ARES_TRUE)) {\n      continue;\n    }\n\n    if (server->udp_port != ares_sconfig_get_port(channel, s, ARES_FALSE)) {\n      continue;\n    }\n\n    return node;\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              585,
              0
            ],
            [
              609,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_server_find",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_sconfig_t"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_server_isdup(const ares_channel_t *channel,\n                                     ares_llist_node_t    *s)\n{\n  /* Scan backwards to see if this is a duplicate */\n  ares_llist_node_t    *prev;\n  const ares_sconfig_t *server = ares_llist_node_val(s);\n\n  for (prev = ares_llist_node_prev(s); prev != NULL;\n       prev = ares_llist_node_prev(prev)) {\n    const ares_sconfig_t *p = ares_llist_node_val(prev);\n\n    if (!ares_addr_match(&server->addr, &p->addr)) {\n      continue;\n    }\n\n    if (ares_sconfig_get_port(channel, server, ARES_TRUE) !=\n        ares_sconfig_get_port(channel, p, ARES_TRUE)) {\n      continue;\n    }\n\n    if (ares_sconfig_get_port(channel, server, ARES_FALSE) !=\n        ares_sconfig_get_port(channel, p, ARES_FALSE)) {\n      continue;\n    }\n\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              611,
              0
            ],
            [
              640,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_server_isdup",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_llist_node_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_server_create(ares_channel_t       *channel,\n                                        const ares_sconfig_t *sconfig,\n                                        size_t                idx)\n{\n  ares_status_t  status;\n  ares_server_t *server = ares_malloc_zero(sizeof(*server));\n\n  if (server == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  server->idx         = idx;\n  server->channel     = channel;\n  server->udp_port    = ares_sconfig_get_port(channel, sconfig, ARES_FALSE);\n  server->tcp_port    = ares_sconfig_get_port(channel, sconfig, ARES_TRUE);\n  server->addr.family = sconfig->addr.family;\n  server->next_retry_time.sec  = 0;\n  server->next_retry_time.usec = 0;\n\n  if (sconfig->addr.family == AF_INET) {\n    memcpy(&server->addr.addr.addr4, &sconfig->addr.addr.addr4,\n           sizeof(server->addr.addr.addr4));\n  } else if (sconfig->addr.family == AF_INET6) {\n    memcpy(&server->addr.addr.addr6, &sconfig->addr.addr.addr6,\n           sizeof(server->addr.addr.addr6));\n  }\n\n  /* Copy over link-local settings */\n  if (ares_strlen(sconfig->ll_iface)) {\n    ares_strcpy(server->ll_iface, sconfig->ll_iface, sizeof(server->ll_iface));\n    server->ll_scope = sconfig->ll_scope;\n  }\n\n  server->connections = ares_llist_create(NULL);\n  if (server->connections == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (ares_slist_insert(channel->servers, server) == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_destroy_server(server); /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              642,
              0
            ],
            [
              694,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_server_create",
            "parameters": {
              "channel": "ares_channel_t",
              "sconfig": "ares_sconfig_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_server_in_newconfig(const ares_server_t *server,\n                                            ares_llist_t        *srvlist)\n{\n  ares_llist_node_t    *node;\n  const ares_channel_t *channel = server->channel;\n\n  for (node = ares_llist_node_first(srvlist); node != NULL;\n       node = ares_llist_node_next(node)) {\n    const ares_sconfig_t *s = ares_llist_node_val(node);\n\n    if (!ares_addr_match(&server->addr, &s->addr)) {\n      continue;\n    }\n\n    if (server->tcp_port != ares_sconfig_get_port(channel, s, ARES_TRUE)) {\n      continue;\n    }\n\n    if (server->udp_port != ares_sconfig_get_port(channel, s, ARES_FALSE)) {\n      continue;\n    }\n\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              696,
              0
            ],
            [
              722,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_server_in_newconfig",
            "parameters": {
              "server": "ares_server_t",
              "srvlist": "ares_llist_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_servers_remove_stale(ares_channel_t *channel,\n                                             ares_llist_t   *srvlist)\n{\n  ares_bool_t        stale_removed = ARES_FALSE;\n  ares_slist_node_t *snode         = ares_slist_node_first(channel->servers);\n\n  while (snode != NULL) {\n    ares_slist_node_t   *snext  = ares_slist_node_next(snode);\n    const ares_server_t *server = ares_slist_node_val(snode);\n    if (!ares_server_in_newconfig(server, srvlist)) {\n      /* This will clean up all server state via the destruction callback and\n       * move any queries to new servers */\n      ares_slist_node_destroy(snode);\n      stale_removed = ARES_TRUE;\n    }\n    snode = snext;\n  }\n  return stale_removed;\n}",
          "fn_code_pos": [
            [
              724,
              0
            ],
            [
              742,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_servers_remove_stale",
            "parameters": {
              "channel": "ares_channel_t",
              "srvlist": "ares_llist_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_servers_trim_single(ares_channel_t *channel)\n{\n  while (ares_slist_len(channel->servers) > 1) {\n    ares_slist_node_destroy(ares_slist_node_last(channel->servers));\n  }\n}",
          "fn_code_pos": [
            [
              744,
              0
            ],
            [
              749,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_servers_trim_single",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_servers_update(ares_channel_t *channel,\n                                  ares_llist_t   *server_list,\n                                  ares_bool_t     user_specified)\n{\n  ares_llist_node_t *node;\n  size_t             idx = 0;\n  ares_status_t      status;\n  ares_bool_t        list_changed = ARES_FALSE;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* NOTE: a NULL or zero entry server list is considered valid due to\n   *       real-world people needing support for this for their test harnesses\n   */\n\n  /* Add new entries */\n  for (node = ares_llist_node_first(server_list); node != NULL;\n       node = ares_llist_node_next(node)) {\n    const ares_sconfig_t *sconfig = ares_llist_node_val(node);\n    ares_slist_node_t    *snode;\n\n    /* If a server has already appeared in the list of new servers, skip it. */\n    if (ares_server_isdup(channel, node)) {\n      continue;\n    }\n\n    snode = ares_server_find(channel, sconfig);\n    if (snode != NULL) {\n      ares_server_t *server = ares_slist_node_val(snode);\n\n      /* Copy over link-local settings.  Its possible some of this data has\n       * changed, maybe ...  */\n      if (ares_strlen(sconfig->ll_iface)) {\n        ares_strcpy(server->ll_iface, sconfig->ll_iface,\n                    sizeof(server->ll_iface));\n        server->ll_scope = sconfig->ll_scope;\n      }\n\n      if (server->idx != idx) {\n        server->idx = idx;\n        /* Index changed, reinsert node, doesn't require any memory\n         * allocations so can't fail. */\n        ares_slist_node_reinsert(snode);\n      }\n    } else {\n      status = ares_server_create(channel, sconfig, idx);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n\n      list_changed = ARES_TRUE;\n    }\n\n    idx++;\n  }\n\n  /* Remove any servers that don't exist in the current configuration */\n  if (ares_servers_remove_stale(channel, server_list)) {\n    list_changed = ARES_TRUE;\n  }\n\n  /* Trim to one server if ARES_FLAG_PRIMARY is set. */\n  if (channel->flags & ARES_FLAG_PRIMARY) {\n    ares_servers_trim_single(channel);\n  }\n\n  if (user_specified) {\n    /* Save servers as if they were passed in as an option */\n    channel->optmask |= ARES_OPT_SERVERS;\n  }\n\n  /* Clear any cached query results only if the server list changed */\n  if (list_changed) {\n    ares_qcache_flush(channel->qcache);\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              751,
              0
            ],
            [
              833,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_servers_update",
            "parameters": {
              "channel": "ares_channel_t",
              "server_list": "ares_llist_t",
              "user_specified": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_addr_node_to_sconfig_llist(const struct ares_addr_node *servers,\n                                  ares_llist_t               **llist)\n{\n  const struct ares_addr_node *node;\n  ares_llist_t                *s;\n\n  *llist = NULL;\n\n  s = ares_llist_create(ares_free);\n  if (s == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (node = servers; node != NULL; node = node->next) {\n    ares_sconfig_t *sconfig;\n\n    /* Invalid entry */\n    if (node->family != AF_INET && node->family != AF_INET6) {\n      continue;\n    }\n\n    sconfig = ares_malloc_zero(sizeof(*sconfig));\n    if (sconfig == NULL) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    sconfig->addr.family = node->family;\n    if (node->family == AF_INET) {\n      memcpy(&sconfig->addr.addr.addr4, &node->addr.addr4,\n             sizeof(sconfig->addr.addr.addr4));\n    } else if (sconfig->addr.family == AF_INET6) {\n      memcpy(&sconfig->addr.addr.addr6, &node->addr.addr6,\n             sizeof(sconfig->addr.addr.addr6));\n    }\n\n    if (ares_llist_insert_last(s, sconfig) == NULL) {\n      ares_free(sconfig); /* LCOV_EXCL_LINE: OutOfMemory */\n      goto fail;          /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  *llist = s;\n  return ARES_SUCCESS;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  ares_llist_destroy(s);\n  return ARES_ENOMEM;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              835,
              0
            ],
            [
              885,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addr_node_to_sconfig_llist",
            "parameters": {
              "servers": "struct ares_addr_node",
              "llist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_addrpnode_to_sconfig_llist(const struct ares_addr_port_node *servers,\n                                  ares_llist_t                    **llist)\n{\n  const struct ares_addr_port_node *node;\n  ares_llist_t                     *s;\n\n  *llist = NULL;\n\n  s = ares_llist_create(ares_free);\n  if (s == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (node = servers; node != NULL; node = node->next) {\n    ares_sconfig_t *sconfig;\n\n    /* Invalid entry */\n    if (node->family != AF_INET && node->family != AF_INET6) {\n      continue;\n    }\n\n    sconfig = ares_malloc_zero(sizeof(*sconfig));\n    if (sconfig == NULL) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    sconfig->addr.family = node->family;\n    if (node->family == AF_INET) {\n      memcpy(&sconfig->addr.addr.addr4, &node->addr.addr4,\n             sizeof(sconfig->addr.addr.addr4));\n    } else if (sconfig->addr.family == AF_INET6) {\n      memcpy(&sconfig->addr.addr.addr6, &node->addr.addr6,\n             sizeof(sconfig->addr.addr.addr6));\n    }\n\n    sconfig->tcp_port = (unsigned short)node->tcp_port;\n    sconfig->udp_port = (unsigned short)node->udp_port;\n\n    if (ares_llist_insert_last(s, sconfig) == NULL) {\n      ares_free(sconfig); /* LCOV_EXCL_LINE: OutOfMemory */\n      goto fail;          /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  *llist = s;\n  return ARES_SUCCESS;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  ares_llist_destroy(s);\n  return ARES_ENOMEM;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              887,
              0
            ],
            [
              940,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrpnode_to_sconfig_llist",
            "parameters": {
              "servers": "struct ares_addr_port_node",
              "llist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_in_addr_to_sconfig_llist(const struct in_addr *servers,\n                                            size_t                nservers,\n                                            ares_llist_t        **llist)\n{\n  size_t        i;\n  ares_llist_t *s;\n\n  *llist = NULL;\n\n  s = ares_llist_create(ares_free);\n  if (s == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (i = 0; servers != NULL && i < nservers; i++) {\n    ares_sconfig_t *sconfig;\n\n    sconfig = ares_malloc_zero(sizeof(*sconfig));\n    if (sconfig == NULL) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    sconfig->addr.family = AF_INET;\n    memcpy(&sconfig->addr.addr.addr4, &servers[i],\n           sizeof(sconfig->addr.addr.addr4));\n\n    if (ares_llist_insert_last(s, sconfig) == NULL) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  *llist = s;\n  return ARES_SUCCESS;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  ares_llist_destroy(s);\n  return ARES_ENOMEM;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              942,
              0
            ],
            [
              981,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_in_addr_to_sconfig_llist",
            "parameters": {
              "servers": "struct in_addr",
              "nservers": "size_t",
              "llist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_server_use_uri(const ares_server_t *server)\n{\n  /* Currently only reason to use new format is if the ports for udp and tcp\n   * are different */\n  if (server->tcp_port != server->udp_port) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              983,
              0
            ],
            [
              991,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_server_use_uri",
            "parameters": {
              "server": "ares_server_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_get_server_addr_uri(const ares_server_t *server,\n                                              ares_buf_t          *buf)\n{\n  ares_uri_t   *uri = NULL;\n  ares_status_t status;\n  char          addr[INET6_ADDRSTRLEN];\n\n  uri = ares_uri_create();\n  if (uri == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_uri_set_scheme(uri, \"dns\");\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ares_inet_ntop(server->addr.family, &server->addr.addr, addr, sizeof(addr));\n\n  if (ares_strlen(server->ll_iface)) {\n    char addr_iface[256];\n\n    snprintf(addr_iface, sizeof(addr_iface), \"%s%%%s\", addr, server->ll_iface);\n    status = ares_uri_set_host(uri, addr_iface);\n  } else {\n    status = ares_uri_set_host(uri, addr);\n  }\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_set_port(uri, server->udp_port);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (server->udp_port != server->tcp_port) {\n    char port[6];\n    snprintf(port, sizeof(port), \"%d\", server->tcp_port);\n    status = ares_uri_set_query_key(uri, \"tcpport\", port);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  status = ares_uri_write_buf(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_uri_destroy(uri);\n  return status;\n}",
          "fn_code_pos": [
            [
              993,
              0
            ],
            [
              1047,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_server_addr_uri",
            "parameters": {
              "server": "ares_server_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_get_server_addr(const ares_server_t *server, ares_buf_t *buf)\n{\n  ares_status_t status;\n  char          addr[INET6_ADDRSTRLEN];\n\n  if (ares_server_use_uri(server)) {\n    return ares_get_server_addr_uri(server, buf);\n  }\n\n  /* ipv4addr or [ipv6addr] */\n  if (server->addr.family == AF_INET6) {\n    status = ares_buf_append_byte(buf, '[');\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  ares_inet_ntop(server->addr.family, &server->addr.addr, addr, sizeof(addr));\n\n  status = ares_buf_append_str(buf, addr);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (server->addr.family == AF_INET6) {\n    status = ares_buf_append_byte(buf, ']');\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  /* :port */\n  status = ares_buf_append_byte(buf, ':');\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_buf_append_num_dec(buf, server->udp_port, 0);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* %iface */\n  if (ares_strlen(server->ll_iface)) {\n    status = ares_buf_append_byte(buf, '%');\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    status = ares_buf_append_str(buf, server->ll_iface);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1050,
              0
            ],
            [
              1106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_server_addr",
            "parameters": {
              "server": "ares_server_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_get_servers(const ares_channel_t   *channel,\n                     struct ares_addr_node **servers)\n{\n  struct ares_addr_node *srvr_head = NULL;\n  struct ares_addr_node *srvr_last = NULL;\n  struct ares_addr_node *srvr_curr;\n  ares_status_t          status = ARES_SUCCESS;\n  ares_slist_node_t     *node;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  ares_channel_lock(channel);\n\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    const ares_server_t *server = ares_slist_node_val(node);\n\n    /* Allocate storage for this server node appending it to the list */\n    srvr_curr = ares_malloc_data(ARES_DATATYPE_ADDR_NODE);\n    if (!srvr_curr) {\n      status = ARES_ENOMEM;\n      break;\n    }\n    if (srvr_last) {\n      srvr_last->next = srvr_curr;\n    } else {\n      srvr_head = srvr_curr;\n    }\n    srvr_last = srvr_curr;\n\n    /* Fill this server node data */\n    srvr_curr->family = server->addr.family;\n    if (srvr_curr->family == AF_INET) {\n      memcpy(&srvr_curr->addr.addr4, &server->addr.addr.addr4,\n             sizeof(srvr_curr->addr.addr4));\n    } else {\n      memcpy(&srvr_curr->addr.addr6, &server->addr.addr.addr6,\n             sizeof(srvr_curr->addr.addr6));\n    }\n  }\n\n  if (status != ARES_SUCCESS) {\n    ares_free_data(srvr_head);\n    srvr_head = NULL;\n  }\n\n  *servers = srvr_head;\n\n  ares_channel_unlock(channel);\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              1108,
              0
            ],
            [
              1161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_get_servers_ports(const ares_channel_t        *channel,\n                           struct ares_addr_port_node **servers)\n{\n  struct ares_addr_port_node *srvr_head = NULL;\n  struct ares_addr_port_node *srvr_last = NULL;\n  struct ares_addr_port_node *srvr_curr;\n  ares_status_t               status = ARES_SUCCESS;\n  ares_slist_node_t          *node;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  ares_channel_lock(channel);\n\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    const ares_server_t *server = ares_slist_node_val(node);\n\n    /* Allocate storage for this server node appending it to the list */\n    srvr_curr = ares_malloc_data(ARES_DATATYPE_ADDR_PORT_NODE);\n    if (!srvr_curr) {\n      status = ARES_ENOMEM;\n      break;\n    }\n    if (srvr_last) {\n      srvr_last->next = srvr_curr;\n    } else {\n      srvr_head = srvr_curr;\n    }\n    srvr_last = srvr_curr;\n\n    /* Fill this server node data */\n    srvr_curr->family   = server->addr.family;\n    srvr_curr->udp_port = server->udp_port;\n    srvr_curr->tcp_port = server->tcp_port;\n\n    if (srvr_curr->family == AF_INET) {\n      memcpy(&srvr_curr->addr.addr4, &server->addr.addr.addr4,\n             sizeof(srvr_curr->addr.addr4));\n    } else {\n      memcpy(&srvr_curr->addr.addr6, &server->addr.addr.addr6,\n             sizeof(srvr_curr->addr.addr6));\n    }\n  }\n\n  if (status != ARES_SUCCESS) {\n    ares_free_data(srvr_head);\n    srvr_head = NULL;\n  }\n\n  *servers = srvr_head;\n\n  ares_channel_unlock(channel);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              1163,
              0
            ],
            [
              1218,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_ports",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_port_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_set_servers(ares_channel_t              *channel,\n                     const struct ares_addr_node *servers)\n{\n  ares_llist_t *slist;\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  status = ares_addr_node_to_sconfig_llist(servers, &slist);\n  if (status != ARES_SUCCESS) {\n    return (int)status;\n  }\n\n  ares_channel_lock(channel);\n  status = ares_servers_update(channel, slist, ARES_TRUE);\n  ares_channel_unlock(channel);\n\n  ares_llist_destroy(slist);\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              1220,
              0
            ],
            [
              1242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_set_servers_ports(ares_channel_t                   *channel,\n                           const struct ares_addr_port_node *servers)\n{\n  ares_llist_t *slist;\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  status = ares_addrpnode_to_sconfig_llist(servers, &slist);\n  if (status != ARES_SUCCESS) {\n    return (int)status;\n  }\n\n  ares_channel_lock(channel);\n  status = ares_servers_update(channel, slist, ARES_TRUE);\n  ares_channel_unlock(channel);\n\n  ares_llist_destroy(slist);\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              1244,
              0
            ],
            [
              1266,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_ports",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_port_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_status_t set_servers_csv(ares_channel_t *channel, const char *_csv)\n{\n  ares_status_t status;\n  ares_llist_t *slist = NULL;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  if (ares_strlen(_csv) == 0) {\n    /* blank all servers */\n    ares_channel_lock(channel);\n    status = ares_servers_update(channel, NULL, ARES_TRUE);\n    ares_channel_unlock(channel);\n    return status;\n  }\n\n  status = ares_sconfig_append_fromstr(channel, &slist, _csv, ARES_FALSE);\n  if (status != ARES_SUCCESS) {\n    ares_llist_destroy(slist);\n    return status;\n  }\n\n  ares_channel_lock(channel);\n  status = ares_servers_update(channel, slist, ARES_TRUE);\n  ares_channel_unlock(channel);\n\n  ares_llist_destroy(slist);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1270,
              0
            ],
            [
              1300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_servers_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "_csv": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_set_servers_csv(ares_channel_t *channel, const char *_csv)\n{\n  return (int)set_servers_csv(channel, _csv);\n}",
          "fn_code_pos": [
            [
              1303,
              0
            ],
            [
              1306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "_csv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_set_servers_ports_csv(ares_channel_t *channel, const char *_csv)\n{\n  return (int)set_servers_csv(channel, _csv);\n}",
          "fn_code_pos": [
            [
              1308,
              0
            ],
            [
              1311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_ports_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "_csv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "char *ares_get_servers_csv(const ares_channel_t *channel)\n{\n  ares_buf_t        *buf = NULL;\n  char              *out = NULL;\n  ares_slist_node_t *node;\n\n  ares_channel_lock(channel);\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    ares_status_t        status;\n    const ares_server_t *server = ares_slist_node_val(node);\n\n    if (ares_buf_len(buf)) {\n      status = ares_buf_append_byte(buf, ',');\n      if (status != ARES_SUCCESS) {\n        goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n\n    status = ares_get_server_addr(server, buf);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  out = ares_buf_finish_str(buf, NULL);\n  buf = NULL;\n\ndone:\n  ares_channel_unlock(channel);\n  ares_buf_destroy(buf);\n  return out;\n}",
          "fn_code_pos": [
            [
              1313,
              0
            ],
            [
              1351,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_csv",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void ares_set_server_state_callback(ares_channel_t            *channel,\n                                    ares_server_state_callback cb, void *data)\n{\n  if (channel == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  channel->server_state_cb      = cb;\n  channel->server_state_cb_data = data;\n}",
          "fn_code_pos": [
            [
              1353,
              0
            ],
            [
              1361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_server_state_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "cb": "ares_server_state_callback",
              "data": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_server_find(const ares_channel_t *channel,\n                                           const ares_sconfig_t *s)",
          "fn_dec_pos": [
            [
              585,
              26
            ],
            [
              586,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_server_find",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_sconfig_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_get_servers_csv(const ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              1313,
              6
            ],
            [
              1313,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_csv",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  struct ares_addr addr;\n  unsigned short   tcp_port;\n  unsigned short   udp_port;\n\n  char             ll_iface[IF_NAMESIZE];\n  unsigned int     ll_scope;\n} ares_sconfig_t;",
          {
            "addr": "struct ares_addr",
            "tcp_port": "unsigned short",
            "udp_port": "unsigned short",
            "ll_iface[IF_NAMESIZE]": "char",
            "ll_scope": "unsigned int"
          },
          "ares_sconfig_t",
          [
            57,
            0
          ],
          [
            64,
            17
          ]
        ],
        [
          "struct {\n    const unsigned char netbase[16];\n    unsigned char       netmask;\n  }",
          {
            "unsigned char": "const",
            "netmask": "unsigned char"
          },
          "",
          [
            166,
            8
          ],
          [
            169,
            3
          ]
        ],
        [
          "typedef struct {\n  struct ares_addr addr;\n  unsigned short   tcp_port;\n  unsigned short   udp_port;\n\n  char             ll_iface[IF_NAMESIZE];\n  unsigned int     ll_scope;\n} ares_sconfig_t;",
          {
            "addr": "struct ares_addr",
            "tcp_port": "unsigned short",
            "udp_port": "unsigned short",
            "ll_iface[IF_NAMESIZE]": "char",
            "ll_scope": "unsigned int"
          },
          "ares_sconfig_t",
          [
            57,
            0
          ],
          [
            64,
            17
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            58,
            2
          ],
          [
            58,
            18
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            66,
            41
          ],
          [
            66,
            57
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            67,
            41
          ],
          [
            67,
            57
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            95,
            36
          ],
          [
            95,
            52
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            96,
            36
          ],
          [
            96,
            52
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            149,
            41
          ],
          [
            149,
            57
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            151,
            2
          ],
          [
            151,
            18
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            163,
            49
          ],
          [
            163,
            65
          ]
        ],
        [
          "struct {\n    const unsigned char netbase[16];\n    unsigned char       netmask;\n  }",
          {
            "unsigned char": "const",
            "netmask": "unsigned char"
          },
          "",
          [
            166,
            8
          ],
          [
            169,
            3
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            187,
            4
          ],
          [
            187,
            20
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            430,
            40
          ],
          [
            430,
            56
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            836,
            40
          ],
          [
            836,
            61
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            839,
            8
          ],
          [
            839,
            29
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            888,
            40
          ],
          [
            888,
            66
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            891,
            8
          ],
          [
            891,
            34
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            942,
            50
          ],
          [
            942,
            64
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1109,
            21
          ],
          [
            1109,
            42
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1111,
            2
          ],
          [
            1111,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1112,
            2
          ],
          [
            1112,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1113,
            2
          ],
          [
            1113,
            23
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1164,
            27
          ],
          [
            1164,
            53
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1166,
            2
          ],
          [
            1166,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1167,
            2
          ],
          [
            1167,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1168,
            2
          ],
          [
            1168,
            28
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1221,
            27
          ],
          [
            1221,
            48
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1245,
            33
          ],
          [
            1245,
            59
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <net/if.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_freeaddrinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_freeaddrinfo_cnames(struct ares_addrinfo_cname *head)\n{\n  struct ares_addrinfo_cname *current;\n  while (head) {\n    current = head;\n    head    = head->next;\n    ares_free(current->alias);\n    ares_free(current->name);\n    ares_free(current);\n  }\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_freeaddrinfo_cnames",
            "parameters": {
              "head": "struct ares_addrinfo_cname"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_freeaddrinfo_nodes(struct ares_addrinfo_node *head)\n{\n  struct ares_addrinfo_node *current;\n  while (head) {\n    current = head;\n    head    = head->ai_next;\n    ares_free(current->ai_addr);\n    ares_free(current);\n  }\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_freeaddrinfo_nodes",
            "parameters": {
              "head": "struct ares_addrinfo_node"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_freeaddrinfo(struct ares_addrinfo *ai)\n{\n  if (ai == NULL) {\n    return;\n  }\n  ares_freeaddrinfo_cnames(ai->cnames);\n  ares_freeaddrinfo_nodes(ai->nodes);\n\n  ares_free(ai->name);\n  ares_free(ai);\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_freeaddrinfo",
            "parameters": {
              "ai": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            33,
            30
          ],
          [
            33,
            56
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            45,
            29
          ],
          [
            45,
            54
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            47,
            2
          ],
          [
            47,
            27
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            56,
            23
          ],
          [
            56,
            43
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_options.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_destroy_options(struct ares_options *options)\n{\n  int i;\n\n  ares_free(options->servers);\n\n  for (i = 0; options->domains && i < options->ndomains; i++) {\n    ares_free(options->domains[i]);\n  }\n\n  ares_free(options->domains);\n  ares_free(options->sortlist);\n  ares_free(options->lookups);\n  ares_free(options->resolvconf_path);\n  ares_free(options->hosts_path);\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_options",
            "parameters": {
              "options": "struct ares_options"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct in_addr *ares_save_opt_servers(const ares_channel_t *channel,\n                                             int                  *nservers)\n{\n  ares_slist_node_t *snode;\n  struct in_addr    *out =\n    ares_malloc_zero(ares_slist_len(channel->servers) * sizeof(*out));\n\n  *nservers = 0;\n\n  if (out == NULL) {\n    return NULL;\n  }\n\n  for (snode = ares_slist_node_first(channel->servers); snode != NULL;\n       snode = ares_slist_node_next(snode)) {\n    const ares_server_t *server = ares_slist_node_val(snode);\n\n    if (server->addr.family != AF_INET) {\n      continue;\n    }\n\n    memcpy(&out[*nservers], &server->addr.addr.addr4, sizeof(*out));\n    (*nservers)++;\n  }\n\n  return out;\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_save_opt_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "nservers": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int ares_save_options(const ares_channel_t *channel,\n                      struct ares_options *options, int *optmask)\n{\n  size_t i;\n\n  /* NOTE: We can't zero the whole thing out, this is because the size of the\n   *       struct ares_options changes over time, so if someone compiled\n   *       with an older version, their struct size might be smaller and\n   *       we might overwrite their memory! So using the optmask is critical\n   *       here, as they could have only set options they knew about.\n   *\n   *       Unfortunately ares_destroy_options() doesn't take an optmask, so\n   *       there are a few pointers we *must* zero out otherwise we won't\n   *       know if they were allocated or not\n   */\n  options->servers         = NULL;\n  options->domains         = NULL;\n  options->sortlist        = NULL;\n  options->lookups         = NULL;\n  options->resolvconf_path = NULL;\n  options->hosts_path      = NULL;\n\n  if (!ARES_CONFIG_CHECK(channel)) {\n    return ARES_ENODATA;\n  }\n\n  if (channel->optmask & ARES_OPT_FLAGS) {\n    options->flags = (int)channel->flags;\n  }\n\n  /* We convert ARES_OPT_TIMEOUT to ARES_OPT_TIMEOUTMS in\n   * ares_init_by_options() */\n  if (channel->optmask & ARES_OPT_TIMEOUTMS) {\n    options->timeout = (int)channel->timeout;\n  }\n\n  if (channel->optmask & ARES_OPT_TRIES) {\n    options->tries = (int)channel->tries;\n  }\n\n  if (channel->optmask & ARES_OPT_NDOTS) {\n    options->ndots = (int)channel->ndots;\n  }\n\n  if (channel->optmask & ARES_OPT_MAXTIMEOUTMS) {\n    options->maxtimeout = (int)channel->maxtimeout;\n  }\n\n  if (channel->optmask & ARES_OPT_UDP_PORT) {\n    options->udp_port = channel->udp_port;\n  }\n  if (channel->optmask & ARES_OPT_TCP_PORT) {\n    options->tcp_port = channel->tcp_port;\n  }\n\n  if (channel->optmask & ARES_OPT_SOCK_STATE_CB) {\n    options->sock_state_cb      = channel->sock_state_cb;\n    options->sock_state_cb_data = channel->sock_state_cb_data;\n  }\n\n  if (channel->optmask & ARES_OPT_SERVERS) {\n    options->servers = ares_save_opt_servers(channel, &options->nservers);\n    if (options->servers == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (channel->optmask & ARES_OPT_DOMAINS) {\n    options->domains = NULL;\n    if (channel->ndomains) {\n      options->domains = ares_malloc(channel->ndomains * sizeof(char *));\n      if (!options->domains) {\n        return ARES_ENOMEM;\n      }\n\n      for (i = 0; i < channel->ndomains; i++) {\n        options->domains[i] = ares_strdup(channel->domains[i]);\n        if (!options->domains[i]) {\n          options->ndomains = (int)i;\n          return ARES_ENOMEM;\n        }\n      }\n    }\n    options->ndomains = (int)channel->ndomains;\n  }\n\n  if (channel->optmask & ARES_OPT_LOOKUPS) {\n    options->lookups = ares_strdup(channel->lookups);\n    if (!options->lookups && channel->lookups) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (channel->optmask & ARES_OPT_SORTLIST) {\n    options->sortlist = NULL;\n    if (channel->nsort) {\n      options->sortlist = ares_malloc(channel->nsort * sizeof(struct apattern));\n      if (!options->sortlist) {\n        return ARES_ENOMEM;\n      }\n      for (i = 0; i < channel->nsort; i++) {\n        options->sortlist[i] = channel->sortlist[i];\n      }\n    }\n    options->nsort = (int)channel->nsort;\n  }\n\n  if (channel->optmask & ARES_OPT_RESOLVCONF) {\n    options->resolvconf_path = ares_strdup(channel->resolvconf_path);\n    if (!options->resolvconf_path) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (channel->optmask & ARES_OPT_HOSTS_FILE) {\n    options->hosts_path = ares_strdup(channel->hosts_path);\n    if (!options->hosts_path) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (channel->optmask & ARES_OPT_SOCK_SNDBUF &&\n      channel->socket_send_buffer_size > 0) {\n    options->socket_send_buffer_size = channel->socket_send_buffer_size;\n  }\n\n  if (channel->optmask & ARES_OPT_SOCK_RCVBUF &&\n      channel->socket_receive_buffer_size > 0) {\n    options->socket_receive_buffer_size = channel->socket_receive_buffer_size;\n  }\n\n  if (channel->optmask & ARES_OPT_EDNSPSZ) {\n    options->ednspsz = (int)channel->ednspsz;\n  }\n\n  if (channel->optmask & ARES_OPT_UDP_MAX_QUERIES) {\n    options->udp_max_queries = (int)channel->udp_max_queries;\n  }\n\n  if (channel->optmask & ARES_OPT_QUERY_CACHE) {\n    options->qcache_max_ttl = channel->qcache_max_ttl;\n  }\n\n  if (channel->optmask & ARES_OPT_EVENT_THREAD) {\n    options->evsys = channel->evsys;\n  }\n\n  /* Set options for server failover behavior */\n  if (channel->optmask & ARES_OPT_SERVER_FAILOVER) {\n    options->server_failover_opts.retry_chance = channel->server_retry_chance;\n    options->server_failover_opts.retry_delay  = channel->server_retry_delay;\n  }\n\n  *optmask = (int)channel->optmask;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_save_options",
            "parameters": {
              "channel": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_status_t ares_init_options_servers(ares_channel_t       *channel,\n                                               const struct in_addr *servers,\n                                               size_t                nservers)\n{\n  ares_llist_t *slist = NULL;\n  ares_status_t status;\n\n  status = ares_in_addr_to_sconfig_llist(servers, nservers, &slist);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_servers_update(channel, slist, ARES_TRUE);\n\n  ares_llist_destroy(slist);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_options_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct in_addr",
              "nservers": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_init_by_options(ares_channel_t            *channel,\n                                   const struct ares_options *options,\n                                   int                        optmask)\n{\n  size_t i;\n\n  if (channel == NULL) {\n    return ARES_ENODATA; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (options == NULL) {\n    if (optmask != 0) {\n      return ARES_ENODATA; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n    return ARES_SUCCESS;\n  }\n\n  /* Easy stuff. */\n\n  /* Event Thread requires threading support and is incompatible with socket\n   * state callbacks */\n  if (optmask & ARES_OPT_EVENT_THREAD) {\n    if (!ares_threadsafety()) {\n      return ARES_ENOTIMP;\n    }\n    if (optmask & ARES_OPT_SOCK_STATE_CB) {\n      return ARES_EFORMERR;\n    }\n    channel->evsys = options->evsys;\n  }\n\n  if (optmask & ARES_OPT_FLAGS) {\n    channel->flags = (unsigned int)options->flags;\n  }\n\n  if (optmask & ARES_OPT_TIMEOUTMS) {\n    /* Apparently some integrations were passing -1 to tell c-ares to use\n     * the default instead of just omitting the optmask */\n    if (options->timeout <= 0) {\n      optmask &= ~(ARES_OPT_TIMEOUTMS);\n    } else {\n      channel->timeout = (unsigned int)options->timeout;\n    }\n  } else if (optmask & ARES_OPT_TIMEOUT) {\n    optmask &= ~(ARES_OPT_TIMEOUT);\n    /* Apparently some integrations were passing -1 to tell c-ares to use\n     * the default instead of just omitting the optmask */\n    if (options->timeout > 0) {\n      /* Convert to milliseconds */\n      optmask          |= ARES_OPT_TIMEOUTMS;\n      channel->timeout  = (unsigned int)options->timeout * 1000;\n    }\n  }\n\n  if (optmask & ARES_OPT_TRIES) {\n    if (options->tries <= 0) {\n      optmask &= ~(ARES_OPT_TRIES);\n    } else {\n      channel->tries = (size_t)options->tries;\n    }\n  }\n\n  if (optmask & ARES_OPT_NDOTS) {\n    if (options->ndots < 0) {\n      optmask &= ~(ARES_OPT_NDOTS);\n    } else {\n      channel->ndots = (size_t)options->ndots;\n    }\n  }\n\n  if (optmask & ARES_OPT_MAXTIMEOUTMS) {\n    if (options->maxtimeout <= 0) {\n      optmask &= ~(ARES_OPT_MAXTIMEOUTMS);\n    } else {\n      channel->maxtimeout = (size_t)options->maxtimeout;\n    }\n  }\n\n  if (optmask & ARES_OPT_ROTATE) {\n    channel->rotate = ARES_TRUE;\n  }\n\n  if (optmask & ARES_OPT_NOROTATE) {\n    channel->rotate = ARES_FALSE;\n  }\n\n  if (optmask & ARES_OPT_UDP_PORT) {\n    channel->udp_port = options->udp_port;\n  }\n\n  if (optmask & ARES_OPT_TCP_PORT) {\n    channel->tcp_port = options->tcp_port;\n  }\n\n  if (optmask & ARES_OPT_SOCK_STATE_CB) {\n    channel->sock_state_cb      = options->sock_state_cb;\n    channel->sock_state_cb_data = options->sock_state_cb_data;\n  }\n\n  if (optmask & ARES_OPT_SOCK_SNDBUF) {\n    if (options->socket_send_buffer_size <= 0) {\n      optmask &= ~(ARES_OPT_SOCK_SNDBUF);\n    } else {\n      channel->socket_send_buffer_size = options->socket_send_buffer_size;\n    }\n  }\n\n  if (optmask & ARES_OPT_SOCK_RCVBUF) {\n    if (options->socket_receive_buffer_size <= 0) {\n      optmask &= ~(ARES_OPT_SOCK_RCVBUF);\n    } else {\n      channel->socket_receive_buffer_size = options->socket_receive_buffer_size;\n    }\n  }\n\n  if (optmask & ARES_OPT_EDNSPSZ) {\n    if (options->ednspsz <= 0) {\n      optmask &= ~(ARES_OPT_EDNSPSZ);\n    } else {\n      channel->ednspsz = (size_t)options->ednspsz;\n    }\n  }\n\n  /* Copy the domains, if given.  Keep channel->ndomains consistent so\n   * we can clean up in case of error.\n   */\n  if (optmask & ARES_OPT_DOMAINS && options->ndomains > 0) {\n    channel->domains =\n      ares_malloc_zero((size_t)options->ndomains * sizeof(char *));\n    if (!channel->domains) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    channel->ndomains = (size_t)options->ndomains;\n    for (i = 0; i < (size_t)options->ndomains; i++) {\n      channel->domains[i] = ares_strdup(options->domains[i]);\n      if (!channel->domains[i]) {\n        return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  /* Set lookups, if given. */\n  if (optmask & ARES_OPT_LOOKUPS) {\n    if (options->lookups == NULL) {\n      optmask &= ~(ARES_OPT_LOOKUPS);\n    } else {\n      channel->lookups = ares_strdup(options->lookups);\n      if (!channel->lookups) {\n        return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  /* copy sortlist */\n  if (optmask & ARES_OPT_SORTLIST && options->nsort > 0) {\n    channel->nsort = (size_t)options->nsort;\n    channel->sortlist =\n      ares_malloc((size_t)options->nsort * sizeof(struct apattern));\n    if (!channel->sortlist) {\n      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    for (i = 0; i < (size_t)options->nsort; i++) {\n      channel->sortlist[i] = options->sortlist[i];\n    }\n  }\n\n  /* Set path for resolv.conf file, if given. */\n  if (optmask & ARES_OPT_RESOLVCONF) {\n    if (options->resolvconf_path == NULL) {\n      optmask &= ~(ARES_OPT_RESOLVCONF);\n    } else {\n      channel->resolvconf_path = ares_strdup(options->resolvconf_path);\n      if (channel->resolvconf_path == NULL) {\n        return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  /* Set path for hosts file, if given. */\n  if (optmask & ARES_OPT_HOSTS_FILE) {\n    if (options->hosts_path == NULL) {\n      optmask &= ~(ARES_OPT_HOSTS_FILE);\n    } else {\n      channel->hosts_path = ares_strdup(options->hosts_path);\n      if (channel->hosts_path == NULL) {\n        return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  if (optmask & ARES_OPT_UDP_MAX_QUERIES) {\n    if (options->udp_max_queries <= 0) {\n      optmask &= ~(ARES_OPT_UDP_MAX_QUERIES);\n    } else {\n      channel->udp_max_queries = (size_t)options->udp_max_queries;\n    }\n  }\n\n  /* As of c-ares 1.31.0, the Query Cache is on by default.  The only way to\n   * disable it is to set options->qcache_max_ttl = 0 while specifying the\n   * ARES_OPT_QUERY_CACHE which will actually disable it completely. */\n  if (optmask & ARES_OPT_QUERY_CACHE) {\n    /* qcache_max_ttl is unsigned unlike the others */\n    channel->qcache_max_ttl = options->qcache_max_ttl;\n  } else {\n    optmask                 |= ARES_OPT_QUERY_CACHE;\n    channel->qcache_max_ttl  = 3600;\n  }\n\n  /* Initialize the ipv4 servers if provided */\n  if (optmask & ARES_OPT_SERVERS) {\n    if (options->nservers <= 0) {\n      optmask &= ~(ARES_OPT_SERVERS);\n    } else {\n      ares_status_t status;\n      status = ares_init_options_servers(channel, options->servers,\n                                         (size_t)options->nservers);\n      if (status != ARES_SUCCESS) {\n        return status; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  /* Set fields for server failover behavior */\n  if (optmask & ARES_OPT_SERVER_FAILOVER) {\n    channel->server_retry_chance = options->server_failover_opts.retry_chance;\n    channel->server_retry_delay  = options->server_failover_opts.retry_delay;\n  }\n\n  channel->optmask = (unsigned int)optmask;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              259,
              0
            ],
            [
              491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_by_options",
            "parameters": {
              "channel": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_save_opt_servers(const ares_channel_t *channel,\n                                             int                  *nservers)",
          "fn_dec_pos": [
            [
              53,
              23
            ],
            [
              54,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_save_opt_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "nservers": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_options",
          {},
          "",
          [
            36,
            26
          ],
          [
            36,
            45
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            53,
            7
          ],
          [
            53,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            57,
            2
          ],
          [
            57,
            16
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            83,
            22
          ],
          [
            83,
            41
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            178,
            62
          ],
          [
            178,
            77
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            241,
            53
          ],
          [
            241,
            67
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            260,
            41
          ],
          [
            260,
            60
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            416,
            50
          ],
          [
            416,
            65
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_process.c": {
      "fn_def_list": [
        {
          "fn_code": "static void        ares_query_remove_from_conn(ares_query_t *query)\n{\n  /* If its not part of a connection, it can't be tracked for timeouts either */\n  ares_slist_node_destroy(query->node_queries_by_timeout);\n  ares_llist_node_destroy(query->node_queries_to_conn);\n  query->node_queries_by_timeout = NULL;\n  query->node_queries_to_conn    = NULL;\n  query->conn                    = NULL;\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_remove_from_conn",
            "parameters": {
              "query": "ares_query_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void invoke_server_state_cb(const ares_server_t *server,\n                                   ares_bool_t success, int flags)\n{\n  const ares_channel_t *channel = server->channel;\n  ares_buf_t           *buf;\n  ares_status_t         status;\n  char                 *server_string;\n\n  if (channel->server_state_cb == NULL) {\n    return;\n  }\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    return; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_get_server_addr(server, buf);\n  if (status != ARES_SUCCESS) {\n    ares_buf_destroy(buf); /* LCOV_EXCL_LINE: OutOfMemory */\n    return;                /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  server_string = ares_buf_finish_str(buf, NULL);\n  buf           = NULL;\n  if (server_string == NULL) {\n    return; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  channel->server_state_cb(server_string, success, flags,\n                           channel->server_state_cb_data);\n  ares_free(server_string);\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "invoke_server_state_cb",
            "parameters": {
              "server": "ares_server_t",
              "success": "ares_bool_t",
              "flags": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void server_increment_failures(ares_server_t *server,\n                                      ares_bool_t    used_tcp)\n{\n  ares_slist_node_t    *node;\n  const ares_channel_t *channel = server->channel;\n  ares_timeval_t        next_retry_time;\n\n  node = ares_slist_node_find(channel->servers, server);\n  if (node == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  server->consec_failures++;\n  ares_slist_node_reinsert(node);\n\n  ares_tvnow(&next_retry_time);\n  timeadd(&next_retry_time, channel->server_retry_delay);\n  server->next_retry_time = next_retry_time;\n\n  invoke_server_state_cb(server, ARES_FALSE,\n                         used_tcp == ARES_TRUE ? ARES_SERV_STATE_TCP\n                                               : ARES_SERV_STATE_UDP);\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_increment_failures",
            "parameters": {
              "server": "ares_server_t",
              "used_tcp": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void server_set_good(ares_server_t *server, ares_bool_t used_tcp)\n{\n  ares_slist_node_t    *node;\n  const ares_channel_t *channel = server->channel;\n\n  node = ares_slist_node_find(channel->servers, server);\n  if (node == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (server->consec_failures > 0) {\n    server->consec_failures = 0;\n    ares_slist_node_reinsert(node);\n  }\n\n  server->next_retry_time.sec  = 0;\n  server->next_retry_time.usec = 0;\n\n  invoke_server_state_cb(server, ARES_TRUE,\n                         used_tcp == ARES_TRUE ? ARES_SERV_STATE_TCP\n                                               : ARES_SERV_STATE_UDP);\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_set_good",
            "parameters": {
              "server": "ares_server_t",
              "used_tcp": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares_timedout(const ares_timeval_t *now,\n                          const ares_timeval_t *check)\n{\n  ares_int64_t secs = (now->sec - check->sec);\n\n  if (secs > 0) {\n    return ARES_TRUE; /* yes, timed out */\n  }\n  if (secs < 0) {\n    return ARES_FALSE; /* nope, not timed out */\n  }\n\n  /* if the full seconds were identical, check the sub second parts */\n  return ((ares_int64_t)now->usec - (ares_int64_t)check->usec) >= 0\n           ? ARES_TRUE\n           : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timedout",
            "parameters": {
              "now": "ares_timeval_t",
              "check": "ares_timeval_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void timeadd(ares_timeval_t *now, size_t millisecs)\n{\n  now->sec  += (ares_int64_t)millisecs / 1000;\n  now->usec += (unsigned int)((millisecs % 1000) * 1000);\n\n  if (now->usec >= 1000000) {\n    now->sec  += now->usec / 1000000;\n    now->usec %= 1000000;\n  }\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "timeadd",
            "parameters": {
              "now": "ares_timeval_t",
              "millisecs": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_process_fds_nolock(ares_channel_t         *channel,\n                                             const ares_fd_events_t *events,\n                                             size_t nevents, unsigned int flags)\n{\n  ares_timeval_t now;\n  size_t         i;\n  ares_status_t  status = ARES_SUCCESS;\n\n  if (channel == NULL || (events == NULL && nevents != 0)) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_tvnow(&now);\n\n  /* Process write events */\n  for (i = 0; i < nevents; i++) {\n    if (events[i].fd == ARES_SOCKET_BAD ||\n        !(events[i].events & ARES_FD_EVENT_WRITE)) {\n      continue;\n    }\n    status = process_write(channel, events[i].fd);\n    /* We only care about ENOMEM, anything else is handled via connection\n     * retries, etc */\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n  }\n\n  /* Process read events */\n  for (i = 0; i < nevents; i++) {\n    if (events[i].fd == ARES_SOCKET_BAD ||\n        !(events[i].events & ARES_FD_EVENT_READ)) {\n      continue;\n    }\n    status = process_read(channel, events[i].fd, &now);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n  }\n\n  if (!(flags & ARES_PROCESS_FLAG_SKIP_NON_FD)) {\n    status = process_timeouts(channel, &now);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n\n    /* Cleanup should be done after processing timeouts as it may invalidate\n     * connections */\n    ares_check_cleanup_conns(channel);\n  }\n\ndone:\n  if (status == ARES_ENOMEM) {\n    return ARES_ENOMEM;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process_fds_nolock",
            "parameters": {
              "channel": "ares_channel_t",
              "events": "ares_fd_events_t",
              "nevents": "size_t",
              "flags": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_process_fds(ares_channel_t         *channel,\n                               const ares_fd_events_t *events, size_t nevents,\n                               unsigned int flags)\n{\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares_channel_lock(channel);\n  status = ares_process_fds_nolock(channel, events, nevents, flags);\n  ares_channel_unlock(channel);\n  return status;\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process_fds",
            "parameters": {
              "channel": "ares_channel_t",
              "events": "ares_fd_events_t",
              "nevents": "size_t",
              "flags": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_process_fd(ares_channel_t *channel, ares_socket_t read_fd,\n                     ares_socket_t write_fd)\n{\n  ares_fd_events_t events[2];\n  size_t           nevents = 0;\n\n  memset(events, 0, sizeof(events));\n\n  if (read_fd != ARES_SOCKET_BAD) {\n    nevents++;\n    events[nevents - 1].fd      = read_fd;\n    events[nevents - 1].events |= ARES_FD_EVENT_READ;\n  }\n\n  if (write_fd != ARES_SOCKET_BAD) {\n    if (write_fd != read_fd) {\n      nevents++;\n    }\n    events[nevents - 1].fd      = write_fd;\n    events[nevents - 1].events |= ARES_FD_EVENT_WRITE;\n  }\n\n  ares_process_fds(channel, events, nevents, ARES_PROCESS_FLAG_NONE);\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process_fd",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fd": "ares_socket_t",
              "write_fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_socket_t *channel_socket_list(const ares_channel_t *channel,\n                                          size_t               *num)\n{\n  ares_slist_node_t *snode;\n  ares_array_t      *arr = ares_array_create(sizeof(ares_socket_t), NULL);\n\n  *num = 0;\n\n  if (arr == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (snode = ares_slist_node_first(channel->servers); snode != NULL;\n       snode = ares_slist_node_next(snode)) {\n    ares_server_t     *server = ares_slist_node_val(snode);\n    ares_llist_node_t *node;\n\n    for (node = ares_llist_node_first(server->connections); node != NULL;\n         node = ares_llist_node_next(node)) {\n      const ares_conn_t *conn = ares_llist_node_val(node);\n      ares_socket_t     *sptr;\n      ares_status_t      status;\n\n      if (conn->fd == ARES_SOCKET_BAD) {\n        continue;\n      }\n\n      status = ares_array_insert_last((void **)&sptr, arr);\n      if (status != ARES_SUCCESS) {\n        ares_array_destroy(arr); /* LCOV_EXCL_LINE: OutOfMemory */\n        return NULL;             /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      *sptr = conn->fd;\n    }\n  }\n\n  return ares_array_finish(arr, num);\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "channel_socket_list",
            "parameters": {
              "channel": "ares_channel_t",
              "num": "size_t"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "void ares_process(ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)\n{\n  size_t            i;\n  size_t            num_sockets;\n  ares_socket_t    *socketlist;\n  ares_fd_events_t *events  = NULL;\n  size_t            nevents = 0;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  ares_channel_lock(channel);\n\n  /* There is no good way to iterate across an fd_set, instead we must pull a\n   * list of all known fds, and iterate across that checking against the fd_set.\n   */\n  socketlist = channel_socket_list(channel, &num_sockets);\n\n  /* Lets create an events array, maximum number is the number of sockets in\n   * the list, so we'll use that and just track entries with nevents */\n  if (num_sockets) {\n    events = ares_malloc_zero(sizeof(*events) * num_sockets);\n    if (events == NULL) {\n      goto done;\n    }\n  }\n\n  for (i = 0; i < num_sockets; i++) {\n    ares_bool_t had_read = ARES_FALSE;\n    if (read_fds && FD_ISSET(socketlist[i], read_fds)) {\n      nevents++;\n      events[nevents - 1].fd      = socketlist[i];\n      events[nevents - 1].events |= ARES_FD_EVENT_READ;\n      had_read                    = ARES_TRUE;\n    }\n    if (write_fds && FD_ISSET(socketlist[i], write_fds)) {\n      if (!had_read) {\n        nevents++;\n      }\n      events[nevents - 1].fd      = socketlist[i];\n      events[nevents - 1].events |= ARES_FD_EVENT_WRITE;\n    }\n  }\n\ndone:\n  ares_process_fds_nolock(channel, events, nevents, ARES_PROCESS_FLAG_NONE);\n  ares_free(events);\n  ares_free(socketlist);\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "write_fds": "fd_set"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t process_write(ares_channel_t *channel,\n                                   ares_socket_t   write_fd)\n{\n  ares_conn_t  *conn = ares_conn_from_fd(channel, write_fd);\n  ares_status_t status;\n\n  if (conn == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* Mark as connected if we got here and TFO Initial not set */\n  if (!(conn->flags & ARES_CONN_FLAG_TFO_INITIAL)) {\n    conn->state_flags |= ARES_CONN_STATE_CONNECTED;\n  }\n\n  status = ares_conn_flush(conn);\n  if (status != ARES_SUCCESS) {\n    handle_conn_error(conn, ARES_TRUE, status);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              385,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_write",
            "parameters": {
              "channel": "ares_channel_t",
              "write_fd": "ares_socket_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_process_pending_write(ares_channel_t *channel)\n{\n  ares_slist_node_t *node;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  ares_channel_lock(channel);\n  if (!channel->notify_pending_write) {\n    ares_channel_unlock(channel);\n    return;\n  }\n\n  /* Set as untriggerd before calling into ares_conn_flush(), this is\n   * because its possible ares_conn_flush() might cause additional data to\n   * be enqueued if there is some form of exception so it will need to recurse.\n   */\n  channel->notify_pending_write = ARES_FALSE;\n\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    ares_server_t *server = ares_slist_node_val(node);\n    ares_conn_t   *conn   = server->tcp_conn;\n    ares_status_t  status;\n\n    if (conn == NULL) {\n      continue;\n    }\n\n    /* Enqueue any pending data if there is any */\n    status = ares_conn_flush(conn);\n    if (status != ARES_SUCCESS) {\n      handle_conn_error(conn, ARES_TRUE, status);\n    }\n  }\n\n  ares_channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process_pending_write",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t read_conn_packets(ares_conn_t *conn)\n{\n  ares_bool_t           read_again;\n  ares_conn_err_t       err;\n  const ares_channel_t *channel = conn->server->channel;\n\n  do {\n    size_t         count;\n    size_t         len = 65535;\n    unsigned char *ptr;\n    size_t         start_len = ares_buf_len(conn->in_buf);\n\n    /* If UDP, lets write out a placeholder for the length indicator */\n    if (!(conn->flags & ARES_CONN_FLAG_TCP) &&\n        ares_buf_append_be16(conn->in_buf, 0) != ARES_SUCCESS) {\n      handle_conn_error(conn, ARES_FALSE /* not critical to connection */,\n                        ARES_SUCCESS);\n      return ARES_ENOMEM;\n    }\n\n    /* Get a buffer of sufficient size */\n    ptr = ares_buf_append_start(conn->in_buf, &len);\n\n    if (ptr == NULL) {\n      handle_conn_error(conn, ARES_FALSE /* not critical to connection */,\n                        ARES_SUCCESS);\n      return ARES_ENOMEM;\n    }\n\n    /* Read from socket */\n    err = ares_conn_read(conn, ptr, len, &count);\n\n    if (err != ARES_CONN_ERR_SUCCESS) {\n      ares_buf_append_finish(conn->in_buf, 0);\n      if (!(conn->flags & ARES_CONN_FLAG_TCP)) {\n        ares_buf_set_length(conn->in_buf, start_len);\n      }\n      break;\n    }\n\n    /* Record amount of data read */\n    ares_buf_append_finish(conn->in_buf, count);\n\n    /* Only loop if sockets support non-blocking operation, and are using UDP\n     * or are using TCP and read the maximum buffer size */\n    read_again = ARES_FALSE;\n    if (channel->sock_funcs.flags & ARES_SOCKFUNC_FLAG_NONBLOCKING &&\n        (!(conn->flags & ARES_CONN_FLAG_TCP) || count == len)) {\n      read_again = ARES_TRUE;\n    }\n\n    /* If UDP, overwrite length */\n    if (!(conn->flags & ARES_CONN_FLAG_TCP)) {\n      len = ares_buf_len(conn->in_buf);\n      ares_buf_set_length(conn->in_buf, start_len);\n      ares_buf_append_be16(conn->in_buf, (unsigned short)count);\n      ares_buf_set_length(conn->in_buf, len);\n    }\n    /* Try to read again only if *we* set up the socket, otherwise it may be\n     * a blocking socket and would cause recvfrom to hang. */\n  } while (read_again);\n\n  if (err != ARES_CONN_ERR_SUCCESS && err != ARES_CONN_ERR_WOULDBLOCK) {\n    handle_conn_error(conn, ARES_TRUE, ARES_ECONNREFUSED);\n    return ARES_ECONNREFUSED;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              447,
              0
            ],
            [
              515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_conn_packets",
            "parameters": {
              "conn": "ares_conn_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_append_requeue_int(ares_array_t     **requeue,\n                                             requeue_type_t     type,\n                                             ares_query_t      *query,\n                                             ares_server_t     *server,\n                                             ares_status_t      status,\n                                             ares_dns_record_t *dnsrec)\n{\n  ares_requeue_t entry;\n\n  if (*requeue == NULL) {\n    *requeue = ares_array_create(sizeof(ares_requeue_t), NULL);\n    if (*requeue == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  ares_query_remove_from_conn(query);\n\n  entry.type   = type;\n  entry.qid    = query->qid;\n  entry.server = server;\n  entry.status = status;\n  entry.dnsrec = dnsrec;\n  return ares_array_insertdata_last(*requeue, &entry);\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              556,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_requeue_int",
            "parameters": {
              "requeue": "ares_array_t",
              "type": "requeue_type_t",
              "query": "ares_query_t",
              "server": "ares_server_t",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_append_requeue(ares_array_t **requeue,\n                                         ares_query_t  *query,\n                                         ares_server_t *server)\n{\n  return ares_append_requeue_int(requeue, REQUEUE_REQUEUE, query, server, 0,\n    NULL);\n}",
          "fn_code_pos": [
            [
              558,
              0
            ],
            [
              564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_requeue",
            "parameters": {
              "requeue": "ares_array_t",
              "query": "ares_query_t",
              "server": "ares_server_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_append_endqueue(ares_array_t     **requeue,\n                                          ares_query_t      *query,\n                                          ares_status_t      status,\n                                          ares_dns_record_t *dnsrec)\n{\n  return ares_append_requeue_int(requeue, REQUEUE_ENDQUERY, query, NULL, status,\n    dnsrec);\n}",
          "fn_code_pos": [
            [
              566,
              0
            ],
            [
              573,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_endqueue",
            "parameters": {
              "requeue": "ares_array_t",
              "query": "ares_query_t",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t read_answers(ares_conn_t *conn, const ares_timeval_t *now)\n{\n  ares_status_t   status;\n  ares_channel_t *channel  = conn->server->channel;\n  ares_array_t   *requeue  = NULL;\n\n  /* Process all queued answers */\n  while (1) {\n    unsigned short       dns_len  = 0;\n    const unsigned char *data     = NULL;\n    size_t               data_len = 0;\n\n    /* Tag so we can roll back */\n    ares_buf_tag(conn->in_buf);\n\n    /* Read length indicator */\n    status = ares_buf_fetch_be16(conn->in_buf, &dns_len);\n    if (status != ARES_SUCCESS) {\n      ares_buf_tag_rollback(conn->in_buf);\n      break;\n    }\n\n    /* Not enough data for a full response yet */\n    status = ares_buf_consume(conn->in_buf, dns_len);\n    if (status != ARES_SUCCESS) {\n      ares_buf_tag_rollback(conn->in_buf);\n      break;\n    }\n\n    /* Can't fail except for misuse */\n    data = ares_buf_tag_fetch(conn->in_buf, &data_len);\n    if (data == NULL || data_len < 2) {\n      ares_buf_tag_clear(conn->in_buf);\n      break;\n    }\n\n    /* Strip off 2 bytes length */\n    data     += 2;\n    data_len -= 2;\n\n    /* We finished reading this answer; process it */\n    status = process_answer(channel, data, data_len, conn, now, &requeue);\n    if (status != ARES_SUCCESS) {\n      handle_conn_error(conn, ARES_TRUE, status);\n      goto cleanup;\n    }\n\n    /* Since we processed the answer, clear the tag so space can be reclaimed */\n    ares_buf_tag_clear(conn->in_buf);\n  }\n\ncleanup:\n\n  /* Flush requeue */\n  while (ares_array_len(requeue) > 0) {\n    ares_query_t  *query;\n    ares_requeue_t entry;\n    ares_status_t  internal_status;\n\n    internal_status = ares_array_claim_at(&entry, sizeof(entry), requeue, 0);\n    if (internal_status != ARES_SUCCESS) {\n      break;\n    }\n\n    query = ares_htable_szvp_get_direct(channel->queries_by_qid, entry.qid);\n\n    if (entry.type == REQUEUE_REQUEUE) {\n      /* query disappeared */\n      if (query == NULL) {\n        continue;\n      }\n      internal_status = ares_send_query(entry.server, query, now);\n      /* We only care about ARES_ENOMEM */\n      if (internal_status == ARES_ENOMEM) {\n        status = ARES_ENOMEM;\n      }\n    } else { /* REQUEUE_ENDQUERY */\n      if (query != NULL) {\n        query->callback(query->arg, entry.status, query->timeouts, entry.dnsrec);\n        ares_free_query(query);\n      }\n      ares_dns_record_destroy(entry.dnsrec);\n    }\n  }\n  /* Don't forget to send notification if queue emptied */\n  if (requeue != NULL) {\n    ares_queue_notify_empty(channel);\n  }\n  ares_array_destroy(requeue);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              575,
              0
            ],
            [
              666,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_answers",
            "parameters": {
              "conn": "ares_conn_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t process_read(ares_channel_t       *channel,\n                                  ares_socket_t         read_fd,\n                                  const ares_timeval_t *now)\n{\n  ares_conn_t  *conn = ares_conn_from_fd(channel, read_fd);\n  ares_status_t status;\n\n  if (conn == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* TODO: There might be a potential issue here where there was a read that\n   *       read some data, then looped and read again and got a disconnect.\n   *       Right now, that would cause a resend instead of processing the data\n   *       we have.  This is fairly unlikely to occur due to only looping if\n   *       a full buffer of 65535 bytes was read. */\n  status = read_conn_packets(conn);\n\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return read_answers(conn, now);\n}",
          "fn_code_pos": [
            [
              668,
              0
            ],
            [
              691,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_read",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fd": "ares_socket_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t process_timeouts(ares_channel_t       *channel,\n                                      const ares_timeval_t *now)\n{\n  ares_slist_node_t *node;\n  ares_status_t      status = ARES_SUCCESS;\n\n  /* Just keep popping off the first as this list will re-sort as things come\n   * and go.  We don't want to try to rely on 'next' as some operation might\n   * cause a cleanup of that pointer and would become invalid */\n  while ((node = ares_slist_node_first(channel->queries_by_timeout)) != NULL) {\n    ares_query_t *query = ares_slist_node_val(node);\n    ares_conn_t  *conn;\n\n    /* Since this is sorted, as soon as we hit a query that isn't timed out,\n     * break */\n    if (!ares_timedout(now, &query->timeout)) {\n      break;\n    }\n\n    query->timeouts++;\n\n    conn = query->conn;\n    server_increment_failures(conn->server, query->using_tcp);\n    status = ares_requeue_query(query, now, ARES_ETIMEOUT, ARES_TRUE, NULL,\n      NULL);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n  }\ndone:\n  if (status == ARES_ENOMEM) {\n    return ARES_ENOMEM;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              694,
              0
            ],
            [
              728,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_timeouts",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t rewrite_without_edns(ares_query_t *query)\n{\n  ares_status_t status = ARES_SUCCESS;\n  size_t        i;\n  ares_bool_t   found_opt_rr = ARES_FALSE;\n\n  /* Find and remove the OPT RR record */\n  for (i = 0; i < ares_dns_record_rr_cnt(query->query, ARES_SECTION_ADDITIONAL);\n       i++) {\n    const ares_dns_rr_t *rr;\n    rr = ares_dns_record_rr_get(query->query, ARES_SECTION_ADDITIONAL, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      ares_dns_record_rr_del(query->query, ARES_SECTION_ADDITIONAL, i);\n      found_opt_rr = ARES_TRUE;\n      break;\n    }\n  }\n\n  if (!found_opt_rr) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              730,
              0
            ],
            [
              755,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rewrite_without_edns",
            "parameters": {
              "query": "ares_query_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t issue_might_be_edns(const ares_dns_record_t *req,\n                                       const ares_dns_record_t *rsp)\n{\n  const ares_dns_rr_t *rr;\n\n  /* If we use EDNS and server answers with FORMERR without an OPT RR, the\n   * protocol extension is not understood by the responder. We must retry the\n   * query without EDNS enabled. */\n  if (ares_dns_record_get_rcode(rsp) != ARES_RCODE_FORMERR) {\n    return ARES_FALSE;\n  }\n\n  rr = ares_dns_get_opt_rr_const(req);\n  if (rr == NULL) {\n    /* We didn't send EDNS */\n    return ARES_FALSE;\n  }\n\n  if (ares_dns_get_opt_rr_const(rsp) == NULL) {\n    /* Spec says EDNS won't be echo'd back on non-supporting servers, so\n     * retry without EDNS */\n    return ARES_TRUE;\n  }\n\n  /* As per issue #911 some non-compliant servers that do indeed support EDNS\n   * but don't support unrecognized option codes exist.  At this point we\n   * expect them to have also returned an EDNS opt record, but we may remove\n   * that check in the future. Lets detect this situation if we're sending\n   * option codes */\n  if (ares_dns_rr_get_opt_cnt(rr, ARES_RR_OPT_OPTIONS) == 0) {\n    /* We didn't send any option codes */\n    return ARES_FALSE;\n  }\n\n  if (ares_dns_get_opt_rr_const(rsp) != NULL) {\n    /* At this time we're requiring the server to respond with EDNS opt\n     * records since that's what has been observed in the field.  We might\n     * find in the future we have to remove this, who knows. Lets go\n     * ahead and force a retry without EDNS*/\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              757,
              0
            ],
            [
              800,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "issue_might_be_edns",
            "parameters": {
              "req": "ares_dns_record_t",
              "rsp": "ares_dns_record_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t process_answer(ares_channel_t      *channel,\n                                    const unsigned char *abuf, size_t alen,\n                                    ares_conn_t          *conn,\n                                    const ares_timeval_t *now,\n                                    ares_array_t        **requeue)\n{\n  ares_query_t      *query;\n  /* Cache these as once ares_send_query() gets called, it may end up\n   * invalidating the connection all-together */\n  ares_server_t     *server  = conn->server;\n  ares_dns_record_t *rdnsrec = NULL;\n  ares_status_t      status;\n  ares_bool_t        is_cached = ARES_FALSE;\n\n  /* UDP can have 0-byte messages, drop them to the ground */\n  if (alen == 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* Parse the response */\n  status = ares_dns_parse(abuf, alen, 0, &rdnsrec);\n  if (status != ARES_SUCCESS) {\n    /* Malformations are never accepted */\n    status = ARES_EBADRESP;\n    goto cleanup;\n  }\n\n  /* Find the query corresponding to this packet. The queries are\n   * hashed/bucketed by query id, so this lookup should be quick.\n   */\n  query = ares_htable_szvp_get_direct(channel->queries_by_qid,\n                                      ares_dns_record_get_id(rdnsrec));\n  if (!query) {\n    /* We may have stopped listening for this query, that's ok */\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* Both the query id and the questions must be the same. We will drop any\n   * replies that aren't for the same query as this is considered invalid. */\n  if (!same_questions(query, rdnsrec)) {\n    /* Possible qid conflict due to delayed response, that's ok */\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* Validate DNS cookie in response. This function may need to requeue the\n   * query. */\n  if (ares_cookie_validate(query, rdnsrec, conn, now, requeue)\n      != ARES_SUCCESS) {\n    /* Drop response and return */\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* At this point we know we've received an answer for this query, so we should\n   * remove it from the connection's queue so we can possibly invalidate the\n   * connection. Delay cleaning up the connection though as we may enqueue\n   * something new.  */\n  ares_llist_node_destroy(query->node_queries_to_conn);\n  query->node_queries_to_conn = NULL;\n\n  /* There are old servers that don't understand EDNS at all, then some servers\n   * that have non-compliant implementations.  Lets try to detect this sort\n   * of thing. */\n  if (issue_might_be_edns(query->query, rdnsrec)) {\n    status = rewrite_without_edns(query);\n    if (status != ARES_SUCCESS) {\n      end_query(channel, server, query, status, NULL, NULL);\n      goto cleanup;\n    }\n\n    /* Requeue to same server */\n    status = ares_append_requeue(requeue, query, server);\n    goto cleanup;\n  }\n\n  /* If we got a truncated UDP packet and are not ignoring truncation,\n   * don't accept the packet, and switch the query to TCP if we hadn't\n   * done so already.\n   */\n  if (ares_dns_record_get_flags(rdnsrec) & ARES_FLAG_TC &&\n      !(conn->flags & ARES_CONN_FLAG_TCP) &&\n      !(channel->flags & ARES_FLAG_IGNTC)) {\n    query->using_tcp = ARES_TRUE;\n    status = ares_append_requeue(requeue, query, NULL);\n    /* Status will reflect success except on memory error, which is good since\n     * requeuing to TCP is ok */\n    goto cleanup;\n  }\n\n  /* If we aren't passing through all error packets, discard packets\n   * with SERVFAIL, NOTIMP, or REFUSED response codes.\n   */\n  if (!(channel->flags & ARES_FLAG_NOCHECKRESP)) {\n    ares_dns_rcode_t rcode = ares_dns_record_get_rcode(rdnsrec);\n    if (rcode == ARES_RCODE_SERVFAIL || rcode == ARES_RCODE_NOTIMP ||\n        rcode == ARES_RCODE_REFUSED) {\n      switch (rcode) {\n        case ARES_RCODE_SERVFAIL:\n          status = ARES_ESERVFAIL;\n          break;\n        case ARES_RCODE_NOTIMP:\n          status = ARES_ENOTIMP;\n          break;\n        case ARES_RCODE_REFUSED:\n          status = ARES_EREFUSED;\n          break;\n        default:\n          break;\n      }\n\n      server_increment_failures(server, query->using_tcp);\n      status = ares_requeue_query(query, now, status, ARES_TRUE, rdnsrec,\n        requeue);\n      rdnsrec = NULL; /* Free'd by ares_requeue_query() */\n\n      if (status != ARES_ENOMEM) {\n        /* Should any of these cause a connection termination?\n         * Maybe SERVER_FAILURE? */\n        status = ARES_SUCCESS;\n      }\n      goto cleanup;\n    }\n  }\n\n  /* If cache insertion was successful, it took ownership.  We ignore\n   * other cache insertion failures. */\n  ares_qcache_insert(channel, now, query, rdnsrec);\n\n  server_set_good(server, query->using_tcp);\n  end_query(channel, server, query, ARES_SUCCESS, rdnsrec, requeue);\n  rdnsrec = NULL; /* Free'd by the requeue */\n\n  status = ARES_SUCCESS;\n\ncleanup:\n  /* Don't cleanup the cached pointer to the dns response */\n  if (!is_cached) {\n    ares_dns_record_destroy(rdnsrec);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              805,
              0
            ],
            [
              948,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_answer",
            "parameters": {
              "channel": "ares_channel_t",
              "abuf": "unsigned char",
              "alen": "size_t",
              "conn": "ares_conn_t",
              "now": "ares_timeval_t",
              "requeue": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void handle_conn_error(ares_conn_t *conn, ares_bool_t critical_failure,\n                              ares_status_t failure_status)\n{\n  ares_server_t *server = conn->server;\n\n  /* Increment failures first before requeue so it is unlikely to requeue\n   * to the same server */\n  if (critical_failure) {\n    server_increment_failures(\n      server, (conn->flags & ARES_CONN_FLAG_TCP) ? ARES_TRUE : ARES_FALSE);\n  }\n\n  /* This will requeue any connections automatically */\n  ares_close_connection(conn, failure_status);\n}",
          "fn_code_pos": [
            [
              950,
              0
            ],
            [
              964,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "handle_conn_error",
            "parameters": {
              "conn": "ares_conn_t",
              "critical_failure": "ares_bool_t",
              "failure_status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_requeue_query(ares_query_t *query, const ares_timeval_t *now,\n                                 ares_status_t            status,\n                                 ares_bool_t              inc_try_count,\n                                 ares_dns_record_t       *dnsrec,\n                                 ares_array_t           **requeue)\n{\n  ares_channel_t *channel   = query->channel;\n  size_t          max_tries = ares_slist_len(channel->servers) * channel->tries;\n\n  ares_query_remove_from_conn(query);\n\n  if (status != ARES_SUCCESS) {\n    query->error_status = status;\n  }\n\n  if (inc_try_count) {\n    query->try_count++;\n  }\n\n  if (query->try_count < max_tries && !query->no_retries) {\n    ares_dns_record_destroy(dnsrec);\n    if (requeue != NULL) {\n      return ares_append_requeue(requeue, query, NULL);\n    }\n    return ares_send_query(NULL, query, now);\n  }\n\n  /* If we are here, all attempts to perform query failed. */\n  if (query->error_status == ARES_SUCCESS) {\n    query->error_status = ARES_ETIMEOUT;\n  }\n\n  end_query(channel, NULL, query, query->error_status, dnsrec, requeue);\n  return ARES_ETIMEOUT;\n}",
          "fn_code_pos": [
            [
              969,
              0
            ],
            [
              1003,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_requeue_query",
            "parameters": {
              "query": "ares_query_t",
              "now": "ares_timeval_t",
              "status": "ares_status_t",
              "inc_try_count": "ares_bool_t",
              "dnsrec": "ares_dns_record_t",
              "requeue": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static size_t count_highest_prio_servers(const ares_channel_t *channel)\n{\n  ares_slist_node_t *node;\n  size_t             cnt                  = 0;\n  size_t             last_consec_failures = SIZE_MAX;\n\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    const ares_server_t *server = ares_slist_node_val(node);\n\n    if (last_consec_failures != SIZE_MAX &&\n        last_consec_failures < server->consec_failures) {\n      break;\n    }\n\n    last_consec_failures = server->consec_failures;\n    cnt++;\n  }\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              1009,
              0
            ],
            [
              1029,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "count_highest_prio_servers",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static ares_server_t *ares_random_server(ares_channel_t *channel)\n{\n  unsigned char      c;\n  size_t             cnt;\n  size_t             idx;\n  ares_slist_node_t *node;\n  size_t             num_servers = count_highest_prio_servers(channel);\n\n  /* Silence coverity, not possible */\n  if (num_servers == 0) {\n    return NULL;\n  }\n\n  ares_rand_bytes(channel->rand_state, &c, 1);\n\n  cnt = c;\n  idx = cnt % num_servers;\n\n  cnt = 0;\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    if (cnt == idx) {\n      return ares_slist_node_val(node);\n    }\n\n    cnt++;\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              1034,
              0
            ],
            [
              1063,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_random_server",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_server_t"
          }
        },
        {
          "fn_code": "static void server_probe_cb(void *arg, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)\n{\n  (void)arg;\n  (void)status;\n  (void)timeouts;\n  (void)dnsrec;\n  /* Nothing to do, the logic internally will handle success/fail of this */\n}",
          "fn_code_pos": [
            [
              1065,
              0
            ],
            [
              1073,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_probe_cb",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_probe_failed_server(ares_channel_t      *channel,\n                                     const ares_server_t *server,\n                                     const ares_query_t  *query)\n{\n  const ares_server_t *last_server = ares_slist_last_val(channel->servers);\n  unsigned short       r;\n  ares_timeval_t       now;\n  ares_slist_node_t   *node;\n  ares_server_t       *probe_server = NULL;\n\n  /* If no servers have failures, or we're not configured with a server retry\n   * chance, then nothing to probe */\n  if ((last_server != NULL && last_server->consec_failures == 0) ||\n      channel->server_retry_chance == 0) {\n    return;\n  }\n\n  /* Generate a random value to decide whether to retry a failed server. The\n   * probability to use is 1/channel->server_retry_chance, rounded up to a\n   * precision of 1/2^B where B is the number of bits in the random value.\n   * We use an unsigned short for the random value for increased precision.\n   */\n  ares_rand_bytes(channel->rand_state, (unsigned char *)&r, sizeof(r));\n  if (r % channel->server_retry_chance != 0) {\n    return;\n  }\n\n  /* Select the first server with failures to retry that has passed the retry\n   * timeout and doesn't already have a pending probe */\n  ares_tvnow(&now);\n  for (node = ares_slist_node_first(channel->servers); node != NULL;\n       node = ares_slist_node_next(node)) {\n    ares_server_t *node_val = ares_slist_node_val(node);\n    if (node_val != NULL && node_val->consec_failures > 0 &&\n        !node_val->probe_pending &&\n        ares_timedout(&now, &node_val->next_retry_time)) {\n      probe_server = node_val;\n      break;\n    }\n  }\n\n  /* Either nothing to probe or the query was enqueud to the same server\n   * we were going to probe. Do nothing. */\n  if (probe_server == NULL || server == probe_server) {\n    return;\n  }\n\n  /* Enqueue an identical query onto the specified server without honoring\n   * the cache or allowing retries.  We want to make sure it only attempts to\n   * use the server in question */\n  probe_server->probe_pending = ARES_TRUE;\n  ares_send_nolock(channel, probe_server,\n                   ARES_SEND_FLAG_NOCACHE | ARES_SEND_FLAG_NORETRY,\n                   query->query, server_probe_cb, NULL, NULL);\n}",
          "fn_code_pos": [
            [
              1076,
              0
            ],
            [
              1130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_probe_failed_server",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "query": "ares_query_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_calc_query_timeout(const ares_query_t   *query,\n                                      const ares_server_t  *server,\n                                      const ares_timeval_t *now)\n{\n  const ares_channel_t *channel  = query->channel;\n  size_t                timeout  = ares_metrics_server_timeout(server, now);\n  size_t                timeplus = timeout;\n  size_t                rounds;\n  size_t                num_servers = ares_slist_len(channel->servers);\n\n  if (num_servers == 0) {\n    return 0; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* For each trip through the entire server list, we want to double the\n   * retry from the last retry */\n  rounds = (query->try_count / num_servers);\n  if (rounds > 0) {\n    timeplus <<= rounds;\n  }\n\n  if (channel->maxtimeout && timeplus > channel->maxtimeout) {\n    timeplus = channel->maxtimeout;\n  }\n\n  /* Add some jitter to the retry timeout.\n   *\n   * Jitter is needed in situation when resolve requests are performed\n   * simultaneously from multiple hosts and DNS server throttle these requests.\n   * Adding randomness allows to avoid synchronisation of retries.\n   *\n   * Value of timeplus adjusted randomly to the range [0.5 * timeplus,\n   * timeplus].\n   */\n  if (rounds > 0) {\n    unsigned short r;\n    float          delta_multiplier;\n\n    ares_rand_bytes(channel->rand_state, (unsigned char *)&r, sizeof(r));\n    delta_multiplier  = ((float)r / USHRT_MAX) * 0.5f;\n    timeplus         -= (size_t)((float)timeplus * delta_multiplier);\n  }\n\n  /* We want explicitly guarantee that timeplus is greater or equal to timeout\n   * specified in channel options. */\n  if (timeplus < timeout) {\n    timeplus = timeout;\n  }\n\n  return timeplus;\n}",
          "fn_code_pos": [
            [
              1132,
              0
            ],
            [
              1182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_calc_query_timeout",
            "parameters": {
              "query": "ares_query_t",
              "server": "ares_server_t",
              "now": "ares_timeval_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static ares_conn_t *ares_fetch_connection(const ares_channel_t *channel,\n                                          ares_server_t        *server,\n                                          const ares_query_t   *query)\n{\n  ares_llist_node_t *node;\n  ares_conn_t       *conn;\n\n  if (query->using_tcp) {\n    return server->tcp_conn;\n  }\n\n  /* Fetch existing UDP connection */\n  node = ares_llist_node_first(server->connections);\n  if (node == NULL) {\n    return NULL;\n  }\n\n  conn = ares_llist_node_val(node);\n  /* Not UDP, skip */\n  if (conn->flags & ARES_CONN_FLAG_TCP) {\n    return NULL;\n  }\n\n  /* If the associated server has failures, don't use it.  It should be cleaned\n   * up later. */\n  if (conn->server->consec_failures > 0) {\n    return NULL;\n  }\n\n  /* Used too many times */\n  if (channel->udp_max_queries > 0 &&\n      conn->total_queries >= channel->udp_max_queries) {\n    return NULL;\n  }\n\n  return conn;\n}",
          "fn_code_pos": [
            [
              1184,
              0
            ],
            [
              1220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_fetch_connection",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "query": "ares_query_t"
            },
            "return_type": "ares_conn_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_conn_query_write(ares_conn_t          *conn,\n                                           ares_query_t         *query,\n                                           const ares_timeval_t *now)\n{\n  ares_server_t  *server  = conn->server;\n  ares_channel_t *channel = server->channel;\n  ares_status_t   status;\n\n  status = ares_cookie_apply(query->query, conn, now);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* We write using the TCP format even for UDP, we just strip the length\n   * before putting on the wire */\n  status = ares_dns_write_buf_tcp(query->query, conn->out_buf);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Not pending a TFO write and not connected, so we can't even try to\n   * write until we get a signal */\n  if (conn->flags & ARES_CONN_FLAG_TCP &&\n      !(conn->state_flags & ARES_CONN_STATE_CONNECTED) &&\n      !(conn->flags & ARES_CONN_FLAG_TFO_INITIAL)) {\n    return ARES_SUCCESS;\n  }\n\n  /* Delay actual write if possible (TCP only, and only if callback\n   * configured) */\n  if (channel->notify_pending_write_cb && !channel->notify_pending_write &&\n      conn->flags & ARES_CONN_FLAG_TCP) {\n    channel->notify_pending_write = ARES_TRUE;\n    channel->notify_pending_write_cb(channel->notify_pending_write_cb_data);\n    return ARES_SUCCESS;\n  }\n\n  /* Unfortunately we need to write right away and can't aggregate multiple\n   * queries into a single write. */\n  return ares_conn_flush(conn);\n}",
          "fn_code_pos": [
            [
              1222,
              0
            ],
            [
              1262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_query_write",
            "parameters": {
              "conn": "ares_conn_t",
              "query": "ares_query_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_send_query(ares_server_t *requested_server,\n                              ares_query_t *query, const ares_timeval_t *now)\n{\n  ares_channel_t *channel = query->channel;\n  ares_server_t  *server;\n  ares_conn_t    *conn;\n  size_t          timeplus;\n  ares_status_t   status;\n  ares_bool_t     probe_downed_server = ARES_TRUE;\n\n  /* Choose the server to send the query to */\n  if (requested_server != NULL) {\n    server = requested_server;\n  } else {\n    /* If rotate is turned on, do a random selection */\n    if (channel->rotate) {\n      server = ares_random_server(channel);\n    } else {\n      /* First server in list */\n      server = ares_slist_first_val(channel->servers);\n    }\n  }\n\n  if (server == NULL) {\n    end_query(channel, server, query, ARES_ENOSERVER /* ? */, NULL, NULL);\n    return ARES_ENOSERVER;\n  }\n\n  /* If a query is directed to a specific query, or the server chosen has\n   * failures, or the query is being retried, don't probe for downed servers */\n  if (requested_server != NULL || server->consec_failures > 0 ||\n      query->try_count != 0) {\n    probe_downed_server = ARES_FALSE;\n  }\n\n  conn = ares_fetch_connection(channel, server, query);\n  if (conn == NULL) {\n    status = ares_open_connection(&conn, channel, server, query->using_tcp);\n    switch (status) {\n      /* Good result, continue on */\n      case ARES_SUCCESS:\n        break;\n\n      /* These conditions are retryable as they are server-specific\n       * error codes */\n      case ARES_ECONNREFUSED:\n      case ARES_EBADFAMILY:\n        server_increment_failures(server, query->using_tcp);\n        return ares_requeue_query(query, now, status, ARES_TRUE, NULL, NULL);\n\n      /* Anything else is not retryable, likely ENOMEM */\n      default:\n        end_query(channel, server, query, status, NULL, NULL);\n        return status;\n    }\n  }\n\n  /* Write the query */\n  status = ares_conn_query_write(conn, query, now);\n  switch (status) {\n    /* Good result, continue on */\n    case ARES_SUCCESS:\n      break;\n\n    case ARES_ENOMEM:\n      /* Not retryable */\n      end_query(channel, server, query, status, NULL, NULL);\n      return status;\n\n    /* These conditions are retryable as they are server-specific\n     * error codes */\n    case ARES_ECONNREFUSED:\n    case ARES_EBADFAMILY:\n      handle_conn_error(conn, ARES_TRUE, status);\n      status = ares_requeue_query(query, now, status, ARES_TRUE, NULL, NULL);\n      if (status == ARES_ETIMEOUT) {\n        status = ARES_ECONNREFUSED;\n      }\n      return status;\n\n    default:\n      server_increment_failures(server, query->using_tcp);\n      status = ares_requeue_query(query, now, status, ARES_TRUE, NULL, NULL);\n      return status;\n  }\n\n  timeplus = ares_calc_query_timeout(query, server, now);\n  /* Keep track of queries bucketed by timeout, so we can process\n   * timeout events quickly.\n   */\n  ares_slist_node_destroy(query->node_queries_by_timeout);\n  query->ts      = *now;\n  query->timeout = *now;\n  timeadd(&query->timeout, timeplus);\n  query->node_queries_by_timeout =\n    ares_slist_insert(channel->queries_by_timeout, query);\n  if (!query->node_queries_by_timeout) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    end_query(channel, server, query, ARES_ENOMEM, NULL, NULL);\n    return ARES_ENOMEM;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Keep track of queries bucketed by connection, so we can process errors\n   * quickly. */\n  ares_llist_node_destroy(query->node_queries_to_conn);\n  query->node_queries_to_conn =\n    ares_llist_insert_last(conn->queries_to_conn, query);\n\n  if (query->node_queries_to_conn == NULL) {\n    /* LCOV_EXCL_START: OutOfMemory */\n    end_query(channel, server, query, ARES_ENOMEM, NULL, NULL);\n    return ARES_ENOMEM;\n    /* LCOV_EXCL_STOP */\n  }\n\n  query->conn = conn;\n  conn->total_queries++;\n\n  /* We just successfully enqueud a query, see if we should probe downed\n   * servers. */\n  if (probe_downed_server) {\n    ares_probe_failed_server(channel, server, query);\n  }\n\n  if (channel->query_enqueue_cb) {\n    channel->query_enqueue_cb(channel->query_enqueue_cb_data);\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1264,
              0
            ],
            [
              1394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send_query",
            "parameters": {
              "requested_server": "ares_server_t",
              "query": "ares_query_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t same_questions(const ares_query_t      *query,\n                                  const ares_dns_record_t *arec)\n{\n  size_t                   i;\n  ares_bool_t              rv      = ARES_FALSE;\n  const ares_dns_record_t *qrec    = query->query;\n  const ares_channel_t    *channel = query->channel;\n\n\n  if (ares_dns_record_query_cnt(qrec) != ares_dns_record_query_cnt(arec)) {\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_query_cnt(qrec); i++) {\n    const char         *qname = NULL;\n    const char         *aname = NULL;\n    ares_dns_rec_type_t qtype;\n    ares_dns_rec_type_t atype;\n    ares_dns_class_t    qclass;\n    ares_dns_class_t    aclass;\n\n    if (ares_dns_record_query_get(qrec, i, &qname, &qtype, &qclass) !=\n          ARES_SUCCESS ||\n        qname == NULL) {\n      goto done;\n    }\n\n    if (ares_dns_record_query_get(arec, i, &aname, &atype, &aclass) !=\n          ARES_SUCCESS ||\n        aname == NULL) {\n      goto done;\n    }\n\n    if (qtype != atype || qclass != aclass) {\n      goto done;\n    }\n\n    if (channel->flags & ARES_FLAG_DNS0x20 && !query->using_tcp) {\n      /* NOTE: for DNS 0x20, part of the protection is to use a case-sensitive\n       *       comparison of the DNS query name.  This expects the upstream DNS\n       *       server to preserve the case of the name in the response packet.\n       *       https://datatracker.ietf.org/doc/html/draft-vixie-dnsext-dns0x20-00\n       */\n      if (!ares_streq(qname, aname)) {\n        goto done;\n      }\n    } else {\n      /* without DNS0x20 use case-insensitive matching */\n      if (!ares_strcaseeq(qname, aname)) {\n        goto done;\n      }\n    }\n  }\n\n  rv = ARES_TRUE;\n\ndone:\n  return rv;\n}",
          "fn_code_pos": [
            [
              1396,
              0
            ],
            [
              1454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "same_questions",
            "parameters": {
              "query": "ares_query_t",
              "arec": "ares_dns_record_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_detach_query(ares_query_t *query)\n{\n  /* Remove the query from all the lists in which it is linked */\n  ares_query_remove_from_conn(query);\n  ares_htable_szvp_remove(query->channel->queries_by_qid, query->qid);\n  ares_llist_node_destroy(query->node_all_queries);\n  query->node_all_queries = NULL;\n}",
          "fn_code_pos": [
            [
              1456,
              0
            ],
            [
              1463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_detach_query",
            "parameters": {
              "query": "ares_query_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void end_query(ares_channel_t *channel, ares_server_t *server,\n                      ares_query_t *query, ares_status_t status,\n                      ares_dns_record_t *dnsrec, ares_array_t **requeue)\n{\n  /* If we were probing for the server to come back online, lets mark it as\n   * no longer being probed */\n  if (server != NULL) {\n    server->probe_pending = ARES_FALSE;\n  }\n\n  ares_metrics_record(query, server, status, dnsrec);\n\n  /* Delay calling the query callback */\n  if (requeue != NULL) {\n    ares_append_endqueue(requeue, query, status, dnsrec);\n    return;\n  }\n\n  /* Invoke the callback. */\n  query->callback(query->arg, status, query->timeouts, dnsrec);\n  ares_free_query(query);\n\n  /* Check and notify if no other queries are enqueued on the channel.  This\n   * must come after the callback and freeing the query for 2 reasons.\n   *  1) The callback itself may enqueue a new query\n   *  2) Technically the current query isn't detached until it is free()'d.\n   */\n  ares_queue_notify_empty(channel);\n}",
          "fn_code_pos": [
            [
              1465,
              0
            ],
            [
              1493,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_query",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "query": "ares_query_t",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t",
              "requeue": "ares_array_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_free_query(ares_query_t *query)\n{\n  ares_detach_query(query);\n  /* Zero out some important stuff, to help catch bugs */\n  query->callback = NULL;\n  query->arg      = NULL;\n  /* Deallocate the memory associated with the query */\n  ares_dns_record_destroy(query->query);\n\n  ares_free(query);\n}",
          "fn_code_pos": [
            [
              1495,
              0
            ],
            [
              1505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_query",
            "parameters": {
              "query": "ares_query_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "timeadd(ares_timeval_t *now, size_t millisecs)",
          "fn_dec_pos": [
            [
              47,
              21
            ],
            [
              47,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "timeadd",
            "parameters": {
              "now": "ares_timeval_t",
              "millisecs": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "process_write(ares_channel_t *channel,\n                                   ares_socket_t   write_fd)",
          "fn_dec_pos": [
            [
              48,
              21
            ],
            [
              49,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_write",
            "parameters": {
              "channel": "ares_channel_t",
              "write_fd": "ares_socket_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "process_read(ares_channel_t       *channel,\n                                  ares_socket_t         read_fd,\n                                  const ares_timeval_t *now)",
          "fn_dec_pos": [
            [
              50,
              21
            ],
            [
              52,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_read",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fd": "ares_socket_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "process_timeouts(ares_channel_t       *channel,\n                                      const ares_timeval_t *now)",
          "fn_dec_pos": [
            [
              53,
              21
            ],
            [
              54,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_timeouts",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "process_answer(ares_channel_t      *channel,\n                                    const unsigned char *abuf, size_t alen,\n                                    ares_conn_t          *conn,\n                                    const ares_timeval_t *now,\n                                    ares_array_t        **requeue)",
          "fn_dec_pos": [
            [
              55,
              21
            ],
            [
              59,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_answer",
            "parameters": {
              "channel": "ares_channel_t",
              "abuf": "unsigned char",
              "alen": "size_t",
              "conn": "ares_conn_t",
              "now": "ares_timeval_t",
              "requeue": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "handle_conn_error(ares_conn_t *conn, ares_bool_t critical_failure,\n                              ares_status_t failure_status)",
          "fn_dec_pos": [
            [
              60,
              12
            ],
            [
              61,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "handle_conn_error",
            "parameters": {
              "conn": "ares_conn_t",
              "critical_failure": "ares_bool_t",
              "failure_status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "same_questions(const ares_query_t      *query,\n                                  const ares_dns_record_t *arec)",
          "fn_dec_pos": [
            [
              62,
              19
            ],
            [
              63,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "same_questions",
            "parameters": {
              "query": "ares_query_t",
              "arec": "ares_dns_record_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "end_query(ares_channel_t *channel, ares_server_t *server,\n                             ares_query_t *query, ares_status_t status,\n                             ares_dns_record_t *dnsrec,\n                             ares_array_t **requeue)",
          "fn_dec_pos": [
            [
              64,
              19
            ],
            [
              67,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_query",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "query": "ares_query_t",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t",
              "requeue": "ares_array_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "channel_socket_list(const ares_channel_t *channel,\n                                          size_t               *num)",
          "fn_dec_pos": [
            [
              291,
              22
            ],
            [
              292,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "channel_socket_list",
            "parameters": {
              "channel": "ares_channel_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_random_server(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              1034,
              22
            ],
            [
              1034,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_random_server",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_fetch_connection(const ares_channel_t *channel,\n                                          ares_server_t        *server,\n                                          const ares_query_t   *query)",
          "fn_dec_pos": [
            [
              1184,
              20
            ],
            [
              1186,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_fetch_connection",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "query": "ares_query_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  requeue_type_t     type;   /* type of entry, requeue or endquery */\n  unsigned short     qid;    /* query id */\n  ares_server_t     *server; /* requeue only: optional */\n  ares_status_t      status; /* endquery only */\n  ares_dns_record_t *dnsrec; /* endquery only: optional */\n} ares_requeue_t;",
          {
            "type": "requeue_type_t",
            "qid": "unsigned short",
            "*server": "ares_server_t",
            "status": "ares_status_t",
            "*dnsrec": "ares_dns_record_t"
          },
          "ares_requeue_t",
          [
            524,
            0
          ],
          [
            530,
            17
          ]
        ],
        [
          "typedef struct {\n  requeue_type_t     type;   /* type of entry, requeue or endquery */\n  unsigned short     qid;    /* query id */\n  ares_server_t     *server; /* requeue only: optional */\n  ares_status_t      status; /* endquery only */\n  ares_dns_record_t *dnsrec; /* endquery only: optional */\n} ares_requeue_t;",
          {
            "type": "requeue_type_t",
            "qid": "unsigned short",
            "*server": "ares_server_t",
            "status": "ares_status_t",
            "*dnsrec": "ares_dns_record_t"
          },
          "ares_requeue_t",
          [
            524,
            0
          ],
          [
            530,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <sys/filio.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  REQUEUE_REQUEUE  = 1,\n  REQUEUE_ENDQUERY = 2\n} requeue_type_t;",
          {
            "REQUEUE_REQUEUE": "",
            "REQUEUE_ENDQUERY": ""
          },
          "requeue_type_t",
          [
            517,
            0
          ],
          [
            520,
            17
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_gethostbyname.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_gethostbyname_callback(void *arg, int status, int timeouts,\n                                        struct ares_addrinfo *result)\n{\n  struct hostent    *hostent  = NULL;\n  struct host_query *ghbn_arg = arg;\n\n  if (status == ARES_SUCCESS) {\n    status = (int)ares_addrinfo2hostent(result, AF_UNSPEC, &hostent);\n  }\n\n  /* addrinfo2hostent will only return ENODATA if there are no addresses _and_\n   * no cname/aliases.  However, gethostbyname will return ENODATA even if there\n   * is cname/alias data */\n  if (status == ARES_SUCCESS && hostent &&\n      (!hostent->h_addr_list || !hostent->h_addr_list[0])) {\n    status = ARES_ENODATA;\n  }\n\n  if (status == ARES_SUCCESS && ghbn_arg->channel->nsort && hostent) {\n    if (hostent->h_addrtype == AF_INET6) {\n      sort6_addresses(hostent, ghbn_arg->channel->sortlist,\n                      ghbn_arg->channel->nsort);\n    }\n    if (hostent->h_addrtype == AF_INET) {\n      sort_addresses(hostent, ghbn_arg->channel->sortlist,\n                     ghbn_arg->channel->nsort);\n    }\n  }\n\n  ghbn_arg->callback(ghbn_arg->arg, status, timeouts, hostent);\n\n  ares_freeaddrinfo(result);\n  ares_free(ghbn_arg);\n  ares_free_hostent(hostent);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "result": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_gethostbyname(ares_channel_t *channel, const char *name, int family,\n                        ares_host_callback callback, void *arg)\n{\n  struct ares_addrinfo_hints hints;\n  struct host_query         *ghbn_arg;\n\n  if (!callback) {\n    return;\n  }\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_flags  = ARES_AI_CANONNAME;\n  hints.ai_family = family;\n\n  ghbn_arg = ares_malloc(sizeof(*ghbn_arg));\n  if (!ghbn_arg) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n\n  ghbn_arg->callback = callback;\n  ghbn_arg->arg      = arg;\n  ghbn_arg->channel  = channel;\n\n  /* NOTE: ares_getaddrinfo() locks the channel, we don't use the channel\n   *       outside so no need to lock */\n  ares_getaddrinfo(channel, name, NULL, &hints, ares_gethostbyname_callback,\n                   ghbn_arg);\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void sort_addresses(const struct hostent  *host,\n                           const struct apattern *sortlist, size_t nsort)\n{\n  struct in_addr a1;\n  struct in_addr a2;\n  int            i1;\n  int            i2;\n  size_t         ind1;\n  size_t         ind2;\n\n  /* This is a simple insertion sort, not optimized at all.  i1 walks\n   * through the address list, with the loop invariant that everything\n   * to the left of i1 is sorted.  In the loop body, the value at i1 is moved\n   * back through the list (via i2) until it is in sorted order.\n   *\n   * The IPs are sorted in ascending order of corresponding sortlist\n   * indices, with those that don't match the subnets in the sortlist\n   * coming last.  There is no particular order amongst IPs that tie\n   * in this sorting scheme.\n   */\n  for (i1 = 0; host->h_addr_list[i1]; i1++) {\n    memcpy(&a1, host->h_addr_list[i1], sizeof(struct in_addr));\n    ind1 = get_address_index(&a1, sortlist, nsort);\n    for (i2 = i1 - 1; i2 >= 0; i2--) {\n      memcpy(&a2, host->h_addr_list[i2], sizeof(struct in_addr));\n      ind2 = get_address_index(&a2, sortlist, nsort);\n      if (ind2 <= ind1) {\n        break;\n      }\n      memcpy(host->h_addr_list[i2 + 1], &a2, sizeof(struct in_addr));\n    }\n    memcpy(host->h_addr_list[i2 + 1], &a1, sizeof(struct in_addr));\n  }\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort_addresses",
            "parameters": {
              "host": "struct hostent",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t get_address_index(const struct in_addr  *addr,\n                                const struct apattern *sortlist, size_t nsort)\n{\n  size_t           i;\n  struct ares_addr aaddr;\n\n  memset(&aaddr, 0, sizeof(aaddr));\n  aaddr.family = AF_INET;\n  memcpy(&aaddr.addr.addr4, addr, 4);\n\n  for (i = 0; i < nsort; i++) {\n    if (sortlist[i].addr.family != AF_INET) {\n      continue;\n    }\n\n    if (ares_subnet_match(&aaddr, &sortlist[i].addr, sortlist[i].mask)) {\n      break;\n    }\n  }\n\n  return i;\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              187,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_address_index",
            "parameters": {
              "addr": "struct in_addr",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static void sort6_addresses(const struct hostent  *host,\n                            const struct apattern *sortlist, size_t nsort)\n{\n  struct ares_in6_addr a1;\n  struct ares_in6_addr a2;\n  int                  i1;\n  int                  i2;\n  size_t               ind1;\n  size_t               ind2;\n\n  /* This is a simple insertion sort, not optimized at all.  i1 walks\n   * through the address list, with the loop invariant that everything\n   * to the left of i1 is sorted.  In the loop body, the value at i1 is moved\n   * back through the list (via i2) until it is in sorted order.\n   *\n   * The IPv6s are sorted in ascending order of corresponding sortlist\n   * indices, with those that don't match the subnets in the sortlist\n   * coming last.  There is no particular order amongst IPs that tie\n   * in this sorting scheme.\n   */\n  for (i1 = 0; host->h_addr_list[i1]; i1++) {\n    memcpy(&a1, host->h_addr_list[i1], sizeof(struct ares_in6_addr));\n    ind1 = get6_address_index(&a1, sortlist, nsort);\n    for (i2 = i1 - 1; i2 >= 0; i2--) {\n      memcpy(&a2, host->h_addr_list[i2], sizeof(struct ares_in6_addr));\n      ind2 = get6_address_index(&a2, sortlist, nsort);\n      if (ind2 <= ind1) {\n        break;\n      }\n      memcpy(host->h_addr_list[i2 + 1], &a2, sizeof(struct ares_in6_addr));\n    }\n    memcpy(host->h_addr_list[i2 + 1], &a1, sizeof(struct ares_in6_addr));\n  }\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort6_addresses",
            "parameters": {
              "host": "struct hostent",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t get6_address_index(const struct ares_in6_addr *addr,\n                                 const struct apattern *sortlist, size_t nsort)\n{\n  size_t           i;\n  struct ares_addr aaddr;\n\n  memset(&aaddr, 0, sizeof(aaddr));\n  aaddr.family = AF_INET6;\n  memcpy(&aaddr.addr.addr6, addr, 16);\n\n  for (i = 0; i < nsort; i++) {\n    if (sortlist[i].addr.family != AF_INET6) {\n      continue;\n    }\n\n    if (ares_subnet_match(&aaddr, &sortlist[i].addr, sortlist[i].mask)) {\n      break;\n    }\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get6_address_index",
            "parameters": {
              "addr": "struct ares_in6_addr",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_hostent_localhost(const char *name, int family,\n                                            struct hostent **host_out)\n{\n  ares_status_t              status;\n  struct ares_addrinfo      *ai = NULL;\n  struct ares_addrinfo_hints hints;\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = family;\n\n  ai = ares_malloc_zero(sizeof(*ai));\n  if (ai == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_addrinfo_localhost(name, 0, &hints, ai);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_addrinfo2hostent(ai, family, host_out);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\ndone:\n  ares_freeaddrinfo(ai);\n  return status;\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hostent_localhost",
            "parameters": {
              "name": "char",
              "family": "int",
              "host_out": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_gethostbyname_file_int(ares_channel_t *channel,\n                                                 const char *name, int family,\n                                                 struct hostent **host)\n{\n  const ares_hosts_entry_t *entry;\n  ares_status_t             status;\n\n  /* We only take the channel to ensure that ares_init() been called. */\n  if (channel == NULL || name == NULL || host == NULL) {\n    /* Anything will do, really.  This seems fine, and is consistent with\n       other error cases. */\n    if (host != NULL) {\n      *host = NULL;\n    }\n    return ARES_ENOTFOUND;\n  }\n\n  *host  = NULL;\n\n  /* Per RFC 7686, reject queries for \".onion\" domain names with NXDOMAIN. */\n  if (ares_is_onion_domain(name)) {\n    return ARES_ENOTFOUND;\n  }\n\n  status = ares_hosts_search_host(channel, ARES_FALSE, name, &entry);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_hosts_entry_to_hostent(entry, family, host);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\ndone:\n  /* RFC6761 section 6.3 #3 states that \"Name resolution APIs and libraries\n   * SHOULD recognize localhost names as special and SHOULD always return the\n   * IP loopback address for address queries\".\n   * We will also ignore ALL errors when trying to resolve localhost, such\n   * as permissions errors reading /etc/hosts or a malformed /etc/hosts.\n   *\n   * Also, just because the query itself returned success from /etc/hosts\n   * lookup doesn't mean it returned everything it needed to for all requested\n   * address families. As long as we're not on a critical out of memory\n   * condition pass it through to fill in any other address classes. */\n  if (status != ARES_ENOMEM && ares_is_localhost(name)) {\n    return ares_hostent_localhost(name, family, host);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname_file_int",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_gethostbyname_file(ares_channel_t *channel, const char *name,\n                            int family, struct hostent **host)\n{\n  ares_status_t status;\n  if (channel == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  ares_channel_lock(channel);\n  status = ares_gethostbyname_file_int(channel, name, family, host);\n  ares_channel_unlock(channel);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname_file",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "sort_addresses(const struct hostent  *host,\n                             const struct apattern *sortlist, size_t nsort)",
          "fn_dec_pos": [
            [
              47,
              14
            ],
            [
              48,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort_addresses",
            "parameters": {
              "host": "struct hostent",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "sort6_addresses(const struct hostent  *host,\n                              const struct apattern *sortlist, size_t nsort)",
          "fn_dec_pos": [
            [
              49,
              14
            ],
            [
              50,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort6_addresses",
            "parameters": {
              "host": "struct hostent",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "get_address_index(const struct in_addr  *addr,\n                                const struct apattern *sortlist, size_t nsort)",
          "fn_dec_pos": [
            [
              51,
              14
            ],
            [
              52,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_address_index",
            "parameters": {
              "addr": "struct in_addr",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "get6_address_index(const struct ares_in6_addr *addr,\n                                 const struct apattern *sortlist, size_t nsort)",
          "fn_dec_pos": [
            [
              53,
              14
            ],
            [
              54,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get6_address_index",
            "parameters": {
              "addr": "struct ares_in6_addr",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct host_query {\n  ares_host_callback callback;\n  void              *arg;\n  ares_channel_t    *channel;\n}",
          {
            "callback": "ares_host_callback",
            "*arg": "void",
            "*channel": "ares_channel_t"
          },
          "host_query",
          [
            56,
            0
          ],
          [
            60,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            47,
            35
          ],
          [
            47,
            49
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            48,
            35
          ],
          [
            48,
            50
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            49,
            36
          ],
          [
            49,
            50
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            50,
            36
          ],
          [
            50,
            51
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            51,
            38
          ],
          [
            51,
            52
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            52,
            38
          ],
          [
            52,
            53
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            53,
            39
          ],
          [
            53,
            59
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            54,
            39
          ],
          [
            54,
            54
          ]
        ],
        [
          "struct host_query {\n  ares_host_callback callback;\n  void              *arg;\n  ares_channel_t    *channel;\n}",
          {
            "callback": "ares_host_callback",
            "*arg": "void",
            "*channel": "ares_channel_t"
          },
          "host_query",
          [
            56,
            0
          ],
          [
            60,
            1
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            63,
            40
          ],
          [
            63,
            60
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            65,
            2
          ],
          [
            65,
            16
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            66,
            2
          ],
          [
            66,
            19
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            101,
            2
          ],
          [
            101,
            28
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            102,
            2
          ],
          [
            102,
            19
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            128,
            33
          ],
          [
            128,
            47
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            129,
            33
          ],
          [
            129,
            48
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            131,
            2
          ],
          [
            131,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            132,
            2
          ],
          [
            132,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            149,
            46
          ],
          [
            149,
            60
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            152,
            48
          ],
          [
            152,
            62
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            157,
            52
          ],
          [
            157,
            66
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            159,
            50
          ],
          [
            159,
            64
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            166,
            38
          ],
          [
            166,
            52
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            167,
            38
          ],
          [
            167,
            53
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            170,
            2
          ],
          [
            170,
            18
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            189,
            34
          ],
          [
            189,
            48
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            190,
            34
          ],
          [
            190,
            49
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            192,
            2
          ],
          [
            192,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            193,
            2
          ],
          [
            193,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            210,
            46
          ],
          [
            210,
            66
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            213,
            48
          ],
          [
            213,
            68
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            218,
            52
          ],
          [
            218,
            72
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            220,
            50
          ],
          [
            220,
            70
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            227,
            39
          ],
          [
            227,
            59
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            228,
            39
          ],
          [
            228,
            54
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            231,
            2
          ],
          [
            231,
            18
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            250,
            44
          ],
          [
            250,
            58
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            253,
            2
          ],
          [
            253,
            22
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            254,
            2
          ],
          [
            254,
            28
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            284,
            49
          ],
          [
            284,
            63
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            335,
            40
          ],
          [
            335,
            54
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_search.c": {
      "fn_def_list": [
        {
          "fn_code": "static void squery_free(struct search_query *squery)\n{\n  if (squery == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  ares_strsplit_free(squery->names, squery->names_cnt);\n  ares_dns_record_destroy(squery->dnsrec);\n  ares_free(squery);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "squery_free",
            "parameters": {
              "squery": "struct search_query"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void end_squery(struct search_query *squery, ares_status_t status,\n                       const ares_dns_record_t *dnsrec)\n{\n  squery->callback(squery->arg, status, squery->timeouts, dnsrec);\n  squery_free(squery);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_squery",
            "parameters": {
              "squery": "struct search_query",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_search_next(ares_channel_t      *channel,\n                                      struct search_query *squery,\n                                      ares_bool_t         *skip_cleanup)\n{\n  ares_status_t status;\n\n  *skip_cleanup = ARES_FALSE;\n\n  /* Misuse check */\n  if (squery->next_name_idx >= squery->names_cnt) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  status = ares_dns_record_query_set_name(\n    squery->dnsrec, 0, squery->names[squery->next_name_idx++]);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_send_nolock(channel, NULL, 0, squery->dnsrec, search_callback,\n                            squery, NULL);\n\n  if (status != ARES_EFORMERR) {\n    *skip_cleanup = ARES_TRUE;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_next",
            "parameters": {
              "channel": "ares_channel_t",
              "squery": "struct search_query",
              "skip_cleanup": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void search_callback(void *arg, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)\n{\n  struct search_query *squery  = (struct search_query *)arg;\n  ares_channel_t      *channel = squery->channel;\n\n  ares_status_t        mystatus;\n  ares_bool_t          skip_cleanup = ARES_FALSE;\n\n  squery->timeouts += timeouts;\n\n  if (dnsrec) {\n    ares_dns_rcode_t rcode = ares_dns_record_get_rcode(dnsrec);\n    size_t ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n    mystatus       = ares_dns_query_reply_tostatus(rcode, ancount);\n  } else {\n    mystatus = status;\n  }\n\n  switch (mystatus) {\n    case ARES_ENODATA:\n    case ARES_ENOTFOUND:\n      break;\n    case ARES_ESERVFAIL:\n    case ARES_EREFUSED:\n      /* Issue #852, systemd-resolved may return SERVFAIL or REFUSED on a\n       * single label domain name. */\n      if (ares_name_label_cnt(squery->names[squery->next_name_idx - 1]) != 1) {\n        end_squery(squery, mystatus, dnsrec);\n        return;\n      }\n      break;\n    default:\n      end_squery(squery, mystatus, dnsrec);\n      return;\n  }\n\n  /* If we ever get ARES_ENODATA along the way, record that; if the search\n   * should run to the very end and we got at least one ARES_ENODATA,\n   * then callers like ares_gethostbyname() may want to try a T_A search\n   * even if the last domain we queried for T_AAAA resource records\n   * returned ARES_ENOTFOUND.\n   */\n  if (mystatus == ARES_ENODATA) {\n    squery->ever_got_nodata = ARES_TRUE;\n  }\n\n  if (squery->next_name_idx < squery->names_cnt) {\n    mystatus = ares_search_next(channel, squery, &skip_cleanup);\n    if (mystatus != ARES_SUCCESS && !skip_cleanup) {\n      end_squery(squery, mystatus, NULL);\n    }\n    return;\n  }\n\n  /* We have no more domains to search, return an appropriate response. */\n  if (mystatus == ARES_ENOTFOUND && squery->ever_got_nodata) {\n    end_squery(squery, ARES_ENODATA, NULL);\n    return;\n  }\n\n  end_squery(squery, mystatus, NULL);\n}",
          "fn_code_pos": [
            [
              104,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "search_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_search_eligible(const ares_channel_t *channel,\n                                        const char           *name)\n{\n  size_t len = ares_strlen(name);\n\n  /* Name ends in '.', cannot search */\n  if (len && name[len - 1] == '.') {\n    return ARES_FALSE;\n  }\n\n  if (channel->flags & ARES_FLAG_NOSEARCH) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_eligible",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_name_label_cnt(const char *name)\n{\n  const char *p;\n  size_t      ndots = 0;\n\n  if (name == NULL) {\n    return 0;\n  }\n\n  for (p = name; p != NULL && *p != 0; p++) {\n    if (*p == '.') {\n      ndots++;\n    }\n  }\n\n  /* Label count is 1 greater than ndots */\n  return ndots + 1;\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_name_label_cnt",
            "parameters": {
              "name": "char"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_search_name_list(const ares_channel_t *channel,\n                                    const char *name, char ***names,\n                                    size_t *names_len)\n{\n  ares_status_t status;\n  char        **list     = NULL;\n  size_t        list_len = 0;\n  char         *alias    = NULL;\n  size_t        ndots    = 0;\n  size_t        idx      = 0;\n  size_t        i;\n\n  /* Perform HOSTALIASES resolution */\n  status = ares_lookup_hostaliases(channel, name, &alias);\n  if (status == ARES_SUCCESS) {\n    /* If hostalias succeeds, there is no searching, it is used as-is */\n    list_len = 1;\n    list     = ares_malloc_zero(sizeof(*list) * list_len);\n    if (list == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    list[0] = alias;\n    alias   = NULL;\n    goto done;\n  } else if (status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  /* See if searching is eligible at all, if not, look up as-is only */\n  if (!ares_search_eligible(channel, name)) {\n    list_len = 1;\n    list     = ares_malloc_zero(sizeof(*list) * list_len);\n    if (list == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    list[0] = ares_strdup(name);\n    if (list[0] == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    } else {\n      status = ARES_SUCCESS;\n    }\n    goto done;\n  }\n\n  /* Count the number of dots in name, 1 less than label count */\n  ndots = ares_name_label_cnt(name);\n  if (ndots > 0) {\n    ndots--;\n  }\n\n  /* Allocate an entry for each search domain, plus one for as-is */\n  list_len = channel->ndomains + 1;\n  list     = ares_malloc_zero(sizeof(*list) * list_len);\n  if (list == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Set status here, its possible there are no search domains at all, so\n   * status may be ARES_ENOTFOUND from ares_lookup_hostaliases(). */\n  status = ARES_SUCCESS;\n\n  /* Try as-is first */\n  if (ndots >= channel->ndots) {\n    list[idx] = ares_strdup(name);\n    if (list[idx] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    idx++;\n  }\n\n  /* Append each search suffix to the name */\n  for (i = 0; i < channel->ndomains; i++) {\n    status = ares_cat_domain(name, channel->domains[i], &list[idx]);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n    idx++;\n  }\n\n  /* Try as-is last */\n  if (ndots < channel->ndots) {\n    list[idx] = ares_strdup(name);\n    if (list[idx] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    idx++;\n  }\n\n\ndone:\n  if (status == ARES_SUCCESS) {\n    *names     = list;\n    *names_len = list_len;\n  } else {\n    ares_strsplit_free(list, list_len);\n  }\n\n  ares_free(alias);\n  return status;\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_name_list",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "names": "char",
              "names_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_search_int(ares_channel_t          *channel,\n                                     const ares_dns_record_t *dnsrec,\n                                     ares_callback_dnsrec callback, void *arg)\n{\n  struct search_query *squery = NULL;\n  const char          *name;\n  ares_status_t        status       = ARES_SUCCESS;\n  ares_bool_t          skip_cleanup = ARES_FALSE;\n\n  /* Extract the name for the search. Note that searches are only supported for\n   * DNS records containing a single query.\n   */\n  if (ares_dns_record_query_cnt(dnsrec) != 1) {\n    status = ARES_EBADQUERY;\n    goto fail;\n  }\n\n  status = ares_dns_record_query_get(dnsrec, 0, &name, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* Per RFC 7686, reject queries for \".onion\" domain names with NXDOMAIN. */\n  if (ares_is_onion_domain(name)) {\n    status = ARES_ENOTFOUND;\n    goto fail;\n  }\n\n  /* Allocate a search_query structure to hold the state necessary for\n   * doing multiple lookups.\n   */\n  squery = ares_malloc_zero(sizeof(*squery));\n  if (squery == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  squery->channel = channel;\n\n  /* Duplicate DNS record since, name will need to be rewritten */\n  squery->dnsrec = ares_dns_record_duplicate(dnsrec);\n  if (squery->dnsrec == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  squery->callback        = callback;\n  squery->arg             = arg;\n  squery->timeouts        = 0;\n  squery->ever_got_nodata = ARES_FALSE;\n\n  status =\n    ares_search_name_list(channel, name, &squery->names, &squery->names_cnt);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares_search_next(channel, squery, &skip_cleanup);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  return status;\n\nfail:\n  if (!skip_cleanup) {\n    squery_free(squery);\n    callback(arg, status, 0, NULL);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_int",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void *ares_dnsrec_convert_arg(ares_callback callback, void *arg)\n{\n  dnsrec_convert_arg_t *carg = ares_malloc_zero(sizeof(*carg));\n  if (carg == NULL) {\n    return NULL;\n  }\n  carg->callback = callback;\n  carg->arg      = arg;\n  return carg;\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dnsrec_convert_arg",
            "parameters": {
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_dnsrec_convert_cb(void *arg, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)\n{\n  dnsrec_convert_arg_t *carg = arg;\n  unsigned char        *abuf = NULL;\n  size_t                alen = 0;\n\n  if (dnsrec != NULL) {\n    ares_status_t mystatus = ares_dns_write(dnsrec, &abuf, &alen);\n    if (mystatus != ARES_SUCCESS) {\n      status = mystatus;\n    }\n  }\n\n  carg->callback(carg->arg, (int)status, (int)timeouts, abuf, (int)alen);\n\n  ares_free(abuf);\n  ares_free(carg);\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dnsrec_convert_cb",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_search(ares_channel_t *channel, const char *name, int dnsclass,\n                 int type, ares_callback callback, void *arg)\n{\n  ares_status_t      status;\n  ares_dns_record_t *dnsrec = NULL;\n  size_t             max_udp_size;\n  ares_dns_flags_t   rd_flag;\n  void              *carg = NULL;\n  if (channel == NULL || name == NULL) {\n    return;\n  }\n\n  /* For now, ares_search_int() uses the ares_callback prototype. We need to\n   * wrap the callback passed to this function in ares_dnsrec_convert_cb, to\n   * convert from ares_callback_dnsrec to ares_callback. Allocate the convert\n   * arg structure here.\n   */\n  carg = ares_dnsrec_convert_arg(callback, arg);\n  if (carg == NULL) {\n    callback(arg, ARES_ENOMEM, 0, NULL, 0);\n    return;\n  }\n\n  rd_flag      = !(channel->flags & ARES_FLAG_NORECURSE) ? ARES_FLAG_RD : 0;\n  max_udp_size = (channel->flags & ARES_FLAG_EDNS) ? channel->ednspsz : 0;\n  status       = ares_dns_record_create_query(\n    &dnsrec, name, (ares_dns_class_t)dnsclass, (ares_dns_rec_type_t)type, 0,\n    rd_flag, max_udp_size);\n  if (status != ARES_SUCCESS) {\n    callback(arg, (int)status, 0, NULL, 0);\n    ares_free(carg);\n    return;\n  }\n\n  ares_channel_lock(channel);\n  ares_search_int(channel, dnsrec, ares_dnsrec_convert_cb, carg);\n  ares_channel_unlock(channel);\n\n  ares_dns_record_destroy(dnsrec);\n}",
          "fn_code_pos": [
            [
              430,
              0
            ],
            [
              469,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_search_dnsrec(ares_channel_t          *channel,\n                                 const ares_dns_record_t *dnsrec,\n                                 ares_callback_dnsrec callback, void *arg)\n{\n  ares_status_t status;\n\n  if (channel == NULL || dnsrec == NULL || callback == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_channel_lock(channel);\n  status = ares_search_int(channel, dnsrec, callback, arg);\n  ares_channel_unlock(channel);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              472,
              0
            ],
            [
              487,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_cat_domain(const char *name, const char *domain, char **s)\n{\n  size_t nlen = ares_strlen(name);\n  size_t dlen = ares_strlen(domain);\n\n  *s = ares_malloc(nlen + 1 + dlen + 1);\n  if (!*s) {\n    return ARES_ENOMEM;\n  }\n  memcpy(*s, name, nlen);\n  (*s)[nlen] = '.';\n  if (ares_streq(domain, \".\")) {\n    /* Avoid appending the root domain to the separator, which would set *s to\n       an ill-formed value (ending in two consecutive dots). */\n    dlen = 0;\n  }\n  memcpy(*s + nlen + 1, domain, dlen);\n  (*s)[nlen + 1 + dlen] = 0;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              490,
              0
            ],
            [
              509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cat_domain",
            "parameters": {
              "name": "char",
              "domain": "char",
              "s": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_lookup_hostaliases(const ares_channel_t *channel,\n                                      const char *name, char **alias)\n{\n  ares_status_t status      = ARES_SUCCESS;\n  const char   *hostaliases = NULL;\n  ares_buf_t   *buf         = NULL;\n  ares_array_t *lines       = NULL;\n  size_t        num;\n  size_t        i;\n\n  if (channel == NULL || name == NULL || alias == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *alias = NULL;\n\n  /* Configuration says to not perform alias lookup */\n  if (channel->flags & ARES_FLAG_NOALIASES) {\n    return ARES_ENOTFOUND;\n  }\n\n  /* If a domain has a '.', its not allowed to perform an alias lookup */\n  if (strchr(name, '.') != NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  hostaliases = getenv(\"HOSTALIASES\");\n  if (hostaliases == NULL) {\n    status = ARES_ENOTFOUND;\n    goto done;\n  }\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_buf_load_file(hostaliases, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* The HOSTALIASES file is structured as one alias per line.  The first\n   * field in the line is the simple hostname with no periods, followed by\n   * whitespace, then the full domain name, e.g.:\n   *\n   * c-ares  www.c-ares.org\n   * curl    www.curl.se\n   */\n\n  status = ares_buf_split(buf, (const unsigned char *)\"\\n\", 1,\n                          ARES_BUF_SPLIT_TRIM, 0, &lines);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  num = ares_array_len(lines);\n  for (i = 0; i < num; i++) {\n    ares_buf_t **bufptr       = ares_array_at(lines, i);\n    ares_buf_t  *line         = *bufptr;\n    char         hostname[64] = \"\";\n    char         fqdn[256]    = \"\";\n\n    /* Pull off hostname */\n    ares_buf_tag(line);\n    ares_buf_consume_nonwhitespace(line);\n    if (ares_buf_tag_fetch_string(line, hostname, sizeof(hostname)) !=\n        ARES_SUCCESS) {\n      continue;\n    }\n\n    /* Match hostname */\n    if (!ares_strcaseeq(hostname, name)) {\n      continue;\n    }\n\n    /* consume whitespace */\n    ares_buf_consume_whitespace(line, ARES_TRUE);\n\n    /* pull off fqdn */\n    ares_buf_tag(line);\n    ares_buf_consume_nonwhitespace(line);\n    if (ares_buf_tag_fetch_string(line, fqdn, sizeof(fqdn)) != ARES_SUCCESS ||\n        ares_strlen(fqdn) == 0) {\n      continue;\n    }\n\n    /* Validate characterset */\n    if (!ares_is_hostname(fqdn)) {\n      continue;\n    }\n\n    *alias = ares_strdup(fqdn);\n    if (*alias == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Good! */\n    status = ARES_SUCCESS;\n    goto done;\n  }\n\n  status = ARES_ENOTFOUND;\n\ndone:\n  ares_buf_destroy(buf);\n  ares_array_destroy(lines);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              622,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_lookup_hostaliases",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "alias": "char"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "search_callback(void *arg, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              72,
              12
            ],
            [
              73,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "search_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_dnsrec_convert_arg(ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              392,
              6
            ],
            [
              392,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dnsrec_convert_arg",
            "parameters": {
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct search_query {\n  /* Arguments passed to ares_search_dnsrec() */\n  ares_channel_t      *channel;\n  ares_callback_dnsrec callback;\n  void                *arg;\n\n  /* Duplicate of DNS record passed to ares_search_dnsrec() */\n  ares_dns_record_t   *dnsrec;\n\n  /* Search order for names */\n  char               **names;\n  size_t               names_cnt;\n\n  /* State tracking progress through the search query */\n  size_t               next_name_idx; /* next name index being attempted */\n  size_t      timeouts;        /* number of timeouts we saw for this request */\n  ares_bool_t ever_got_nodata; /* did we ever get ARES_ENODATA along the way? */\n}",
          {
            "*channel": "ares_channel_t",
            "callback": "ares_callback_dnsrec",
            "*arg": "void",
            "*dnsrec": "ares_dns_record_t",
            "**names": "char",
            "names_cnt": "size_t",
            "next_name_idx": "size_t",
            "timeouts": "size_t",
            "ever_got_nodata": "ares_bool_t"
          },
          "search_query",
          [
            33,
            0
          ],
          [
            50,
            1
          ]
        ],
        [
          "typedef struct {\n  ares_callback callback;\n  void         *arg;\n} dnsrec_convert_arg_t;",
          {
            "callback": "ares_callback",
            "*arg": "void"
          },
          "dnsrec_convert_arg_t",
          [
            385,
            0
          ],
          [
            388,
            23
          ]
        ],
        [
          "struct search_query {\n  /* Arguments passed to ares_search_dnsrec() */\n  ares_channel_t      *channel;\n  ares_callback_dnsrec callback;\n  void                *arg;\n\n  /* Duplicate of DNS record passed to ares_search_dnsrec() */\n  ares_dns_record_t   *dnsrec;\n\n  /* Search order for names */\n  char               **names;\n  size_t               names_cnt;\n\n  /* State tracking progress through the search query */\n  size_t               next_name_idx; /* next name index being attempted */\n  size_t      timeouts;        /* number of timeouts we saw for this request */\n  ares_bool_t ever_got_nodata; /* did we ever get ARES_ENODATA along the way? */\n}",
          {
            "*channel": "ares_channel_t",
            "callback": "ares_callback_dnsrec",
            "*arg": "void",
            "*dnsrec": "ares_dns_record_t",
            "**names": "char",
            "names_cnt": "size_t",
            "next_name_idx": "size_t",
            "timeouts": "size_t",
            "ever_got_nodata": "ares_bool_t"
          },
          "search_query",
          [
            33,
            0
          ],
          [
            50,
            1
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            52,
            24
          ],
          [
            52,
            43
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            65,
            23
          ],
          [
            65,
            42
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            76,
            38
          ],
          [
            76,
            57
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            107,
            2
          ],
          [
            107,
            21
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            107,
            34
          ],
          [
            107,
            53
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            316,
            2
          ],
          [
            316,
            21
          ]
        ],
        [
          "typedef struct {\n  ares_callback callback;\n  void         *arg;\n} dnsrec_convert_arg_t;",
          {
            "callback": "ares_callback",
            "*arg": "void"
          },
          "dnsrec_convert_arg_t",
          [
            385,
            0
          ],
          [
            388,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/record/ares_dns_write.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_status_t ares_dns_write_header(const ares_dns_record_t *dnsrec,\n                                           ares_buf_t              *buf)\n{\n  unsigned short u16;\n  unsigned short opcode;\n  unsigned short rcode;\n\n  ares_status_t  status;\n\n  /* ID */\n  status = ares_buf_append_be16(buf, dnsrec->id);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* Flags */\n  u16 = 0;\n\n  /* QR */\n  if (dnsrec->flags & ARES_FLAG_QR) {\n    u16 |= 0x8000;\n  }\n\n  /* OPCODE */\n  opcode   = (unsigned short)(dnsrec->opcode & 0xF);\n  opcode <<= 11;\n  u16     |= opcode;\n\n  /* AA */\n  if (dnsrec->flags & ARES_FLAG_AA) {\n    u16 |= 0x400;\n  }\n\n  /* TC */\n  if (dnsrec->flags & ARES_FLAG_TC) {\n    u16 |= 0x200;\n  }\n\n  /* RD */\n  if (dnsrec->flags & ARES_FLAG_RD) {\n    u16 |= 0x100;\n  }\n\n  /* RA */\n  if (dnsrec->flags & ARES_FLAG_RA) {\n    u16 |= 0x80;\n  }\n\n  /* Z -- unused */\n\n  /* AD */\n  if (dnsrec->flags & ARES_FLAG_AD) {\n    u16 |= 0x20;\n  }\n\n  /* CD */\n  if (dnsrec->flags & ARES_FLAG_CD) {\n    u16 |= 0x10;\n  }\n\n  /* RCODE */\n  if (dnsrec->rcode > 15 && ares_dns_get_opt_rr_const(dnsrec) == NULL) {\n    /* Must have OPT RR in order to write extended error codes */\n    rcode = ARES_RCODE_SERVFAIL;\n  } else {\n    rcode = (unsigned short)(dnsrec->rcode & 0xF);\n  }\n  u16 |= rcode;\n\n  status = ares_buf_append_be16(buf, u16);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* QDCOUNT */\n  status = ares_buf_append_be16(\n    buf, (unsigned short)ares_dns_record_query_cnt(dnsrec));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* ANCOUNT */\n  status = ares_buf_append_be16(\n    buf, (unsigned short)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* NSCOUNT */\n  status = ares_buf_append_be16(buf, (unsigned short)ares_dns_record_rr_cnt(\n                                       dnsrec, ARES_SECTION_AUTHORITY));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* ARCOUNT */\n  status = ares_buf_append_be16(buf, (unsigned short)ares_dns_record_rr_cnt(\n                                       dnsrec, ARES_SECTION_ADDITIONAL));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_header",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_questions(const ares_dns_record_t *dnsrec,\n                                              ares_llist_t           **namelist,\n                                              ares_buf_t              *buf)\n{\n  size_t i;\n\n  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    ares_status_t       status;\n    const char         *name = NULL;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n\n    status = ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Name */\n    status = ares_dns_name_write(buf, namelist, ARES_TRUE, name);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Type */\n    status = ares_buf_append_be16(buf, (unsigned short)qtype);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Class */\n    status = ares_buf_append_be16(buf, (unsigned short)qclass);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_questions",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "namelist": "ares_llist_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_name(ares_buf_t          *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_llist_t       **namelist,\n                                            ares_bool_t       validate_hostname,\n                                            ares_dns_rr_key_t key)\n{\n  const char *name;\n\n  name = ares_dns_rr_get_str(rr, key);\n  if (name == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  return ares_dns_name_write(buf, namelist, validate_hostname, name);\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_name",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t",
              "validate_hostname": "ares_bool_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_str(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_dns_rr_key_t    key)\n{\n  const char   *str;\n  size_t        len;\n  ares_status_t status;\n\n  str = ares_dns_rr_get_str(rr, key);\n  if (str == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  len = ares_strlen(str);\n  if (len > 255) {\n    return ARES_EFORMERR;\n  }\n\n  /* Write 1 byte length */\n  status = ares_buf_append_byte(buf, (unsigned char)(len & 0xFF));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (len == 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* Write string */\n  return ares_buf_append(buf, (const unsigned char *)str, len);\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_str",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_binstr(ares_buf_t          *buf,\n                                           const unsigned char *bin,\n                                           size_t               bin_len)\n{\n  const unsigned char *ptr;\n  size_t               ptr_len;\n  ares_status_t        status;\n\n  /* split into possible multiple 255-byte or less length strings */\n  ptr     = bin;\n  ptr_len = bin_len;\n  do {\n    size_t len = ptr_len;\n    if (len > 255) {\n      len = 255;\n    }\n\n    /* Length */\n    status = ares_buf_append_byte(buf, (unsigned char)(len & 0xFF));\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* String */\n    if (len) {\n      status = ares_buf_append(buf, ptr, len);\n      if (status != ARES_SUCCESS) {\n        return status; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n\n    ptr     += len;\n    ptr_len -= len;\n  } while (ptr_len > 0);\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              224,
              0
            ],
            [
              260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_binstr",
            "parameters": {
              "buf": "ares_buf_t",
              "bin": "unsigned char",
              "bin_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_abin(ares_buf_t          *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_dns_rr_key_t    key)\n{\n  ares_status_t status = ARES_EFORMERR;\n  size_t        i;\n  size_t        cnt = ares_dns_rr_get_abin_cnt(rr, key);\n\n  if (cnt == 0) {\n    return ARES_EFORMERR;\n  }\n\n  for (i = 0; i < cnt; i++) {\n    const unsigned char *bin;\n    size_t               bin_len;\n\n    bin = ares_dns_rr_get_abin(rr, key, i, &bin_len);\n\n    status = ares_dns_write_binstr(buf, bin, bin_len);\n    if (status != ARES_SUCCESS) {\n      break;\n    }\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_abin",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_be32(ares_buf_t          *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_dns_rr_key_t    key)\n{\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  return ares_buf_append_be32(buf, ares_dns_rr_get_u32(rr, key));\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_be32",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_be16(ares_buf_t          *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_dns_rr_key_t    key)\n{\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  return ares_buf_append_be16(buf, ares_dns_rr_get_u16(rr, key));\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_be16",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_u8(ares_buf_t          *buf,\n                                          const ares_dns_rr_t *rr,\n                                          ares_dns_rr_key_t    key)\n{\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  return ares_buf_append_byte(buf, ares_dns_rr_get_u8(rr, key));\n}",
          "fn_code_pos": [
            [
              309,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_u8",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_a(ares_buf_t          *buf,\n                                         const ares_dns_rr_t *rr,\n                                         ares_llist_t       **namelist)\n{\n  const struct in_addr *addr;\n  (void)namelist;\n\n  addr = ares_dns_rr_get_addr(rr, ARES_RR_A_ADDR);\n  if (addr == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  return ares_buf_append(buf, (const unsigned char *)addr, sizeof(*addr));\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_a",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_ns(ares_buf_t          *buf,\n                                          const ares_dns_rr_t *rr,\n                                          ares_llist_t       **namelist)\n{\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_NS_NSDNAME);\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_ns",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_cname(ares_buf_t          *buf,\n                                             const ares_dns_rr_t *rr,\n                                             ares_llist_t       **namelist)\n{\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_CNAME_CNAME);\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_cname",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_soa(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_llist_t       **namelist)\n{\n  ares_status_t status;\n\n  /* MNAME */\n  status =\n    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SOA_MNAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* RNAME */\n  status =\n    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SOA_RNAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SERIAL */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_SERIAL);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* REFRESH */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_REFRESH);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* RETRY */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_RETRY);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* EXPIRE */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_EXPIRE);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* MINIMUM */\n  return ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_MINIMUM);\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_soa",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_ptr(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_llist_t       **namelist)\n{\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_PTR_DNAME);\n}",
          "fn_code_pos": [
            [
              398,
              0
            ],
            [
              404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_ptr",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_hinfo(ares_buf_t          *buf,\n                                             const ares_dns_rr_t *rr,\n                                             ares_llist_t       **namelist)\n{\n  ares_status_t status;\n\n  (void)namelist;\n\n  /* CPU */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_HINFO_CPU);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* OS */\n  return ares_dns_write_rr_str(buf, rr, ARES_RR_HINFO_OS);\n}",
          "fn_code_pos": [
            [
              406,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_hinfo",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_mx(ares_buf_t          *buf,\n                                          const ares_dns_rr_t *rr,\n                                          ares_llist_t       **namelist)\n{\n  ares_status_t status;\n\n  /* PREFERENCE */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_MX_PREFERENCE);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* EXCHANGE */\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_MX_EXCHANGE);\n}",
          "fn_code_pos": [
            [
              424,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_mx",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_txt(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_llist_t       **namelist)\n{\n  (void)namelist;\n  return ares_dns_write_rr_abin(buf, rr, ARES_RR_TXT_DATA);\n}",
          "fn_code_pos": [
            [
              441,
              0
            ],
            [
              447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_txt",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_sig(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_llist_t       **namelist)\n{\n  ares_status_t        status;\n  const unsigned char *data;\n  size_t               len = 0;\n\n  (void)namelist;\n\n  /* TYPE COVERED */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SIG_TYPE_COVERED);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* ALGORITHM */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_SIG_ALGORITHM);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* LABELS */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_SIG_LABELS);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* ORIGINAL TTL */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SIG_ORIGINAL_TTL);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* EXPIRATION */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SIG_EXPIRATION);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* INCEPTION */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SIG_INCEPTION);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* KEY TAG */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SIG_KEY_TAG);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* SIGNERS NAME */\n  status = ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                  ARES_RR_SIG_SIGNERS_NAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SIGNATURE -- binary, rest of buffer, required to be non-zero length */\n  data = ares_dns_rr_get_bin(rr, ARES_RR_SIG_SIGNATURE, &len);\n  if (data == NULL || len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  return ares_buf_append(buf, data, len);\n}",
          "fn_code_pos": [
            [
              449,
              0
            ],
            [
              515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_sig",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_aaaa(ares_buf_t          *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_llist_t       **namelist)\n{\n  const struct ares_in6_addr *addr;\n  (void)namelist;\n\n  addr = ares_dns_rr_get_addr6(rr, ARES_RR_AAAA_ADDR);\n  if (addr == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  return ares_buf_append(buf, (const unsigned char *)addr, sizeof(*addr));\n}",
          "fn_code_pos": [
            [
              517,
              0
            ],
            [
              530,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_aaaa",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_srv(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_llist_t       **namelist)\n{\n  ares_status_t status;\n\n  /* PRIORITY */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* WEIGHT */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_WEIGHT);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* PORT */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_PORT);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* TARGET */\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_SRV_TARGET);\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_srv",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_naptr(ares_buf_t          *buf,\n                                             const ares_dns_rr_t *rr,\n                                             ares_llist_t       **namelist)\n{\n  ares_status_t status;\n\n  /* ORDER */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_NAPTR_ORDER);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* PREFERENCE */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_NAPTR_PREFERENCE);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* FLAGS */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_FLAGS);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* SERVICES */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_SERVICES);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* REGEXP */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_REGEXP);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* REPLACEMENT */\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_NAPTR_REPLACEMENT);\n}",
          "fn_code_pos": [
            [
              561,
              0
            ],
            [
              600,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_naptr",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_opt(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_llist_t       **namelist)\n{\n  size_t         len = ares_buf_len(buf);\n  ares_status_t  status;\n  unsigned int   ttl = 0;\n  size_t         i;\n  unsigned short rcode = (unsigned short)((rr->parent->rcode >> 4) & 0xFF);\n\n  (void)namelist;\n\n  /* Coverity reports on this even though its not possible when taken\n   * into context */\n  if (len == 0) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* We need to go back and overwrite the class and ttl that were emitted as\n   * the OPT record overloads them for its own use (yes, very strange!) */\n  status = ares_buf_set_length(buf, len - 2 /* RDLENGTH */\n                                      - 4   /* TTL */\n                                      - 2 /* CLASS */);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Class -> UDP Size */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_OPT_UDP_SIZE);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* TTL -> rcode (u8) << 24 | version (u8) << 16 | flags (u16) */\n  ttl |= (unsigned int)rcode << 24;\n  ttl |= (unsigned int)ares_dns_rr_get_u8(rr, ARES_RR_OPT_VERSION) << 16;\n  ttl |= (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_FLAGS);\n\n  status = ares_buf_append_be32(buf, ttl);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* Now go back to real end */\n  status = ares_buf_set_length(buf, len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Append Options */\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_OPT_OPTIONS); i++) {\n    unsigned short       opt;\n    size_t               val_len;\n    const unsigned char *val;\n\n    opt = ares_dns_rr_get_opt(rr, ARES_RR_OPT_OPTIONS, i, &val, &val_len);\n\n    /* BE16 option */\n    status = ares_buf_append_be16(buf, opt);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* BE16 length */\n    status = ares_buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Value */\n    if (val && val_len) {\n      status = ares_buf_append(buf, val, val_len);\n      if (status != ARES_SUCCESS) {\n        return status; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              602,
              0
            ],
            [
              681,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_opt",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_tlsa(ares_buf_t          *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_llist_t       **namelist)\n{\n  ares_status_t        status;\n  const unsigned char *data;\n  size_t               len = 0;\n\n  (void)namelist;\n\n  /* CERT_USAGE */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_CERT_USAGE);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* SELECTOR */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_SELECTOR);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* MATCH */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_MATCH);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* DATA -- binary, rest of buffer, required to be non-zero length */\n  data = ares_dns_rr_get_bin(rr, ARES_RR_TLSA_DATA, &len);\n  if (data == NULL || len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  return ares_buf_append(buf, data, len);\n}",
          "fn_code_pos": [
            [
              683,
              0
            ],
            [
              718,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_tlsa",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_svcb(ares_buf_t          *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_llist_t       **namelist)\n{\n  ares_status_t status;\n  size_t        i;\n\n  /* PRIORITY */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SVCB_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* TARGET */\n  status =\n    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SVCB_TARGET);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Append Params */\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_SVCB_PARAMS); i++) {\n    unsigned short       opt;\n    size_t               val_len;\n    const unsigned char *val;\n\n    opt = ares_dns_rr_get_opt(rr, ARES_RR_SVCB_PARAMS, i, &val, &val_len);\n\n    /* BE16 option */\n    status = ares_buf_append_be16(buf, opt);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* BE16 length */\n    status = ares_buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Value */\n    if (val && val_len) {\n      status = ares_buf_append(buf, val, val_len);\n      if (status != ARES_SUCCESS) {\n        return status; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              720,
              0
            ],
            [
              769,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_svcb",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_https(ares_buf_t          *buf,\n                                             const ares_dns_rr_t *rr,\n                                             ares_llist_t       **namelist)\n{\n  ares_status_t status;\n  size_t        i;\n\n  /* PRIORITY */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_HTTPS_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* TARGET */\n  status =\n    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_HTTPS_TARGET);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Append Params */\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_HTTPS_PARAMS); i++) {\n    unsigned short       opt;\n    size_t               val_len;\n    const unsigned char *val;\n\n    opt = ares_dns_rr_get_opt(rr, ARES_RR_HTTPS_PARAMS, i, &val, &val_len);\n\n    /* BE16 option */\n    status = ares_buf_append_be16(buf, opt);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* BE16 length */\n    status = ares_buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Value */\n    if (val && val_len) {\n      status = ares_buf_append(buf, val, val_len);\n      if (status != ARES_SUCCESS) {\n        return status; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              771,
              0
            ],
            [
              820,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_https",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_uri(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_llist_t       **namelist)\n{\n  ares_status_t status;\n  const char   *target;\n\n  (void)namelist;\n\n  /* PRIORITY */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_URI_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* WEIGHT */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_URI_WEIGHT);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* TARGET -- not in DNS string format, rest of buffer, required to be\n   * non-zero length */\n  target = ares_dns_rr_get_str(rr, ARES_RR_URI_TARGET);\n  if (target == NULL || ares_strlen(target) == 0) {\n    return ARES_EFORMERR;\n  }\n\n  return ares_buf_append(buf, (const unsigned char *)target,\n                         ares_strlen(target));\n}",
          "fn_code_pos": [
            [
              822,
              0
            ],
            [
              852,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_uri",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_caa(ares_buf_t          *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_llist_t       **namelist)\n{\n  const unsigned char *data     = NULL;\n  size_t               data_len = 0;\n  ares_status_t        status;\n\n  (void)namelist;\n\n  /* CRITICAL */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_CAA_CRITICAL);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* Tag */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_CAA_TAG);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* Value - binary! (remaining buffer */\n  data = ares_dns_rr_get_bin(rr, ARES_RR_CAA_VALUE, &data_len);\n  if (data == NULL || data_len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  return ares_buf_append(buf, data, data_len);\n}",
          "fn_code_pos": [
            [
              854,
              0
            ],
            [
              883,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_caa",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_raw_rr(ares_buf_t          *buf,\n                                              const ares_dns_rr_t *rr,\n                                              ares_llist_t       **namelist)\n{\n  size_t               len = ares_buf_len(buf);\n  ares_status_t        status;\n  const unsigned char *data     = NULL;\n  size_t               data_len = 0;\n\n  (void)namelist;\n\n  /* Coverity reports on this even though its not possible when taken\n   * into context */\n  if (len == 0) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* We need to go back and overwrite the type that was emitted by the parent\n   * function */\n  status = ares_buf_set_length(buf, len - 2 /* RDLENGTH */\n                                      - 4   /* TTL */\n                                      - 2   /* CLASS */\n                                      - 2 /* TYPE */);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_RAW_RR_TYPE);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* Now go back to real end */\n  status = ares_buf_set_length(buf, len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Output raw data */\n  data = ares_dns_rr_get_bin(rr, ARES_RR_RAW_RR_DATA, &data_len);\n  if (data == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (data_len == 0) {\n    return ARES_SUCCESS;\n  }\n\n  return ares_buf_append(buf, data, data_len);\n}",
          "fn_code_pos": [
            [
              885,
              0
            ],
            [
              934,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_raw_rr",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr(const ares_dns_record_t *dnsrec,\n                                       ares_llist_t           **namelist,\n                                       ares_dns_section_t       section,\n                                       ares_buf_t              *buf)\n{\n  size_t i;\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {\n    const ares_dns_rr_t *rr;\n    ares_dns_rec_type_t  type;\n    ares_bool_t          allow_compress;\n    ares_llist_t       **namelistptr = NULL;\n    size_t               pos_len;\n    ares_status_t        status;\n    size_t               rdlength;\n    size_t               end_length;\n    unsigned int         ttl;\n\n    rr = ares_dns_record_rr_get_const(dnsrec, section, i);\n    if (rr == NULL) {\n      return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    type           = ares_dns_rr_get_type(rr);\n    allow_compress = ares_dns_rec_allow_name_comp(type);\n    if (allow_compress) {\n      namelistptr = namelist;\n    }\n\n    /* Name */\n    status =\n      ares_dns_name_write(buf, namelist, ARES_TRUE, ares_dns_rr_get_name(rr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Type */\n    status = ares_buf_append_be16(buf, (unsigned short)type);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Class */\n    status =\n      ares_buf_append_be16(buf, (unsigned short)ares_dns_rr_get_class(rr));\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* TTL */\n    ttl = ares_dns_rr_get_ttl(rr);\n    if (rr->parent->ttl_decrement > ttl) {\n      ttl = 0;\n    } else {\n      ttl -= rr->parent->ttl_decrement;\n    }\n    status = ares_buf_append_be32(buf, ttl);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Length */\n    pos_len = ares_buf_len(buf); /* Save to write real length later */\n    status  = ares_buf_append_be16(buf, 0);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Data */\n    switch (type) {\n      case ARES_REC_TYPE_A:\n        status = ares_dns_write_rr_a(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_NS:\n        status = ares_dns_write_rr_ns(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_CNAME:\n        status = ares_dns_write_rr_cname(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_SOA:\n        status = ares_dns_write_rr_soa(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_PTR:\n        status = ares_dns_write_rr_ptr(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_HINFO:\n        status = ares_dns_write_rr_hinfo(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_MX:\n        status = ares_dns_write_rr_mx(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_TXT:\n        status = ares_dns_write_rr_txt(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_SIG:\n        status = ares_dns_write_rr_sig(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_AAAA:\n        status = ares_dns_write_rr_aaaa(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_SRV:\n        status = ares_dns_write_rr_srv(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_NAPTR:\n        status = ares_dns_write_rr_naptr(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_ANY:\n        status = ARES_EFORMERR;\n        break;\n      case ARES_REC_TYPE_OPT:\n        status = ares_dns_write_rr_opt(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_TLSA:\n        status = ares_dns_write_rr_tlsa(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_SVCB:\n        status = ares_dns_write_rr_svcb(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_HTTPS:\n        status = ares_dns_write_rr_https(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_URI:\n        status = ares_dns_write_rr_uri(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_CAA:\n        status = ares_dns_write_rr_caa(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_RAW_RR:\n        status = ares_dns_write_rr_raw_rr(buf, rr, namelistptr);\n        break;\n    }\n\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Back off write pointer, write real length, then go back to proper\n     * position */\n    end_length = ares_buf_len(buf);\n    rdlength   = end_length - pos_len - 2;\n\n    status = ares_buf_set_length(buf, pos_len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    status = ares_buf_append_be16(buf, (unsigned short)(rdlength & 0xFFFF));\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    status = ares_buf_set_length(buf, end_length);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              936,
              0
            ],
            [
              1094,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "namelist": "ares_llist_t",
              "section": "ares_dns_section_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_write_buf(const ares_dns_record_t *dnsrec,\n                                 ares_buf_t              *buf)\n{\n  ares_llist_t *namelist = NULL;\n  size_t        orig_len;\n  ares_status_t status;\n\n  if (dnsrec == NULL || buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  orig_len = ares_buf_len(buf);\n\n  status = ares_dns_write_header(dnsrec, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write_questions(dnsrec, &namelist, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_ANSWER, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_AUTHORITY, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_ADDITIONAL, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_llist_destroy(namelist);\n  if (status != ARES_SUCCESS) {\n    ares_buf_set_length(buf, orig_len);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1096,
              0
            ],
            [
              1141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_buf",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_write_buf_tcp(const ares_dns_record_t *dnsrec,\n                                     ares_buf_t              *buf)\n{\n  ares_status_t status;\n  size_t        orig_len;\n  size_t        msg_len;\n  size_t        len;\n\n  if (dnsrec == NULL || buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  orig_len = ares_buf_len(buf);\n\n  /* Write placeholder for length */\n  status = ares_buf_append_be16(buf, 0);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* Write message */\n  status = ares_dns_write_buf(dnsrec, buf);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  len     = ares_buf_len(buf);\n  msg_len = len - orig_len - 2;\n  if (msg_len > 65535) {\n    status = ARES_EBADQUERY;\n    goto done;\n  }\n\n  /* Now we need to overwrite the length, so we jump back to the original\n   * message length, overwrite the section and jump back */\n  ares_buf_set_length(buf, orig_len);\n  status = ares_buf_append_be16(buf, (unsigned short)(msg_len & 0xFFFF));\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n  ares_buf_set_length(buf, len);\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_buf_set_length(buf, orig_len);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              1143,
              0
            ],
            [
              1190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_buf_tcp",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_write(const ares_dns_record_t *dnsrec,\n                             unsigned char **buf, size_t *buf_len)\n{\n  ares_buf_t   *b = NULL;\n  ares_status_t status;\n\n  if (buf == NULL || buf_len == NULL || dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *buf     = NULL;\n  *buf_len = 0;\n\n  b = ares_buf_create();\n  if (b == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_dns_write_buf(dnsrec, b);\n\n  if (status != ARES_SUCCESS) {\n    ares_buf_destroy(b);\n    return status;\n  }\n\n  *buf = ares_buf_finish_bin(b, buf_len);\n  return status;\n}",
          "fn_code_pos": [
            [
              1192,
              0
            ],
            [
              1219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "unsigned char",
              "buf_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_dns_record_ttl_decrement(ares_dns_record_t *dnsrec,\n                                   unsigned int       ttl_decrement)\n{\n  if (dnsrec == NULL) {\n    return;\n  }\n  dnsrec->ttl_decrement = ttl_decrement;\n}",
          "fn_code_pos": [
            [
              1221,
              0
            ],
            [
              1228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_ttl_decrement",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "ttl_decrement": "unsigned int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct in_addr",
          {},
          "",
          [
            323,
            8
          ],
          [
            323,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            521,
            8
          ],
          [
            521,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/record/ares_dns_name.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_nameoffset_free(void *arg)\n{\n  ares_nameoffset_t *off = arg;\n  if (off == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  ares_free(off->name);\n  ares_free(off);\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_nameoffset_free",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_nameoffset_create(ares_llist_t **list,\n                                            const char *name, size_t idx)\n{\n  ares_status_t      status;\n  ares_nameoffset_t *off = NULL;\n\n  if (list == NULL || name == NULL || ares_strlen(name) == 0 ||\n      ares_strlen(name) > 255) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (*list == NULL) {\n    *list = ares_llist_create(ares_nameoffset_free);\n  }\n  if (*list == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  off = ares_malloc_zero(sizeof(*off));\n  if (off == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  off->name     = ares_strdup(name);\n  off->name_len = ares_strlen(off->name);\n  off->idx      = idx;\n\n  if (ares_llist_insert_last(*list, off) == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_SUCCESS;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  ares_nameoffset_free(off);\n  return status;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_nameoffset_create",
            "parameters": {
              "list": "ares_llist_t",
              "name": "char",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static const ares_nameoffset_t *ares_nameoffset_find(ares_llist_t *list,\n                                                     const char   *name)\n{\n  size_t                   name_len = ares_strlen(name);\n  ares_llist_node_t       *node;\n  const ares_nameoffset_t *longest_match = NULL;\n\n  if (list == NULL || name == NULL || name_len == 0) {\n    return NULL;\n  }\n\n  for (node = ares_llist_node_first(list); node != NULL;\n       node = ares_llist_node_next(node)) {\n    const ares_nameoffset_t *val = ares_llist_node_val(node);\n    size_t                   prefix_len;\n\n    /* Can't be a match if the stored name is longer */\n    if (val->name_len > name_len) {\n      continue;\n    }\n\n    /* Can't be the longest match if our existing longest match is longer */\n    if (longest_match != NULL && longest_match->name_len > val->name_len) {\n      continue;\n    }\n\n    prefix_len = name_len - val->name_len;\n\n    /* Due to DNS 0x20, lets not inadvertently mangle things, use case-sensitive\n     * matching instead of case-insensitive.  This may result in slightly\n     * larger DNS queries overall. */\n    if (!ares_streq(val->name, name + prefix_len)) {\n      continue;\n    }\n\n    /* We need to make sure if `val->name` is \"example.com\" that name is\n     * is separated by a label, e.g. \"myexample.com\" is not ok, however\n     * \"my.example.com\" is, so we look for the preceding \".\" */\n    if (prefix_len != 0 && name[prefix_len - 1] != '.') {\n      continue;\n    }\n\n    longest_match = val;\n  }\n\n  return longest_match;\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_nameoffset_find",
            "parameters": {
              "list": "ares_llist_t",
              "name": "char"
            },
            "return_type": "ares_nameoffset_t"
          }
        },
        {
          "fn_code": "static void ares_dns_labels_free_cb(void *arg)\n{\n  ares_buf_t **buf = arg;\n  if (buf == NULL) {\n    return;\n  }\n\n  ares_buf_destroy(*buf);\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_free_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_buf_t *ares_dns_labels_add(ares_array_t *labels)\n{\n  ares_buf_t **buf;\n\n  if (labels == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (ares_array_insert_last((void **)&buf, labels) != ARES_SUCCESS) {\n    return NULL;\n  }\n\n  *buf = ares_buf_create();\n  if (*buf == NULL) {\n    ares_array_remove_last(labels);\n    return NULL;\n  }\n\n  return *buf;\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_add",
            "parameters": {
              "labels": "ares_array_t"
            },
            "return_type": "ares_buf_t"
          }
        },
        {
          "fn_code": "static ares_buf_t *ares_dns_labels_get_last(ares_array_t *labels)\n{\n  ares_buf_t **buf = ares_array_last(labels);\n\n  if (buf == NULL) {\n    return NULL;\n  }\n\n  return *buf;\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_get_last",
            "parameters": {
              "labels": "ares_array_t"
            },
            "return_type": "ares_buf_t"
          }
        },
        {
          "fn_code": "static ares_buf_t *ares_dns_labels_get_at(ares_array_t *labels, size_t idx)\n{\n  ares_buf_t **buf = ares_array_at(labels, idx);\n\n  if (buf == NULL) {\n    return NULL;\n  }\n\n  return *buf;\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_get_at",
            "parameters": {
              "labels": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "ares_buf_t"
          }
        },
        {
          "fn_code": "static void ares_dns_name_labels_del_last(ares_array_t *labels)\n{\n  ares_array_remove_last(labels);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_name_labels_del_last",
            "parameters": {
              "labels": "ares_array_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_parse_dns_name_escape(ares_buf_t *namebuf,\n                                                ares_buf_t *label,\n                                                ares_bool_t validate_hostname)\n{\n  ares_status_t status;\n  unsigned char c;\n\n  status = ares_buf_fetch_bytes(namebuf, &c, 1);\n  if (status != ARES_SUCCESS) {\n    return ARES_EBADNAME;\n  }\n\n  /* If next character is a digit, read 2 more digits */\n  if (ares_isdigit(c)) {\n    size_t       i;\n    unsigned int val = 0;\n\n    val = c - '0';\n\n    for (i = 0; i < 2; i++) {\n      status = ares_buf_fetch_bytes(namebuf, &c, 1);\n      if (status != ARES_SUCCESS) {\n        return ARES_EBADNAME;\n      }\n\n      if (!ares_isdigit(c)) {\n        return ARES_EBADNAME;\n      }\n      val *= 10;\n      val += c - '0';\n    }\n\n    /* Out of range */\n    if (val > 255) {\n      return ARES_EBADNAME;\n    }\n\n    if (validate_hostname && !ares_is_hostnamech((unsigned char)val)) {\n      return ARES_EBADNAME;\n    }\n\n    return ares_buf_append_byte(label, (unsigned char)val);\n  }\n\n  /* We can just output the character */\n  if (validate_hostname && !ares_is_hostnamech(c)) {\n    return ARES_EBADNAME;\n  }\n\n  return ares_buf_append_byte(label, c);\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_dns_name_escape",
            "parameters": {
              "namebuf": "ares_buf_t",
              "label": "ares_buf_t",
              "validate_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_split_dns_name(ares_array_t *labels,\n                                         ares_bool_t   validate_hostname,\n                                         const char   *name)\n{\n  ares_status_t status;\n  ares_buf_t   *label   = NULL;\n  ares_buf_t   *namebuf = NULL;\n  size_t        i;\n  size_t        total_len = 0;\n  unsigned char c;\n\n  if (name == NULL || labels == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Put name into a buffer for parsing */\n  namebuf = ares_buf_create();\n  if (namebuf == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  if (*name != '\\0') {\n    status =\n      ares_buf_append(namebuf, (const unsigned char *)name, ares_strlen(name));\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  /* Start with 1 label */\n  label = ares_dns_labels_add(labels);\n  if (label == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  while (ares_buf_fetch_bytes(namebuf, &c, 1) == ARES_SUCCESS) {\n    /* New label */\n    if (c == '.') {\n      label = ares_dns_labels_add(labels);\n      if (label == NULL) {\n        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      continue;\n    }\n\n    /* Escape */\n    if (c == '\\\\') {\n      status = ares_parse_dns_name_escape(namebuf, label, validate_hostname);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n      continue;\n    }\n\n    /* Output direct character */\n    if (validate_hostname && !ares_is_hostnamech(c)) {\n      status = ARES_EBADNAME;\n      goto done;\n    }\n\n    status = ares_buf_append_byte(label, c);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  /* Remove trailing blank label */\n  if (ares_buf_len(ares_dns_labels_get_last(labels)) == 0) {\n    ares_dns_name_labels_del_last(labels);\n  }\n\n  /* If someone passed in \".\" there could have been 2 blank labels, check for\n   * that */\n  if (ares_array_len(labels) == 1 &&\n      ares_buf_len(ares_dns_labels_get_last(labels)) == 0) {\n    ares_dns_name_labels_del_last(labels);\n  }\n\n  /* Scan to make sure label lengths are valid */\n  for (i = 0; i < ares_array_len(labels); i++) {\n    const ares_buf_t *buf = ares_dns_labels_get_at(labels, i);\n    size_t            len = ares_buf_len(buf);\n    /* No 0-length labels, and no labels over 63 bytes */\n    if (len == 0 || len > 63) {\n      status = ARES_EBADNAME;\n      goto done;\n    }\n    total_len += len;\n  }\n\n  /* Can't exceed maximum (unescaped) length */\n  if (ares_array_len(labels) && total_len + ares_array_len(labels) - 1 > 255) {\n    status = ARES_EBADNAME;\n    goto done;\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares_buf_destroy(namebuf);\n  return status;\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_split_dns_name",
            "parameters": {
              "labels": "ares_array_t",
              "validate_hostname": "ares_bool_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_name_write(ares_buf_t *buf, ares_llist_t **list,\n                                  ares_bool_t validate_hostname,\n                                  const char *name)\n{\n  const ares_nameoffset_t *off = NULL;\n  size_t                   name_len;\n  size_t                   orig_name_len;\n  size_t                   pos    = ares_buf_len(buf);\n  ares_array_t            *labels = NULL;\n  char                     name_copy[512];\n  ares_status_t            status;\n\n  if (buf == NULL || name == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  labels = ares_array_create(sizeof(ares_buf_t *), ares_dns_labels_free_cb);\n  if (labels == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  /* NOTE: due to possible escaping, name_copy buffer is > 256 to allow for\n   *       this */\n  name_len      = ares_strcpy(name_copy, name, sizeof(name_copy));\n  orig_name_len = name_len;\n\n  /* Find longest match */\n  if (list != NULL) {\n    off = ares_nameoffset_find(*list, name_copy);\n    if (off != NULL && off->name_len != name_len) {\n      /* truncate */\n      name_len            -= (off->name_len + 1);\n      name_copy[name_len]  = 0;\n    }\n  }\n\n  /* Output labels */\n  if (off == NULL || off->name_len != orig_name_len) {\n    size_t i;\n\n    status = ares_split_dns_name(labels, validate_hostname, name_copy);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    for (i = 0; i < ares_array_len(labels); i++) {\n      size_t               len  = 0;\n      const ares_buf_t    *lbuf = ares_dns_labels_get_at(labels, i);\n      const unsigned char *ptr  = ares_buf_peek(lbuf, &len);\n\n      status = ares_buf_append_byte(buf, (unsigned char)(len & 0xFF));\n      if (status != ARES_SUCCESS) {\n        goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n\n      status = ares_buf_append(buf, ptr, len);\n      if (status != ARES_SUCCESS) {\n        goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n\n    /* If we are NOT jumping to another label, output terminator */\n    if (off == NULL) {\n      status = ares_buf_append_byte(buf, 0);\n      if (status != ARES_SUCCESS) {\n        goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n  }\n\n  /* Output name compression offset jump */\n  if (off != NULL) {\n    unsigned short u16 =\n      (unsigned short)0xC000 | (unsigned short)(off->idx & 0x3FFF);\n    status = ares_buf_append_be16(buf, u16);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  /* Store pointer for future jumps as long as its not an exact match for\n   * a prior entry */\n  if (list != NULL && (off == NULL || off->name_len != orig_name_len) &&\n      name_len > 0) {\n    status = ares_nameoffset_create(list, name /* not truncated copy! */, pos);\n    if (status != ARES_SUCCESS) {\n      goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares_array_destroy(labels);\n  return status;\n}",
          "fn_code_pos": [
            [
              349,
              0
            ],
            [
              444,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_name_write",
            "parameters": {
              "buf": "ares_buf_t",
              "list": "ares_llist_t",
              "validate_hostname": "ares_bool_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t is_reservedch(int ch)\n{\n  switch (ch) {\n    case '\"':\n    case '.':\n    case ';':\n    case '\\\\':\n    case '(':\n    case ')':\n    case '@':\n    case '$':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              447,
              0
            ],
            [
              464,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_reservedch",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_fetch_dnsname_into_buf(ares_buf_t *buf,\n                                                 ares_buf_t *dest, size_t len,\n                                                 ares_bool_t is_hostname)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares_buf_peek(buf, &remaining_len);\n  ares_status_t        status;\n  size_t               i;\n\n  if (buf == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  for (i = 0; i < len; i++) {\n    unsigned char c = ptr[i];\n\n    /* Hostnames have a very specific allowed character set.  Anything outside\n     * of that (non-printable and reserved included) are disallowed */\n    if (is_hostname && !ares_is_hostnamech(c)) {\n      status = ARES_EBADRESP;\n      goto fail;\n    }\n\n    /* NOTE: dest may be NULL if the user is trying to skip the name. validation\n     *       still occurs above. */\n    if (dest == NULL) {\n      continue;\n    }\n\n    /* Non-printable characters need to be output as \\DDD */\n    if (!ares_isprint(c)) {\n      unsigned char escape[4];\n\n      escape[0] = '\\\\';\n      escape[1] = '0' + (c / 100);\n      escape[2] = '0' + ((c % 100) / 10);\n      escape[3] = '0' + (c % 10);\n\n      status = ares_buf_append(dest, escape, sizeof(escape));\n      if (status != ARES_SUCCESS) {\n        goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n\n      continue;\n    }\n\n    /* Reserved characters need to be escaped, otherwise normal */\n    if (is_reservedch(c)) {\n      status = ares_buf_append_byte(dest, '\\\\');\n      if (status != ARES_SUCCESS) {\n        goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n\n    status = ares_buf_append_byte(dest, c);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return ares_buf_consume(buf, len);\n\nfail:\n  return status;\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              530,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_fetch_dnsname_into_buf",
            "parameters": {
              "buf": "ares_buf_t",
              "dest": "ares_buf_t",
              "len": "size_t",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_name_parse(ares_buf_t *buf, char **name,\n                                  ares_bool_t is_hostname)\n{\n  size_t        save_offset = 0;\n  unsigned char c;\n  ares_status_t status;\n  ares_buf_t   *namebuf     = NULL;\n  size_t        label_start = ares_buf_get_position(buf);\n\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (name != NULL) {\n    namebuf = ares_buf_create();\n    if (namebuf == NULL) {\n      status = ARES_ENOMEM;\n      goto fail;\n    }\n  }\n\n  /* The compression scheme allows a domain name in a message to be\n   * represented as either:\n   *\n   * - a sequence of labels ending in a zero octet\n   * - a pointer\n   * - a sequence of labels ending with a pointer\n   */\n  while (1) {\n    /* Keep track of the minimum label starting position to prevent forward\n     * jumping */\n    if (label_start > ares_buf_get_position(buf)) {\n      label_start = ares_buf_get_position(buf);\n    }\n\n    status = ares_buf_fetch_bytes(buf, &c, 1);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    /* Pointer/Redirect */\n    if ((c & 0xc0) == 0xc0) {\n      /* The pointer takes the form of a two octet sequence:\n       *\n       *   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n       *   | 1  1|                OFFSET                   |\n       *   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n       *\n       * The first two bits are ones.  This allows a pointer to be distinguished\n       * from a label, since the label must begin with two zero bits because\n       * labels are restricted to 63 octets or less.  (The 10 and 01\n       * combinations are reserved for future use.)  The OFFSET field specifies\n       * an offset from the start of the message (i.e., the first octet of the\n       * ID field in the domain header).  A zero offset specifies the first byte\n       * of the ID field, etc.\n       */\n      size_t offset = (size_t)((c & 0x3F) << 8);\n\n      /* Fetch second byte of the redirect length */\n      status = ares_buf_fetch_bytes(buf, &c, 1);\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n\n      offset |= ((size_t)c);\n\n      /* According to RFC 1035 4.1.4:\n       *    In this scheme, an entire domain name or a list of labels at\n       *    the end of a domain name is replaced with a pointer to a prior\n       *    occurrence of the same name.\n       * Note the word \"prior\", meaning it must go backwards.  This was\n       * confirmed via the ISC BIND code that it also prevents forward\n       * pointers.\n       */\n      if (offset >= label_start) {\n        status = ARES_EBADNAME;\n        goto fail;\n      }\n\n      /* First time we make a jump, save the current position */\n      if (save_offset == 0) {\n        save_offset = ares_buf_get_position(buf);\n      }\n\n      status = ares_buf_set_position(buf, offset);\n      if (status != ARES_SUCCESS) {\n        status = ARES_EBADNAME;\n        goto fail;\n      }\n\n      continue;\n    } else if ((c & 0xc0) != 0) {\n      /* 10 and 01 are reserved */\n      status = ARES_EBADNAME;\n      goto fail;\n    } else if (c == 0) {\n      /* termination via zero octet*/\n      break;\n    }\n\n    /* New label */\n\n    /* Labels are separated by periods */\n    if (ares_buf_len(namebuf) != 0 && name != NULL) {\n      status = ares_buf_append_byte(namebuf, '.');\n      if (status != ARES_SUCCESS) {\n        goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n    }\n\n    status = ares_fetch_dnsname_into_buf(buf, namebuf, c, is_hostname);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Restore offset read after first redirect/pointer as this is where the DNS\n   * message continues */\n  if (save_offset) {\n    ares_buf_set_position(buf, save_offset);\n  }\n\n  if (name != NULL) {\n    *name = ares_buf_finish_str(namebuf, NULL);\n    if (*name == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  /* We want badname response if we couldn't parse */\n  if (status == ARES_EBADRESP) {\n    status = ARES_EBADNAME;\n  }\n\n  ares_buf_destroy(namebuf);\n  return status;\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              672,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_name_parse",
            "parameters": {
              "buf": "ares_buf_t",
              "name": "char",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_nameoffset_find(ares_llist_t *list,\n                                                     const char   *name)",
          "fn_dec_pos": [
            [
              85,
              32
            ],
            [
              86,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_nameoffset_find",
            "parameters": {
              "list": "ares_llist_t",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_labels_add(ares_array_t *labels)",
          "fn_dec_pos": [
            [
              143,
              19
            ],
            [
              143,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_add",
            "parameters": {
              "labels": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_labels_get_last(ares_array_t *labels)",
          "fn_dec_pos": [
            [
              164,
              19
            ],
            [
              164,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_get_last",
            "parameters": {
              "labels": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_labels_get_at(ares_array_t *labels, size_t idx)",
          "fn_dec_pos": [
            [
              175,
              19
            ],
            [
              175,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_get_at",
            "parameters": {
              "labels": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  char  *name;\n  size_t name_len;\n  size_t idx;\n} ares_nameoffset_t;",
          {
            "*name": "char",
            "name_len": "size_t",
            "idx": "size_t"
          },
          "ares_nameoffset_t",
          [
            27,
            0
          ],
          [
            31,
            20
          ]
        ],
        [
          "typedef struct {\n  char  *name;\n  size_t name_len;\n  size_t idx;\n} ares_nameoffset_t;",
          {
            "*name": "char",
            "name_len": "size_t",
            "idx": "size_t"
          },
          "ares_nameoffset_t",
          [
            27,
            0
          ],
          [
            31,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/record/ares_dns_multistring.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_dns_multistring_free_cb(void *arg)\n{\n  multistring_data_t *data = arg;\n  if (data == NULL) {\n    return;\n  }\n  ares_free(data->data);\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_free_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_dns_multistring_t *ares_dns_multistring_create(void)\n{\n  ares_dns_multistring_t *strs = ares_malloc_zero(sizeof(*strs));\n  if (strs == NULL) {\n    return NULL;\n  }\n\n  strs->strs =\n    ares_array_create(sizeof(multistring_data_t), ares_dns_multistring_free_cb);\n  if (strs->strs == NULL) {\n    ares_free(strs);\n    return NULL;\n  }\n\n  return strs;\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_create",
            "parameters": {},
            "return_type": "ares_dns_multistring_t"
          }
        },
        {
          "fn_code": "void ares_dns_multistring_clear(ares_dns_multistring_t *strs)\n{\n  if (strs == NULL) {\n    return;\n  }\n\n  while (ares_array_len(strs->strs)) {\n    ares_array_remove_last(strs->strs);\n  }\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_clear",
            "parameters": {
              "strs": "ares_dns_multistring_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_dns_multistring_destroy(ares_dns_multistring_t *strs)\n{\n  if (strs == NULL) {\n    return;\n  }\n  ares_dns_multistring_clear(strs);\n  ares_array_destroy(strs->strs);\n  ares_free(strs->cache_str);\n  ares_free(strs);\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_destroy",
            "parameters": {
              "strs": "ares_dns_multistring_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_multistring_swap_own(ares_dns_multistring_t *strs,\n                                            size_t idx, unsigned char *str,\n                                            size_t len)\n{\n  multistring_data_t *data;\n\n  if (strs == NULL || str == NULL || len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  strs->cache_invalidated = ARES_TRUE;\n\n  data = ares_array_at(strs->strs, idx);\n  if (data == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares_free(data->data);\n  data->data = str;\n  data->len  = len;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_swap_own",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "idx": "size_t",
              "str": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_multistring_del(ares_dns_multistring_t *strs, size_t idx)\n{\n  if (strs == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  strs->cache_invalidated = ARES_TRUE;\n\n  return ares_array_remove_at(strs->strs, idx);\n}",
          "fn_code_pos": [
            [
              115,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_del",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_multistring_add_own(ares_dns_multistring_t *strs,\n                                           unsigned char *str, size_t len)\n{\n  multistring_data_t *data;\n  ares_status_t       status;\n\n  if (strs == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  strs->cache_invalidated = ARES_TRUE;\n\n  /* NOTE: its ok to have an empty string added */\n  if (str == NULL && len != 0) {\n    return ARES_EFORMERR;\n  }\n\n  status = ares_array_insert_last((void **)&data, strs->strs);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Issue #921, ares_dns_multistring_get() doesn't have a way to indicate\n   * success or fail on a zero-length string which is actually valid.  So we\n   * are going to allocate a 1-byte buffer to use as a placeholder in this\n   * case */\n  if (str == NULL) {\n    str = ares_malloc_zero(1);\n    if (str == NULL) {\n      ares_array_remove_last(strs->strs);\n      return ARES_ENOMEM;\n    }\n  }\n\n  data->data = str;\n  data->len  = len;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_add_own",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "str": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "size_t ares_dns_multistring_cnt(const ares_dns_multistring_t *strs)\n{\n  if (strs == NULL) {\n    return 0;\n  }\n  return ares_array_len(strs->strs);\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_cnt",
            "parameters": {
              "strs": "ares_dns_multistring_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "const unsigned char *\n  ares_dns_multistring_get(const ares_dns_multistring_t *strs, size_t idx,\n                           size_t *len)\n{\n  const multistring_data_t *data;\n\n  if (strs == NULL || len == NULL) {\n    return NULL;\n  }\n\n  data = ares_array_at_const(strs->strs, idx);\n  if (data == NULL) {\n    return NULL;\n  }\n\n  *len = data->len;\n  return data->data;\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_get",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "idx": "size_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const unsigned char *ares_dns_multistring_combined(ares_dns_multistring_t *strs,\n                                                   size_t                 *len)\n{\n  ares_buf_t *buf = NULL;\n  size_t      i;\n\n  if (strs == NULL || len == NULL) {\n    return NULL;\n  }\n\n  *len = 0;\n\n  /* Return cache if possible */\n  if (!strs->cache_invalidated) {\n    *len = strs->cache_str_len;\n    return strs->cache_str;\n  }\n\n  /* Clear cache */\n  ares_free(strs->cache_str);\n  strs->cache_str     = NULL;\n  strs->cache_str_len = 0;\n\n  buf = ares_buf_create();\n\n  for (i = 0; i < ares_array_len(strs->strs); i++) {\n    const multistring_data_t *data = ares_array_at_const(strs->strs, i);\n    if (data == NULL ||\n        ares_buf_append(buf, data->data, data->len) != ARES_SUCCESS) {\n      ares_buf_destroy(buf);\n      return NULL;\n    }\n  }\n\n  strs->cache_str =\n    (unsigned char *)ares_buf_finish_str(buf, &strs->cache_str_len);\n  if (strs->cache_str != NULL) {\n    strs->cache_invalidated = ARES_FALSE;\n  }\n  *len = strs->cache_str_len;\n  return strs->cache_str;\n}",
          "fn_code_pos": [
            [
              193,
              0
            ],
            [
              234,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_combined",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_multistring_parse_buf(ares_buf_t *buf,\n                                             size_t      remaining_len,\n                                             ares_dns_multistring_t **strs,\n                                             ares_bool_t validate_printable)\n{\n  unsigned char len;\n  ares_status_t status   = ARES_EBADRESP;\n  size_t        orig_len = ares_buf_len(buf);\n\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (remaining_len == 0) {\n    return ARES_EBADRESP;\n  }\n\n  if (strs != NULL) {\n    *strs = ares_dns_multistring_create();\n    if (*strs == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  while (orig_len - ares_buf_len(buf) < remaining_len) {\n    status = ares_buf_fetch_bytes(buf, &len, 1);\n    if (status != ARES_SUCCESS) {\n      break; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n\n    /* When used by the _str() parser, it really needs to be validated to\n     * be a valid printable ascii string.  Do that here */\n    if (len && validate_printable && ares_buf_len(buf) >= len) {\n      size_t      mylen;\n      const char *data = (const char *)ares_buf_peek(buf, &mylen);\n      if (!ares_str_isprint(data, len)) {\n        status = ARES_EBADSTR;\n        break;\n      }\n    }\n\n    if (strs != NULL) {\n      unsigned char *data = NULL;\n      if (len) {\n        status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &data);\n        if (status != ARES_SUCCESS) {\n          break;\n        }\n      }\n      status = ares_dns_multistring_add_own(*strs, data, len);\n      if (status != ARES_SUCCESS) {\n        ares_free(data);\n        break;\n      }\n    } else {\n      status = ares_buf_consume(buf, len);\n      if (status != ARES_SUCCESS) {\n        break;\n      }\n    }\n\n  }\n\n  if (status != ARES_SUCCESS && strs != NULL) {\n    ares_dns_multistring_destroy(*strs);\n    *strs = NULL;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_parse_buf",
            "parameters": {
              "buf": "ares_buf_t",
              "remaining_len": "size_t",
              "strs": "ares_dns_multistring_t",
              "validate_printable": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_multistring_create(void)",
          "fn_dec_pos": [
            [
              53,
              24
            ],
            [
              53,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_multistring_get(const ares_dns_multistring_t *strs, size_t idx,\n                           size_t *len)",
          "fn_dec_pos": [
            [
              175,
              2
            ],
            [
              176,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_get",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "idx": "size_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_multistring_combined(ares_dns_multistring_t *strs,\n                                                   size_t                 *len)",
          "fn_dec_pos": [
            [
              193,
              21
            ],
            [
              194,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_combined",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  unsigned char *data;\n  size_t         len;\n} multistring_data_t;",
          {
            "*data": "unsigned char",
            "len": "size_t"
          },
          "multistring_data_t",
          [
            28,
            0
          ],
          [
            31,
            21
          ]
        ],
        [
          "struct ares_dns_multistring {\n  /*! whether or not cached concatenated string is valid */\n  ares_bool_t    cache_invalidated;\n  /*! combined/concatenated string cache */\n  unsigned char *cache_str;\n  /*! length of combined/concatenated string */\n  size_t         cache_str_len;\n  /*! Data making up strings */\n  ares_array_t  *strs; /*!< multistring_data_t type */\n}",
          {
            "cache_invalidated": "ares_bool_t",
            "*cache_str": "unsigned char",
            "cache_str_len": "size_t",
            "*strs": "ares_array_t"
          },
          "ares_dns_multistring",
          [
            33,
            0
          ],
          [
            42,
            1
          ]
        ],
        [
          "typedef struct {\n  unsigned char *data;\n  size_t         len;\n} multistring_data_t;",
          {
            "*data": "unsigned char",
            "len": "size_t"
          },
          "multistring_data_t",
          [
            28,
            0
          ],
          [
            31,
            21
          ]
        ],
        [
          "struct ares_dns_multistring {\n  /*! whether or not cached concatenated string is valid */\n  ares_bool_t    cache_invalidated;\n  /*! combined/concatenated string cache */\n  unsigned char *cache_str;\n  /*! length of combined/concatenated string */\n  size_t         cache_str_len;\n  /*! Data making up strings */\n  ares_array_t  *strs; /*!< multistring_data_t type */\n}",
          {
            "cache_invalidated": "ares_bool_t",
            "*cache_str": "unsigned char",
            "cache_str_len": "size_t",
            "*strs": "ares_array_t"
          },
          "ares_dns_multistring",
          [
            33,
            0
          ],
          [
            42,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_dns_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/record/ares_dns_parse.c": {
      "fn_def_list": [
        {
          "fn_code": "static size_t ares_dns_rr_remaining_len(const ares_buf_t *buf, size_t orig_len,\n                                        size_t rdlength)\n{\n  size_t used_len = orig_len - ares_buf_len(buf);\n  if (used_len >= rdlength) {\n    return 0;\n  }\n  return rdlength - used_len;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              39,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_remaining_len",
            "parameters": {
              "buf": "ares_buf_t",
              "orig_len": "size_t",
              "rdlength": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_dns_name(ares_buf_t    *buf,\n                                                     ares_bool_t    is_hostname,\n                                                     ares_dns_rr_t *rr,\n                                                     ares_dns_rr_key_t key)\n{\n  ares_status_t status;\n  char         *name = NULL;\n\n  status = ares_dns_name_parse(buf, &name, is_hostname);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_str_own(rr, key, name);\n  if (status != ARES_SUCCESS) {\n    ares_free(name);\n    return status;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_dns_name",
            "parameters": {
              "buf": "ares_buf_t",
              "is_hostname": "ares_bool_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_dns_str(ares_buf_t       *buf,\n                                                    size_t            max_len,\n                                                    ares_dns_rr_t    *rr,\n                                                    ares_dns_rr_key_t key,\n                                                    ares_bool_t blank_allowed)\n{\n  ares_status_t status;\n  char         *str = NULL;\n\n  status = ares_buf_parse_dns_str(buf, max_len, &str);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (!blank_allowed && ares_strlen(str) == 0) {\n    ares_free(str);\n    return ARES_EBADRESP;\n  }\n\n  status = ares_dns_rr_set_str_own(rr, key, str);\n  if (status != ARES_SUCCESS) {\n    ares_free(str);\n    return status;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_dns_str",
            "parameters": {
              "buf": "ares_buf_t",
              "max_len": "size_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "blank_allowed": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_dns_parse_and_set_dns_abin(ares_buf_t *buf, size_t max_len,\n                                  ares_dns_rr_t *rr, ares_dns_rr_key_t key,\n                                  ares_bool_t validate_printable)\n{\n  ares_status_t           status;\n  ares_dns_multistring_t *strs = NULL;\n\n  status =\n    ares_dns_multistring_parse_buf(buf, max_len, &strs, validate_printable);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_abin_own(rr, key, strs);\n  if (status != ARES_SUCCESS) {\n    ares_dns_multistring_destroy(strs);\n    return status;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_dns_abin",
            "parameters": {
              "buf": "ares_buf_t",
              "max_len": "size_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "validate_printable": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_be32(ares_buf_t       *buf,\n                                                 ares_dns_rr_t    *rr,\n                                                 ares_dns_rr_key_t key)\n{\n  ares_status_t status;\n  unsigned int  u32;\n\n  status = ares_buf_fetch_be32(buf, &u32);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_u32(rr, key, u32);\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_be32",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_be16(ares_buf_t       *buf,\n                                                 ares_dns_rr_t    *rr,\n                                                 ares_dns_rr_key_t key)\n{\n  ares_status_t  status;\n  unsigned short u16;\n\n  status = ares_buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_u16(rr, key, u16);\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_be16",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_u8(ares_buf_t       *buf,\n                                               ares_dns_rr_t    *rr,\n                                               ares_dns_rr_key_t key)\n{\n  ares_status_t status;\n  unsigned char u8;\n\n  status = ares_buf_fetch_bytes(buf, &u8, 1);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_u8(rr, key, u8);\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_u8",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_a(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                         size_t rdlength)\n{\n  struct in_addr addr;\n  ares_status_t  status;\n\n  (void)rdlength; /* Not needed */\n\n  status = ares_buf_fetch_bytes(buf, (unsigned char *)&addr, sizeof(addr));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_addr(rr, ARES_RR_A_ADDR, &addr);\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_a",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_ns(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                          size_t rdlength)\n{\n  (void)rdlength; /* Not needed */\n\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_NS_NSDNAME);\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_ns",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_cname(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                             size_t rdlength)\n{\n  (void)rdlength; /* Not needed */\n\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_CNAME_CNAME);\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_cname",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_soa(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  ares_status_t status;\n\n  (void)rdlength; /* Not needed */\n\n  /* MNAME */\n  status =\n    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SOA_MNAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* RNAME */\n  status =\n    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SOA_RNAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SERIAL */\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_SERIAL);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REFRESH */\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_REFRESH);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* RETRY */\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_RETRY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* EXPIRE */\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_EXPIRE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* MINIMUM */\n  return ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_MINIMUM);\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_soa",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_ptr(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  (void)rdlength; /* Not needed */\n\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_PTR_DNAME);\n}",
          "fn_code_pos": [
            [
              239,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_ptr",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_hinfo(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                             size_t rdlength)\n{\n  ares_status_t status;\n  size_t        orig_len = ares_buf_len(buf);\n\n  (void)rdlength; /* Not needed */\n\n  /* CPU */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,\n    ARES_RR_HINFO_CPU, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* OS */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,\n    ARES_RR_HINFO_OS, ARES_TRUE);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_hinfo",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_mx(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                          size_t rdlength)\n{\n  ares_status_t status;\n\n  (void)rdlength; /* Not needed */\n\n  /* PREFERENCE */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_MX_PREFERENCE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* EXCHANGE */\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_MX_EXCHANGE);\n}",
          "fn_code_pos": [
            [
              272,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_mx",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_txt(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  return ares_dns_parse_and_set_dns_abin(buf, rdlength, rr, ARES_RR_TXT_DATA,\n                                         ARES_FALSE);\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_txt",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_sig(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  ares_status_t  status;\n  size_t         orig_len = ares_buf_len(buf);\n  size_t         len;\n  unsigned char *data;\n\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SIG_TYPE_COVERED);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_SIG_ALGORITHM);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_SIG_LABELS);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SIG_ORIGINAL_TTL);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SIG_EXPIRATION);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SIG_INCEPTION);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SIG_KEY_TAG);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                           ARES_RR_SIG_SIGNERS_NAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);\n  if (len == 0) {\n    return ARES_EBADRESP;\n  }\n\n  status = ares_buf_fetch_bytes_dup(buf, len, ARES_FALSE, &data);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_bin_own(rr, ARES_RR_SIG_SIGNATURE, data, len);\n  if (status != ARES_SUCCESS) {\n    ares_free(data);\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_sig",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_aaaa(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                            size_t rdlength)\n{\n  struct ares_in6_addr addr;\n  ares_status_t        status;\n\n  (void)rdlength; /* Not needed */\n\n  status = ares_buf_fetch_bytes(buf, (unsigned char *)&addr, sizeof(addr));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_addr6(rr, ARES_RR_AAAA_ADDR, &addr);\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_aaaa",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_srv(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  ares_status_t status;\n\n  (void)rdlength; /* Not needed */\n\n  /* PRIORITY */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* WEIGHT */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_WEIGHT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* PORT */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_PORT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TARGET */\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_SRV_TARGET);\n}",
          "fn_code_pos": [
            [
              381,
              0
            ],
            [
              409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_srv",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_naptr(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                             size_t rdlength)\n{\n  ares_status_t status;\n  size_t        orig_len = ares_buf_len(buf);\n\n  /* ORDER */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_NAPTR_ORDER);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* PREFERENCE */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_NAPTR_PREFERENCE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* FLAGS */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,\n    ARES_RR_NAPTR_FLAGS, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SERVICES */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,\n    ARES_RR_NAPTR_SERVICES, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REGEXP */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,\n    ARES_RR_NAPTR_REGEXP, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REPLACEMENT */\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_NAPTR_REPLACEMENT);\n}",
          "fn_code_pos": [
            [
              411,
              0
            ],
            [
              456,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_naptr",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_opt(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t         rdlength,\n                                           unsigned short raw_class,\n                                           unsigned int   raw_ttl)\n{\n  ares_status_t  status;\n  size_t         orig_len = ares_buf_len(buf);\n  unsigned short rcode_high;\n\n  status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE, raw_class);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* First 8 bits of TTL are an extended RCODE, and they go in the higher order\n   * after the original 4-bit rcode */\n  rcode_high             = (unsigned short)((raw_ttl >> 20) & 0x0FF0);\n  rr->parent->raw_rcode |= rcode_high;\n\n  status = ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION,\n                              (unsigned char)(raw_ttl >> 16) & 0xFF);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS,\n                               (unsigned short)(raw_ttl & 0xFFFF));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Parse options */\n  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {\n    unsigned short opt = 0;\n    unsigned short len = 0;\n    unsigned char *val = NULL;\n\n    /* Fetch be16 option */\n    status = ares_buf_fetch_be16(buf, &opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Fetch be16 length */\n    status = ares_buf_fetch_be16(buf, &len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    if (len) {\n      status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n\n    status = ares_dns_rr_set_opt_own(rr, ARES_RR_OPT_OPTIONS, opt, val, len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              458,
              0
            ],
            [
              521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_opt",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t",
              "raw_class": "unsigned short",
              "raw_ttl": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_tlsa(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                            size_t rdlength)\n{\n  ares_status_t  status;\n  size_t         orig_len = ares_buf_len(buf);\n  size_t         len;\n  unsigned char *data;\n\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_CERT_USAGE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_SELECTOR);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_MATCH);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);\n  if (len == 0) {\n    return ARES_EBADRESP;\n  }\n\n  status = ares_buf_fetch_bytes_dup(buf, len, ARES_FALSE, &data);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_bin_own(rr, ARES_RR_TLSA_DATA, data, len);\n  if (status != ARES_SUCCESS) {\n    ares_free(data);\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              563,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_tlsa",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_svcb(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                            size_t rdlength)\n{\n  ares_status_t status;\n  size_t        orig_len = ares_buf_len(buf);\n\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SVCB_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status =\n    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SVCB_TARGET);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Parse params */\n  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {\n    unsigned short opt = 0;\n    unsigned short len = 0;\n    unsigned char *val = NULL;\n\n    /* Fetch be16 option */\n    status = ares_buf_fetch_be16(buf, &opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Fetch be16 length */\n    status = ares_buf_fetch_be16(buf, &len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    if (len) {\n      status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n\n    status = ares_dns_rr_set_opt_own(rr, ARES_RR_SVCB_PARAMS, opt, val, len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              565,
              0
            ],
            [
              614,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_svcb",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_https(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                             size_t rdlength)\n{\n  ares_status_t status;\n  size_t        orig_len = ares_buf_len(buf);\n\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_HTTPS_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status =\n    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_HTTPS_TARGET);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Parse params */\n  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {\n    unsigned short opt = 0;\n    unsigned short len = 0;\n    unsigned char *val = NULL;\n\n    /* Fetch be16 option */\n    status = ares_buf_fetch_be16(buf, &opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Fetch be16 length */\n    status = ares_buf_fetch_be16(buf, &len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    if (len) {\n      status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n\n    status = ares_dns_rr_set_opt_own(rr, ARES_RR_HTTPS_PARAMS, opt, val, len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              616,
              0
            ],
            [
              665,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_https",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_uri(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  char         *name = NULL;\n  ares_status_t status;\n  size_t        orig_len = ares_buf_len(buf);\n  size_t        remaining_len;\n\n  /* PRIORITY */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_URI_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* WEIGHT */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_URI_WEIGHT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TARGET -- not in string format, rest of buffer, required to be\n   * non-zero length */\n  remaining_len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);\n  if (remaining_len == 0) {\n    status = ARES_EBADRESP;\n    return status;\n  }\n\n  /* NOTE: Not in DNS string format */\n  status = ares_buf_fetch_str_dup(buf, remaining_len, &name);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (!ares_str_isprint(name, remaining_len)) {\n    ares_free(name);\n    return ARES_EBADRESP;\n  }\n\n  status = ares_dns_rr_set_str_own(rr, ARES_RR_URI_TARGET, name);\n  if (status != ARES_SUCCESS) {\n    ares_free(name);\n    return status;\n  }\n  name = NULL;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              667,
              0
            ],
            [
              714,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_uri",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_caa(ares_buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  unsigned char *data     = NULL;\n  size_t         data_len = 0;\n  ares_status_t  status;\n  size_t         orig_len = ares_buf_len(buf);\n\n  /* CRITICAL */\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_CAA_CRITICAL);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Tag */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,\n    ARES_RR_CAA_TAG, ARES_FALSE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Value - binary! (remaining buffer */\n  data_len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);\n  if (data_len == 0) {\n    status = ARES_EBADRESP;\n    return status;\n  }\n  status = ares_buf_fetch_bytes_dup(buf, data_len, ARES_TRUE, &data);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_bin_own(rr, ARES_RR_CAA_VALUE, data, data_len);\n  if (status != ARES_SUCCESS) {\n    ares_free(data);\n    return status;\n  }\n  data = NULL;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              716,
              0
            ],
            [
              757,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_caa",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_raw_rr(ares_buf_t    *buf,\n                                              ares_dns_rr_t *rr,\n                                              size_t         rdlength,\n                                              unsigned short raw_type)\n{\n  ares_status_t  status;\n  unsigned char *bytes = NULL;\n\n  if (rdlength == 0) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares_buf_fetch_bytes_dup(buf, rdlength, ARES_FALSE, &bytes);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Can't fail */\n  status = ares_dns_rr_set_u16(rr, ARES_RR_RAW_RR_TYPE, raw_type);\n  if (status != ARES_SUCCESS) {\n    ares_free(bytes);\n    return status;\n  }\n\n  status = ares_dns_rr_set_bin_own(rr, ARES_RR_RAW_RR_DATA, bytes, rdlength);\n  if (status != ARES_SUCCESS) {\n    ares_free(bytes);\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              759,
              0
            ],
            [
              790,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_raw_rr",
            "parameters": {
              "buf": "ares_buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t",
              "raw_type": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_header(ares_buf_t *buf, unsigned int flags,\n                                           ares_dns_record_t **dnsrec,\n                                           unsigned short     *qdcount,\n                                           unsigned short     *ancount,\n                                           unsigned short     *nscount,\n                                           unsigned short     *arcount)\n{\n  ares_status_t     status = ARES_EBADRESP;\n  unsigned short    u16;\n  unsigned short    id;\n  unsigned short    dns_flags = 0;\n  ares_dns_opcode_t opcode;\n  unsigned short    rcode;\n\n  (void)flags; /* currently unused */\n\n  if (buf == NULL || dnsrec == NULL || qdcount == NULL || ancount == NULL ||\n      nscount == NULL || arcount == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dnsrec = NULL;\n\n  /*\n   *  RFC 1035 4.1.1. Header section format.\n   *  and Updated by RFC 2065 to add AD and CD bits.\n   *                                  1  1  1  1  1  1\n   *    0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                      ID                       |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |QR|   Opcode  |AA|TC|RD|RA| Z|AD|CD|   RCODE   |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                    QDCOUNT                    |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                    ANCOUNT                    |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                    NSCOUNT                    |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                    ARCOUNT                    |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   */\n\n  /* ID */\n  status = ares_buf_fetch_be16(buf, &id);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* Flags */\n  status = ares_buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* QR */\n  if (u16 & 0x8000) {\n    dns_flags |= ARES_FLAG_QR;\n  }\n\n  /* OPCODE */\n  opcode = (u16 >> 11) & 0xf;\n\n  /* AA */\n  if (u16 & 0x400) {\n    dns_flags |= ARES_FLAG_AA;\n  }\n\n  /* TC */\n  if (u16 & 0x200) {\n    dns_flags |= ARES_FLAG_TC;\n  }\n\n  /* RD */\n  if (u16 & 0x100) {\n    dns_flags |= ARES_FLAG_RD;\n  }\n\n  /* RA */\n  if (u16 & 0x80) {\n    dns_flags |= ARES_FLAG_RA;\n  }\n\n  /* Z -- unused */\n\n  /* AD */\n  if (u16 & 0x20) {\n    dns_flags |= ARES_FLAG_AD;\n  }\n\n  /* CD */\n  if (u16 & 0x10) {\n    dns_flags |= ARES_FLAG_CD;\n  }\n\n  /* RCODE */\n  rcode = u16 & 0xf;\n\n  /* QDCOUNT */\n  status = ares_buf_fetch_be16(buf, qdcount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* ANCOUNT */\n  status = ares_buf_fetch_be16(buf, ancount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* NSCOUNT */\n  status = ares_buf_fetch_be16(buf, nscount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* ARCOUNT */\n  status = ares_buf_fetch_be16(buf, arcount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares_dns_record_create(dnsrec, id, dns_flags, opcode,\n                                  ARES_RCODE_NOERROR /* Temporary */);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  (*dnsrec)->raw_rcode = rcode;\n\n  if (*ancount > 0) {\n    status =\n      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_ANSWER, *ancount);\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  if (*nscount > 0) {\n    status =\n      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_AUTHORITY, *nscount);\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  if (*arcount > 0) {\n    status =\n      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_ADDITIONAL, *arcount);\n    if (status != ARES_SUCCESS) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  ares_dns_record_destroy(*dnsrec);\n  *dnsrec  = NULL;\n  *qdcount = 0;\n  *ancount = 0;\n  *nscount = 0;\n  *arcount = 0;\n\n  return status;\n}",
          "fn_code_pos": [
            [
              792,
              0
            ],
            [
              957,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_header",
            "parameters": {
              "buf": "ares_buf_t",
              "flags": "unsigned int",
              "dnsrec": "ares_dns_record_t",
              "qdcount": "unsigned short",
              "ancount": "unsigned short",
              "nscount": "unsigned short",
              "arcount": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_dns_parse_rr_data(ares_buf_t *buf, size_t rdlength, ares_dns_rr_t *rr,\n                         ares_dns_rec_type_t type, unsigned short raw_type,\n                         unsigned short raw_class, unsigned int raw_ttl)\n{\n  switch (type) {\n    case ARES_REC_TYPE_A:\n      return ares_dns_parse_rr_a(buf, rr, rdlength);\n    case ARES_REC_TYPE_NS:\n      return ares_dns_parse_rr_ns(buf, rr, rdlength);\n    case ARES_REC_TYPE_CNAME:\n      return ares_dns_parse_rr_cname(buf, rr, rdlength);\n    case ARES_REC_TYPE_SOA:\n      return ares_dns_parse_rr_soa(buf, rr, rdlength);\n    case ARES_REC_TYPE_PTR:\n      return ares_dns_parse_rr_ptr(buf, rr, rdlength);\n    case ARES_REC_TYPE_HINFO:\n      return ares_dns_parse_rr_hinfo(buf, rr, rdlength);\n    case ARES_REC_TYPE_MX:\n      return ares_dns_parse_rr_mx(buf, rr, rdlength);\n    case ARES_REC_TYPE_TXT:\n      return ares_dns_parse_rr_txt(buf, rr, rdlength);\n    case ARES_REC_TYPE_SIG:\n      return ares_dns_parse_rr_sig(buf, rr, rdlength);\n    case ARES_REC_TYPE_AAAA:\n      return ares_dns_parse_rr_aaaa(buf, rr, rdlength);\n    case ARES_REC_TYPE_SRV:\n      return ares_dns_parse_rr_srv(buf, rr, rdlength);\n    case ARES_REC_TYPE_NAPTR:\n      return ares_dns_parse_rr_naptr(buf, rr, rdlength);\n    case ARES_REC_TYPE_ANY:\n      return ARES_EBADRESP;\n    case ARES_REC_TYPE_OPT:\n      return ares_dns_parse_rr_opt(buf, rr, rdlength, raw_class, raw_ttl);\n    case ARES_REC_TYPE_TLSA:\n      return ares_dns_parse_rr_tlsa(buf, rr, rdlength);\n    case ARES_REC_TYPE_SVCB:\n      return ares_dns_parse_rr_svcb(buf, rr, rdlength);\n    case ARES_REC_TYPE_HTTPS:\n      return ares_dns_parse_rr_https(buf, rr, rdlength);\n    case ARES_REC_TYPE_URI:\n      return ares_dns_parse_rr_uri(buf, rr, rdlength);\n    case ARES_REC_TYPE_CAA:\n      return ares_dns_parse_rr_caa(buf, rr, rdlength);\n    case ARES_REC_TYPE_RAW_RR:\n      return ares_dns_parse_rr_raw_rr(buf, rr, rdlength, raw_type);\n  }\n  return ARES_EFORMERR;\n}",
          "fn_code_pos": [
            [
              959,
              0
            ],
            [
              1007,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_data",
            "parameters": {
              "buf": "ares_buf_t",
              "rdlength": "size_t",
              "rr": "ares_dns_rr_t",
              "type": "ares_dns_rec_type_t",
              "raw_type": "unsigned short",
              "raw_class": "unsigned short",
              "raw_ttl": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_qd(ares_buf_t        *buf,\n                                       ares_dns_record_t *dnsrec)\n{\n  char               *name = NULL;\n  unsigned short      u16;\n  ares_status_t       status;\n  ares_dns_rec_type_t type;\n  ares_dns_class_t    qclass;\n  /* The question section is used to carry the \"question\" in most queries,\n   * i.e., the parameters that define what is being asked.  The section\n   * contains QDCOUNT (usually 1) entries, each of the following format:\n   *                                 1  1  1  1  1  1\n   *   0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                                               |\n   * /                     QNAME                     /\n   * /                                               /\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                     QTYPE                     |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                     QCLASS                    |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   */\n\n  /* Name */\n  status = ares_dns_name_parse(buf, &name, ARES_FALSE);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Type */\n  status = ares_buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  type = u16;\n\n  /* Class */\n  status = ares_buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  qclass = u16;\n\n  /* Add question */\n  status = ares_dns_record_query_add(dnsrec, name, type, qclass);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_free(name);\n  return status;\n}",
          "fn_code_pos": [
            [
              1009,
              0
            ],
            [
              1062,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_qd",
            "parameters": {
              "buf": "ares_buf_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr(ares_buf_t *buf, unsigned int flags,\n                                       ares_dns_section_t sect,\n                                       ares_dns_record_t *dnsrec)\n{\n  char               *name = NULL;\n  unsigned short      u16;\n  unsigned short      raw_type;\n  ares_status_t       status;\n  ares_dns_rec_type_t type;\n  ares_dns_class_t    qclass;\n  unsigned int        ttl;\n  size_t              rdlength;\n  ares_dns_rr_t      *rr            = NULL;\n  size_t              remaining_len = 0;\n  size_t              processed_len = 0;\n  ares_bool_t         namecomp;\n\n  /* All RRs have the same top level format shown below:\n   *                                 1  1  1  1  1  1\n   *   0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                                               |\n   * /                                               /\n   * /                      NAME                     /\n   * |                                               |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                      TYPE                     |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                     CLASS                     |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                      TTL                      |\n   * |                                               |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                   RDLENGTH                    |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n   * /                     RDATA                     /\n   * /                                               /\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   */\n\n  /* Name */\n  status = ares_dns_name_parse(buf, &name, ARES_FALSE);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Type */\n  status = ares_buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  type     = u16;\n  raw_type = u16; /* Only used for raw rr data */\n\n  /* Class */\n  status = ares_buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  qclass = u16;\n\n  /* TTL */\n  status = ares_buf_fetch_be32(buf, &ttl);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Length */\n  status = ares_buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  rdlength = u16;\n\n  if (!ares_dns_rec_type_isvalid(type, ARES_FALSE)) {\n    type = ARES_REC_TYPE_RAW_RR;\n  }\n\n  namecomp = ares_dns_rec_allow_name_comp(type);\n  if (sect == ARES_SECTION_ANSWER &&\n      (flags &\n       (namecomp ? ARES_DNS_PARSE_AN_BASE_RAW : ARES_DNS_PARSE_AN_EXT_RAW))) {\n    type = ARES_REC_TYPE_RAW_RR;\n  }\n  if (sect == ARES_SECTION_AUTHORITY &&\n      (flags &\n       (namecomp ? ARES_DNS_PARSE_NS_BASE_RAW : ARES_DNS_PARSE_NS_EXT_RAW))) {\n    type = ARES_REC_TYPE_RAW_RR;\n  }\n  if (sect == ARES_SECTION_ADDITIONAL &&\n      (flags &\n       (namecomp ? ARES_DNS_PARSE_AR_BASE_RAW : ARES_DNS_PARSE_AR_EXT_RAW))) {\n    type = ARES_REC_TYPE_RAW_RR;\n  }\n\n  /* Pull into another buffer for safety */\n  if (rdlength > ares_buf_len(buf)) {\n    status = ARES_EBADRESP;\n    goto done;\n  }\n\n  /* Add the base rr */\n  status =\n    ares_dns_record_rr_add(&rr, dnsrec, sect, name, type,\n                           type == ARES_REC_TYPE_OPT ? ARES_CLASS_IN : qclass,\n                           type == ARES_REC_TYPE_OPT ? 0 : ttl);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Record the current remaining length in the buffer so we can tell how\n   * much was processed */\n  remaining_len = ares_buf_len(buf);\n\n  /* Fill in the data for the rr */\n  status = ares_dns_parse_rr_data(buf, rdlength, rr, type, raw_type,\n                                  (unsigned short)qclass, ttl);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Determine how many bytes were processed */\n  processed_len = remaining_len - ares_buf_len(buf);\n\n  /* If too many bytes were processed, error! */\n  if (processed_len > rdlength) {\n    status = ARES_EBADRESP;\n    goto done;\n  }\n\n  /* If too few bytes were processed, consume the unprocessed data for this\n   * record as the parser may not have wanted/needed to use it */\n  if (processed_len < rdlength) {\n    ares_buf_consume(buf, rdlength - processed_len);\n  }\n\n\ndone:\n  ares_free(name);\n  return status;\n}",
          "fn_code_pos": [
            [
              1064,
              0
            ],
            [
              1204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr",
            "parameters": {
              "buf": "ares_buf_t",
              "flags": "unsigned int",
              "sect": "ares_dns_section_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_buf(ares_buf_t *buf, unsigned int flags,\n                                        ares_dns_record_t **dnsrec)\n{\n  ares_status_t  status;\n  unsigned short qdcount;\n  unsigned short ancount;\n  unsigned short nscount;\n  unsigned short arcount;\n  unsigned short i;\n\n  if (buf == NULL || dnsrec == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Maximum DNS packet size is 64k, even over TCP */\n  if (ares_buf_len(buf) > 0xFFFF) {\n    return ARES_EFORMERR;\n  }\n\n  /* All communications inside of the domain protocol are carried in a single\n   * format called a message.  The top level format of message is divided\n   * into 5 sections (some of which are empty in certain cases) shown below:\n   *\n   * +---------------------+\n   * |        Header       |\n   * +---------------------+\n   * |       Question      | the question for the name server\n   * +---------------------+\n   * |        Answer       | RRs answering the question\n   * +---------------------+\n   * |      Authority      | RRs pointing toward an authority\n   * +---------------------+\n   * |      Additional     | RRs holding additional information\n   * +---------------------+\n   */\n\n  /* Parse header */\n  status = ares_dns_parse_header(buf, flags, dnsrec, &qdcount, &ancount,\n                                 &nscount, &arcount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* Must have questions */\n  if (qdcount == 0) {\n    status = ARES_EBADRESP;\n    goto fail;\n  }\n\n  /* XXX: this should be controlled by a flag in case we want to allow\n   *      multiple questions.  I think mDNS allows this */\n  if (qdcount > 1) {\n    status = ARES_EBADRESP;\n    goto fail;\n  }\n\n  /* Parse questions */\n  for (i = 0; i < qdcount; i++) {\n    status = ares_dns_parse_qd(buf, *dnsrec);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Parse Answers */\n  for (i = 0; i < ancount; i++) {\n    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_ANSWER, *dnsrec);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Parse Authority */\n  for (i = 0; i < nscount; i++) {\n    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_AUTHORITY, *dnsrec);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Parse Additional */\n  for (i = 0; i < arcount; i++) {\n    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_ADDITIONAL, *dnsrec);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Finalize rcode now that if we have OPT it is processed */\n  if (!ares_dns_rcode_isvalid((*dnsrec)->raw_rcode)) {\n    (*dnsrec)->rcode = ARES_RCODE_SERVFAIL;\n  } else {\n    (*dnsrec)->rcode = (ares_dns_rcode_t)(*dnsrec)->raw_rcode;\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  ares_dns_record_destroy(*dnsrec);\n  *dnsrec = NULL;\n  return status;\n}",
          "fn_code_pos": [
            [
              1206,
              0
            ],
            [
              1307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_buf",
            "parameters": {
              "buf": "ares_buf_t",
              "flags": "unsigned int",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_parse(const unsigned char *buf, size_t buf_len,\n                             unsigned int flags, ares_dns_record_t **dnsrec)\n{\n  ares_buf_t   *parser = NULL;\n  ares_status_t status;\n\n  if (buf == NULL || buf_len == 0 || dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  parser = ares_buf_create_const(buf, buf_len);\n  if (parser == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_dns_parse_buf(parser, flags, dnsrec);\n  ares_buf_destroy(parser);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1309,
              0
            ],
            [
              1328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse",
            "parameters": {
              "buf": "unsigned char",
              "buf_len": "size_t",
              "flags": "unsigned int",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct in_addr",
          {},
          "",
          [
            159,
            2
          ],
          [
            159,
            16
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            368,
            2
          ],
          [
            368,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/record/ares_dns_mapping.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_bool_t ares_dns_opcode_isvalid(ares_dns_opcode_t opcode)\n{\n  switch (opcode) {\n    case ARES_OPCODE_QUERY:\n    case ARES_OPCODE_IQUERY:\n    case ARES_OPCODE_STATUS:\n    case ARES_OPCODE_NOTIFY:\n    case ARES_OPCODE_UPDATE:\n      return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              38,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_isvalid",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rcode_isvalid(ares_dns_rcode_t rcode)\n{\n  switch (rcode) {\n    case ARES_RCODE_NOERROR:\n    case ARES_RCODE_FORMERR:\n    case ARES_RCODE_SERVFAIL:\n    case ARES_RCODE_NXDOMAIN:\n    case ARES_RCODE_NOTIMP:\n    case ARES_RCODE_REFUSED:\n    case ARES_RCODE_YXDOMAIN:\n    case ARES_RCODE_YXRRSET:\n    case ARES_RCODE_NXRRSET:\n    case ARES_RCODE_NOTAUTH:\n    case ARES_RCODE_NOTZONE:\n    case ARES_RCODE_DSOTYPEI:\n    case ARES_RCODE_BADSIG:\n    case ARES_RCODE_BADKEY:\n    case ARES_RCODE_BADTIME:\n    case ARES_RCODE_BADMODE:\n    case ARES_RCODE_BADNAME:\n    case ARES_RCODE_BADALG:\n    case ARES_RCODE_BADTRUNC:\n    case ARES_RCODE_BADCOOKIE:\n      return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_isvalid",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_flags_arevalid(unsigned short flags)\n{\n  unsigned short allflags = ARES_FLAG_QR | ARES_FLAG_AA | ARES_FLAG_TC |\n                            ARES_FLAG_RD | ARES_FLAG_RA | ARES_FLAG_AD |\n                            ARES_FLAG_CD;\n\n  if (flags & ~allflags) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_flags_arevalid",
            "parameters": {
              "flags": "unsigned short"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rec_type_isvalid(ares_dns_rec_type_t type,\n                                      ares_bool_t         is_query)\n{\n  switch (type) {\n    case ARES_REC_TYPE_A:\n    case ARES_REC_TYPE_NS:\n    case ARES_REC_TYPE_CNAME:\n    case ARES_REC_TYPE_SOA:\n    case ARES_REC_TYPE_PTR:\n    case ARES_REC_TYPE_HINFO:\n    case ARES_REC_TYPE_MX:\n    case ARES_REC_TYPE_TXT:\n    case ARES_REC_TYPE_SIG:\n    case ARES_REC_TYPE_AAAA:\n    case ARES_REC_TYPE_SRV:\n    case ARES_REC_TYPE_NAPTR:\n    case ARES_REC_TYPE_OPT:\n    case ARES_REC_TYPE_TLSA:\n    case ARES_REC_TYPE_SVCB:\n    case ARES_REC_TYPE_HTTPS:\n    case ARES_REC_TYPE_ANY:\n    case ARES_REC_TYPE_URI:\n    case ARES_REC_TYPE_CAA:\n      return ARES_TRUE;\n    case ARES_REC_TYPE_RAW_RR:\n      return is_query ? ARES_FALSE : ARES_TRUE;\n    default:\n      break;\n  }\n  return is_query ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_isvalid",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "is_query": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rec_allow_name_comp(ares_dns_rec_type_t type)\n{\n  /* Only record types defined in RFC1035 allow name compression within the\n   * RDATA.  Otherwise nameservers that don't understand an RR may not be\n   * able to pass along the RR in a proper manner */\n  switch (type) {\n    case ARES_REC_TYPE_A:\n    case ARES_REC_TYPE_NS:\n    case ARES_REC_TYPE_CNAME:\n    case ARES_REC_TYPE_SOA:\n    case ARES_REC_TYPE_PTR:\n    case ARES_REC_TYPE_HINFO:\n    case ARES_REC_TYPE_MX:\n    case ARES_REC_TYPE_TXT:\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_allow_name_comp",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_class_isvalid(ares_dns_class_t    qclass,\n                                   ares_dns_rec_type_t type,\n                                   ares_bool_t         is_query)\n{\n  /* If we don't understand the record type, we shouldn't validate the class\n   * as there are some instances like on RFC 2391 (SIG RR) the class is\n   * meaningless, but since we didn't support that record type, we didn't\n   * know it shouldn't be validated */\n  if (type == ARES_REC_TYPE_RAW_RR) {\n    return ARES_TRUE;\n  }\n\n  switch (qclass) {\n    case ARES_CLASS_IN:\n    case ARES_CLASS_CHAOS:\n    case ARES_CLASS_HESOID:\n    case ARES_CLASS_NONE:\n      return ARES_TRUE;\n    case ARES_CLASS_ANY:\n      if (type == ARES_REC_TYPE_SIG) {\n        return ARES_TRUE;\n      }\n      if (is_query) {\n        return ARES_TRUE;\n      }\n      return ARES_FALSE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_isvalid",
            "parameters": {
              "qclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "is_query": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_section_isvalid(ares_dns_section_t sect)\n{\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n    case ARES_SECTION_AUTHORITY:\n    case ARES_SECTION_ADDITIONAL:\n      return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_isvalid",
            "parameters": {
              "sect": "ares_dns_section_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_rec_type_t ares_dns_rr_key_to_rec_type(ares_dns_rr_key_t key)\n{\n  /* NOTE: due to the way we've numerated the keys, we can simply divide by\n   *       100 to get the type rather than having to do a huge switch\n   *       statement.  That said, we do then validate the type returned is\n   *       valid in case something completely bogus is passed in */\n  ares_dns_rec_type_t type = key / 100;\n  if (!ares_dns_rec_type_isvalid(type, ARES_FALSE)) {\n    return 0;\n  }\n  return type;\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_to_rec_type",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_dns_rec_type_t"
          }
        },
        {
          "fn_code": "const char *ares_dns_rec_type_tostr(ares_dns_rec_type_t type)\n{\n  switch (type) {\n    case ARES_REC_TYPE_A:\n      return \"A\";\n    case ARES_REC_TYPE_NS:\n      return \"NS\";\n    case ARES_REC_TYPE_CNAME:\n      return \"CNAME\";\n    case ARES_REC_TYPE_SOA:\n      return \"SOA\";\n    case ARES_REC_TYPE_PTR:\n      return \"PTR\";\n    case ARES_REC_TYPE_HINFO:\n      return \"HINFO\";\n    case ARES_REC_TYPE_MX:\n      return \"MX\";\n    case ARES_REC_TYPE_TXT:\n      return \"TXT\";\n    case ARES_REC_TYPE_SIG:\n      return \"SIG\";\n    case ARES_REC_TYPE_AAAA:\n      return \"AAAA\";\n    case ARES_REC_TYPE_SRV:\n      return \"SRV\";\n    case ARES_REC_TYPE_NAPTR:\n      return \"NAPTR\";\n    case ARES_REC_TYPE_OPT:\n      return \"OPT\";\n    case ARES_REC_TYPE_TLSA:\n      return \"TLSA\";\n    case ARES_REC_TYPE_SVCB:\n      return \"SVCB\";\n    case ARES_REC_TYPE_HTTPS:\n      return \"HTTPS\";\n    case ARES_REC_TYPE_ANY:\n      return \"ANY\";\n    case ARES_REC_TYPE_URI:\n      return \"URI\";\n    case ARES_REC_TYPE_CAA:\n      return \"CAA\";\n    case ARES_REC_TYPE_RAW_RR:\n      return \"RAWRR\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_tostr",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_class_tostr(ares_dns_class_t qclass)\n{\n  switch (qclass) {\n    case ARES_CLASS_IN:\n      return \"IN\";\n    case ARES_CLASS_CHAOS:\n      return \"CH\";\n    case ARES_CLASS_HESOID:\n      return \"HS\";\n    case ARES_CLASS_ANY:\n      return \"ANY\";\n    case ARES_CLASS_NONE:\n      return \"NONE\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_tostr",
            "parameters": {
              "qclass": "ares_dns_class_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_opcode_tostr(ares_dns_opcode_t opcode)\n{\n  switch (opcode) {\n    case ARES_OPCODE_QUERY:\n      return \"QUERY\";\n    case ARES_OPCODE_IQUERY:\n      return \"IQUERY\";\n    case ARES_OPCODE_STATUS:\n      return \"STATUS\";\n    case ARES_OPCODE_NOTIFY:\n      return \"NOTIFY\";\n    case ARES_OPCODE_UPDATE:\n      return \"UPDATE\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_tostr",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_rr_key_tostr(ares_dns_rr_key_t key)\n{\n  switch (key) {\n    case ARES_RR_A_ADDR:\n      return \"ADDR\";\n\n    case ARES_RR_NS_NSDNAME:\n      return \"NSDNAME\";\n\n    case ARES_RR_CNAME_CNAME:\n      return \"CNAME\";\n\n    case ARES_RR_SOA_MNAME:\n      return \"MNAME\";\n\n    case ARES_RR_SOA_RNAME:\n      return \"RNAME\";\n\n    case ARES_RR_SOA_SERIAL:\n      return \"SERIAL\";\n\n    case ARES_RR_SOA_REFRESH:\n      return \"REFRESH\";\n\n    case ARES_RR_SOA_RETRY:\n      return \"RETRY\";\n\n    case ARES_RR_SOA_EXPIRE:\n      return \"EXPIRE\";\n\n    case ARES_RR_SOA_MINIMUM:\n      return \"MINIMUM\";\n\n    case ARES_RR_PTR_DNAME:\n      return \"DNAME\";\n\n    case ARES_RR_AAAA_ADDR:\n      return \"ADDR\";\n\n    case ARES_RR_HINFO_CPU:\n      return \"CPU\";\n\n    case ARES_RR_HINFO_OS:\n      return \"OS\";\n\n    case ARES_RR_MX_PREFERENCE:\n      return \"PREFERENCE\";\n\n    case ARES_RR_MX_EXCHANGE:\n      return \"EXCHANGE\";\n\n    case ARES_RR_TXT_DATA:\n      return \"DATA\";\n\n    case ARES_RR_SIG_TYPE_COVERED:\n      return \"TYPE_COVERED\";\n\n    case ARES_RR_SIG_ALGORITHM:\n      return \"ALGORITHM\";\n\n    case ARES_RR_SIG_LABELS:\n      return \"LABELS\";\n\n    case ARES_RR_SIG_ORIGINAL_TTL:\n      return \"ORIGINAL_TTL\";\n\n    case ARES_RR_SIG_EXPIRATION:\n      return \"EXPIRATION\";\n\n    case ARES_RR_SIG_INCEPTION:\n      return \"INCEPTION\";\n\n    case ARES_RR_SIG_KEY_TAG:\n      return \"KEY_TAG\";\n\n    case ARES_RR_SIG_SIGNERS_NAME:\n      return \"SIGNERS_NAME\";\n\n    case ARES_RR_SIG_SIGNATURE:\n      return \"SIGNATURE\";\n\n    case ARES_RR_SRV_PRIORITY:\n      return \"PRIORITY\";\n\n    case ARES_RR_SRV_WEIGHT:\n      return \"WEIGHT\";\n\n    case ARES_RR_SRV_PORT:\n      return \"PORT\";\n\n    case ARES_RR_SRV_TARGET:\n      return \"TARGET\";\n\n    case ARES_RR_NAPTR_ORDER:\n      return \"ORDER\";\n\n    case ARES_RR_NAPTR_PREFERENCE:\n      return \"PREFERENCE\";\n\n    case ARES_RR_NAPTR_FLAGS:\n      return \"FLAGS\";\n\n    case ARES_RR_NAPTR_SERVICES:\n      return \"SERVICES\";\n\n    case ARES_RR_NAPTR_REGEXP:\n      return \"REGEXP\";\n\n    case ARES_RR_NAPTR_REPLACEMENT:\n      return \"REPLACEMENT\";\n\n    case ARES_RR_OPT_UDP_SIZE:\n      return \"UDP_SIZE\";\n\n    case ARES_RR_OPT_VERSION:\n      return \"VERSION\";\n\n    case ARES_RR_OPT_FLAGS:\n      return \"FLAGS\";\n\n    case ARES_RR_OPT_OPTIONS:\n      return \"OPTIONS\";\n\n    case ARES_RR_TLSA_CERT_USAGE:\n      return \"CERT_USAGE\";\n\n    case ARES_RR_TLSA_SELECTOR:\n      return \"SELECTOR\";\n\n    case ARES_RR_TLSA_MATCH:\n      return \"MATCH\";\n\n    case ARES_RR_TLSA_DATA:\n      return \"DATA\";\n\n    case ARES_RR_SVCB_PRIORITY:\n      return \"PRIORITY\";\n\n    case ARES_RR_SVCB_TARGET:\n      return \"TARGET\";\n\n    case ARES_RR_SVCB_PARAMS:\n      return \"PARAMS\";\n\n    case ARES_RR_HTTPS_PRIORITY:\n      return \"PRIORITY\";\n\n    case ARES_RR_HTTPS_TARGET:\n      return \"TARGET\";\n\n    case ARES_RR_HTTPS_PARAMS:\n      return \"PARAMS\";\n\n    case ARES_RR_URI_PRIORITY:\n      return \"PRIORITY\";\n\n    case ARES_RR_URI_WEIGHT:\n      return \"WEIGHT\";\n\n    case ARES_RR_URI_TARGET:\n      return \"TARGET\";\n\n    case ARES_RR_CAA_CRITICAL:\n      return \"CRITICAL\";\n\n    case ARES_RR_CAA_TAG:\n      return \"TAG\";\n\n    case ARES_RR_CAA_VALUE:\n      return \"VALUE\";\n\n    case ARES_RR_RAW_RR_TYPE:\n      return \"TYPE\";\n\n    case ARES_RR_RAW_RR_DATA:\n      return \"DATA\";\n  }\n\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_tostr",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_dns_datatype_t ares_dns_rr_key_datatype(ares_dns_rr_key_t key)\n{\n  switch (key) {\n    case ARES_RR_A_ADDR:\n      return ARES_DATATYPE_INADDR;\n\n    case ARES_RR_AAAA_ADDR:\n      return ARES_DATATYPE_INADDR6;\n\n    case ARES_RR_NS_NSDNAME:\n    case ARES_RR_CNAME_CNAME:\n    case ARES_RR_SOA_MNAME:\n    case ARES_RR_SOA_RNAME:\n    case ARES_RR_PTR_DNAME:\n    case ARES_RR_MX_EXCHANGE:\n    case ARES_RR_SIG_SIGNERS_NAME:\n    case ARES_RR_SRV_TARGET:\n    case ARES_RR_SVCB_TARGET:\n    case ARES_RR_HTTPS_TARGET:\n    case ARES_RR_NAPTR_REPLACEMENT:\n    case ARES_RR_URI_TARGET:\n      return ARES_DATATYPE_NAME;\n\n    case ARES_RR_HINFO_CPU:\n    case ARES_RR_HINFO_OS:\n    case ARES_RR_NAPTR_FLAGS:\n    case ARES_RR_NAPTR_SERVICES:\n    case ARES_RR_NAPTR_REGEXP:\n    case ARES_RR_CAA_TAG:\n      return ARES_DATATYPE_STR;\n\n    case ARES_RR_SOA_SERIAL:\n    case ARES_RR_SOA_REFRESH:\n    case ARES_RR_SOA_RETRY:\n    case ARES_RR_SOA_EXPIRE:\n    case ARES_RR_SOA_MINIMUM:\n    case ARES_RR_SIG_ORIGINAL_TTL:\n    case ARES_RR_SIG_EXPIRATION:\n    case ARES_RR_SIG_INCEPTION:\n      return ARES_DATATYPE_U32;\n\n    case ARES_RR_MX_PREFERENCE:\n    case ARES_RR_SIG_TYPE_COVERED:\n    case ARES_RR_SIG_KEY_TAG:\n    case ARES_RR_SRV_PRIORITY:\n    case ARES_RR_SRV_WEIGHT:\n    case ARES_RR_SRV_PORT:\n    case ARES_RR_NAPTR_ORDER:\n    case ARES_RR_NAPTR_PREFERENCE:\n    case ARES_RR_OPT_UDP_SIZE:\n    case ARES_RR_OPT_FLAGS:\n    case ARES_RR_SVCB_PRIORITY:\n    case ARES_RR_HTTPS_PRIORITY:\n    case ARES_RR_URI_PRIORITY:\n    case ARES_RR_URI_WEIGHT:\n    case ARES_RR_RAW_RR_TYPE:\n      return ARES_DATATYPE_U16;\n\n    case ARES_RR_SIG_ALGORITHM:\n    case ARES_RR_SIG_LABELS:\n    case ARES_RR_OPT_VERSION:\n    case ARES_RR_TLSA_CERT_USAGE:\n    case ARES_RR_TLSA_SELECTOR:\n    case ARES_RR_TLSA_MATCH:\n    case ARES_RR_CAA_CRITICAL:\n      return ARES_DATATYPE_U8;\n\n    case ARES_RR_CAA_VALUE:\n      return ARES_DATATYPE_BINP;\n\n    case ARES_RR_TXT_DATA:\n      return ARES_DATATYPE_ABINP;\n\n    case ARES_RR_SIG_SIGNATURE:\n    case ARES_RR_TLSA_DATA:\n    case ARES_RR_RAW_RR_DATA:\n      return ARES_DATATYPE_BIN;\n\n    case ARES_RR_OPT_OPTIONS:\n    case ARES_RR_SVCB_PARAMS:\n    case ARES_RR_HTTPS_PARAMS:\n      return ARES_DATATYPE_OPT;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              450,
              0
            ],
            [
              535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_datatype",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_dns_datatype_t"
          }
        },
        {
          "fn_code": "const ares_dns_rr_key_t       *ares_dns_rr_get_keys(ares_dns_rec_type_t type,\n                                                    size_t             *cnt)\n{\n  if (cnt == NULL) {\n    return NULL;\n  }\n\n  *cnt = 0;\n\n  switch (type) {\n    case ARES_REC_TYPE_A:\n      *cnt = sizeof(rr_a_keys) / sizeof(*rr_a_keys);\n      return rr_a_keys;\n    case ARES_REC_TYPE_NS:\n      *cnt = sizeof(rr_ns_keys) / sizeof(*rr_ns_keys);\n      return rr_ns_keys;\n    case ARES_REC_TYPE_CNAME:\n      *cnt = sizeof(rr_cname_keys) / sizeof(*rr_cname_keys);\n      return rr_cname_keys;\n    case ARES_REC_TYPE_SOA:\n      *cnt = sizeof(rr_soa_keys) / sizeof(*rr_soa_keys);\n      return rr_soa_keys;\n    case ARES_REC_TYPE_PTR:\n      *cnt = sizeof(rr_ptr_keys) / sizeof(*rr_ptr_keys);\n      return rr_ptr_keys;\n    case ARES_REC_TYPE_HINFO:\n      *cnt = sizeof(rr_hinfo_keys) / sizeof(*rr_hinfo_keys);\n      return rr_hinfo_keys;\n    case ARES_REC_TYPE_MX:\n      *cnt = sizeof(rr_mx_keys) / sizeof(*rr_mx_keys);\n      return rr_mx_keys;\n    case ARES_REC_TYPE_TXT:\n      *cnt = sizeof(rr_txt_keys) / sizeof(*rr_txt_keys);\n      return rr_txt_keys;\n    case ARES_REC_TYPE_SIG:\n      *cnt = sizeof(rr_sig_keys) / sizeof(*rr_sig_keys);\n      return rr_sig_keys;\n    case ARES_REC_TYPE_AAAA:\n      *cnt = sizeof(rr_aaaa_keys) / sizeof(*rr_aaaa_keys);\n      return rr_aaaa_keys;\n    case ARES_REC_TYPE_SRV:\n      *cnt = sizeof(rr_srv_keys) / sizeof(*rr_srv_keys);\n      return rr_srv_keys;\n    case ARES_REC_TYPE_NAPTR:\n      *cnt = sizeof(rr_naptr_keys) / sizeof(*rr_naptr_keys);\n      return rr_naptr_keys;\n    case ARES_REC_TYPE_OPT:\n      *cnt = sizeof(rr_opt_keys) / sizeof(*rr_opt_keys);\n      return rr_opt_keys;\n    case ARES_REC_TYPE_TLSA:\n      *cnt = sizeof(rr_tlsa_keys) / sizeof(*rr_tlsa_keys);\n      return rr_tlsa_keys;\n    case ARES_REC_TYPE_SVCB:\n      *cnt = sizeof(rr_svcb_keys) / sizeof(*rr_svcb_keys);\n      return rr_svcb_keys;\n    case ARES_REC_TYPE_HTTPS:\n      *cnt = sizeof(rr_https_keys) / sizeof(*rr_https_keys);\n      return rr_https_keys;\n    case ARES_REC_TYPE_ANY:\n      /* Not real */\n      break;\n    case ARES_REC_TYPE_URI:\n      *cnt = sizeof(rr_uri_keys) / sizeof(*rr_uri_keys);\n      return rr_uri_keys;\n    case ARES_REC_TYPE_CAA:\n      *cnt = sizeof(rr_caa_keys) / sizeof(*rr_caa_keys);\n      return rr_caa_keys;\n    case ARES_REC_TYPE_RAW_RR:\n      *cnt = sizeof(rr_raw_rr_keys) / sizeof(*rr_raw_rr_keys);\n      return rr_raw_rr_keys;\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              587,
              0
            ],
            [
              660,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_keys",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "cnt": "size_t"
            },
            "return_type": "ares_dns_rr_key_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_class_fromstr(ares_dns_class_t *qclass, const char *str)\n{\n  size_t i;\n\n  static const struct {\n    const char      *name;\n    ares_dns_class_t qclass;\n  } list[] = {\n    { \"IN\",   ARES_CLASS_IN     },\n    { \"CH\",   ARES_CLASS_CHAOS  },\n    { \"HS\",   ARES_CLASS_HESOID },\n    { \"NONE\", ARES_CLASS_NONE   },\n    { \"ANY\",  ARES_CLASS_ANY    },\n    { NULL,   0                 }\n  };\n\n  if (qclass == NULL || str == NULL) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; list[i].name != NULL; i++) {\n    if (ares_strcaseeq(list[i].name, str)) {\n      *qclass = list[i].qclass;\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              662,
              0
            ],
            [
              689,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_fromstr",
            "parameters": {
              "qclass": "ares_dns_class_t",
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rec_type_fromstr(ares_dns_rec_type_t *qtype,\n                                      const char          *str)\n{\n  size_t i;\n\n  static const struct {\n    const char         *name;\n    ares_dns_rec_type_t type;\n  } list[] = {\n    { \"A\",      ARES_REC_TYPE_A      },\n    { \"NS\",     ARES_REC_TYPE_NS     },\n    { \"CNAME\",  ARES_REC_TYPE_CNAME  },\n    { \"SOA\",    ARES_REC_TYPE_SOA    },\n    { \"PTR\",    ARES_REC_TYPE_PTR    },\n    { \"HINFO\",  ARES_REC_TYPE_HINFO  },\n    { \"MX\",     ARES_REC_TYPE_MX     },\n    { \"TXT\",    ARES_REC_TYPE_TXT    },\n    { \"SIG\",    ARES_REC_TYPE_SIG    },\n    { \"AAAA\",   ARES_REC_TYPE_AAAA   },\n    { \"SRV\",    ARES_REC_TYPE_SRV    },\n    { \"NAPTR\",  ARES_REC_TYPE_NAPTR  },\n    { \"OPT\",    ARES_REC_TYPE_OPT    },\n    { \"TLSA\",   ARES_REC_TYPE_TLSA   },\n    { \"SVCB\",   ARES_REC_TYPE_SVCB   },\n    { \"HTTPS\",  ARES_REC_TYPE_HTTPS  },\n    { \"ANY\",    ARES_REC_TYPE_ANY    },\n    { \"URI\",    ARES_REC_TYPE_URI    },\n    { \"CAA\",    ARES_REC_TYPE_CAA    },\n    { \"RAW_RR\", ARES_REC_TYPE_RAW_RR },\n    { NULL,     0                    }\n  };\n\n  if (qtype == NULL || str == NULL) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; list[i].name != NULL; i++) {\n    if (ares_strcaseeq(list[i].name, str)) {\n      *qtype = list[i].type;\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              691,
              0
            ],
            [
              734,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_fromstr",
            "parameters": {
              "qtype": "ares_dns_rec_type_t",
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "const char *ares_dns_section_tostr(ares_dns_section_t section)\n{\n  switch (section) {\n    case ARES_SECTION_ANSWER:\n      return \"ANSWER\";\n    case ARES_SECTION_AUTHORITY:\n      return \"AUTHORITY\";\n    case ARES_SECTION_ADDITIONAL:\n      return \"ADDITIONAL\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              736,
              0
            ],
            [
              747,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_tostr",
            "parameters": {
              "section": "ares_dns_section_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_dns_opt_datatype_t ares_dns_opt_get_type_opt(unsigned short opt)\n{\n  ares_opt_param_t param = (ares_opt_param_t)opt;\n  switch (param) {\n    case ARES_OPT_PARAM_LLQ:\n      /* Really it is u16 version, u16 opcode, u16 error, u64 id, u32 lease */\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_UL:\n      return ARES_OPT_DATATYPE_U32;\n    case ARES_OPT_PARAM_NSID:\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_DAU:\n      return ARES_OPT_DATATYPE_U8_LIST;\n    case ARES_OPT_PARAM_DHU:\n      return ARES_OPT_DATATYPE_U8_LIST;\n    case ARES_OPT_PARAM_N3U:\n      return ARES_OPT_DATATYPE_U8_LIST;\n    case ARES_OPT_PARAM_EDNS_CLIENT_SUBNET:\n      /* Really it is a u16 address family, u8 source prefix length,\n       * u8 scope prefix length, address */\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_EDNS_EXPIRE:\n      return ARES_OPT_DATATYPE_U32;\n    case ARES_OPT_PARAM_COOKIE:\n      /* 8 bytes for client, 16-40 bytes for server */\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE:\n      /* Timeout in 100ms intervals */\n      return ARES_OPT_DATATYPE_U16;\n    case ARES_OPT_PARAM_PADDING:\n      /* Arbitrary padding */\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_CHAIN:\n      return ARES_OPT_DATATYPE_NAME;\n    case ARES_OPT_PARAM_EDNS_KEY_TAG:\n      return ARES_OPT_DATATYPE_U16_LIST;\n    case ARES_OPT_PARAM_EXTENDED_DNS_ERROR:\n      /* Really 16bit code followed by textual message */\n      return ARES_OPT_DATATYPE_BIN;\n  }\n  return ARES_OPT_DATATYPE_BIN;\n}",
          "fn_code_pos": [
            [
              749,
              0
            ],
            [
              790,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_type_opt",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": "ares_dns_opt_datatype_t"
          }
        },
        {
          "fn_code": "static ares_dns_opt_datatype_t ares_dns_opt_get_type_svcb(unsigned short opt)\n{\n  ares_svcb_param_t param = (ares_svcb_param_t)opt;\n  switch (param) {\n    case ARES_SVCB_PARAM_NO_DEFAULT_ALPN:\n      return ARES_OPT_DATATYPE_NONE;\n    case ARES_SVCB_PARAM_ECH:\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_SVCB_PARAM_MANDATORY:\n      return ARES_OPT_DATATYPE_U16_LIST;\n    case ARES_SVCB_PARAM_ALPN:\n      return ARES_OPT_DATATYPE_STR_LIST;\n    case ARES_SVCB_PARAM_PORT:\n      return ARES_OPT_DATATYPE_U16;\n    case ARES_SVCB_PARAM_IPV4HINT:\n      return ARES_OPT_DATATYPE_INADDR4_LIST;\n    case ARES_SVCB_PARAM_IPV6HINT:\n      return ARES_OPT_DATATYPE_INADDR6_LIST;\n  }\n  return ARES_OPT_DATATYPE_BIN;\n}",
          "fn_code_pos": [
            [
              792,
              0
            ],
            [
              812,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_type_svcb",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": "ares_dns_opt_datatype_t"
          }
        },
        {
          "fn_code": "ares_dns_opt_datatype_t ares_dns_opt_get_datatype(ares_dns_rr_key_t key,\n                                                  unsigned short    opt)\n{\n  switch (key) {\n    case ARES_RR_OPT_OPTIONS:\n      return ares_dns_opt_get_type_opt(opt);\n    case ARES_RR_SVCB_PARAMS:\n    case ARES_RR_HTTPS_PARAMS:\n      return ares_dns_opt_get_type_svcb(opt);\n    default:\n      break;\n  }\n  return ARES_OPT_DATATYPE_BIN;\n}",
          "fn_code_pos": [
            [
              814,
              0
            ],
            [
              827,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_datatype",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": "ares_dns_opt_datatype_t"
          }
        },
        {
          "fn_code": "static const char *ares_dns_opt_get_name_opt(unsigned short opt)\n{\n  ares_opt_param_t param = (ares_opt_param_t)opt;\n  switch (param) {\n    case ARES_OPT_PARAM_LLQ:\n      return \"LLQ\";\n    case ARES_OPT_PARAM_UL:\n      return \"UL\";\n    case ARES_OPT_PARAM_NSID:\n      return \"NSID\";\n    case ARES_OPT_PARAM_DAU:\n      return \"DAU\";\n    case ARES_OPT_PARAM_DHU:\n      return \"DHU\";\n    case ARES_OPT_PARAM_N3U:\n      return \"N3U\";\n    case ARES_OPT_PARAM_EDNS_CLIENT_SUBNET:\n      return \"edns-client-subnet\";\n    case ARES_OPT_PARAM_EDNS_EXPIRE:\n      return \"edns-expire\";\n    case ARES_OPT_PARAM_COOKIE:\n      return \"COOKIE\";\n    case ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE:\n      return \"edns-tcp-keepalive\";\n    case ARES_OPT_PARAM_PADDING:\n      return \"Padding\";\n    case ARES_OPT_PARAM_CHAIN:\n      return \"CHAIN\";\n    case ARES_OPT_PARAM_EDNS_KEY_TAG:\n      return \"edns-key-tag\";\n    case ARES_OPT_PARAM_EXTENDED_DNS_ERROR:\n      return \"extended-dns-error\";\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              829,
              0
            ],
            [
              863,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name_opt",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static const char *ares_dns_opt_get_name_svcb(unsigned short opt)\n{\n  ares_svcb_param_t param = (ares_svcb_param_t)opt;\n  switch (param) {\n    case ARES_SVCB_PARAM_NO_DEFAULT_ALPN:\n      return \"no-default-alpn\";\n    case ARES_SVCB_PARAM_ECH:\n      return \"ech\";\n    case ARES_SVCB_PARAM_MANDATORY:\n      return \"mandatory\";\n    case ARES_SVCB_PARAM_ALPN:\n      return \"alpn\";\n    case ARES_SVCB_PARAM_PORT:\n      return \"port\";\n    case ARES_SVCB_PARAM_IPV4HINT:\n      return \"ipv4hint\";\n    case ARES_SVCB_PARAM_IPV6HINT:\n      return \"ipv6hint\";\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              865,
              0
            ],
            [
              885,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name_svcb",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_opt_get_name(ares_dns_rr_key_t key, unsigned short opt)\n{\n  switch (key) {\n    case ARES_RR_OPT_OPTIONS:\n      return ares_dns_opt_get_name_opt(opt);\n    case ARES_RR_SVCB_PARAMS:\n    case ARES_RR_HTTPS_PARAMS:\n      return ares_dns_opt_get_name_svcb(opt);\n    default:\n      break;\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              887,
              0
            ],
            [
              899,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_rcode_tostr(ares_dns_rcode_t rcode)\n{\n  switch (rcode) {\n    case ARES_RCODE_NOERROR:\n      return \"NOERROR\";\n    case ARES_RCODE_FORMERR:\n      return \"FORMERR\";\n    case ARES_RCODE_SERVFAIL:\n      return \"SERVFAIL\";\n    case ARES_RCODE_NXDOMAIN:\n      return \"NXDOMAIN\";\n    case ARES_RCODE_NOTIMP:\n      return \"NOTIMP\";\n    case ARES_RCODE_REFUSED:\n      return \"REFUSED\";\n    case ARES_RCODE_YXDOMAIN:\n      return \"YXDOMAIN\";\n    case ARES_RCODE_YXRRSET:\n      return \"YXRRSET\";\n    case ARES_RCODE_NXRRSET:\n      return \"NXRRSET\";\n    case ARES_RCODE_NOTAUTH:\n      return \"NOTAUTH\";\n    case ARES_RCODE_NOTZONE:\n      return \"NOTZONE\";\n    case ARES_RCODE_DSOTYPEI:\n      return \"DSOTYPEI\";\n    case ARES_RCODE_BADSIG:\n      return \"BADSIG\";\n    case ARES_RCODE_BADKEY:\n      return \"BADKEY\";\n    case ARES_RCODE_BADTIME:\n      return \"BADTIME\";\n    case ARES_RCODE_BADMODE:\n      return \"BADMODE\";\n    case ARES_RCODE_BADNAME:\n      return \"BADNAME\";\n    case ARES_RCODE_BADALG:\n      return \"BADALG\";\n    case ARES_RCODE_BADTRUNC:\n      return \"BADTRUNC\";\n    case ARES_RCODE_BADCOOKIE:\n      return \"BADCOOKIE\";\n  }\n\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              901,
              0
            ],
            [
              947,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_tostr",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_query_reply_tostatus(ares_dns_rcode_t rcode,\n                                            size_t           ancount)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  switch (rcode) {\n    case ARES_RCODE_NOERROR:\n      status = (ancount > 0) ? ARES_SUCCESS : ARES_ENODATA;\n      break;\n    case ARES_RCODE_FORMERR:\n      status = ARES_EFORMERR;\n      break;\n    case ARES_RCODE_SERVFAIL:\n      status = ARES_ESERVFAIL;\n      break;\n    case ARES_RCODE_NXDOMAIN:\n      status = ARES_ENOTFOUND;\n      break;\n    case ARES_RCODE_NOTIMP:\n      status = ARES_ENOTIMP;\n      break;\n    case ARES_RCODE_REFUSED:\n      status = ARES_EREFUSED;\n      break;\n    default:\n      break;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              952,
              0
            ],
            [
              981,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_query_reply_tostatus",
            "parameters": {
              "rcode": "ares_dns_rcode_t",
              "ancount": "size_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_rec_type_tostr(ares_dns_rec_type_t type)",
          "fn_dec_pos": [
            [
              188,
              12
            ],
            [
              188,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_tostr",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_class_tostr(ares_dns_class_t qclass)",
          "fn_dec_pos": [
            [
              235,
              12
            ],
            [
              235,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_tostr",
            "parameters": {
              "qclass": "ares_dns_class_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opcode_tostr(ares_dns_opcode_t opcode)",
          "fn_dec_pos": [
            [
              252,
              12
            ],
            [
              252,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_tostr",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_key_tostr(ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              269,
              12
            ],
            [
              269,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_tostr",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_keys(ares_dns_rec_type_t type,\n                                                    size_t             *cnt)",
          "fn_dec_pos": [
            [
              587,
              31
            ],
            [
              588,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_keys",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "cnt": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_section_tostr(ares_dns_section_t section)",
          "fn_dec_pos": [
            [
              736,
              12
            ],
            [
              736,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_tostr",
            "parameters": {
              "section": "ares_dns_section_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opt_get_name_opt(unsigned short opt)",
          "fn_dec_pos": [
            [
              829,
              19
            ],
            [
              829,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name_opt",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opt_get_name_svcb(unsigned short opt)",
          "fn_dec_pos": [
            [
              865,
              19
            ],
            [
              865,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name_svcb",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opt_get_name(ares_dns_rr_key_t key, unsigned short opt)",
          "fn_dec_pos": [
            [
              887,
              12
            ],
            [
              887,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rcode_tostr(ares_dns_rcode_t rcode)",
          "fn_dec_pos": [
            [
              901,
              12
            ],
            [
              901,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_tostr",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n    const char      *name;\n    ares_dns_class_t qclass;\n  }",
          {
            "char": "const",
            "qclass": "ares_dns_class_t"
          },
          "",
          [
            666,
            15
          ],
          [
            669,
            3
          ]
        ],
        [
          "struct {\n    const char         *name;\n    ares_dns_rec_type_t type;\n  }",
          {
            "char": "const",
            "type": "ares_dns_rec_type_t"
          },
          "",
          [
            696,
            15
          ],
          [
            699,
            3
          ]
        ],
        [
          "struct {\n    const char      *name;\n    ares_dns_class_t qclass;\n  }",
          {
            "char": "const",
            "qclass": "ares_dns_class_t"
          },
          "",
          [
            666,
            15
          ],
          [
            669,
            3
          ]
        ],
        [
          "struct {\n    const char         *name;\n    ares_dns_rec_type_t type;\n  }",
          {
            "char": "const",
            "type": "ares_dns_rec_type_t"
          },
          "",
          [
            696,
            15
          ],
          [
            699,
            3
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/record/ares_dns_record.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_dns_qd_free_cb(void *arg)\n{\n  ares_dns_qd_t *qd = arg;\n  if (qd == NULL) {\n    return;\n  }\n  ares_free(qd->name);\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              40,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_qd_free_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_dns_rr_free_cb(void *arg)\n{\n  ares_dns_rr_t *rr = arg;\n  if (rr == NULL) {\n    return;\n  }\n  ares_dns_rr_free(rr);\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_free_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_create(ares_dns_record_t **dnsrec,\n                                     unsigned short id, unsigned short flags,\n                                     ares_dns_opcode_t opcode,\n                                     ares_dns_rcode_t  rcode)\n{\n  if (dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dnsrec = NULL;\n\n  if (!ares_dns_opcode_isvalid(opcode) || !ares_dns_rcode_isvalid(rcode) ||\n      !ares_dns_flags_arevalid(flags)) {\n    return ARES_EFORMERR;\n  }\n\n  *dnsrec = ares_malloc_zero(sizeof(**dnsrec));\n  if (*dnsrec == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  (*dnsrec)->id     = id;\n  (*dnsrec)->flags  = flags;\n  (*dnsrec)->opcode = opcode;\n  (*dnsrec)->rcode  = rcode;\n  (*dnsrec)->qd = ares_array_create(sizeof(ares_dns_qd_t), ares_dns_qd_free_cb);\n  (*dnsrec)->an = ares_array_create(sizeof(ares_dns_rr_t), ares_dns_rr_free_cb);\n  (*dnsrec)->ns = ares_array_create(sizeof(ares_dns_rr_t), ares_dns_rr_free_cb);\n  (*dnsrec)->ar = ares_array_create(sizeof(ares_dns_rr_t), ares_dns_rr_free_cb);\n\n  if ((*dnsrec)->qd == NULL || (*dnsrec)->an == NULL || (*dnsrec)->ns == NULL ||\n      (*dnsrec)->ar == NULL) {\n    ares_dns_record_destroy(*dnsrec);\n    *dnsrec = NULL;\n    return ARES_ENOMEM;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_create",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "id": "unsigned short",
              "flags": "unsigned short",
              "opcode": "ares_dns_opcode_t",
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "unsigned short ares_dns_record_get_id(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->id;\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_id",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_record_set_id(ares_dns_record_t *dnsrec, unsigned short id)\n{\n  if (dnsrec == NULL) {\n    return ARES_FALSE;\n  }\n  dnsrec->id = id;\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_set_id",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "id": "unsigned short"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "unsigned short ares_dns_record_get_flags(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->flags;\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_flags",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opcode_t ares_dns_record_get_opcode(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->opcode;\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_opcode",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_opcode_t"
          }
        },
        {
          "fn_code": "ares_dns_rcode_t ares_dns_record_get_rcode(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->rcode;\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_rcode",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_rcode_t"
          }
        },
        {
          "fn_code": "static void ares_dns_rr_free(ares_dns_rr_t *rr)\n{\n  ares_free(rr->name);\n\n  switch (rr->type) {\n    case ARES_REC_TYPE_A:\n    case ARES_REC_TYPE_AAAA:\n    case ARES_REC_TYPE_ANY:\n      /* Nothing to free */\n      break;\n\n    case ARES_REC_TYPE_NS:\n      ares_free(rr->r.ns.nsdname);\n      break;\n\n    case ARES_REC_TYPE_CNAME:\n      ares_free(rr->r.cname.cname);\n      break;\n\n    case ARES_REC_TYPE_SOA:\n      ares_free(rr->r.soa.mname);\n      ares_free(rr->r.soa.rname);\n      break;\n\n    case ARES_REC_TYPE_PTR:\n      ares_free(rr->r.ptr.dname);\n      break;\n\n    case ARES_REC_TYPE_HINFO:\n      ares_free(rr->r.hinfo.cpu);\n      ares_free(rr->r.hinfo.os);\n      break;\n\n    case ARES_REC_TYPE_MX:\n      ares_free(rr->r.mx.exchange);\n      break;\n\n    case ARES_REC_TYPE_TXT:\n      ares_dns_multistring_destroy(rr->r.txt.strs);\n      break;\n\n    case ARES_REC_TYPE_SIG:\n      ares_free(rr->r.sig.signers_name);\n      ares_free(rr->r.sig.signature);\n      break;\n\n    case ARES_REC_TYPE_SRV:\n      ares_free(rr->r.srv.target);\n      break;\n\n    case ARES_REC_TYPE_NAPTR:\n      ares_free(rr->r.naptr.flags);\n      ares_free(rr->r.naptr.services);\n      ares_free(rr->r.naptr.regexp);\n      ares_free(rr->r.naptr.replacement);\n      break;\n\n    case ARES_REC_TYPE_OPT:\n      ares_array_destroy(rr->r.opt.options);\n      break;\n\n    case ARES_REC_TYPE_TLSA:\n      ares_free(rr->r.tlsa.data);\n      break;\n\n    case ARES_REC_TYPE_SVCB:\n      ares_free(rr->r.svcb.target);\n      ares_array_destroy(rr->r.svcb.params);\n      break;\n\n    case ARES_REC_TYPE_HTTPS:\n      ares_free(rr->r.https.target);\n      ares_array_destroy(rr->r.https.params);\n      break;\n\n    case ARES_REC_TYPE_URI:\n      ares_free(rr->r.uri.target);\n      break;\n\n    case ARES_REC_TYPE_CAA:\n      ares_free(rr->r.caa.tag);\n      ares_free(rr->r.caa.value);\n      break;\n\n    case ARES_REC_TYPE_RAW_RR:\n      ares_free(rr->r.raw_rr.data);\n      break;\n  }\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_free",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_dns_record_destroy(ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return;\n  }\n\n  /* Free questions */\n  ares_array_destroy(dnsrec->qd);\n\n  /* Free answers */\n  ares_array_destroy(dnsrec->an);\n\n  /* Free authority */\n  ares_array_destroy(dnsrec->ns);\n\n  /* Free additional */\n  ares_array_destroy(dnsrec->ar);\n\n  ares_free(dnsrec);\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_destroy",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares_dns_record_query_cnt(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return ares_array_len(dnsrec->qd);\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              249,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_cnt",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_add(ares_dns_record_t  *dnsrec,\n                                        const char         *name,\n                                        ares_dns_rec_type_t qtype,\n                                        ares_dns_class_t    qclass)\n{\n  size_t         idx;\n  ares_dns_qd_t *qd;\n  ares_status_t  status;\n\n  if (dnsrec == NULL || name == NULL ||\n      !ares_dns_rec_type_isvalid(qtype, ARES_TRUE) ||\n      !ares_dns_class_isvalid(qclass, qtype, ARES_TRUE)) {\n    return ARES_EFORMERR;\n  }\n\n  idx    = ares_array_len(dnsrec->qd);\n  status = ares_array_insert_last((void **)&qd, dnsrec->qd);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  qd->name = ares_strdup(name);\n  if (qd->name == NULL) {\n    ares_array_remove_at(dnsrec->qd, idx);\n    return ARES_ENOMEM;\n  }\n  qd->qtype  = qtype;\n  qd->qclass = qclass;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              251,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_add",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "name": "char",
              "qtype": "ares_dns_rec_type_t",
              "qclass": "ares_dns_class_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_set_name(ares_dns_record_t *dnsrec,\n                                             size_t idx, const char *name)\n{\n  char          *orig_name = NULL;\n  ares_dns_qd_t *qd;\n\n  if (dnsrec == NULL || idx >= ares_array_len(dnsrec->qd) || name == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  qd = ares_array_at(dnsrec->qd, idx);\n\n  orig_name = qd->name;\n  qd->name  = ares_strdup(name);\n  if (qd->name == NULL) {\n    qd->name = orig_name; /* LCOV_EXCL_LINE: OutOfMemory */\n    return ARES_ENOMEM;   /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  ares_free(orig_name);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_set_name",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_set_type(ares_dns_record_t  *dnsrec,\n                                             size_t              idx,\n                                             ares_dns_rec_type_t qtype)\n{\n  ares_dns_qd_t *qd;\n\n  if (dnsrec == NULL || idx >= ares_array_len(dnsrec->qd) ||\n      !ares_dns_rec_type_isvalid(qtype, ARES_TRUE)) {\n    return ARES_EFORMERR;\n  }\n\n  qd        = ares_array_at(dnsrec->qd, idx);\n  qd->qtype = qtype;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_set_type",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "qtype": "ares_dns_rec_type_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_get(const ares_dns_record_t *dnsrec,\n                                        size_t idx, const char **name,\n                                        ares_dns_rec_type_t *qtype,\n                                        ares_dns_class_t    *qclass)\n{\n  const ares_dns_qd_t *qd;\n  if (dnsrec == NULL || idx >= ares_array_len(dnsrec->qd)) {\n    return ARES_EFORMERR;\n  }\n\n  qd = ares_array_at(dnsrec->qd, idx);\n  if (name != NULL) {\n    *name = qd->name;\n  }\n\n  if (qtype != NULL) {\n    *qtype = qd->qtype;\n  }\n\n  if (qclass != NULL) {\n    *qclass = qd->qclass;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_get",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "name": "char",
              "qtype": "ares_dns_rec_type_t",
              "qclass": "ares_dns_class_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "size_t ares_dns_record_rr_cnt(const ares_dns_record_t *dnsrec,\n                              ares_dns_section_t       sect)\n{\n  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {\n    return 0;\n  }\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      return ares_array_len(dnsrec->an);\n    case ARES_SECTION_AUTHORITY:\n      return ares_array_len(dnsrec->ns);\n    case ARES_SECTION_ADDITIONAL:\n      return ares_array_len(dnsrec->ar);\n  }\n\n  return 0; /* LCOV_EXCL_LINE: DefensiveCoding */\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              365,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_cnt",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_prealloc(ares_dns_record_t *dnsrec,\n                                          ares_dns_section_t sect, size_t cnt)\n{\n  ares_array_t *arr = NULL;\n\n  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {\n    return ARES_EFORMERR;\n  }\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      arr = dnsrec->an;\n      break;\n    case ARES_SECTION_AUTHORITY:\n      arr = dnsrec->ns;\n      break;\n    case ARES_SECTION_ADDITIONAL:\n      arr = dnsrec->ar;\n      break;\n  }\n\n  if (cnt < ares_array_len(arr)) {\n    return ARES_EFORMERR;\n  }\n\n  return ares_array_set_size(arr, cnt);\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_prealloc",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "cnt": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_add(ares_dns_rr_t    **rr_out,\n                                     ares_dns_record_t *dnsrec,\n                                     ares_dns_section_t sect, const char *name,\n                                     ares_dns_rec_type_t type,\n                                     ares_dns_class_t rclass, unsigned int ttl)\n{\n  ares_dns_rr_t *rr  = NULL;\n  ares_array_t  *arr = NULL;\n  ares_status_t  status;\n  size_t         idx;\n\n  if (dnsrec == NULL || name == NULL || rr_out == NULL ||\n      !ares_dns_section_isvalid(sect) ||\n      !ares_dns_rec_type_isvalid(type, ARES_FALSE) ||\n      !ares_dns_class_isvalid(rclass, type, ARES_FALSE)) {\n    return ARES_EFORMERR;\n  }\n\n  *rr_out = NULL;\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      arr = dnsrec->an;\n      break;\n    case ARES_SECTION_AUTHORITY:\n      arr = dnsrec->ns;\n      break;\n    case ARES_SECTION_ADDITIONAL:\n      arr = dnsrec->ar;\n      break;\n  }\n\n  idx    = ares_array_len(arr);\n  status = ares_array_insert_last((void **)&rr, arr);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  rr->name = ares_strdup(name);\n  if (rr->name == NULL) {\n    ares_array_remove_at(arr, idx);\n    return ARES_ENOMEM;\n  }\n\n  rr->parent = dnsrec;\n  rr->type   = type;\n  rr->rclass = rclass;\n  rr->ttl    = ttl;\n\n  *rr_out = rr;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              395,
              0
            ],
            [
              447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_add",
            "parameters": {
              "rr_out": "ares_dns_rr_t",
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "name": "char",
              "type": "ares_dns_rec_type_t",
              "rclass": "ares_dns_class_t",
              "ttl": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_del(ares_dns_record_t *dnsrec,\n                                     ares_dns_section_t sect, size_t idx)\n{\n  ares_array_t *arr = NULL;\n\n  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {\n    return ARES_EFORMERR;\n  }\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      arr = dnsrec->an;\n      break;\n    case ARES_SECTION_AUTHORITY:\n      arr = dnsrec->ns;\n      break;\n    case ARES_SECTION_ADDITIONAL:\n      arr = dnsrec->ar;\n      break;\n  }\n\n  return ares_array_remove_at(arr, idx);\n}",
          "fn_code_pos": [
            [
              449,
              0
            ],
            [
              471,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_del",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_t *ares_dns_record_rr_get(ares_dns_record_t *dnsrec,\n                                      ares_dns_section_t sect, size_t idx)\n{\n  ares_array_t *arr = NULL;\n\n  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {\n    return NULL;\n  }\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      arr = dnsrec->an;\n      break;\n    case ARES_SECTION_AUTHORITY:\n      arr = dnsrec->ns;\n      break;\n    case ARES_SECTION_ADDITIONAL:\n      arr = dnsrec->ar;\n      break;\n  }\n\n  return ares_array_at(arr, idx);\n}",
          "fn_code_pos": [
            [
              473,
              0
            ],
            [
              495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_get",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "const ares_dns_rr_t *\n  ares_dns_record_rr_get_const(const ares_dns_record_t *dnsrec,\n                               ares_dns_section_t sect, size_t idx)\n{\n  return ares_dns_record_rr_get((void *)((size_t)dnsrec), sect, idx);\n}",
          "fn_code_pos": [
            [
              497,
              0
            ],
            [
              502,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_get_const",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "const char *ares_dns_rr_get_name(const ares_dns_rr_t *rr)\n{\n  if (rr == NULL) {\n    return NULL;\n  }\n  return rr->name;\n}",
          "fn_code_pos": [
            [
              504,
              0
            ],
            [
              510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_name",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_dns_rec_type_t ares_dns_rr_get_type(const ares_dns_rr_t *rr)\n{\n  if (rr == NULL) {\n    return 0;\n  }\n  return rr->type;\n}",
          "fn_code_pos": [
            [
              512,
              0
            ],
            [
              518,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_type",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "ares_dns_rec_type_t"
          }
        },
        {
          "fn_code": "ares_dns_class_t ares_dns_rr_get_class(const ares_dns_rr_t *rr)\n{\n  if (rr == NULL) {\n    return 0;\n  }\n  return rr->rclass;\n}",
          "fn_code_pos": [
            [
              520,
              0
            ],
            [
              526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_class",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "ares_dns_class_t"
          }
        },
        {
          "fn_code": "unsigned int ares_dns_rr_get_ttl(const ares_dns_rr_t *rr)\n{\n  if (rr == NULL) {\n    return 0;\n  }\n  return rr->ttl;\n}",
          "fn_code_pos": [
            [
              528,
              0
            ],
            [
              534,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_ttl",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void *ares_dns_rr_data_ptr(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  size_t **lenptr)\n{\n  if (dns_rr == NULL || dns_rr->type != ares_dns_rr_key_to_rec_type(key)) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  switch (key) {\n    case ARES_RR_A_ADDR:\n      return &dns_rr->r.a.addr;\n\n    case ARES_RR_NS_NSDNAME:\n      return &dns_rr->r.ns.nsdname;\n\n    case ARES_RR_CNAME_CNAME:\n      return &dns_rr->r.cname.cname;\n\n    case ARES_RR_SOA_MNAME:\n      return &dns_rr->r.soa.mname;\n\n    case ARES_RR_SOA_RNAME:\n      return &dns_rr->r.soa.rname;\n\n    case ARES_RR_SOA_SERIAL:\n      return &dns_rr->r.soa.serial;\n\n    case ARES_RR_SOA_REFRESH:\n      return &dns_rr->r.soa.refresh;\n\n    case ARES_RR_SOA_RETRY:\n      return &dns_rr->r.soa.retry;\n\n    case ARES_RR_SOA_EXPIRE:\n      return &dns_rr->r.soa.expire;\n\n    case ARES_RR_SOA_MINIMUM:\n      return &dns_rr->r.soa.minimum;\n\n    case ARES_RR_PTR_DNAME:\n      return &dns_rr->r.ptr.dname;\n\n    case ARES_RR_AAAA_ADDR:\n      return &dns_rr->r.aaaa.addr;\n\n    case ARES_RR_HINFO_CPU:\n      return &dns_rr->r.hinfo.cpu;\n\n    case ARES_RR_HINFO_OS:\n      return &dns_rr->r.hinfo.os;\n\n    case ARES_RR_MX_PREFERENCE:\n      return &dns_rr->r.mx.preference;\n\n    case ARES_RR_MX_EXCHANGE:\n      return &dns_rr->r.mx.exchange;\n\n    case ARES_RR_SIG_TYPE_COVERED:\n      return &dns_rr->r.sig.type_covered;\n\n    case ARES_RR_SIG_ALGORITHM:\n      return &dns_rr->r.sig.algorithm;\n\n    case ARES_RR_SIG_LABELS:\n      return &dns_rr->r.sig.labels;\n\n    case ARES_RR_SIG_ORIGINAL_TTL:\n      return &dns_rr->r.sig.original_ttl;\n\n    case ARES_RR_SIG_EXPIRATION:\n      return &dns_rr->r.sig.expiration;\n\n    case ARES_RR_SIG_INCEPTION:\n      return &dns_rr->r.sig.inception;\n\n    case ARES_RR_SIG_KEY_TAG:\n      return &dns_rr->r.sig.key_tag;\n\n    case ARES_RR_SIG_SIGNERS_NAME:\n      return &dns_rr->r.sig.signers_name;\n\n    case ARES_RR_SIG_SIGNATURE:\n      if (lenptr == NULL) {\n        return NULL;\n      }\n      *lenptr = &dns_rr->r.sig.signature_len;\n      return &dns_rr->r.sig.signature;\n\n    case ARES_RR_TXT_DATA:\n      return &dns_rr->r.txt.strs;\n\n    case ARES_RR_SRV_PRIORITY:\n      return &dns_rr->r.srv.priority;\n\n    case ARES_RR_SRV_WEIGHT:\n      return &dns_rr->r.srv.weight;\n\n    case ARES_RR_SRV_PORT:\n      return &dns_rr->r.srv.port;\n\n    case ARES_RR_SRV_TARGET:\n      return &dns_rr->r.srv.target;\n\n    case ARES_RR_NAPTR_ORDER:\n      return &dns_rr->r.naptr.order;\n\n    case ARES_RR_NAPTR_PREFERENCE:\n      return &dns_rr->r.naptr.preference;\n\n    case ARES_RR_NAPTR_FLAGS:\n      return &dns_rr->r.naptr.flags;\n\n    case ARES_RR_NAPTR_SERVICES:\n      return &dns_rr->r.naptr.services;\n\n    case ARES_RR_NAPTR_REGEXP:\n      return &dns_rr->r.naptr.regexp;\n\n    case ARES_RR_NAPTR_REPLACEMENT:\n      return &dns_rr->r.naptr.replacement;\n\n    case ARES_RR_OPT_UDP_SIZE:\n      return &dns_rr->r.opt.udp_size;\n\n    case ARES_RR_OPT_VERSION:\n      return &dns_rr->r.opt.version;\n\n    case ARES_RR_OPT_FLAGS:\n      return &dns_rr->r.opt.flags;\n\n    case ARES_RR_OPT_OPTIONS:\n      return &dns_rr->r.opt.options;\n\n    case ARES_RR_TLSA_CERT_USAGE:\n      return &dns_rr->r.tlsa.cert_usage;\n\n    case ARES_RR_TLSA_SELECTOR:\n      return &dns_rr->r.tlsa.selector;\n\n    case ARES_RR_TLSA_MATCH:\n      return &dns_rr->r.tlsa.match;\n\n    case ARES_RR_TLSA_DATA:\n      if (lenptr == NULL) {\n        return NULL;\n      }\n      *lenptr = &dns_rr->r.tlsa.data_len;\n      return &dns_rr->r.tlsa.data;\n\n    case ARES_RR_SVCB_PRIORITY:\n      return &dns_rr->r.svcb.priority;\n\n    case ARES_RR_SVCB_TARGET:\n      return &dns_rr->r.svcb.target;\n\n    case ARES_RR_SVCB_PARAMS:\n      return &dns_rr->r.svcb.params;\n\n    case ARES_RR_HTTPS_PRIORITY:\n      return &dns_rr->r.https.priority;\n\n    case ARES_RR_HTTPS_TARGET:\n      return &dns_rr->r.https.target;\n\n    case ARES_RR_HTTPS_PARAMS:\n      return &dns_rr->r.https.params;\n\n    case ARES_RR_URI_PRIORITY:\n      return &dns_rr->r.uri.priority;\n\n    case ARES_RR_URI_WEIGHT:\n      return &dns_rr->r.uri.weight;\n\n    case ARES_RR_URI_TARGET:\n      return &dns_rr->r.uri.target;\n\n    case ARES_RR_CAA_CRITICAL:\n      return &dns_rr->r.caa.critical;\n\n    case ARES_RR_CAA_TAG:\n      return &dns_rr->r.caa.tag;\n\n    case ARES_RR_CAA_VALUE:\n      if (lenptr == NULL) {\n        return NULL;\n      }\n      *lenptr = &dns_rr->r.caa.value_len;\n      return &dns_rr->r.caa.value;\n\n    case ARES_RR_RAW_RR_TYPE:\n      return &dns_rr->r.raw_rr.type;\n\n    case ARES_RR_RAW_RR_DATA:\n      if (lenptr == NULL) {\n        return NULL;\n      }\n      *lenptr = &dns_rr->r.raw_rr.length;\n      return &dns_rr->r.raw_rr.data;\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              536,
              0
            ],
            [
              736,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_data_ptr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "lenptr": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static const void *ares_dns_rr_data_ptr_const(const ares_dns_rr_t *dns_rr,\n                                              ares_dns_rr_key_t    key,\n                                              const size_t       **lenptr)\n{\n  /* We're going to cast off the const */\n  return ares_dns_rr_data_ptr((void *)((size_t)dns_rr), key,\n                              (void *)((size_t)lenptr));\n}",
          "fn_code_pos": [
            [
              738,
              0
            ],
            [
              745,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_data_ptr_const",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "lenptr": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const struct in_addr *ares_dns_rr_get_addr(const ares_dns_rr_t *dns_rr,\n                                           ares_dns_rr_key_t    key)\n{\n  const struct in_addr *addr;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR) {\n    return NULL;\n  }\n\n  addr = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (addr == NULL) {\n    return NULL;\n  }\n\n  return addr;\n}",
          "fn_code_pos": [
            [
              747,
              0
            ],
            [
              762,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const struct ares_in6_addr *ares_dns_rr_get_addr6(const ares_dns_rr_t *dns_rr,\n                                                  ares_dns_rr_key_t    key)\n{\n  const struct ares_in6_addr *addr;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR6) {\n    return NULL;\n  }\n\n  addr = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (addr == NULL) {\n    return NULL;\n  }\n\n  return addr;\n}",
          "fn_code_pos": [
            [
              764,
              0
            ],
            [
              779,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned char ares_dns_rr_get_u8(const ares_dns_rr_t *dns_rr,\n                                 ares_dns_rr_key_t    key)\n{\n  const unsigned char *u8;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {\n    return 0;\n  }\n\n  u8 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (u8 == NULL) {\n    return 0;\n  }\n\n  return *u8;\n}",
          "fn_code_pos": [
            [
              781,
              0
            ],
            [
              796,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u8",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned short ares_dns_rr_get_u16(const ares_dns_rr_t *dns_rr,\n                                   ares_dns_rr_key_t    key)\n{\n  const unsigned short *u16;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {\n    return 0;\n  }\n\n  u16 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (u16 == NULL) {\n    return 0;\n  }\n\n  return *u16;\n}",
          "fn_code_pos": [
            [
              798,
              0
            ],
            [
              813,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u16",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int ares_dns_rr_get_u32(const ares_dns_rr_t *dns_rr,\n                                 ares_dns_rr_key_t    key)\n{\n  const unsigned int *u32;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {\n    return 0;\n  }\n\n  u32 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (u32 == NULL) {\n    return 0;\n  }\n\n  return *u32;\n}",
          "fn_code_pos": [
            [
              815,
              0
            ],
            [
              830,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u32",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const unsigned char *ares_dns_rr_get_bin(const ares_dns_rr_t *dns_rr,\n                                         ares_dns_rr_key_t key, size_t *len)\n{\n  unsigned char * const *bin     = NULL;\n  size_t const          *bin_len = NULL;\n\n  if ((ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BIN &&\n       ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BINP &&\n       ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) ||\n      len == NULL) {\n    return NULL;\n  }\n\n  /* Array of strings, return concatenated version */\n  if (ares_dns_rr_key_datatype(key) == ARES_DATATYPE_ABINP) {\n    ares_dns_multistring_t * const *strs =\n      ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n\n    if (strs == NULL) {\n      return NULL;\n    }\n\n    return ares_dns_multistring_combined(*strs, len);\n  }\n\n  /* Not a multi-string, just straight binary data */\n  bin = ares_dns_rr_data_ptr_const(dns_rr, key, &bin_len);\n  if (bin == NULL) {\n    return NULL;\n  }\n\n  /* Shouldn't be possible */\n  if (bin_len == NULL) {\n    return NULL;\n  }\n  *len = *bin_len;\n\n  return *bin;\n}",
          "fn_code_pos": [
            [
              832,
              0
            ],
            [
              870,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "size_t ares_dns_rr_get_abin_cnt(const ares_dns_rr_t *dns_rr,\n                                ares_dns_rr_key_t    key)\n{\n  ares_dns_multistring_t * const *strs;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {\n    return 0;\n  }\n\n  strs = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (strs == NULL) {\n    return 0;\n  }\n\n  return ares_dns_multistring_cnt(*strs);\n}",
          "fn_code_pos": [
            [
              872,
              0
            ],
            [
              887,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_abin_cnt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "const unsigned char *ares_dns_rr_get_abin(const ares_dns_rr_t *dns_rr,\n                                          ares_dns_rr_key_t key, size_t idx,\n                                          size_t *len)\n{\n  ares_dns_multistring_t * const *strs;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {\n    return NULL;\n  }\n\n  strs = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (strs == NULL) {\n    return NULL;\n  }\n\n  return ares_dns_multistring_get(*strs, idx, len);\n}",
          "fn_code_pos": [
            [
              889,
              0
            ],
            [
              905,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_abin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_del_abin(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                   size_t idx)\n{\n  ares_dns_multistring_t **strs;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {\n    return ARES_EFORMERR;\n  }\n\n  strs = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (strs == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  return ares_dns_multistring_del(*strs, idx);\n}",
          "fn_code_pos": [
            [
              907,
              0
            ],
            [
              922,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_del_abin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_add_abin(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                   const unsigned char *val, size_t len)\n{\n  ares_status_t       status;\n  ares_dns_datatype_t datatype = ares_dns_rr_key_datatype(key);\n  ares_bool_t         is_nullterm =\n    (datatype == ARES_DATATYPE_ABINP) ? ARES_TRUE : ARES_FALSE;\n  size_t                   alloclen = is_nullterm ? len + 1 : len;\n  unsigned char           *temp;\n  ares_dns_multistring_t **strs;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {\n    return ARES_EFORMERR;\n  }\n\n  strs = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (strs == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*strs == NULL) {\n    *strs = ares_dns_multistring_create();\n    if (*strs == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  temp = ares_malloc(alloclen);\n  if (temp == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  memcpy(temp, val, len);\n\n  /* NULL-term ABINP */\n  if (is_nullterm) {\n    temp[len] = 0;\n  }\n\n  status = ares_dns_multistring_add_own(*strs, temp, len);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              924,
              0
            ],
            [
              969,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_add_abin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const char *ares_dns_rr_get_str(const ares_dns_rr_t *dns_rr,\n                                ares_dns_rr_key_t    key)\n{\n  char * const *str;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_STR &&\n      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_NAME) {\n    return NULL;\n  }\n\n  str = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (str == NULL) {\n    return NULL;\n  }\n\n  return *str;\n}",
          "fn_code_pos": [
            [
              971,
              0
            ],
            [
              987,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "size_t ares_dns_rr_get_opt_cnt(const ares_dns_rr_t *dns_rr,\n                               ares_dns_rr_key_t    key)\n{\n  ares_array_t * const *opts;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return 0;\n  }\n\n  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (opts == NULL || *opts == NULL) {\n    return 0;\n  }\n\n  return ares_array_len(*opts);\n}",
          "fn_code_pos": [
            [
              989,
              0
            ],
            [
              1004,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt_cnt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "unsigned short ares_dns_rr_get_opt(const ares_dns_rr_t *dns_rr,\n                                   ares_dns_rr_key_t key, size_t idx,\n                                   const unsigned char **val, size_t *val_len)\n{\n  ares_array_t * const    *opts;\n  const ares_dns_optval_t *opt;\n\n  if (val) {\n    *val = NULL;\n  }\n  if (val_len) {\n    *val_len = 0;\n  }\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return 65535;\n  }\n\n  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (opts == NULL || *opts == NULL) {\n    return 65535;\n  }\n\n  opt = ares_array_at(*opts, idx);\n  if (opt == NULL) {\n    return 65535;\n  }\n\n  if (val) {\n    *val = opt->val;\n  }\n  if (val_len) {\n    *val_len = opt->val_len;\n  }\n\n  return opt->opt;\n}",
          "fn_code_pos": [
            [
              1006,
              0
            ],
            [
              1042,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rr_get_opt_byid(const ares_dns_rr_t *dns_rr,\n                                     ares_dns_rr_key_t key, unsigned short opt,\n                                     const unsigned char **val, size_t *val_len)\n{\n  ares_array_t * const    *opts;\n  size_t                   i;\n  size_t                   cnt;\n  const ares_dns_optval_t *optptr = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n  if (val_len) {\n    *val_len = 0;\n  }\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return ARES_FALSE;\n  }\n\n  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (opts == NULL || *opts == NULL) {\n    return ARES_FALSE;\n  }\n\n  cnt = ares_array_len(*opts);\n  for (i = 0; i < cnt; i++) {\n    optptr = ares_array_at(*opts, i);\n    if (optptr == NULL) {\n      return ARES_FALSE;\n    }\n    if (optptr->opt == opt) {\n      break;\n    }\n  }\n\n  if (i >= cnt || optptr == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = optptr->val;\n  }\n  if (val_len) {\n    *val_len = optptr->val_len;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              1044,
              0
            ],
            [
              1091,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt_byid",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_addr(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                   const struct in_addr *addr)\n{\n  struct in_addr *a;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR || addr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  a = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (a == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  memcpy(a, addr, sizeof(*a));\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1093,
              0
            ],
            [
              1109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "addr": "struct in_addr"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_addr6(ares_dns_rr_t              *dns_rr,\n                                    ares_dns_rr_key_t           key,\n                                    const struct ares_in6_addr *addr)\n{\n  struct ares_in6_addr *a;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR6 || addr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  a = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (a == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  memcpy(a, addr, sizeof(*a));\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1111,
              0
            ],
            [
              1128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "addr": "struct ares_in6_addr"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u8(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                 unsigned char val)\n{\n  unsigned char *u8;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {\n    return ARES_EFORMERR;\n  }\n\n  u8 = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (u8 == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *u8 = val;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1130,
              0
            ],
            [
              1146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_u8",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u16(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  unsigned short val)\n{\n  unsigned short *u16;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {\n    return ARES_EFORMERR;\n  }\n\n  u16 = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (u16 == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *u16 = val;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1148,
              0
            ],
            [
              1164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_u16",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u32(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  unsigned int val)\n{\n  unsigned int *u32;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {\n    return ARES_EFORMERR;\n  }\n\n  u32 = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (u32 == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *u32 = val;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1166,
              0
            ],
            [
              1182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_u32",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_bin_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, unsigned char *val,\n                                      size_t len)\n{\n  unsigned char **bin;\n  size_t         *bin_len = NULL;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BIN &&\n      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BINP &&\n      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {\n    return ARES_EFORMERR;\n  }\n\n  if (ares_dns_rr_key_datatype(key) == ARES_DATATYPE_ABINP) {\n    ares_dns_multistring_t **strs = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n    if (strs == NULL) {\n      return ARES_EFORMERR;\n    }\n\n    if (*strs == NULL) {\n      *strs = ares_dns_multistring_create();\n      if (*strs == NULL) {\n        return ARES_ENOMEM;\n      }\n    }\n\n    /* Clear all existing entries as this is an override */\n    ares_dns_multistring_clear(*strs);\n\n    return ares_dns_multistring_add_own(*strs, val, len);\n  }\n\n  bin = ares_dns_rr_data_ptr(dns_rr, key, &bin_len);\n  if (bin == NULL || bin_len == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*bin) {\n    ares_free(*bin);\n  }\n  *bin     = val;\n  *bin_len = len;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1184,
              0
            ],
            [
              1228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_bin_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_bin(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  const unsigned char *val, size_t len)\n{\n  ares_status_t       status;\n  ares_dns_datatype_t datatype = ares_dns_rr_key_datatype(key);\n  ares_bool_t         is_nullterm =\n    (datatype == ARES_DATATYPE_BINP || datatype == ARES_DATATYPE_ABINP)\n              ? ARES_TRUE\n              : ARES_FALSE;\n  size_t         alloclen = is_nullterm ? len + 1 : len;\n  unsigned char *temp     = ares_malloc(alloclen);\n\n  if (temp == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  memcpy(temp, val, len);\n\n  /* NULL-term BINP */\n  if (is_nullterm) {\n    temp[len] = 0;\n  }\n\n  status = ares_dns_rr_set_bin_own(dns_rr, key, temp, len);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1230,
              0
            ],
            [
              1259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_str_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, char *val)\n{\n  char **str;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_STR &&\n      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_NAME) {\n    return ARES_EFORMERR;\n  }\n\n  str = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (str == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*str) {\n    ares_free(*str);\n  }\n  *str = val;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1261,
              0
            ],
            [
              1282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_str_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_str(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  const char *val)\n{\n  ares_status_t status;\n  char         *temp = NULL;\n\n  if (val != NULL) {\n    temp = ares_strdup(val);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  status = ares_dns_rr_set_str_own(dns_rr, key, temp);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1284,
              0
            ],
            [
              1303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_abin_own(ares_dns_rr_t          *dns_rr,\n                                       ares_dns_rr_key_t       key,\n                                       ares_dns_multistring_t *strs)\n{\n  ares_dns_multistring_t **strs_ptr;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {\n    return ARES_EFORMERR;\n  }\n\n  strs_ptr = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (strs_ptr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*strs_ptr != NULL) {\n    ares_dns_multistring_destroy(*strs_ptr);\n  }\n  *strs_ptr = strs;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1305,
              0
            ],
            [
              1326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_abin_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "strs": "ares_dns_multistring_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void ares_dns_opt_free_cb(void *arg)\n{\n  ares_dns_optval_t *opt = arg;\n  if (opt == NULL) {\n    return;\n  }\n  ares_free(opt->val);\n}",
          "fn_code_pos": [
            [
              1328,
              0
            ],
            [
              1335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_free_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_opt_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, unsigned short opt,\n                                      unsigned char *val, size_t val_len)\n{\n  ares_array_t     **options;\n  ares_dns_optval_t *optptr = NULL;\n  size_t             idx;\n  size_t             cnt;\n  ares_status_t      status;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return ARES_EFORMERR;\n  }\n\n  options = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (options == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*options == NULL) {\n    *options =\n      ares_array_create(sizeof(ares_dns_optval_t), ares_dns_opt_free_cb);\n  }\n  if (*options == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  cnt = ares_array_len(*options);\n  for (idx = 0; idx < cnt; idx++) {\n    optptr = ares_array_at(*options, idx);\n    if (optptr == NULL) {\n      return ARES_EFORMERR;\n    }\n    if (optptr->opt == opt) {\n      break;\n    }\n  }\n\n  /* Duplicate entry, replace */\n  if (idx != cnt && optptr != NULL) {\n    goto done;\n  }\n\n  status = ares_array_insert_last((void **)&optptr, *options);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\ndone:\n  ares_free(optptr->val);\n  optptr->opt     = opt;\n  optptr->val     = val;\n  optptr->val_len = val_len;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1337,
              0
            ],
            [
              1392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_opt_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_opt(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  unsigned short opt, const unsigned char *val,\n                                  size_t val_len)\n{\n  unsigned char *temp = NULL;\n  ares_status_t  status;\n\n  if (val != NULL) {\n    temp = ares_malloc(val_len + 1);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n    memcpy(temp, val, val_len);\n    temp[val_len] = 0;\n  }\n\n  status = ares_dns_rr_set_opt_own(dns_rr, key, opt, temp, val_len);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1394,
              0
            ],
            [
              1416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_opt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_del_opt_byid(ares_dns_rr_t    *dns_rr,\n                                       ares_dns_rr_key_t key,\n                                       unsigned short    opt)\n{\n  ares_array_t           **options;\n  const ares_dns_optval_t *optptr;\n  size_t                   idx;\n  size_t                   cnt;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return ARES_EFORMERR;\n  }\n\n  options = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (options == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* No options */\n  if (*options == NULL) {\n    return ARES_SUCCESS;\n  }\n\n  cnt = ares_array_len(*options);\n  for (idx = 0; idx < cnt; idx++) {\n    optptr = ares_array_at_const(*options, idx);\n    if (optptr == NULL) {\n      return ARES_ENOTFOUND;\n    }\n    if (optptr->opt == opt) {\n      return ares_array_remove_at(*options, idx);\n    }\n  }\n\n  return ARES_ENOTFOUND;\n}",
          "fn_code_pos": [
            [
              1418,
              0
            ],
            [
              1453,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_del_opt_byid",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "char *ares_dns_addr_to_ptr(const struct ares_addr *addr)\n{\n  ares_buf_t                *buf     = NULL;\n  const unsigned char       *ptr     = NULL;\n  size_t                     ptr_len = 0;\n  size_t                     i;\n  ares_status_t              status;\n  static const unsigned char hexbytes[] = \"0123456789abcdef\";\n\n  if (addr->family != AF_INET && addr->family != AF_INET6) {\n    goto fail;\n  }\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    goto fail;\n  }\n\n  if (addr->family == AF_INET) {\n    ptr     = (const unsigned char *)&addr->addr.addr4;\n    ptr_len = 4;\n  } else {\n    ptr     = (const unsigned char *)&addr->addr.addr6;\n    ptr_len = 16;\n  }\n\n  for (i = ptr_len; i > 0; i--) {\n    if (addr->family == AF_INET) {\n      status = ares_buf_append_num_dec(buf, (size_t)ptr[i - 1], 0);\n    } else {\n      unsigned char c;\n\n      c      = ptr[i - 1] & 0xF;\n      status = ares_buf_append_byte(buf, hexbytes[c]);\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n\n      status = ares_buf_append_byte(buf, '.');\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n\n      c      = (ptr[i - 1] >> 4) & 0xF;\n      status = ares_buf_append_byte(buf, hexbytes[c]);\n    }\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    status = ares_buf_append_byte(buf, '.');\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  if (addr->family == AF_INET) {\n    status = ares_buf_append(buf, (const unsigned char *)\"in-addr.arpa\", 12);\n  } else {\n    status = ares_buf_append(buf, (const unsigned char *)\"ip6.arpa\", 8);\n  }\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  return ares_buf_finish_str(buf, NULL);\n\nfail:\n  ares_buf_destroy(buf);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              1455,
              0
            ],
            [
              1525,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_addr_to_ptr",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_dns_rr_t *ares_dns_get_opt_rr(ares_dns_record_t *rec)\n{\n  size_t i;\n  for (i = 0; i < ares_dns_record_rr_cnt(rec, ARES_SECTION_ADDITIONAL); i++) {\n    ares_dns_rr_t *rr = ares_dns_record_rr_get(rec, ARES_SECTION_ADDITIONAL, i);\n\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      return rr;\n    }\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              1527,
              0
            ],
            [
              1538,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_get_opt_rr",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "const ares_dns_rr_t *ares_dns_get_opt_rr_const(const ares_dns_record_t *rec)\n{\n  size_t i;\n  for (i = 0; i < ares_dns_record_rr_cnt(rec, ARES_SECTION_ADDITIONAL); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get_const(rec, ARES_SECTION_ADDITIONAL, i);\n\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      return rr;\n    }\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              1540,
              0
            ],
            [
              1552,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_get_opt_rr_const",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "ares_status_t\n  ares_dns_record_create_query(ares_dns_record_t **dnsrec, const char *name,\n                               ares_dns_class_t    dnsclass,\n                               ares_dns_rec_type_t type, unsigned short id,\n                               ares_dns_flags_t flags, size_t max_udp_size)\n{\n  ares_status_t  status;\n  ares_dns_rr_t *rr = NULL;\n\n  if (dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dnsrec = NULL;\n\n  /* Per RFC 7686, reject queries for \".onion\" domain names with NXDOMAIN */\n  if (ares_is_onion_domain(name)) {\n    status = ARES_ENOTFOUND;\n    goto done;\n  }\n\n  status = ares_dns_record_create(dnsrec, id, (unsigned short)flags,\n                                  ARES_OPCODE_QUERY, ARES_RCODE_NOERROR);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_record_query_add(*dnsrec, name, type, dnsclass);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* max_udp_size > 0 indicates EDNS, so send OPT RR as an additional record */\n  if (max_udp_size > 0) {\n    /* max_udp_size must fit into a 16 bit unsigned integer field on the OPT\n     * RR, so check here that it fits\n     */\n    if (max_udp_size > 65535) {\n      status = ARES_EFORMERR;\n      goto done;\n    }\n\n    status = ares_dns_record_rr_add(&rr, *dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n                                    ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE,\n                                 (unsigned short)max_udp_size);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS, 0);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_dns_record_destroy(*dnsrec);\n    *dnsrec = NULL;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              1557,
              0
            ],
            [
              1628,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_create_query",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "id": "unsigned short",
              "flags": "ares_dns_flags_t",
              "max_udp_size": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_duplicate_ex(ares_dns_record_t      **dest,\n                                           const ares_dns_record_t *src)\n{\n  unsigned char *data     = NULL;\n  size_t         data_len = 0;\n  ares_status_t  status;\n\n  if (dest == NULL || src == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dest = NULL;\n\n  status = ares_dns_write(src, &data, &data_len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse(data, data_len, 0, dest);\n  ares_free(data);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1630,
              0
            ],
            [
              1652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_duplicate_ex",
            "parameters": {
              "dest": "ares_dns_record_t",
              "src": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_record_t *ares_dns_record_duplicate(const ares_dns_record_t *dnsrec)\n{\n  ares_dns_record_t *dest = NULL;\n\n  ares_dns_record_duplicate_ex(&dest, dnsrec);\n  return dest;\n}",
          "fn_code_pos": [
            [
              1654,
              0
            ],
            [
              1660,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_duplicate",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_record_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_rr_free(ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              31,
              12
            ],
            [
              31,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_free",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_dns_record_rr_get(ares_dns_record_t *dnsrec,\n                                      ares_dns_section_t sect, size_t idx)",
          "fn_dec_pos": [
            [
              473,
              15
            ],
            [
              474,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_get",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_record_rr_get_const(const ares_dns_record_t *dnsrec,\n                               ares_dns_section_t sect, size_t idx)",
          "fn_dec_pos": [
            [
              498,
              2
            ],
            [
              499,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_get_const",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_name(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              504,
              12
            ],
            [
              504,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_name",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_data_ptr(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  size_t **lenptr)",
          "fn_dec_pos": [
            [
              536,
              13
            ],
            [
              537,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_data_ptr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "lenptr": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_data_ptr_const(const ares_dns_rr_t *dns_rr,\n                                              ares_dns_rr_key_t    key,\n                                              const size_t       **lenptr)",
          "fn_dec_pos": [
            [
              738,
              19
            ],
            [
              740,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_data_ptr_const",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "lenptr": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_addr(const ares_dns_rr_t *dns_rr,\n                                           ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              747,
              22
            ],
            [
              748,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_addr6(const ares_dns_rr_t *dns_rr,\n                                                  ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              764,
              28
            ],
            [
              765,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_bin(const ares_dns_rr_t *dns_rr,\n                                         ares_dns_rr_key_t key, size_t *len)",
          "fn_dec_pos": [
            [
              832,
              21
            ],
            [
              833,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_abin(const ares_dns_rr_t *dns_rr,\n                                          ares_dns_rr_key_t key, size_t idx,\n                                          size_t *len)",
          "fn_dec_pos": [
            [
              889,
              21
            ],
            [
              891,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_abin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_str(const ares_dns_rr_t *dns_rr,\n                                ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              971,
              12
            ],
            [
              972,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_addr_to_ptr(const struct ares_addr *addr)",
          "fn_dec_pos": [
            [
              1455,
              6
            ],
            [
              1455,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_addr_to_ptr",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_get_opt_rr(ares_dns_record_t *rec)",
          "fn_dec_pos": [
            [
              1527,
              15
            ],
            [
              1527,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_get_opt_rr",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_get_opt_rr_const(const ares_dns_record_t *rec)",
          "fn_dec_pos": [
            [
              1540,
              21
            ],
            [
              1540,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_get_opt_rr_const",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_record_duplicate(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              1654,
              19
            ],
            [
              1654,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_duplicate",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct in_addr",
          {},
          "",
          [
            747,
            6
          ],
          [
            747,
            20
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            750,
            8
          ],
          [
            750,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            764,
            6
          ],
          [
            764,
            26
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            767,
            8
          ],
          [
            767,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1094,
            41
          ],
          [
            1094,
            55
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1096,
            2
          ],
          [
            1096,
            16
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            1113,
            42
          ],
          [
            1113,
            62
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            1115,
            2
          ],
          [
            1115,
            22
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            1455,
            33
          ],
          [
            1455,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_htable_dict.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_htable_dict_destroy(ares_htable_dict_t *htable)\n{\n  if (htable == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_destroy",
            "parameters": {
              "htable": "ares_htable_dict_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  return ares_htable_hash_FNV1a_casecmp(key, ares_strlen(key), seed);\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares_htable_dict_bucket_t *arg = bucket;\n  return arg->key;\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares_htable_dict_bucket_t *arg = bucket;\n\n  ares_free(arg->key);\n  ares_free(arg->val);\n\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  return ares_strcaseeq(key1, key2);\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_dict_t *ares_htable_dict_create(void)\n{\n  ares_htable_dict_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return htable;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  if (htable) {\n    ares_htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_create",
            "parameters": {},
            "return_type": "ares_htable_dict_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_dict_insert(ares_htable_dict_t *htable, const char *key,\n                                    const char *val)\n{\n  ares_htable_dict_bucket_t *bucket = NULL;\n\n  if (htable == NULL || ares_strlen(key) == 0) {\n    goto fail;\n  }\n\n  bucket = ares_malloc_zero(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail;\n  }\n\n  bucket->parent = htable;\n  bucket->key    = ares_strdup(key);\n  if (bucket->key == NULL) {\n    goto fail;\n  }\n\n  if (val != NULL) {\n    bucket->val = ares_strdup(val);\n    if (bucket->val == NULL) {\n      goto fail;\n    }\n  }\n\n  if (!ares_htable_insert(htable->hash, bucket)) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket->val);\n    ares_free(bucket);\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_insert",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char",
              "val": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_dict_get(const ares_htable_dict_t *htable,\n                                 const char *key, const char **val)\n{\n  const ares_htable_dict_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares_htable_get(htable->hash, key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_get",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char",
              "val": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "const char *ares_htable_dict_get_direct(const ares_htable_dict_t *htable,\n                                        const char               *key)\n{\n  const char *val = NULL;\n  ares_htable_dict_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_get_direct",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_dict_remove(ares_htable_dict_t *htable, const char *key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares_htable_remove(htable->hash, key);\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_remove",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_htable_dict_num_keys(const ares_htable_dict_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares_htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              187,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_num_keys",
            "parameters": {
              "htable": "ares_htable_dict_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "char **ares_htable_dict_keys(const ares_htable_dict_t *htable, size_t *num)\n{\n  const void **buckets = NULL;\n  size_t       cnt     = 0;\n  char       **out     = NULL;\n  size_t       i;\n\n  if (htable == NULL || num == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *num = 0;\n\n  buckets = ares_htable_all_buckets(htable->hash, &cnt);\n  if (buckets == NULL || cnt == 0) {\n    return NULL;\n  }\n\n  out = ares_malloc_zero(sizeof(*out) * cnt);\n  if (out == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (i = 0; i < cnt; i++) {\n    out[i] = ares_strdup(((const ares_htable_dict_bucket_t *)buckets[i])->key);\n    if (out[i] == NULL) {\n      goto fail;\n    }\n  }\n\n  ares_free(buckets);\n  *num = cnt;\n  return out;\n\nfail:\n  *num = 0;\n  ares_free_array(out, cnt, ares_free);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              54,
              19
            ],
            [
              54,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_dict_create(void)",
          "fn_dec_pos": [
            [
              75,
              20
            ],
            [
              75,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_dict_get_direct(const ares_htable_dict_t *htable,\n                                        const char               *key)",
          "fn_dec_pos": [
            [
              164,
              12
            ],
            [
              165,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_get_direct",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_dict_keys(const ares_htable_dict_t *htable, size_t *num)",
          "fn_dec_pos": [
            [
              189,
              7
            ],
            [
              189,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_keys",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "num": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_dict {\n  ares_htable_t *hash;\n}",
          {
            "*hash": "ares_htable_t"
          },
          "ares_htable_dict",
          [
            29,
            0
          ],
          [
            31,
            1
          ]
        ],
        [
          "typedef struct {\n  char               *key;\n  char               *val;\n  ares_htable_dict_t *parent;\n} ares_htable_dict_bucket_t;",
          {
            "*key": "char",
            "*val": "char",
            "*parent": "ares_htable_dict_t"
          },
          "ares_htable_dict_bucket_t",
          [
            33,
            0
          ],
          [
            37,
            28
          ]
        ],
        [
          "struct ares_htable_dict {\n  ares_htable_t *hash;\n}",
          {
            "*hash": "ares_htable_t"
          },
          "ares_htable_dict",
          [
            29,
            0
          ],
          [
            31,
            1
          ]
        ],
        [
          "typedef struct {\n  char               *key;\n  char               *val;\n  ares_htable_dict_t *parent;\n} ares_htable_dict_bucket_t;",
          {
            "*key": "char",
            "*val": "char",
            "*parent": "ares_htable_dict_t"
          },
          "ares_htable_dict_bucket_t",
          [
            33,
            0
          ],
          [
            37,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_htable.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_htable_dict.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_htable.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned int ares_htable_generate_seed(ares_htable_t *htable)\n{\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  /* Seed needs to be static for fuzzing */\n  return 0;\n#else\n  unsigned int seed = 0;\n  time_t       t    = time(NULL);\n\n  /* Mix stack address, heap address, and time to generate a random seed, it\n   * doesn't have to be super secure, just quick.  Likelihood of a hash\n   * collision attack is very low with a small amount of effort */\n  seed |= (unsigned int)((size_t)htable & 0xFFFFFFFF);\n  seed |= (unsigned int)((size_t)&seed & 0xFFFFFFFF);\n  seed |= (unsigned int)(((ares_uint64_t)t) & 0xFFFFFFFF);\n  return seed;\n#endif\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_generate_seed",
            "parameters": {
              "htable": "ares_htable_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void ares_htable_buckets_destroy(ares_llist_t **buckets,\n                                        unsigned int   size,\n                                        ares_bool_t    destroy_vals)\n{\n  unsigned int i;\n\n  if (buckets == NULL) {\n    return;\n  }\n\n  for (i = 0; i < size; i++) {\n    if (buckets[i] == NULL) {\n      continue;\n    }\n\n    if (!destroy_vals) {\n      ares_llist_replace_destructor(buckets[i], NULL);\n    }\n\n    ares_llist_destroy(buckets[i]);\n  }\n\n  ares_free(buckets);\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_buckets_destroy",
            "parameters": {
              "buckets": "ares_llist_t",
              "size": "unsigned int",
              "destroy_vals": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_htable_destroy(ares_htable_t *htable)\n{\n  if (htable == NULL) {\n    return;\n  }\n  ares_htable_buckets_destroy(htable->buckets, htable->size, ARES_TRUE);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_destroy",
            "parameters": {
              "htable": "ares_htable_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_htable_t *ares_htable_create(ares_htable_hashfunc_t    hash_func,\n                                  ares_htable_bucket_key_t  bucket_key,\n                                  ares_htable_bucket_free_t bucket_free,\n                                  ares_htable_key_eq_t      key_eq)\n{\n  ares_htable_t *htable = NULL;\n\n  if (hash_func == NULL || bucket_key == NULL || bucket_free == NULL ||\n      key_eq == NULL) {\n    goto fail;\n  }\n\n  htable = ares_malloc_zero(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  htable->hash        = hash_func;\n  htable->bucket_key  = bucket_key;\n  htable->bucket_free = bucket_free;\n  htable->key_eq      = key_eq;\n  htable->seed        = ares_htable_generate_seed(htable);\n  htable->size        = ARES__HTABLE_MIN_BUCKETS;\n  htable->buckets = ares_malloc_zero(sizeof(*htable->buckets) * htable->size);\n\n  if (htable->buckets == NULL) {\n    goto fail;\n  }\n\n  return htable;\n\nfail:\n  ares_htable_destroy(htable);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              104,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_create",
            "parameters": {
              "hash_func": "ares_htable_hashfunc_t",
              "bucket_key": "ares_htable_bucket_key_t",
              "bucket_free": "ares_htable_bucket_free_t",
              "key_eq": "ares_htable_key_eq_t"
            },
            "return_type": "ares_htable_t"
          }
        },
        {
          "fn_code": "const void **ares_htable_all_buckets(const ares_htable_t *htable, size_t *num)\n{\n  const void **out = NULL;\n  size_t       cnt = 0;\n  size_t       i;\n\n  if (htable == NULL || num == NULL) {\n    return NULL; /* LCOV_EXCL_LINE */\n  }\n\n  *num = 0;\n\n  out = ares_malloc_zero(sizeof(*out) * htable->num_keys);\n  if (out == NULL) {\n    return NULL; /* LCOV_EXCL_LINE */\n  }\n\n  for (i = 0; i < htable->size; i++) {\n    ares_llist_node_t *node;\n    for (node = ares_llist_node_first(htable->buckets[i]); node != NULL;\n         node = ares_llist_node_next(node)) {\n      out[cnt++] = ares_llist_node_val(node);\n    }\n  }\n\n  *num = cnt;\n  return out;\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_llist_node_t *ares_htable_find(const ares_htable_t *htable,\n                                           unsigned int idx, const void *key)\n{\n  ares_llist_node_t *node = NULL;\n\n  for (node = ares_llist_node_first(htable->buckets[idx]); node != NULL;\n       node = ares_llist_node_next(node)) {\n    if (htable->key_eq(key, htable->bucket_key(ares_llist_node_val(node)))) {\n      break;\n    }\n  }\n\n  return node;\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_find",
            "parameters": {
              "htable": "ares_htable_t",
              "idx": "unsigned int",
              "key": "void"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_htable_expand(ares_htable_t *htable)\n{\n  ares_llist_t **buckets  = NULL;\n  unsigned int   old_size = htable->size;\n  size_t         i;\n  ares_llist_t **prealloc_llist     = NULL;\n  size_t         prealloc_llist_len = 0;\n  ares_bool_t    rv                 = ARES_FALSE;\n\n  /* Not a failure, just won't expand */\n  if (old_size == ARES__HTABLE_MAX_BUCKETS) {\n    return ARES_TRUE; /* LCOV_EXCL_LINE */\n  }\n\n  htable->size <<= 1;\n\n  /* We must pre-allocate all memory we'll need before moving entries to the\n   * new hash array.  Otherwise if there's a memory allocation failure in the\n   * middle, we wouldn't be able to recover. */\n  buckets = ares_malloc_zero(sizeof(*buckets) * htable->size);\n  if (buckets == NULL) {\n    goto done; /* LCOV_EXCL_LINE */\n  }\n\n  /* The maximum number of new llists we'll need is the number of collisions\n   * that were recorded */\n  prealloc_llist_len = htable->num_collisions;\n  if (prealloc_llist_len) {\n    prealloc_llist =\n      ares_malloc_zero(sizeof(*prealloc_llist) * prealloc_llist_len);\n    if (prealloc_llist == NULL) {\n      goto done; /* LCOV_EXCL_LINE */\n    }\n  }\n  for (i = 0; i < prealloc_llist_len; i++) {\n    prealloc_llist[i] = ares_llist_create(htable->bucket_free);\n    if (prealloc_llist[i] == NULL) {\n      goto done;\n    }\n  }\n\n  /* Iterate across all buckets and move the entries to the new buckets */\n  htable->num_collisions = 0;\n  for (i = 0; i < old_size; i++) {\n    ares_llist_node_t *node;\n\n    /* Nothing in this bucket */\n    if (htable->buckets[i] == NULL) {\n      continue;\n    }\n\n    /* Fast path optimization (most likely case), there is likely only a single\n     * entry in both the source and destination, check for this to confirm and\n     * if so, just move the bucket over */\n    if (ares_llist_len(htable->buckets[i]) == 1) {\n      const void *val = ares_llist_first_val(htable->buckets[i]);\n      size_t      idx = HASH_IDX(htable, htable->bucket_key(val));\n\n      if (buckets[idx] == NULL) {\n        /* Swap! */\n        buckets[idx]       = htable->buckets[i];\n        htable->buckets[i] = NULL;\n        continue;\n      }\n    }\n\n    /* Slow path, collisions */\n    while ((node = ares_llist_node_first(htable->buckets[i])) != NULL) {\n      const void *val = ares_llist_node_val(node);\n      size_t      idx = HASH_IDX(htable, htable->bucket_key(val));\n\n      /* Try fast path again as maybe we popped one collision off and the\n       * next we can reuse the llist parent */\n      if (buckets[idx] == NULL && ares_llist_len(htable->buckets[i]) == 1) {\n        /* Swap! */\n        buckets[idx]       = htable->buckets[i];\n        htable->buckets[i] = NULL;\n        break;\n      }\n\n      /* Grab one off our preallocated list */\n      if (buckets[idx] == NULL) {\n        /* Silence static analysis, this isn't possible but it doesn't know */\n        if (prealloc_llist == NULL || prealloc_llist_len == 0) {\n          goto done; /* LCOV_EXCL_LINE */\n        }\n        buckets[idx] = prealloc_llist[prealloc_llist_len - 1];\n        prealloc_llist_len--;\n      } else {\n        /* Collision occurred since the bucket wasn't empty */\n        htable->num_collisions++;\n      }\n\n      ares_llist_node_mvparent_first(node, buckets[idx]);\n    }\n\n    /* Abandoned bucket, destroy */\n    if (htable->buckets[i] != NULL) {\n      ares_llist_destroy(htable->buckets[i]);\n      htable->buckets[i] = NULL;\n    }\n  }\n\n  /* We have guaranteed all the buckets have either been moved or destroyed,\n   * so we just call ares_free() on the array and swap out the pointer */\n  ares_free(htable->buckets);\n  htable->buckets = buckets;\n  buckets         = NULL;\n  rv              = ARES_TRUE;\n\ndone:\n  ares_free(buckets);\n  /* destroy any unused preallocated buckets */\n  ares_htable_buckets_destroy(prealloc_llist, (unsigned int)prealloc_llist_len,\n                              ARES_FALSE);\n\n  /* On failure, we need to restore the htable size */\n  if (rv != ARES_TRUE) {\n    htable->size = old_size; /* LCOV_EXCL_LINE */\n  }\n\n  return rv;\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_expand",
            "parameters": {
              "htable": "ares_htable_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_insert(ares_htable_t *htable, void *bucket)\n{\n  unsigned int       idx  = 0;\n  ares_llist_node_t *node = NULL;\n  const void        *key  = NULL;\n\n  if (htable == NULL || bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n\n  key = htable->bucket_key(bucket);\n  idx = HASH_IDX(htable, key);\n\n  /* See if we have a matching bucket already, if so, replace it */\n  node = ares_htable_find(htable, idx, key);\n  if (node != NULL) {\n    ares_llist_node_replace(node, bucket);\n    return ARES_TRUE;\n  }\n\n  /* Check to see if we should rehash because likelihood of collisions has\n   * increased beyond our threshold */\n  if (htable->num_keys + 1 >\n      (htable->size * ARES__HTABLE_EXPAND_PERCENT) / 100) {\n    if (!ares_htable_expand(htable)) {\n      return ARES_FALSE; /* LCOV_EXCL_LINE */\n    }\n    /* If we expanded, need to calculate a new index */\n    idx = HASH_IDX(htable, key);\n  }\n\n  /* We lazily allocate the linked list */\n  if (htable->buckets[idx] == NULL) {\n    htable->buckets[idx] = ares_llist_create(htable->bucket_free);\n    if (htable->buckets[idx] == NULL) {\n      return ARES_FALSE;\n    }\n  }\n\n  node = ares_llist_insert_first(htable->buckets[idx], bucket);\n  if (node == NULL) {\n    return ARES_FALSE;\n  }\n\n  /* Track collisions for rehash stability */\n  if (ares_llist_len(htable->buckets[idx]) > 1) {\n    htable->num_collisions++;\n  }\n\n  htable->num_keys++;\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              315,
              0
            ],
            [
              368,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_insert",
            "parameters": {
              "htable": "ares_htable_t",
              "bucket": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares_htable_get(const ares_htable_t *htable, const void *key)\n{\n  unsigned int idx;\n\n  if (htable == NULL || key == NULL) {\n    return NULL;\n  }\n\n  idx = HASH_IDX(htable, key);\n\n  return ares_llist_node_val(ares_htable_find(htable, idx, key));\n}",
          "fn_code_pos": [
            [
              370,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_get",
            "parameters": {
              "htable": "ares_htable_t",
              "key": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_remove(ares_htable_t *htable, const void *key)\n{\n  ares_llist_node_t *node;\n  unsigned int       idx;\n\n  if (htable == NULL || key == NULL) {\n    return ARES_FALSE;\n  }\n\n  idx  = HASH_IDX(htable, key);\n  node = ares_htable_find(htable, idx, key);\n  if (node == NULL) {\n    return ARES_FALSE;\n  }\n\n  htable->num_keys--;\n\n  /* Reduce collisions */\n  if (ares_llist_len(ares_llist_node_parent(node)) > 1) {\n    htable->num_collisions--;\n  }\n\n  ares_llist_node_destroy(node);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              383,
              0
            ],
            [
              407,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_remove",
            "parameters": {
              "htable": "ares_htable_t",
              "key": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_htable_num_keys(const ares_htable_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return htable->num_keys;\n}",
          "fn_code_pos": [
            [
              409,
              0
            ],
            [
              415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_num_keys",
            "parameters": {
              "htable": "ares_htable_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "unsigned int ares_htable_hash_FNV1a(const unsigned char *key, size_t key_len,\n                                    unsigned int seed)\n{\n  unsigned int hv = seed ^ 2166136261U;\n  size_t       i;\n\n  for (i = 0; i < key_len; i++) {\n    hv ^= (unsigned int)key[i];\n    /* hv *= 16777619 (0x01000193) */\n    hv += (hv << 1) + (hv << 4) + (hv << 7) + (hv << 8) + (hv << 24);\n  }\n\n  return hv;\n}",
          "fn_code_pos": [
            [
              417,
              0
            ],
            [
              430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_hash_FNV1a",
            "parameters": {
              "key": "unsigned char",
              "key_len": "size_t",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int ares_htable_hash_FNV1a_casecmp(const unsigned char *key,\n                                            size_t key_len, unsigned int seed)\n{\n  unsigned int hv = seed ^ 2166136261U;\n  size_t       i;\n\n  for (i = 0; i < key_len; i++) {\n    hv ^= (unsigned int)ares_tolower(key[i]);\n    /* hv *= 16777619 (0x01000193) */\n    hv += (hv << 1) + (hv << 4) + (hv << 7) + (hv << 8) + (hv << 24);\n  }\n\n  return hv;\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_hash_FNV1a_casecmp",
            "parameters": {
              "key": "unsigned char",
              "key_len": "size_t",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_htable_create(ares_htable_hashfunc_t    hash_func,\n                                  ares_htable_bucket_key_t  bucket_key,\n                                  ares_htable_bucket_free_t bucket_free,\n                                  ares_htable_key_eq_t      key_eq)",
          "fn_dec_pos": [
            [
              104,
              15
            ],
            [
              107,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_create",
            "parameters": {
              "hash_func": "ares_htable_hashfunc_t",
              "bucket_key": "ares_htable_bucket_key_t",
              "bucket_free": "ares_htable_bucket_free_t",
              "key_eq": "ares_htable_key_eq_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_all_buckets(const ares_htable_t *htable, size_t *num)",
          "fn_dec_pos": [
            [
              140,
              13
            ],
            [
              140,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_all_buckets",
            "parameters": {
              "htable": "ares_htable_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_find(const ares_htable_t *htable,\n                                           unsigned int idx, const void *key)",
          "fn_dec_pos": [
            [
              176,
              26
            ],
            [
              177,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_find",
            "parameters": {
              "htable": "ares_htable_t",
              "idx": "unsigned int",
              "key": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_get(const ares_htable_t *htable, const void *key)",
          "fn_dec_pos": [
            [
              370,
              6
            ],
            [
              370,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_get",
            "parameters": {
              "htable": "ares_htable_t",
              "key": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable {\n  ares_htable_hashfunc_t    hash;\n  ares_htable_bucket_key_t  bucket_key;\n  ares_htable_bucket_free_t bucket_free;\n  ares_htable_key_eq_t      key_eq;\n  unsigned int              seed;\n  unsigned int              size;\n  size_t                    num_keys;\n  size_t                    num_collisions;\n  /* NOTE: if we converted buckets into ares_slist_t we could guarantee on\n   *       hash collisions we would have O(log n) worst case insert and search\n   *       performance.  (We'd also need to make key_eq into a key_cmp to\n   *       support sort).  That said, risk with a random hash seed is near zero,\n   *       and ares_slist_t is heavier weight, so I think using ares_llist_t\n   *       is an overall win. */\n  ares_llist_t            **buckets;\n}",
          {
            "hash": "ares_htable_hashfunc_t",
            "bucket_key": "ares_htable_bucket_key_t",
            "bucket_free": "ares_htable_bucket_free_t",
            "key_eq": "ares_htable_key_eq_t",
            "seed": "unsigned int",
            "size": "unsigned int",
            "num_keys": "size_t",
            "num_collisions": "size_t",
            "**buckets": "ares_llist_t"
          },
          "ares_htable",
          [
            33,
            0
          ],
          [
            49,
            1
          ]
        ],
        [
          "struct ares_htable {\n  ares_htable_hashfunc_t    hash;\n  ares_htable_bucket_key_t  bucket_key;\n  ares_htable_bucket_free_t bucket_free;\n  ares_htable_key_eq_t      key_eq;\n  unsigned int              seed;\n  unsigned int              size;\n  size_t                    num_keys;\n  size_t                    num_collisions;\n  /* NOTE: if we converted buckets into ares_slist_t we could guarantee on\n   *       hash collisions we would have O(log n) worst case insert and search\n   *       performance.  (We'd also need to make key_eq into a key_cmp to\n   *       support sort).  That said, risk with a random hash seed is near zero,\n   *       and ares_slist_t is heavier weight, so I think using ares_llist_t\n   *       is an overall win. */\n  ares_llist_t            **buckets;\n}",
          {
            "hash": "ares_htable_hashfunc_t",
            "bucket_key": "ares_htable_bucket_key_t",
            "bucket_free": "ares_htable_bucket_free_t",
            "key_eq": "ares_htable_key_eq_t",
            "seed": "unsigned int",
            "size": "unsigned int",
            "num_keys": "size_t",
            "num_collisions": "size_t",
            "**buckets": "ares_llist_t"
          },
          "ares_htable",
          [
            33,
            0
          ],
          [
            49,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_llist.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_htable.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_htable_vpvp.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_htable_vpvp_destroy(ares_htable_vpvp_t *htable)\n{\n  if (htable == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_destroy",
            "parameters": {
              "htable": "ares_htable_vpvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  return ares_htable_hash_FNV1a((const unsigned char *)&key, sizeof(key), seed);\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares_htable_vpvp_bucket_t *arg = bucket;\n  return arg->key;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares_htable_vpvp_bucket_t *arg = bucket;\n\n  if (arg->parent->free_key) {\n    arg->parent->free_key(arg->key);\n  }\n\n  if (arg->parent->free_val) {\n    arg->parent->free_val(arg->val);\n  }\n\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              75,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  if (key1 == key2) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_vpvp_t *\n  ares_htable_vpvp_create(ares_htable_vpvp_key_free_t key_free,\n                          ares_htable_vpvp_val_free_t val_free)\n{\n  ares_htable_vpvp_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  htable->free_key = key_free;\n  htable->free_val = val_free;\n\n  return htable;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  if (htable) {\n    ares_htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_create",
            "parameters": {
              "key_free": "ares_htable_vpvp_key_free_t",
              "val_free": "ares_htable_vpvp_val_free_t"
            },
            "return_type": "ares_htable_vpvp_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpvp_insert(ares_htable_vpvp_t *htable, void *key,\n                                    void *val)\n{\n  ares_htable_vpvp_bucket_t *bucket = NULL;\n\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  bucket = ares_malloc(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail;\n  }\n\n  bucket->parent = htable;\n  bucket->key    = key;\n  bucket->val    = val;\n\n  if (!ares_htable_insert(htable->hash, bucket)) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket);\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              115,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_insert",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpvp_get(const ares_htable_vpvp_t *htable,\n                                 const void *key, void **val)\n{\n  ares_htable_vpvp_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares_htable_get(htable->hash, key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_get",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares_htable_vpvp_get_direct(const ares_htable_vpvp_t *htable,\n                                  const void               *key)\n{\n  void *val = NULL;\n  ares_htable_vpvp_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_get_direct",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpvp_remove(ares_htable_vpvp_t *htable, const void *key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares_htable_remove(htable->hash, key);\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_remove",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_htable_vpvp_num_keys(const ares_htable_vpvp_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares_htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_num_keys",
            "parameters": {
              "htable": "ares_htable_vpvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              56,
              19
            ],
            [
              56,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_vpvp_create(ares_htable_vpvp_key_free_t key_free,\n                          ares_htable_vpvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              87,
              2
            ],
            [
              88,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_create",
            "parameters": {
              "key_free": "ares_htable_vpvp_key_free_t",
              "val_free": "ares_htable_vpvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_vpvp_get_direct(const ares_htable_vpvp_t *htable,\n                                  const void               *key)",
          "fn_dec_pos": [
            [
              170,
              6
            ],
            [
              171,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_get_direct",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_vpvp {\n  ares_htable_vpvp_key_free_t free_key;\n  ares_htable_vpvp_val_free_t free_val;\n  ares_htable_t              *hash;\n}",
          {
            "free_key": "ares_htable_vpvp_key_free_t",
            "free_val": "ares_htable_vpvp_val_free_t",
            "*hash": "ares_htable_t"
          },
          "ares_htable_vpvp",
          [
            29,
            0
          ],
          [
            33,
            1
          ]
        ],
        [
          "typedef struct {\n  void               *key;\n  void               *val;\n  ares_htable_vpvp_t *parent;\n} ares_htable_vpvp_bucket_t;",
          {
            "*key": "void",
            "*val": "void",
            "*parent": "ares_htable_vpvp_t"
          },
          "ares_htable_vpvp_bucket_t",
          [
            35,
            0
          ],
          [
            39,
            28
          ]
        ],
        [
          "struct ares_htable_vpvp {\n  ares_htable_vpvp_key_free_t free_key;\n  ares_htable_vpvp_val_free_t free_val;\n  ares_htable_t              *hash;\n}",
          {
            "free_key": "ares_htable_vpvp_key_free_t",
            "free_val": "ares_htable_vpvp_val_free_t",
            "*hash": "ares_htable_t"
          },
          "ares_htable_vpvp",
          [
            29,
            0
          ],
          [
            33,
            1
          ]
        ],
        [
          "typedef struct {\n  void               *key;\n  void               *val;\n  ares_htable_vpvp_t *parent;\n} ares_htable_vpvp_bucket_t;",
          {
            "*key": "void",
            "*val": "void",
            "*parent": "ares_htable_vpvp_t"
          },
          "ares_htable_vpvp_bucket_t",
          [
            35,
            0
          ],
          [
            39,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_htable.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_htable_vpvp.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_htable_asvp.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_htable_asvp_destroy(ares_htable_asvp_t *htable)\n{\n  if (htable == NULL) {\n    return;\n  }\n\n  ares_htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_destroy",
            "parameters": {
              "htable": "ares_htable_asvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  const ares_socket_t *arg = key;\n  return ares_htable_hash_FNV1a((const unsigned char *)arg, sizeof(*arg), seed);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares_htable_asvp_bucket_t *arg = bucket;\n  return &arg->key;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares_htable_asvp_bucket_t *arg = bucket;\n\n  if (arg->parent->free_val) {\n    arg->parent->free_val(arg->val);\n  }\n\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  const ares_socket_t *k1 = key1;\n  const ares_socket_t *k2 = key2;\n\n  if (*k1 == *k2) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_asvp_t *\n  ares_htable_asvp_create(ares_htable_asvp_val_free_t val_free)\n{\n  ares_htable_asvp_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail;\n  }\n\n  htable->free_val = val_free;\n\n  return htable;\n\nfail:\n  if (htable) {\n    ares_htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_create",
            "parameters": {
              "val_free": "ares_htable_asvp_val_free_t"
            },
            "return_type": "ares_htable_asvp_t"
          }
        },
        {
          "fn_code": "ares_socket_t *ares_htable_asvp_keys(const ares_htable_asvp_t *htable,\n                                     size_t                   *num)\n{\n  const void   **buckets = NULL;\n  size_t         cnt     = 0;\n  ares_socket_t *out     = NULL;\n  size_t         i;\n\n  if (htable == NULL || num == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *num = 0;\n\n  buckets = ares_htable_all_buckets(htable->hash, &cnt);\n  if (buckets == NULL || cnt == 0) {\n    return NULL;\n  }\n\n  out = ares_malloc_zero(sizeof(*out) * cnt);\n  if (out == NULL) {\n    ares_free(buckets); /* LCOV_EXCL_LINE: OutOfMemory */\n    return NULL;        /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (i = 0; i < cnt; i++) {\n    out[i] = ((const ares_htable_asvp_bucket_t *)buckets[i])->key;\n  }\n\n  ares_free(buckets);\n  *num = cnt;\n  return out;\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_keys",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "num": "size_t"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_asvp_insert(ares_htable_asvp_t *htable,\n                                    ares_socket_t key, void *val)\n{\n  ares_htable_asvp_bucket_t *bucket = NULL;\n\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  bucket = ares_malloc(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  bucket->parent = htable;\n  bucket->key    = key;\n  bucket->val    = val;\n\n  if (!ares_htable_insert(htable->hash, bucket)) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket); /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_insert",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_asvp_get(const ares_htable_asvp_t *htable,\n                                 ares_socket_t key, void **val)\n{\n  ares_htable_asvp_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares_htable_get(htable->hash, &key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_get",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares_htable_asvp_get_direct(const ares_htable_asvp_t *htable,\n                                  ares_socket_t             key)\n{\n  void *val = NULL;\n  ares_htable_asvp_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_get_direct",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_asvp_remove(ares_htable_asvp_t *htable,\n                                    ares_socket_t       key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares_htable_remove(htable->hash, &key);\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_remove",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_htable_asvp_num_keys(const ares_htable_asvp_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares_htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_num_keys",
            "parameters": {
              "htable": "ares_htable_asvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              56,
              19
            ],
            [
              56,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_asvp_create(ares_htable_asvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              86,
              2
            ],
            [
              86,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_create",
            "parameters": {
              "val_free": "ares_htable_asvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_asvp_keys(const ares_htable_asvp_t *htable,\n                                     size_t                   *num)",
          "fn_dec_pos": [
            [
              110,
              15
            ],
            [
              111,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_keys",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_asvp_get_direct(const ares_htable_asvp_t *htable,\n                                  ares_socket_t             key)",
          "fn_dec_pos": [
            [
              199,
              6
            ],
            [
              200,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_get_direct",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_asvp {\n  ares_htable_asvp_val_free_t free_val;\n  ares_htable_t              *hash;\n}",
          {
            "free_val": "ares_htable_asvp_val_free_t",
            "*hash": "ares_htable_t"
          },
          "ares_htable_asvp",
          [
            29,
            0
          ],
          [
            32,
            1
          ]
        ],
        [
          "typedef struct {\n  ares_socket_t       key;\n  void               *val;\n  ares_htable_asvp_t *parent;\n} ares_htable_asvp_bucket_t;",
          {
            "key": "ares_socket_t",
            "*val": "void",
            "*parent": "ares_htable_asvp_t"
          },
          "ares_htable_asvp_bucket_t",
          [
            34,
            0
          ],
          [
            38,
            28
          ]
        ],
        [
          "struct ares_htable_asvp {\n  ares_htable_asvp_val_free_t free_val;\n  ares_htable_t              *hash;\n}",
          {
            "free_val": "ares_htable_asvp_val_free_t",
            "*hash": "ares_htable_t"
          },
          "ares_htable_asvp",
          [
            29,
            0
          ],
          [
            32,
            1
          ]
        ],
        [
          "typedef struct {\n  ares_socket_t       key;\n  void               *val;\n  ares_htable_asvp_t *parent;\n} ares_htable_asvp_bucket_t;",
          {
            "key": "ares_socket_t",
            "*val": "void",
            "*parent": "ares_htable_asvp_t"
          },
          "ares_htable_asvp_bucket_t",
          [
            34,
            0
          ],
          [
            38,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_htable.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_htable_asvp.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_slist.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_slist_t *ares_slist_create(ares_rand_state        *rand_state,\n                                ares_slist_cmp_t        cmp,\n                                ares_slist_destructor_t destruct)\n{\n  ares_slist_t *list;\n\n  if (rand_state == NULL || cmp == NULL) {\n    return NULL;\n  }\n\n  list = ares_malloc_zero(sizeof(*list));\n\n  if (list == NULL) {\n    return NULL;\n  }\n\n  list->rand_state = rand_state;\n  list->cmp        = cmp;\n  list->destruct   = destruct;\n\n  list->levels = ARES__SLIST_START_LEVELS;\n  list->head   = ares_malloc_zero(sizeof(*list->head) * list->levels);\n  if (list->head == NULL) {\n    ares_free(list);\n    return NULL;\n  }\n\n  return list;\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "cmp": "ares_slist_cmp_t",
              "destruct": "ares_slist_destructor_t"
            },
            "return_type": "ares_slist_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_slist_coin_flip(ares_slist_t *list)\n{\n  size_t total_bits = sizeof(list->rand_data) * 8;\n  size_t bit;\n\n  /* Refill random data used for coin flips.  We pull this in 8 byte chunks.\n   * ares_rand_bytes() has some built-in caching of its own so we don't need\n   * to be excessive in caching ourselves.  Prefer to require less memory per\n   * skiplist */\n  if (list->rand_bits == 0) {\n    ares_rand_bytes(list->rand_state, list->rand_data, sizeof(list->rand_data));\n    list->rand_bits = total_bits;\n  }\n\n  bit = total_bits - list->rand_bits;\n  list->rand_bits--;\n\n  return (list->rand_data[bit / 8] & (1 << (bit % 8))) ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_coin_flip",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void ares_slist_replace_destructor(ares_slist_t           *list,\n                                   ares_slist_destructor_t destruct)\n{\n  if (list == NULL) {\n    return;\n  }\n\n  list->destruct = destruct;\n}",
          "fn_code_pos": [
            [
              104,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_replace_destructor",
            "parameters": {
              "list": "ares_slist_t",
              "destruct": "ares_slist_destructor_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_slist_max_level(const ares_slist_t *list)\n{\n  size_t max_level = 0;\n\n  if (list->cnt + 1 <= (1 << ARES__SLIST_START_LEVELS)) {\n    max_level = ARES__SLIST_START_LEVELS;\n  } else {\n    max_level = ares_log2(ares_round_up_pow2(list->cnt + 1));\n  }\n\n  if (list->levels > max_level) {\n    max_level = list->levels;\n  }\n\n  return max_level;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_max_level",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static size_t ares_slist_calc_level(ares_slist_t *list)\n{\n  size_t max_level = ares_slist_max_level(list);\n  size_t level;\n\n  for (level = 1; ares_slist_coin_flip(list) && level < max_level; level++)\n    ;\n\n  return level;\n}",
          "fn_code_pos": [
            [
              131,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_calc_level",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static void ares_slist_node_push(ares_slist_t *list, ares_slist_node_t *node)\n{\n  size_t             i;\n  ares_slist_node_t *left = NULL;\n\n  /* Scan from highest level in the slist, even if we're not using that number\n   * of levels for this entry as this is what makes it O(log n) */\n  for (i = list->levels; i-- > 0;) {\n    /* set left if left is NULL and the current node value is greater than the\n     * head at this level */\n    if (left == NULL && list->head[i] != NULL &&\n        list->cmp(node->data, list->head[i]->data) > 0) {\n      left = list->head[i];\n    }\n\n    if (left != NULL) {\n      /* scan forward to find our insertion point */\n      while (left->next[i] != NULL &&\n             list->cmp(node->data, left->next[i]->data) > 0) {\n        left = left->next[i];\n      }\n    }\n\n    /* search only as we didn't randomly select this number of levels */\n    if (i >= node->levels) {\n      continue;\n    }\n\n    if (left == NULL) {\n      /* head insertion */\n      node->next[i] = list->head[i];\n      node->prev[i] = NULL;\n      list->head[i] = node;\n    } else {\n      /* Chain */\n      node->next[i] = left->next[i];\n      node->prev[i] = left;\n      left->next[i] = node;\n    }\n\n    if (node->next[i] != NULL) {\n      /* chain prev */\n      node->next[i]->prev[i] = node;\n    } else {\n      if (i == 0) {\n        /* update tail */\n        list->tail = node;\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_push",
            "parameters": {
              "list": "ares_slist_t",
              "node": "ares_slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_slist_node_t *ares_slist_insert(ares_slist_t *list, void *val)\n{\n  ares_slist_node_t *node = NULL;\n\n  if (list == NULL || val == NULL) {\n    return NULL;\n  }\n\n  node = ares_malloc_zero(sizeof(*node));\n\n  if (node == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  node->data   = val;\n  node->parent = list;\n\n  /* Randomly determine the number of levels we want to use */\n  node->levels = ares_slist_calc_level(list);\n\n  /* Allocate array of next and prev nodes for linking each level */\n  node->next = ares_malloc_zero(sizeof(*node->next) * node->levels);\n  if (node->next == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  node->prev = ares_malloc_zero(sizeof(*node->prev) * node->levels);\n  if (node->prev == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* If the number of levels is greater than we currently support in the slist,\n   * increase the count */\n  if (list->levels < node->levels) {\n    void *ptr =\n      ares_realloc_zero(list->head, sizeof(*list->head) * list->levels,\n                        sizeof(*list->head) * node->levels);\n    if (ptr == NULL) {\n      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    list->head   = ptr;\n    list->levels = node->levels;\n  }\n\n  ares_slist_node_push(list, node);\n\n  list->cnt++;\n\n  return node;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  if (node) {\n    ares_free(node->prev);\n    ares_free(node->next);\n    ares_free(node);\n  }\n  return NULL;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_insert",
            "parameters": {
              "list": "ares_slist_t",
              "val": "void"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "static void ares_slist_node_pop(ares_slist_node_t *node)\n{\n  ares_slist_t *list = node->parent;\n  size_t        i;\n\n  /* relink each node at each level */\n  for (i = node->levels; i-- > 0;) {\n    if (node->next[i] == NULL) {\n      if (i == 0) {\n        list->tail = node->prev[0];\n      }\n    } else {\n      node->next[i]->prev[i] = node->prev[i];\n    }\n\n    if (node->prev[i] == NULL) {\n      list->head[i] = node->next[i];\n    } else {\n      node->prev[i]->next[i] = node->next[i];\n    }\n  }\n\n  memset(node->next, 0, sizeof(*node->next) * node->levels);\n  memset(node->prev, 0, sizeof(*node->prev) * node->levels);\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_pop",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_slist_node_claim(ares_slist_node_t *node)\n{\n  ares_slist_t *list;\n  void         *val;\n\n  if (node == NULL) {\n    return NULL;\n  }\n\n  list = node->parent;\n  val  = node->data;\n\n  ares_slist_node_pop(node);\n\n  ares_free(node->next);\n  ares_free(node->prev);\n  ares_free(node);\n\n  list->cnt--;\n\n  return val;\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_claim",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_slist_node_reinsert(ares_slist_node_t *node)\n{\n  ares_slist_t *list;\n\n  if (node == NULL) {\n    return;\n  }\n\n  list = node->parent;\n\n  ares_slist_node_pop(node);\n  ares_slist_node_push(list, node);\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_reinsert",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_slist_node_t *ares_slist_node_find(const ares_slist_t *list,\n                                        const void         *val)\n{\n  size_t             i;\n  ares_slist_node_t *node = NULL;\n  int                rv   = -1;\n\n  if (list == NULL || val == NULL) {\n    return NULL;\n  }\n\n  /* Scan nodes starting at the highest level. For each level scan forward\n   * until the value is between the prior and next node, or if equal quit\n   * as we found a match */\n  for (i = list->levels; i-- > 0;) {\n    if (node == NULL) {\n      node = list->head[i];\n    }\n\n    if (node == NULL) {\n      continue;\n    }\n\n    do {\n      rv = list->cmp(val, node->data);\n\n      if (rv < 0) {\n        /* back off, our value is greater than current node reference */\n        node = node->prev[i];\n      } else if (rv > 0) {\n        /* move forward and try again. if it goes past, it will loop again and\n         * go to previous entry */\n        node = node->next[i];\n      }\n\n      /* rv == 0 will terminate loop */\n\n    } while (node != NULL && rv > 0);\n\n    /* Found a match, no need to continue */\n    if (rv == 0) {\n      break;\n    }\n  }\n\n  /* no match */\n  if (rv != 0) {\n    return NULL;\n  }\n\n  /* The list may have multiple entries that match.  They're guaranteed to be\n   * in order, but we're not guaranteed to have selected the _first_ matching\n   * node.  Lets scan backwards to find the first match */\n  while (node->prev[0] != NULL && list->cmp(node->prev[0]->data, val) == 0) {\n    node = node->prev[0];\n  }\n\n  return node;\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_find",
            "parameters": {
              "list": "ares_slist_t",
              "val": "void"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "ares_slist_node_t *ares_slist_node_first(const ares_slist_t *list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n\n  return list->head[0];\n}",
          "fn_code_pos": [
            [
              379,
              0
            ],
            [
              386,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_first",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "ares_slist_node_t *ares_slist_node_last(const ares_slist_t *list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n  return list->tail;\n}",
          "fn_code_pos": [
            [
              388,
              0
            ],
            [
              394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_last",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "ares_slist_node_t *ares_slist_node_next(const ares_slist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->next[0];\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_next",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "ares_slist_node_t *ares_slist_node_prev(const ares_slist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->prev[0];\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_prev",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "void *ares_slist_node_val(ares_slist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return node->data;\n}",
          "fn_code_pos": [
            [
              412,
              0
            ],
            [
              419,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_val",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares_slist_len(const ares_slist_t *list)\n{\n  if (list == NULL) {\n    return 0;\n  }\n  return list->cnt;\n}",
          "fn_code_pos": [
            [
              421,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_len",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_slist_t *ares_slist_node_parent(ares_slist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->parent;\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_parent",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "ares_slist_t"
          }
        },
        {
          "fn_code": "void *ares_slist_first_val(const ares_slist_t *list)\n{\n  return ares_slist_node_val(ares_slist_node_first(list));\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_first_val",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_slist_last_val(const ares_slist_t *list)\n{\n  return ares_slist_node_val(ares_slist_node_last(list));\n}",
          "fn_code_pos": [
            [
              442,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_last_val",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_slist_node_destroy(ares_slist_node_t *node)\n{\n  ares_slist_destructor_t destruct;\n  void                   *val;\n\n  if (node == NULL) {\n    return;\n  }\n\n  destruct = node->parent->destruct;\n  val      = ares_slist_node_claim(node);\n\n  if (val != NULL && destruct != NULL) {\n    destruct(val);\n  }\n}",
          "fn_code_pos": [
            [
              447,
              0
            ],
            [
              462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_destroy",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_slist_destroy(ares_slist_t *list)\n{\n  ares_slist_node_t *node;\n\n  if (list == NULL) {\n    return;\n  }\n\n  while ((node = ares_slist_node_first(list)) != NULL) {\n    ares_slist_node_destroy(node);\n  }\n\n  ares_free(list->head);\n  ares_free(list);\n}",
          "fn_code_pos": [
            [
              464,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_destroy",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_slist_create(ares_rand_state        *rand_state,\n                                ares_slist_cmp_t        cmp,\n                                ares_slist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              54,
              14
            ],
            [
              56,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "cmp": "ares_slist_cmp_t",
              "destruct": "ares_slist_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_insert(ares_slist_t *list, void *val)",
          "fn_dec_pos": [
            [
              194,
              19
            ],
            [
              194,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_insert",
            "parameters": {
              "list": "ares_slist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_claim(ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              282,
              6
            ],
            [
              282,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_claim",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_find(const ares_slist_t *list,\n                                        const void         *val)",
          "fn_dec_pos": [
            [
              319,
              19
            ],
            [
              320,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_find",
            "parameters": {
              "list": "ares_slist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_first(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              379,
              19
            ],
            [
              379,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_first",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_last(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              388,
              19
            ],
            [
              388,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_last",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_next(const ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              396,
              19
            ],
            [
              396,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_next",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_prev(const ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              404,
              19
            ],
            [
              404,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_prev",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_val(ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              412,
              6
            ],
            [
              412,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_val",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_parent(ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              429,
              14
            ],
            [
              429,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_parent",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_first_val(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              437,
              6
            ],
            [
              437,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_first_val",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_last_val(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              442,
              6
            ],
            [
              442,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_last_val",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_slist {\n  ares_rand_state        *rand_state;\n  unsigned char           rand_data[8];\n  size_t                  rand_bits;\n\n  ares_slist_node_t     **head;\n  size_t                  levels;\n  ares_slist_node_t      *tail;\n\n  ares_slist_cmp_t        cmp;\n  ares_slist_destructor_t destruct;\n  size_t                  cnt;\n}",
          {
            "*rand_state": "ares_rand_state",
            "rand_data[8]": "unsigned char",
            "rand_bits": "size_t",
            "**head": "ares_slist_node_t",
            "levels": "size_t",
            "*tail": "ares_slist_node_t",
            "cmp": "ares_slist_cmp_t",
            "destruct": "ares_slist_destructor_t",
            "cnt": "size_t"
          },
          "ares_slist",
          [
            32,
            0
          ],
          [
            44,
            1
          ]
        ],
        [
          "struct ares_slist_node {\n  void               *data;\n  ares_slist_node_t **prev;\n  ares_slist_node_t **next;\n  size_t              levels;\n  ares_slist_t       *parent;\n}",
          {
            "*data": "void",
            "**prev": "ares_slist_node_t",
            "**next": "ares_slist_node_t",
            "levels": "size_t",
            "*parent": "ares_slist_t"
          },
          "ares_slist_node",
          [
            46,
            0
          ],
          [
            52,
            1
          ]
        ],
        [
          "struct ares_slist {\n  ares_rand_state        *rand_state;\n  unsigned char           rand_data[8];\n  size_t                  rand_bits;\n\n  ares_slist_node_t     **head;\n  size_t                  levels;\n  ares_slist_node_t      *tail;\n\n  ares_slist_cmp_t        cmp;\n  ares_slist_destructor_t destruct;\n  size_t                  cnt;\n}",
          {
            "*rand_state": "ares_rand_state",
            "rand_data[8]": "unsigned char",
            "rand_bits": "size_t",
            "**head": "ares_slist_node_t",
            "levels": "size_t",
            "*tail": "ares_slist_node_t",
            "cmp": "ares_slist_cmp_t",
            "destruct": "ares_slist_destructor_t",
            "cnt": "size_t"
          },
          "ares_slist",
          [
            32,
            0
          ],
          [
            44,
            1
          ]
        ],
        [
          "struct ares_slist_node {\n  void               *data;\n  ares_slist_node_t **prev;\n  ares_slist_node_t **next;\n  size_t              levels;\n  ares_slist_t       *parent;\n}",
          {
            "*data": "void",
            "**prev": "ares_slist_node_t",
            "**next": "ares_slist_node_t",
            "levels": "size_t",
            "*parent": "ares_slist_t"
          },
          "ares_slist_node",
          [
            46,
            0
          ],
          [
            52,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_slist.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_htable_szvp.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_htable_szvp_destroy(ares_htable_szvp_t *htable)\n{\n  if (htable == NULL) {\n    return;\n  }\n\n  ares_htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_destroy",
            "parameters": {
              "htable": "ares_htable_szvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  const size_t *arg = key;\n  return ares_htable_hash_FNV1a((const unsigned char *)arg, sizeof(*arg), seed);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares_htable_szvp_bucket_t *arg = bucket;\n  return &arg->key;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares_htable_szvp_bucket_t *arg = bucket;\n\n  if (arg->parent->free_val) {\n    arg->parent->free_val(arg->val);\n  }\n\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  const size_t *k1 = key1;\n  const size_t *k2 = key2;\n\n  if (*k1 == *k2) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_szvp_t *\n  ares_htable_szvp_create(ares_htable_szvp_val_free_t val_free)\n{\n  ares_htable_szvp_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail;\n  }\n\n  htable->free_val = val_free;\n\n  return htable;\n\nfail:\n  if (htable) {\n    ares_htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_create",
            "parameters": {
              "val_free": "ares_htable_szvp_val_free_t"
            },
            "return_type": "ares_htable_szvp_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_szvp_insert(ares_htable_szvp_t *htable, size_t key,\n                                    void *val)\n{\n  ares_htable_szvp_bucket_t *bucket = NULL;\n\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  bucket = ares_malloc(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  bucket->parent = htable;\n  bucket->key    = key;\n  bucket->val    = val;\n\n  if (!ares_htable_insert(htable->hash, bucket)) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket); /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_insert",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_szvp_get(const ares_htable_szvp_t *htable, size_t key,\n                                 void **val)\n{\n  ares_htable_szvp_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares_htable_get(htable->hash, &key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_get",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares_htable_szvp_get_direct(const ares_htable_szvp_t *htable, size_t key)\n{\n  void *val = NULL;\n  ares_htable_szvp_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_get_direct",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_szvp_remove(ares_htable_szvp_t *htable, size_t key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares_htable_remove(htable->hash, &key);\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_remove",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_htable_szvp_num_keys(const ares_htable_szvp_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares_htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              187,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_num_keys",
            "parameters": {
              "htable": "ares_htable_szvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              56,
              19
            ],
            [
              56,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_szvp_create(ares_htable_szvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              86,
              2
            ],
            [
              86,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_create",
            "parameters": {
              "val_free": "ares_htable_szvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_szvp_get_direct(const ares_htable_szvp_t *htable, size_t key)",
          "fn_dec_pos": [
            [
              165,
              6
            ],
            [
              165,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_get_direct",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_szvp {\n  ares_htable_szvp_val_free_t free_val;\n  ares_htable_t              *hash;\n}",
          {
            "free_val": "ares_htable_szvp_val_free_t",
            "*hash": "ares_htable_t"
          },
          "ares_htable_szvp",
          [
            29,
            0
          ],
          [
            32,
            1
          ]
        ],
        [
          "typedef struct {\n  size_t              key;\n  void               *val;\n  ares_htable_szvp_t *parent;\n} ares_htable_szvp_bucket_t;",
          {
            "key": "size_t",
            "*val": "void",
            "*parent": "ares_htable_szvp_t"
          },
          "ares_htable_szvp_bucket_t",
          [
            34,
            0
          ],
          [
            38,
            28
          ]
        ],
        [
          "struct ares_htable_szvp {\n  ares_htable_szvp_val_free_t free_val;\n  ares_htable_t              *hash;\n}",
          {
            "free_val": "ares_htable_szvp_val_free_t",
            "*hash": "ares_htable_t"
          },
          "ares_htable_szvp",
          [
            29,
            0
          ],
          [
            32,
            1
          ]
        ],
        [
          "typedef struct {\n  size_t              key;\n  void               *val;\n  ares_htable_szvp_t *parent;\n} ares_htable_szvp_bucket_t;",
          {
            "key": "size_t",
            "*val": "void",
            "*parent": "ares_htable_szvp_t"
          },
          "ares_htable_szvp_bucket_t",
          [
            34,
            0
          ],
          [
            38,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_htable.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_htable_szvp.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_llist.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_llist_t *ares_llist_create(ares_llist_destructor_t destruct)\n{\n  ares_llist_t *list = ares_malloc_zero(sizeof(*list));\n\n  if (list == NULL) {\n    return NULL;\n  }\n\n  list->destruct = destruct;\n\n  return list;\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_create",
            "parameters": {
              "destruct": "ares_llist_destructor_t"
            },
            "return_type": "ares_llist_t"
          }
        },
        {
          "fn_code": "void ares_llist_replace_destructor(ares_llist_t           *list,\n                                   ares_llist_destructor_t destruct)\n{\n  if (list == NULL) {\n    return;\n  }\n\n  list->destruct = destruct;\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_replace_destructor",
            "parameters": {
              "list": "ares_llist_t",
              "destruct": "ares_llist_destructor_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_llist_attach_at(ares_llist_t            *list,\n                                 ares_llist_insert_type_t type,\n                                 ares_llist_node_t *at, ares_llist_node_t *node)\n{\n  if (list == NULL || node == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  node->parent = list;\n\n  if (type == ARES__LLIST_INSERT_BEFORE && (at == list->head || at == NULL)) {\n    type = ARES__LLIST_INSERT_HEAD;\n  }\n\n  switch (type) {\n    case ARES__LLIST_INSERT_HEAD:\n      node->next = list->head;\n      node->prev = NULL;\n      if (list->head) {\n        list->head->prev = node;\n      }\n      list->head = node;\n      break;\n    case ARES__LLIST_INSERT_TAIL:\n      node->next = NULL;\n      node->prev = list->tail;\n      if (list->tail) {\n        list->tail->next = node;\n      }\n      list->tail = node;\n      break;\n    case ARES__LLIST_INSERT_BEFORE:\n      node->next = at;\n      node->prev = at->prev;\n      at->prev   = node;\n      break;\n  }\n  if (list->tail == NULL) {\n    list->tail = node;\n  }\n  if (list->head == NULL) {\n    list->head = node;\n  }\n\n  list->cnt++;\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_attach_at",
            "parameters": {
              "list": "ares_llist_t",
              "type": "ares_llist_insert_type_t",
              "at": "ares_llist_node_t",
              "node": "ares_llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_llist_node_t *ares_llist_insert_at(ares_llist_t            *list,\n                                               ares_llist_insert_type_t type,\n                                               ares_llist_node_t *at, void *val)\n{\n  ares_llist_node_t *node = NULL;\n\n  if (list == NULL || val == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  node = ares_malloc_zero(sizeof(*node));\n\n  if (node == NULL) {\n    return NULL;\n  }\n\n  node->data = val;\n  ares_llist_attach_at(list, type, at, node);\n\n  return node;\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_at",
            "parameters": {
              "list": "ares_llist_t",
              "type": "ares_llist_insert_type_t",
              "at": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_insert_first(ares_llist_t *list, void *val)\n{\n  return ares_llist_insert_at(list, ARES__LLIST_INSERT_HEAD, NULL, val);\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_first",
            "parameters": {
              "list": "ares_llist_t",
              "val": "void"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_insert_last(ares_llist_t *list, void *val)\n{\n  return ares_llist_insert_at(list, ARES__LLIST_INSERT_TAIL, NULL, val);\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              148,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_last",
            "parameters": {
              "list": "ares_llist_t",
              "val": "void"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_insert_before(ares_llist_node_t *node, void *val)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return ares_llist_insert_at(node->parent, ARES__LLIST_INSERT_BEFORE, node,\n                              val);\n}",
          "fn_code_pos": [
            [
              150,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_before",
            "parameters": {
              "node": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_insert_after(ares_llist_node_t *node, void *val)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n\n  if (node->next == NULL) {\n    return ares_llist_insert_last(node->parent, val);\n  }\n\n  return ares_llist_insert_at(node->parent, ARES__LLIST_INSERT_BEFORE,\n                              node->next, val);\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_after",
            "parameters": {
              "node": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_node_first(ares_llist_t *list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n  return list->head;\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_first",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_node_idx(ares_llist_t *list, size_t idx)\n{\n  ares_llist_node_t *node;\n  size_t             cnt;\n\n  if (list == NULL) {\n    return NULL;\n  }\n  if (idx >= list->cnt) {\n    return NULL;\n  }\n\n  node = list->head;\n  for (cnt = 0; node != NULL && cnt < idx; cnt++) {\n    node = node->next;\n  }\n\n  return node;\n}",
          "fn_code_pos": [
            [
              182,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_idx",
            "parameters": {
              "list": "ares_llist_t",
              "idx": "size_t"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_node_last(ares_llist_t *list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n  return list->tail;\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_last",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_node_next(ares_llist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->next;\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_next",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "ares_llist_node_t *ares_llist_node_prev(ares_llist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->prev;\n}",
          "fn_code_pos": [
            [
              218,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_prev",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": "ares_llist_node_t"
          }
        },
        {
          "fn_code": "void *ares_llist_node_val(ares_llist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return node->data;\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_val",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares_llist_len(const ares_llist_t *list)\n{\n  if (list == NULL) {\n    return 0;\n  }\n  return list->cnt;\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_len",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_llist_t *ares_llist_node_parent(ares_llist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->parent;\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              249,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_parent",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": "ares_llist_t"
          }
        },
        {
          "fn_code": "void *ares_llist_first_val(ares_llist_t *list)\n{\n  return ares_llist_node_val(ares_llist_node_first(list));\n}",
          "fn_code_pos": [
            [
              251,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_first_val",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_llist_last_val(ares_llist_t *list)\n{\n  return ares_llist_node_val(ares_llist_node_last(list));\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_last_val",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_llist_node_detach(ares_llist_node_t *node)\n{\n  ares_llist_t *list;\n\n  if (node == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  list = node->parent;\n\n  if (node->prev) {\n    node->prev->next = node->next;\n  }\n\n  if (node->next) {\n    node->next->prev = node->prev;\n  }\n\n  if (node == list->head) {\n    list->head = node->next;\n  }\n\n  if (node == list->tail) {\n    list->tail = node->prev;\n  }\n\n  node->parent = NULL;\n  list->cnt--;\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_detach",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_llist_node_claim(ares_llist_node_t *node)\n{\n  void *val;\n\n  if (node == NULL) {\n    return NULL;\n  }\n\n  val = node->data;\n  ares_llist_node_detach(node);\n  ares_free(node);\n\n  return val;\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_claim",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_llist_node_destroy(ares_llist_node_t *node)\n{\n  ares_llist_destructor_t destruct;\n  void                   *val;\n\n  if (node == NULL) {\n    return;\n  }\n\n  destruct = node->parent->destruct;\n\n  val = ares_llist_node_claim(node);\n  if (val != NULL && destruct != NULL) {\n    destruct(val);\n  }\n}",
          "fn_code_pos": [
            [
              306,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_destroy",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_llist_node_replace(ares_llist_node_t *node, void *val)\n{\n  ares_llist_destructor_t destruct;\n\n  if (node == NULL) {\n    return;\n  }\n\n  destruct = node->parent->destruct;\n  if (destruct != NULL) {\n    destruct(node->data);\n  }\n\n  node->data = val;\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_replace",
            "parameters": {
              "node": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_llist_clear(ares_llist_t *list)\n{\n  ares_llist_node_t *node;\n\n  if (list == NULL) {\n    return;\n  }\n\n  while ((node = ares_llist_node_first(list)) != NULL) {\n    ares_llist_node_destroy(node);\n  }\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_clear",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_llist_destroy(ares_llist_t *list)\n{\n  if (list == NULL) {\n    return;\n  }\n  ares_llist_clear(list);\n  ares_free(list);\n}",
          "fn_code_pos": [
            [
              352,
              0
            ],
            [
              359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_destroy",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_llist_node_mvparent_last(ares_llist_node_t *node,\n                                   ares_llist_t      *new_parent)\n{\n  if (node == NULL || new_parent == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_llist_node_detach(node);\n  ares_llist_attach_at(new_parent, ARES__LLIST_INSERT_TAIL, NULL, node);\n}",
          "fn_code_pos": [
            [
              361,
              0
            ],
            [
              370,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_mvparent_last",
            "parameters": {
              "node": "ares_llist_node_t",
              "new_parent": "ares_llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_llist_node_mvparent_first(ares_llist_node_t *node,\n                                    ares_llist_t      *new_parent)\n{\n  if (node == NULL || new_parent == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_llist_node_detach(node);\n  ares_llist_attach_at(new_parent, ARES__LLIST_INSERT_HEAD, NULL, node);\n}",
          "fn_code_pos": [
            [
              372,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_mvparent_first",
            "parameters": {
              "node": "ares_llist_node_t",
              "new_parent": "ares_llist_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_llist_create(ares_llist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              42,
              14
            ],
            [
              42,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_create",
            "parameters": {
              "destruct": "ares_llist_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_insert_at(ares_llist_t            *list,\n                                               ares_llist_insert_type_t type,\n                                               ares_llist_node_t *at, void *val)",
          "fn_dec_pos": [
            [
              118,
              26
            ],
            [
              120,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_at",
            "parameters": {
              "list": "ares_llist_t",
              "type": "ares_llist_insert_type_t",
              "at": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_insert_first(ares_llist_t *list, void *val)",
          "fn_dec_pos": [
            [
              140,
              19
            ],
            [
              140,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_first",
            "parameters": {
              "list": "ares_llist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_insert_last(ares_llist_t *list, void *val)",
          "fn_dec_pos": [
            [
              145,
              19
            ],
            [
              145,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_last",
            "parameters": {
              "list": "ares_llist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_insert_before(ares_llist_node_t *node, void *val)",
          "fn_dec_pos": [
            [
              150,
              19
            ],
            [
              150,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_before",
            "parameters": {
              "node": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_insert_after(ares_llist_node_t *node, void *val)",
          "fn_dec_pos": [
            [
              160,
              19
            ],
            [
              160,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_insert_after",
            "parameters": {
              "node": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_first(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              174,
              19
            ],
            [
              174,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_first",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_idx(ares_llist_t *list, size_t idx)",
          "fn_dec_pos": [
            [
              182,
              19
            ],
            [
              182,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_idx",
            "parameters": {
              "list": "ares_llist_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_last(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              202,
              19
            ],
            [
              202,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_last",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_next(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              210,
              19
            ],
            [
              210,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_next",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_prev(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              218,
              19
            ],
            [
              218,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_prev",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_val(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              226,
              6
            ],
            [
              226,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_val",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_parent(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              243,
              14
            ],
            [
              243,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_parent",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_first_val(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              251,
              6
            ],
            [
              251,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_first_val",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_last_val(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              256,
              6
            ],
            [
              256,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_last_val",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_claim(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              291,
              6
            ],
            [
              291,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_claim",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_llist {\n  ares_llist_node_t      *head;\n  ares_llist_node_t      *tail;\n  ares_llist_destructor_t destruct;\n  size_t                  cnt;\n}",
          {
            "*head": "ares_llist_node_t",
            "*tail": "ares_llist_node_t",
            "destruct": "ares_llist_destructor_t",
            "cnt": "size_t"
          },
          "ares_llist",
          [
            28,
            0
          ],
          [
            33,
            1
          ]
        ],
        [
          "struct ares_llist_node {\n  void              *data;\n  ares_llist_node_t *prev;\n  ares_llist_node_t *next;\n  ares_llist_t      *parent;\n}",
          {
            "*data": "void",
            "*prev": "ares_llist_node_t",
            "*next": "ares_llist_node_t",
            "*parent": "ares_llist_t"
          },
          "ares_llist_node",
          [
            35,
            0
          ],
          [
            40,
            1
          ]
        ],
        [
          "struct ares_llist {\n  ares_llist_node_t      *head;\n  ares_llist_node_t      *tail;\n  ares_llist_destructor_t destruct;\n  size_t                  cnt;\n}",
          {
            "*head": "ares_llist_node_t",
            "*tail": "ares_llist_node_t",
            "destruct": "ares_llist_destructor_t",
            "cnt": "size_t"
          },
          "ares_llist",
          [
            28,
            0
          ],
          [
            33,
            1
          ]
        ],
        [
          "struct ares_llist_node {\n  void              *data;\n  ares_llist_node_t *prev;\n  ares_llist_node_t *next;\n  ares_llist_t      *parent;\n}",
          {
            "*data": "void",
            "*prev": "ares_llist_node_t",
            "*next": "ares_llist_node_t",
            "*parent": "ares_llist_t"
          },
          "ares_llist_node",
          [
            35,
            0
          ],
          [
            40,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_llist.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES__LLIST_INSERT_HEAD,\n  ARES__LLIST_INSERT_TAIL,\n  ARES__LLIST_INSERT_BEFORE\n} ares_llist_insert_type_t;",
          {
            "ARES__LLIST_INSERT_HEAD": "",
            "ARES__LLIST_INSERT_TAIL": "",
            "ARES__LLIST_INSERT_BEFORE": ""
          },
          "ares_llist_insert_type_t",
          [
            65,
            0
          ],
          [
            69,
            27
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_htable_strvp.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_htable_strvp_destroy(ares_htable_strvp_t *htable)\n{\n  if (htable == NULL) {\n    return;\n  }\n\n  ares_htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_destroy",
            "parameters": {
              "htable": "ares_htable_strvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  const char *arg = key;\n  return ares_htable_hash_FNV1a_casecmp((const unsigned char *)arg,\n                                        ares_strlen(arg), seed);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares_htable_strvp_bucket_t *arg = bucket;\n  return arg->key;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares_htable_strvp_bucket_t *arg = bucket;\n\n  if (arg->parent->free_val) {\n    arg->parent->free_val(arg->val);\n  }\n  ares_free(arg->key);\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  return ares_strcaseeq(key1, key2);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_strvp_t *\n  ares_htable_strvp_create(ares_htable_strvp_val_free_t val_free)\n{\n  ares_htable_strvp_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail;\n  }\n\n  htable->free_val = val_free;\n\n  return htable;\n\nfail:\n  if (htable) {\n    ares_htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_create",
            "parameters": {
              "val_free": "ares_htable_strvp_val_free_t"
            },
            "return_type": "ares_htable_strvp_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_strvp_insert(ares_htable_strvp_t *htable,\n                                     const char *key, void *val)\n{\n  ares_htable_strvp_bucket_t *bucket = NULL;\n\n  if (htable == NULL || key == NULL) {\n    goto fail;\n  }\n\n  bucket = ares_malloc(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail;\n  }\n\n  bucket->parent = htable;\n  bucket->key    = ares_strdup(key);\n  if (bucket->key == NULL) {\n    goto fail;\n  }\n  bucket->val = val;\n\n  if (!ares_htable_insert(htable->hash, bucket)) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket->key);\n    ares_free(bucket);\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              104,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_insert",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_strvp_get(const ares_htable_strvp_t *htable,\n                                  const char *key, void **val)\n{\n  ares_htable_strvp_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL || key == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares_htable_get(htable->hash, key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              139,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_get",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares_htable_strvp_get_direct(const ares_htable_strvp_t *htable,\n                                   const char                *key)\n{\n  void *val = NULL;\n  ares_htable_strvp_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_get_direct",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_strvp_remove(ares_htable_strvp_t *htable,\n                                     const char          *key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares_htable_remove(htable->hash, key);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_remove",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares_htable_strvp_claim(ares_htable_strvp_t *htable, const char *key)\n{\n  ares_htable_strvp_bucket_t *bucket = NULL;\n  void                       *val;\n\n  if (htable == NULL || key == NULL) {\n    return NULL;\n  }\n\n  bucket = ares_htable_get(htable->hash, key);\n  if (bucket == NULL) {\n    return NULL;\n  }\n\n  /* Unassociate value from bucket */\n  val         = bucket->val;\n  bucket->val = NULL;\n\n  ares_htable_strvp_remove(htable, key);\n  return val;\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_claim",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares_htable_strvp_num_keys(const ares_htable_strvp_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares_htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_num_keys",
            "parameters": {
              "htable": "ares_htable_strvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              57,
              19
            ],
            [
              57,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_strvp_create(ares_htable_strvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              80,
              2
            ],
            [
              80,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_create",
            "parameters": {
              "val_free": "ares_htable_strvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_strvp_get_direct(const ares_htable_strvp_t *htable,\n                                   const char                *key)",
          "fn_dec_pos": [
            [
              163,
              6
            ],
            [
              164,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_get_direct",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_strvp_claim(ares_htable_strvp_t *htable, const char *key)",
          "fn_dec_pos": [
            [
              181,
              6
            ],
            [
              181,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_claim",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_strvp {\n  ares_htable_strvp_val_free_t free_val;\n  ares_htable_t               *hash;\n}",
          {
            "free_val": "ares_htable_strvp_val_free_t",
            "*hash": "ares_htable_t"
          },
          "ares_htable_strvp",
          [
            29,
            0
          ],
          [
            32,
            1
          ]
        ],
        [
          "typedef struct {\n  char                *key;\n  void                *val;\n  ares_htable_strvp_t *parent;\n} ares_htable_strvp_bucket_t;",
          {
            "*key": "char",
            "*val": "void",
            "*parent": "ares_htable_strvp_t"
          },
          "ares_htable_strvp_bucket_t",
          [
            34,
            0
          ],
          [
            38,
            29
          ]
        ],
        [
          "struct ares_htable_strvp {\n  ares_htable_strvp_val_free_t free_val;\n  ares_htable_t               *hash;\n}",
          {
            "free_val": "ares_htable_strvp_val_free_t",
            "*hash": "ares_htable_t"
          },
          "ares_htable_strvp",
          [
            29,
            0
          ],
          [
            32,
            1
          ]
        ],
        [
          "typedef struct {\n  char                *key;\n  void                *val;\n  ares_htable_strvp_t *parent;\n} ares_htable_strvp_bucket_t;",
          {
            "*key": "char",
            "*val": "void",
            "*parent": "ares_htable_strvp_t"
          },
          "ares_htable_strvp_bucket_t",
          [
            34,
            0
          ],
          [
            38,
            29
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_htable.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_htable_strvp.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_htable_vpstr.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_htable_vpstr_destroy(ares_htable_vpstr_t *htable)\n{\n  if (htable == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_destroy",
            "parameters": {
              "htable": "ares_htable_vpstr_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  return ares_htable_hash_FNV1a((const unsigned char *)&key, sizeof(key), seed);\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares_htable_vpstr_bucket_t *arg = bucket;\n  return arg->key;\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares_htable_vpstr_bucket_t *arg = bucket;\n\n  ares_free(arg->val);\n\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  if (key1 == key2) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_vpstr_t *ares_htable_vpstr_create(void)\n{\n  ares_htable_vpstr_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return htable;\n\n/* LCOV_EXCL_START: OutOfMemory */\nfail:\n  if (htable) {\n    ares_htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_create",
            "parameters": {},
            "return_type": "ares_htable_vpstr_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpstr_insert(ares_htable_vpstr_t *htable, void *key,\n                                     const char *val)\n{\n  ares_htable_vpstr_bucket_t *bucket = NULL;\n\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  bucket = ares_malloc(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail;\n  }\n\n  bucket->parent = htable;\n  bucket->key    = key;\n  bucket->val    = ares_strdup(val);\n  if (bucket->val == NULL) {\n    goto fail;\n  }\n\n  if (!ares_htable_insert(htable->hash, bucket)) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket->val);\n    ares_free(bucket);\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_insert",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void",
              "val": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpstr_get(const ares_htable_vpstr_t *htable,\n                                  const void *key, const char **val)\n{\n  const ares_htable_vpstr_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares_htable_get(htable->hash, key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_get",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void",
              "val": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "const char *ares_htable_vpstr_get_direct(const ares_htable_vpstr_t *htable,\n                                         const void                *key)\n{\n  const char *val = NULL;\n  ares_htable_vpstr_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_get_direct",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpstr_remove(ares_htable_vpstr_t *htable,\n                                     const void          *key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares_htable_remove(htable->hash, key);\n}",
          "fn_code_pos": [
            [
              169,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_remove",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_htable_vpstr_num_keys(const ares_htable_vpstr_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares_htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_num_keys",
            "parameters": {
              "htable": "ares_htable_vpstr_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              54,
              19
            ],
            [
              54,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_vpstr_create(void)",
          "fn_dec_pos": [
            [
              78,
              21
            ],
            [
              78,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_vpstr_get_direct(const ares_htable_vpstr_t *htable,\n                                         const void                *key)",
          "fn_dec_pos": [
            [
              161,
              12
            ],
            [
              162,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_get_direct",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_vpstr {\n  ares_htable_t *hash;\n}",
          {
            "*hash": "ares_htable_t"
          },
          "ares_htable_vpstr",
          [
            29,
            0
          ],
          [
            31,
            1
          ]
        ],
        [
          "typedef struct {\n  void                *key;\n  char                *val;\n  ares_htable_vpstr_t *parent;\n} ares_htable_vpstr_bucket_t;",
          {
            "*key": "void",
            "*val": "char",
            "*parent": "ares_htable_vpstr_t"
          },
          "ares_htable_vpstr_bucket_t",
          [
            33,
            0
          ],
          [
            37,
            29
          ]
        ],
        [
          "struct ares_htable_vpstr {\n  ares_htable_t *hash;\n}",
          {
            "*hash": "ares_htable_t"
          },
          "ares_htable_vpstr",
          [
            29,
            0
          ],
          [
            31,
            1
          ]
        ],
        [
          "typedef struct {\n  void                *key;\n  char                *val;\n  ares_htable_vpstr_t *parent;\n} ares_htable_vpstr_bucket_t;",
          {
            "*key": "void",
            "*val": "char",
            "*parent": "ares_htable_vpstr_t"
          },
          "ares_htable_vpstr_bucket_t",
          [
            33,
            0
          ],
          [
            37,
            29
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_htable.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_htable_vpstr.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_array.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_array_t *ares_array_create(size_t                  member_size,\n                                ares_array_destructor_t destruct)\n{\n  ares_array_t *arr;\n\n  if (member_size == 0) {\n    return NULL;\n  }\n\n  arr = ares_malloc_zero(sizeof(*arr));\n  if (arr == NULL) {\n    return NULL;\n  }\n\n  arr->member_size = member_size;\n  arr->destruct    = destruct;\n  return arr;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_create",
            "parameters": {
              "member_size": "size_t",
              "destruct": "ares_array_destructor_t"
            },
            "return_type": "ares_array_t"
          }
        },
        {
          "fn_code": "size_t ares_array_len(const ares_array_t *arr)\n{\n  if (arr == NULL) {\n    return 0;\n  }\n  return arr->cnt;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_len",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "void *ares_array_at(ares_array_t *arr, size_t idx)\n{\n  if (arr == NULL || idx >= arr->cnt) {\n    return NULL;\n  }\n  return (unsigned char *)arr->arr + ((idx + arr->offset) * arr->member_size);\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_at",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const void *ares_array_at_const(const ares_array_t *arr, size_t idx)\n{\n  if (arr == NULL || idx >= arr->cnt) {\n    return NULL;\n  }\n  return (unsigned char *)arr->arr + ((idx + arr->offset) * arr->member_size);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_at_const",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_sort(ares_array_t *arr, ares_array_cmp_t cmp)\n{\n  if (arr == NULL || cmp == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Nothing to sort */\n  if (arr->cnt < 2) {\n    return ARES_SUCCESS;\n  }\n\n  qsort((unsigned char *)arr->arr + (arr->offset * arr->member_size), arr->cnt,\n        arr->member_size, cmp);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_sort",
            "parameters": {
              "arr": "ares_array_t",
              "cmp": "ares_array_cmp_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_array_destroy(ares_array_t *arr)\n{\n  size_t i;\n\n  if (arr == NULL) {\n    return;\n  }\n\n  if (arr->destruct != NULL) {\n    for (i = 0; i < arr->cnt; i++) {\n      arr->destruct(ares_array_at(arr, i));\n    }\n  }\n\n  ares_free(arr->arr);\n  ares_free(arr);\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_destroy",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_array_move(ares_array_t *arr, size_t dest_idx,\n                                     size_t src_idx)\n{\n  void       *dest_ptr;\n  const void *src_ptr;\n  size_t      nmembers;\n\n  if (arr == NULL || dest_idx >= arr->alloc_cnt || src_idx >= arr->alloc_cnt) {\n    return ARES_EFORMERR;\n  }\n\n  /* Nothing to do */\n  if (dest_idx == src_idx) {\n    return ARES_SUCCESS;\n  }\n\n  dest_ptr = (unsigned char *)arr->arr + (dest_idx * arr->member_size);\n  src_ptr  = (unsigned char *)arr->arr + (src_idx * arr->member_size);\n\n  /* Check to make sure shifting to the right won't overflow our allocation\n   * boundary */\n  if (dest_idx > src_idx && arr->cnt + (dest_idx - src_idx) > arr->alloc_cnt) {\n    return ARES_EFORMERR;\n  }\n\n  nmembers = arr->cnt - (src_idx - arr->offset);\n  memmove(dest_ptr, src_ptr, nmembers * arr->member_size);\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_move",
            "parameters": {
              "arr": "ares_array_t",
              "dest_idx": "size_t",
              "src_idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void *ares_array_finish(ares_array_t *arr, size_t *num_members)\n{\n  void *ptr;\n\n  if (arr == NULL || num_members == NULL) {\n    return NULL;\n  }\n\n  /* Make sure we move data to beginning of allocation */\n  if (arr->offset != 0) {\n    if (ares_array_move(arr, 0, arr->offset) != ARES_SUCCESS) {\n      return NULL;\n    }\n    arr->offset = 0;\n  }\n\n  ptr          = arr->arr;\n  *num_members = arr->cnt;\n  ares_free(arr);\n  return ptr;\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_finish",
            "parameters": {
              "arr": "ares_array_t",
              "num_members": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_set_size(ares_array_t *arr, size_t size)\n{\n  void *temp;\n\n  if (arr == NULL || size == 0 || size < arr->cnt) {\n    return ARES_EFORMERR;\n  }\n\n  /* Always operate on powers of 2 */\n  size = ares_round_up_pow2(size);\n\n  if (size < ARES__ARRAY_MIN) {\n    size = ARES__ARRAY_MIN;\n  }\n\n  /* If our allocation size is already large enough, skip */\n  if (size <= arr->alloc_cnt) {\n    return ARES_SUCCESS;\n  }\n\n  temp = ares_realloc_zero(arr->arr, arr->alloc_cnt * arr->member_size,\n                           size * arr->member_size);\n  if (temp == NULL) {\n    return ARES_ENOMEM;\n  }\n  arr->alloc_cnt = size;\n  arr->arr       = temp;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_set_size",
            "parameters": {
              "arr": "ares_array_t",
              "size": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insert_at(void **elem_ptr, ares_array_t *arr,\n                                   size_t idx)\n{\n  void         *ptr;\n  ares_status_t status;\n\n  if (arr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Not >= since we are allowed to append to the end */\n  if (idx > arr->cnt) {\n    return ARES_EFORMERR;\n  }\n\n  /* Allocate more if needed */\n  status = ares_array_set_size(arr, arr->cnt + 1);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Shift if we have memory but not enough room at the end */\n  if (arr->cnt + 1 + arr->offset > arr->alloc_cnt) {\n    status = ares_array_move(arr, 0, arr->offset);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n    arr->offset = 0;\n  }\n\n  /* If we're inserting anywhere other than the end, we need to move some\n   * elements out of the way */\n  if (idx != arr->cnt) {\n    status = ares_array_move(arr, idx + arr->offset + 1, idx + arr->offset);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* Ok, we're guaranteed to have a gap where we need it, lets zero it out,\n   * and return it */\n  ptr = (unsigned char *)arr->arr + ((idx + arr->offset) * arr->member_size);\n  memset(ptr, 0, arr->member_size);\n  arr->cnt++;\n\n  if (elem_ptr) {\n    *elem_ptr = ptr;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_insert_at",
            "parameters": {
              "elem_ptr": "void",
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insert_last(void **elem_ptr, ares_array_t *arr)\n{\n  return ares_array_insert_at(elem_ptr, arr, ares_array_len(arr));\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_insert_last",
            "parameters": {
              "elem_ptr": "void",
              "arr": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insert_first(void **elem_ptr, ares_array_t *arr)\n{\n  return ares_array_insert_at(elem_ptr, arr, 0);\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_insert_first",
            "parameters": {
              "elem_ptr": "void",
              "arr": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insertdata_at(ares_array_t *arr, size_t idx,\n                                       const void *data_ptr)\n{\n  ares_status_t status;\n  void         *ptr = NULL;\n\n  status = ares_array_insert_at(&ptr, arr, idx);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n  memcpy(ptr, data_ptr, arr->member_size);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_insertdata_at",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t",
              "data_ptr": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insertdata_last(ares_array_t *arr,\n                                         const void   *data_ptr)\n{\n  ares_status_t status;\n  void         *ptr = NULL;\n\n  status = ares_array_insert_last(&ptr, arr);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n  memcpy(ptr, data_ptr, arr->member_size);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              277,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_insertdata_last",
            "parameters": {
              "arr": "ares_array_t",
              "data_ptr": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insertdata_first(ares_array_t *arr,\n                                          const void   *data_ptr)\n{\n  ares_status_t status;\n  void         *ptr = NULL;\n\n  status = ares_array_insert_last(&ptr, arr);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n  memcpy(ptr, data_ptr, arr->member_size);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_insertdata_first",
            "parameters": {
              "arr": "ares_array_t",
              "data_ptr": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void *ares_array_first(ares_array_t *arr)\n{\n  return ares_array_at(arr, 0);\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_first",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_array_last(ares_array_t *arr)\n{\n  size_t cnt = ares_array_len(arr);\n  if (cnt == 0) {\n    return NULL;\n  }\n  return ares_array_at(arr, cnt - 1);\n}",
          "fn_code_pos": [
            [
              310,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_last",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const void *ares_array_first_const(const ares_array_t *arr)\n{\n  return ares_array_at_const(arr, 0);\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_first_const",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const void *ares_array_last_const(const ares_array_t *arr)\n{\n  size_t cnt = ares_array_len(arr);\n  if (cnt == 0) {\n    return NULL;\n  }\n  return ares_array_at_const(arr, cnt - 1);\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_last_const",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_claim_at(void *dest, size_t dest_size,\n                                  ares_array_t *arr, size_t idx)\n{\n  ares_status_t status;\n\n  if (arr == NULL || idx >= arr->cnt) {\n    return ARES_EFORMERR;\n  }\n\n  if (dest != NULL && dest_size < arr->member_size) {\n    return ARES_EFORMERR;\n  }\n\n  if (dest) {\n    memcpy(dest, ares_array_at(arr, idx), arr->member_size);\n  }\n\n  if (idx == 0) {\n    /* Optimization, if first element, just increment offset, makes removing a\n     * lot from the start quick */\n    arr->offset++;\n  } else if (idx != arr->cnt - 1) {\n    /* Must shift entire array if removing an element from the middle. Does\n     * nothing if removing last element other than decrement count. */\n    status = ares_array_move(arr, idx + arr->offset, idx + arr->offset + 1);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  arr->cnt--;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              365,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_claim_at",
            "parameters": {
              "dest": "void",
              "dest_size": "size_t",
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_remove_at(ares_array_t *arr, size_t idx)\n{\n  void *ptr = ares_array_at(arr, idx);\n  if (arr == NULL || ptr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (arr->destruct != NULL) {\n    arr->destruct(ptr);\n  }\n\n  return ares_array_claim_at(NULL, 0, arr, idx);\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_remove_at",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_remove_first(ares_array_t *arr)\n{\n  return ares_array_remove_at(arr, 0);\n}",
          "fn_code_pos": [
            [
              381,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_remove_first",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_remove_last(ares_array_t *arr)\n{\n  size_t cnt = ares_array_len(arr);\n  if (cnt == 0) {\n    return ARES_EFORMERR;\n  }\n  return ares_array_remove_at(arr, cnt - 1);\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_remove_last",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_array_create(size_t                  member_size,\n                                ares_array_destructor_t destruct)",
          "fn_dec_pos": [
            [
              39,
              14
            ],
            [
              40,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_create",
            "parameters": {
              "member_size": "size_t",
              "destruct": "ares_array_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_at(ares_array_t *arr, size_t idx)",
          "fn_dec_pos": [
            [
              66,
              6
            ],
            [
              66,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_at",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_at_const(const ares_array_t *arr, size_t idx)",
          "fn_dec_pos": [
            [
              74,
              12
            ],
            [
              74,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_at_const",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_finish(ares_array_t *arr, size_t *num_members)",
          "fn_dec_pos": [
            [
              149,
              6
            ],
            [
              149,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_finish",
            "parameters": {
              "arr": "ares_array_t",
              "num_members": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_first(ares_array_t *arr)",
          "fn_dec_pos": [
            [
              305,
              6
            ],
            [
              305,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_first",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_last(ares_array_t *arr)",
          "fn_dec_pos": [
            [
              310,
              6
            ],
            [
              310,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_last",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_first_const(const ares_array_t *arr)",
          "fn_dec_pos": [
            [
              319,
              12
            ],
            [
              319,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_first_const",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_last_const(const ares_array_t *arr)",
          "fn_dec_pos": [
            [
              324,
              12
            ],
            [
              324,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_last_const",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_array {\n  ares_array_destructor_t destruct;\n  void                   *arr;\n  size_t                  member_size;\n  size_t                  cnt;\n  size_t                  offset;\n  size_t                  alloc_cnt;\n}",
          {
            "destruct": "ares_array_destructor_t",
            "*arr": "void",
            "member_size": "size_t",
            "cnt": "size_t",
            "offset": "size_t",
            "alloc_cnt": "size_t"
          },
          "ares_array",
          [
            30,
            0
          ],
          [
            37,
            1
          ]
        ],
        [
          "struct ares_array {\n  ares_array_destructor_t destruct;\n  void                   *arr;\n  size_t                  member_size;\n  size_t                  cnt;\n  size_t                  offset;\n  size_t                  alloc_cnt;\n}",
          {
            "destruct": "ares_array_destructor_t",
            "*arr": "void",
            "member_size": "size_t",
            "cnt": "size_t",
            "offset": "size_t",
            "alloc_cnt": "size_t"
          },
          "ares_array",
          [
            30,
            0
          ],
          [
            37,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_array.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_iface_ips.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_iface_ip_free_cb(void *arg)\n{\n  ares_iface_ip_t *ip = arg;\n  if (ip == NULL) {\n    return;\n  }\n  ares_free(ip->name);\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ip_free_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_iface_ips_t *ares_iface_ips_alloc(ares_iface_ip_flags_t flags)\n{\n  ares_iface_ips_t *ips = ares_malloc_zero(sizeof(*ips));\n  if (ips == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  ips->enum_flags = flags;\n  ips->ips = ares_array_create(sizeof(ares_iface_ip_t), ares_iface_ip_free_cb);\n  if (ips->ips == NULL) {\n    ares_free(ips); /* LCOV_EXCL_LINE: OutOfMemory */\n    return NULL;    /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  return ips;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_alloc",
            "parameters": {
              "flags": "ares_iface_ip_flags_t"
            },
            "return_type": "ares_iface_ips_t"
          }
        },
        {
          "fn_code": "void ares_iface_ips_destroy(ares_iface_ips_t *ips)\n{\n  if (ips == NULL) {\n    return;\n  }\n\n  ares_array_destroy(ips->ips);\n  ares_free(ips);\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_destroy",
            "parameters": {
              "ips": "ares_iface_ips_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_iface_ips(ares_iface_ips_t    **ips,\n                             ares_iface_ip_flags_t flags, const char *name)\n{\n  ares_status_t status;\n\n  if (ips == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *ips = ares_iface_ips_alloc(flags);\n  if (*ips == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_iface_ips_enumerate(*ips, name);\n  if (status != ARES_SUCCESS) {\n    /* LCOV_EXCL_START: UntestablePath */\n    ares_iface_ips_destroy(*ips);\n    *ips = NULL;\n    return status;\n    /* LCOV_EXCL_STOP */\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "flags": "ares_iface_ip_flags_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_iface_ips_add(ares_iface_ips_t *ips, ares_iface_ip_flags_t flags,\n                     const char *name, const struct ares_addr *addr,\n                     unsigned char netmask, unsigned int ll_scope)\n{\n  ares_iface_ip_t *ip;\n  ares_status_t    status;\n\n  if (ips == NULL || name == NULL || addr == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Don't want loopback */\n  if (flags & ARES_IFACE_IP_LOOPBACK &&\n      !(ips->enum_flags & ARES_IFACE_IP_LOOPBACK)) {\n    return ARES_SUCCESS;\n  }\n\n  /* Don't want offline */\n  if (flags & ARES_IFACE_IP_OFFLINE &&\n      !(ips->enum_flags & ARES_IFACE_IP_OFFLINE)) {\n    return ARES_SUCCESS;\n  }\n\n  /* Check for link-local */\n  if (ares_addr_is_linklocal(addr)) {\n    flags |= ARES_IFACE_IP_LINKLOCAL;\n  }\n  if (flags & ARES_IFACE_IP_LINKLOCAL &&\n      !(ips->enum_flags & ARES_IFACE_IP_LINKLOCAL)) {\n    return ARES_SUCCESS;\n  }\n\n  /* Set address flag based on address provided */\n  if (addr->family == AF_INET) {\n    flags |= ARES_IFACE_IP_V4;\n  }\n\n  if (addr->family == AF_INET6) {\n    flags |= ARES_IFACE_IP_V6;\n  }\n\n  /* If they specified either v4 or v6 validate flags otherwise assume they\n   * want to enumerate both */\n  if (ips->enum_flags & (ARES_IFACE_IP_V4 | ARES_IFACE_IP_V6)) {\n    if (flags & ARES_IFACE_IP_V4 && !(ips->enum_flags & ARES_IFACE_IP_V4)) {\n      return ARES_SUCCESS;\n    }\n    if (flags & ARES_IFACE_IP_V6 && !(ips->enum_flags & ARES_IFACE_IP_V6)) {\n      return ARES_SUCCESS;\n    }\n  }\n\n  status = ares_array_insert_last((void **)&ip, ips->ips);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  ip->flags   = flags;\n  ip->netmask = netmask;\n  if (flags & ARES_IFACE_IP_LINKLOCAL) {\n    ip->ll_scope = ll_scope;\n  }\n  memcpy(&ip->addr, addr, sizeof(*addr));\n  ip->name = ares_strdup(name);\n  if (ip->name == NULL) {\n    ares_array_remove_last(ips->ips);\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_add",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "flags": "ares_iface_ip_flags_t",
              "name": "char",
              "addr": "struct ares_addr",
              "netmask": "unsigned char",
              "ll_scope": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "size_t ares_iface_ips_cnt(const ares_iface_ips_t *ips)\n{\n  if (ips == NULL) {\n    return 0;\n  }\n  return ares_array_len(ips->ips);\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_cnt",
            "parameters": {
              "ips": "ares_iface_ips_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "const char *ares_iface_ips_get_name(const ares_iface_ips_t *ips, size_t idx)\n{\n  const ares_iface_ip_t *ip;\n\n  if (ips == NULL) {\n    return NULL;\n  }\n\n  ip = ares_array_at_const(ips->ips, idx);\n  if (ip == NULL) {\n    return NULL;\n  }\n\n  return ip->name;\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_name",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const struct ares_addr *ares_iface_ips_get_addr(const ares_iface_ips_t *ips,\n                                                size_t                  idx)\n{\n  const ares_iface_ip_t *ip;\n\n  if (ips == NULL) {\n    return NULL;\n  }\n\n  ip = ares_array_at_const(ips->ips, idx);\n  if (ip == NULL) {\n    return NULL;\n  }\n\n  return &ip->addr;\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_addr",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_iface_ip_flags_t ares_iface_ips_get_flags(const ares_iface_ips_t *ips,\n                                               size_t                  idx)\n{\n  const ares_iface_ip_t *ip;\n\n  if (ips == NULL) {\n    return 0;\n  }\n\n  ip = ares_array_at_const(ips->ips, idx);\n  if (ip == NULL) {\n    return 0;\n  }\n\n  return ip->flags;\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_flags",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": "ares_iface_ip_flags_t"
          }
        },
        {
          "fn_code": "unsigned char ares_iface_ips_get_netmask(const ares_iface_ips_t *ips,\n                                         size_t                  idx)\n{\n  const ares_iface_ip_t *ip;\n\n  if (ips == NULL) {\n    return 0;\n  }\n\n  ip = ares_array_at_const(ips->ips, idx);\n  if (ip == NULL) {\n    return 0;\n  }\n\n  return ip->netmask;\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              284,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_netmask",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int ares_iface_ips_get_ll_scope(const ares_iface_ips_t *ips,\n                                         size_t                  idx)\n{\n  const ares_iface_ip_t *ip;\n\n  if (ips == NULL) {\n    return 0;\n  }\n\n  ip = ares_array_at_const(ips->ips, idx);\n  if (ip == NULL) {\n    return 0;\n  }\n\n  return ip->ll_scope;\n}",
          "fn_code_pos": [
            [
              286,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_ll_scope",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static char *wcharp_to_charp(const wchar_t *in)\n{\n  char *out;\n  int   len;\n\n  len = WideCharToMultiByte(CP_UTF8, 0, in, -1, NULL, 0, NULL, NULL);\n  if (len == -1) {\n    return NULL;\n  }\n\n  out = ares_malloc_zero((size_t)len + 1);\n\n  if (WideCharToMultiByte(CP_UTF8, 0, in, -1, out, len, NULL, NULL) == -1) {\n    ares_free(out);\n    return NULL;\n  }\n\n  return out;\n}",
          "fn_code_pos": [
            [
              307,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wcharp_to_charp",
            "parameters": {
              "in": "wchar_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_bool_t name_match(const char *name, const char *adapter_name,\n                              unsigned int ll_scope)\n{\n  if (name == NULL || *name == 0) {\n    return ARES_TRUE;\n  }\n\n  if (ares_strcaseeq(name, adapter_name)) {\n    return ARES_TRUE;\n  }\n\n  if (ares_str_isnum(name) && (unsigned int)atoi(name) == ll_scope) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              328,
              0
            ],
            [
              344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "name_match",
            "parameters": {
              "name": "char",
              "adapter_name": "char",
              "ll_scope": "unsigned int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_iface_ips_enumerate(ares_iface_ips_t *ips,\n                                              const char       *name)\n{\n  ULONG myflags = GAA_FLAG_INCLUDE_PREFIX /*|GAA_FLAG_INCLUDE_ALL_INTERFACES */;\n  ULONG outBufLen = 0;\n  DWORD retval;\n  IP_ADAPTER_ADDRESSES *addresses = NULL;\n  IP_ADAPTER_ADDRESSES *address   = NULL;\n  ares_status_t         status    = ARES_SUCCESS;\n\n  /* Get necessary buffer size */\n  GetAdaptersAddresses(AF_UNSPEC, myflags, NULL, NULL, &outBufLen);\n  if (outBufLen == 0) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  addresses = ares_malloc_zero(outBufLen);\n  if (addresses == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  retval =\n    GetAdaptersAddresses(AF_UNSPEC, myflags, NULL, addresses, &outBufLen);\n  if (retval != ERROR_SUCCESS) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  for (address = addresses; address != NULL; address = address->Next) {\n    IP_ADAPTER_UNICAST_ADDRESS *ipaddr     = NULL;\n    ares_iface_ip_flags_t       addrflag   = 0;\n    char                        ifname[64] = \"\";\n\n#  if defined(HAVE_CONVERTINTERFACEINDEXTOLUID) && \\\n    defined(HAVE_CONVERTINTERFACELUIDTONAMEA)\n    /* Retrieve name from interface index.\n     * address->AdapterName appears to be a GUID/UUID of some sort, not a name.\n     * address->FriendlyName is user-changeable.\n     * That said, this doesn't appear to help us out on systems that don't\n     * have if_nametoindex() or if_indextoname() as they don't have these\n     * functions either! */\n    NET_LUID luid;\n    ConvertInterfaceIndexToLuid(address->IfIndex, &luid);\n    ConvertInterfaceLuidToNameA(&luid, ifname, sizeof(ifname));\n#  else\n    ares_strcpy(ifname, address->AdapterName, sizeof(ifname));\n#  endif\n\n    if (address->OperStatus != IfOperStatusUp) {\n      addrflag |= ARES_IFACE_IP_OFFLINE;\n    }\n\n    if (address->IfType == IF_TYPE_SOFTWARE_LOOPBACK) {\n      addrflag |= ARES_IFACE_IP_LOOPBACK;\n    }\n\n    for (ipaddr = address->FirstUnicastAddress; ipaddr != NULL;\n         ipaddr = ipaddr->Next) {\n      struct ares_addr addr;\n\n      if (ipaddr->Address.lpSockaddr->sa_family == AF_INET) {\n        const struct sockaddr_in *sockaddr_in =\n          (const struct sockaddr_in *)((void *)ipaddr->Address.lpSockaddr);\n        addr.family = AF_INET;\n        memcpy(&addr.addr.addr4, &sockaddr_in->sin_addr,\n               sizeof(addr.addr.addr4));\n      } else if (ipaddr->Address.lpSockaddr->sa_family == AF_INET6) {\n        const struct sockaddr_in6 *sockaddr_in6 =\n          (const struct sockaddr_in6 *)((void *)ipaddr->Address.lpSockaddr);\n        addr.family = AF_INET6;\n        memcpy(&addr.addr.addr6, &sockaddr_in6->sin6_addr,\n               sizeof(addr.addr.addr6));\n      } else {\n        /* Unknown */\n        continue;\n      }\n\n      /* Sometimes windows may use numerics to indicate a DNS server's adapter,\n       * which corresponds to the index rather than the name.  Check and\n       * validate both. */\n      if (!name_match(name, ifname, address->Ipv6IfIndex)) {\n        continue;\n      }\n\n      status = ares_iface_ips_add(ips, addrflag, ifname, &addr,\n#if _WIN32_WINNT >= 0x0600\n                                  ipaddr->OnLinkPrefixLength /* netmask */,\n#else\n                                  ipaddr->Address.lpSockaddr->sa_family\n                                    == AF_INET?32:128,\n#endif\n                                  address->Ipv6IfIndex /* ll_scope */\n                                  );\n\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n  }\n\ndone:\n  ares_free(addresses);\n  return status;\n}",
          "fn_code_pos": [
            [
              346,
              0
            ],
            [
              451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_enumerate",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static unsigned char count_addr_bits(const unsigned char *addr, size_t addr_len)\n{\n  size_t        i;\n  unsigned char count = 0;\n\n  for (i = 0; i < addr_len; i++) {\n    count += ares_count_bits_u8(addr[i]);\n  }\n  return count;\n}",
          "fn_code_pos": [
            [
              455,
              0
            ],
            [
              464,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "count_addr_bits",
            "parameters": {
              "addr": "unsigned char",
              "addr_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_status_t ares_iface_ips_enumerate(ares_iface_ips_t *ips,\n                                              const char       *name)\n{\n  struct ifaddrs *ifap   = NULL;\n  struct ifaddrs *ifa    = NULL;\n  ares_status_t   status = ARES_SUCCESS;\n\n  if (getifaddrs(&ifap) != 0) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n    ares_iface_ip_flags_t addrflag = 0;\n    struct ares_addr      addr;\n    unsigned char         netmask  = 0;\n    unsigned int          ll_scope = 0;\n\n    if (ifa->ifa_addr == NULL) {\n      continue;\n    }\n\n    if (!(ifa->ifa_flags & IFF_UP)) {\n      addrflag |= ARES_IFACE_IP_OFFLINE;\n    }\n\n    if (ifa->ifa_flags & IFF_LOOPBACK) {\n      addrflag |= ARES_IFACE_IP_LOOPBACK;\n    }\n\n    if (ifa->ifa_addr->sa_family == AF_INET) {\n      const struct sockaddr_in *sockaddr_in =\n        (const struct sockaddr_in *)((void *)ifa->ifa_addr);\n      addr.family = AF_INET;\n      memcpy(&addr.addr.addr4, &sockaddr_in->sin_addr, sizeof(addr.addr.addr4));\n      /* netmask */\n      sockaddr_in = (struct sockaddr_in *)((void *)ifa->ifa_netmask);\n      netmask     = count_addr_bits((const void *)&sockaddr_in->sin_addr, 4);\n    } else if (ifa->ifa_addr->sa_family == AF_INET6) {\n      const struct sockaddr_in6 *sockaddr_in6 =\n        (const struct sockaddr_in6 *)((void *)ifa->ifa_addr);\n      addr.family = AF_INET6;\n      memcpy(&addr.addr.addr6, &sockaddr_in6->sin6_addr,\n             sizeof(addr.addr.addr6));\n      /* netmask */\n      sockaddr_in6 = (struct sockaddr_in6 *)((void *)ifa->ifa_netmask);\n      netmask = count_addr_bits((const void *)&sockaddr_in6->sin6_addr, 16);\n#  ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n      ll_scope = sockaddr_in6->sin6_scope_id;\n#  endif\n    } else {\n      /* unknown */\n      continue;\n    }\n\n    /* Name mismatch */\n    if (name != NULL && !ares_strcaseeq(ifa->ifa_name, name)) {\n      continue;\n    }\n\n    status = ares_iface_ips_add(ips, addrflag, ifa->ifa_name, &addr, netmask,\n                                ll_scope);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  freeifaddrs(ifap);\n  return status;\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              536,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_enumerate",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_iface_ips_enumerate(ares_iface_ips_t *ips,\n                                              const char       *name)\n{\n  (void)ips;\n  (void)name;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              540,
              0
            ],
            [
              546,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_enumerate",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "unsigned int ares_os_if_nametoindex(const char *name)\n{\n#ifdef HAVE_IF_NAMETOINDEX\n  if (name == NULL) {\n    return 0;\n  }\n  return if_nametoindex(name);\n#else\n  ares_status_t     status;\n  ares_iface_ips_t *ips = NULL;\n  size_t            i;\n  unsigned int      index = 0;\n\n  if (name == NULL) {\n    return 0;\n  }\n\n  status =\n    ares_iface_ips(&ips, ARES_IFACE_IP_V6 | ARES_IFACE_IP_LINKLOCAL, name);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (i = 0; i < ares_iface_ips_cnt(ips); i++) {\n    if (ares_iface_ips_get_flags(ips, i) & ARES_IFACE_IP_LINKLOCAL) {\n      index = ares_iface_ips_get_ll_scope(ips, i);\n      goto done;\n    }\n  }\n\ndone:\n  ares_iface_ips_destroy(ips);\n  return index;\n#endif\n}",
          "fn_code_pos": [
            [
              551,
              0
            ],
            [
              585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_os_if_nametoindex",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const char *ares_os_if_indextoname(unsigned int index, char *name, size_t name_len)\n{\n#ifdef HAVE_IF_INDEXTONAME\n  if (name_len < IF_NAMESIZE) {\n    return NULL;\n  }\n  return if_indextoname(index, name);\n#else\n  ares_status_t     status;\n  ares_iface_ips_t *ips = NULL;\n  size_t            i;\n  const char       *ptr = NULL;\n\n  if (name == NULL || name_len < IF_NAMESIZE) {\n    goto done;\n  }\n\n  if (index == 0) {\n    goto done;\n  }\n\n  status =\n    ares_iface_ips(&ips, ARES_IFACE_IP_V6 | ARES_IFACE_IP_LINKLOCAL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (i = 0; i < ares_iface_ips_cnt(ips); i++) {\n    if (ares_iface_ips_get_flags(ips, i) & ARES_IFACE_IP_LINKLOCAL &&\n        ares_iface_ips_get_ll_scope(ips, i) == index) {\n      ares_strcpy(name, ares_iface_ips_get_name(ips, i), name_len);\n      ptr = name;\n      goto done;\n    }\n  }\n\ndone:\n  ares_iface_ips_destroy(ips);\n  return ptr;\n#endif\n}",
          "fn_code_pos": [
            [
              587,
              0
            ],
            [
              627,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_os_if_indextoname",
            "parameters": {
              "index": "unsigned int",
              "name": "char",
              "name_len": "size_t"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_iface_ips_enumerate(ares_iface_ips_t *ips,\n                                              const char       *name)",
          "fn_dec_pos": [
            [
              61,
              21
            ],
            [
              62,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_enumerate",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_iface_ips_alloc(ares_iface_ip_flags_t flags)",
          "fn_dec_pos": [
            [
              86,
              25
            ],
            [
              86,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_alloc",
            "parameters": {
              "flags": "ares_iface_ip_flags_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_iface_ips_get_name(const ares_iface_ips_t *ips, size_t idx)",
          "fn_dec_pos": [
            [
              219,
              12
            ],
            [
              219,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_name",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_iface_ips_get_addr(const ares_iface_ips_t *ips,\n                                                size_t                  idx)",
          "fn_dec_pos": [
            [
              235,
              24
            ],
            [
              236,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_addr",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "wcharp_to_charp(const wchar_t *in)",
          "fn_dec_pos": [
            [
              307,
              13
            ],
            [
              307,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wcharp_to_charp",
            "parameters": {
              "in": "wchar_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_os_if_indextoname(unsigned int index, char *name, size_t name_len)",
          "fn_dec_pos": [
            [
              587,
              12
            ],
            [
              587,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_os_if_indextoname",
            "parameters": {
              "index": "unsigned int",
              "name": "char",
              "name_len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  char                 *name;\n  struct ares_addr      addr;\n  unsigned char         netmask;\n  unsigned int          ll_scope;\n  ares_iface_ip_flags_t flags;\n} ares_iface_ip_t;",
          {
            "*name": "char",
            "addr": "struct ares_addr",
            "netmask": "unsigned char",
            "ll_scope": "unsigned int",
            "flags": "ares_iface_ip_flags_t"
          },
          "ares_iface_ip_t",
          [
            64,
            0
          ],
          [
            70,
            18
          ]
        ],
        [
          "struct ares_iface_ips {\n  ares_array_t         *ips; /*!< Type is ares_iface_ip_t */\n  ares_iface_ip_flags_t enum_flags;\n}",
          {
            "*ips": "ares_array_t",
            "enum_flags": "ares_iface_ip_flags_t"
          },
          "ares_iface_ips",
          [
            72,
            0
          ],
          [
            75,
            1
          ]
        ],
        [
          "typedef struct {\n  char                 *name;\n  struct ares_addr      addr;\n  unsigned char         netmask;\n  unsigned int          ll_scope;\n  ares_iface_ip_flags_t flags;\n} ares_iface_ip_t;",
          {
            "*name": "char",
            "addr": "struct ares_addr",
            "netmask": "unsigned char",
            "ll_scope": "unsigned int",
            "flags": "ares_iface_ip_flags_t"
          },
          "ares_iface_ip_t",
          [
            64,
            0
          ],
          [
            70,
            18
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            66,
            2
          ],
          [
            66,
            18
          ]
        ],
        [
          "struct ares_iface_ips {\n  ares_array_t         *ips; /*!< Type is ares_iface_ip_t */\n  ares_iface_ip_flags_t enum_flags;\n}",
          {
            "*ips": "ares_array_t",
            "enum_flags": "ares_iface_ip_flags_t"
          },
          "ares_iface_ips",
          [
            72,
            0
          ],
          [
            75,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            140,
            45
          ],
          [
            140,
            61
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            235,
            6
          ],
          [
            235,
            22
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            406,
            6
          ],
          [
            406,
            22
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            409,
            14
          ],
          [
            409,
            32
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            410,
            17
          ],
          [
            410,
            35
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            415,
            14
          ],
          [
            415,
            33
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            416,
            17
          ],
          [
            416,
            36
          ]
        ],
        [
          "struct ifaddrs",
          {},
          "",
          [
            469,
            2
          ],
          [
            469,
            16
          ]
        ],
        [
          "struct ifaddrs",
          {},
          "",
          [
            470,
            2
          ],
          [
            470,
            16
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            480,
            4
          ],
          [
            480,
            20
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            497,
            12
          ],
          [
            497,
            30
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            498,
            15
          ],
          [
            498,
            33
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            502,
            21
          ],
          [
            502,
            39
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            505,
            12
          ],
          [
            505,
            31
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            506,
            15
          ],
          [
            506,
            34
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            511,
            22
          ],
          [
            511,
            41
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#  include <winsock2.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <ws2tcpip.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#  include <net/if.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include <ifaddrs.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_threads.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_thread_mutex_t *ares_thread_mutex_create(void)\n{\n  ares_thread_mutex_t *mut = ares_malloc_zero(sizeof(*mut));\n  if (mut == NULL) {\n    return NULL;\n  }\n\n  InitializeCriticalSection(&mut->mutex);\n  return mut;\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_create",
            "parameters": {},
            "return_type": "ares_thread_mutex_t"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_destroy(ares_thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  DeleteCriticalSection(&mut->mutex);\n  ares_free(mut);\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_destroy",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_lock(ares_thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  EnterCriticalSection(&mut->mutex);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_lock",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_unlock(ares_thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  LeaveCriticalSection(&mut->mutex);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_unlock",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_cond_t *ares_thread_cond_create(void)\n{\n  ares_thread_cond_t *cond = ares_malloc_zero(sizeof(*cond));\n  if (cond == NULL) {\n    return NULL;\n  }\n  InitializeConditionVariable(&cond->cond);\n  return cond;\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": "ares_thread_cond_t"
          }
        },
        {
          "fn_code": "void ares_thread_cond_destroy(ares_thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  ares_free(cond);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_destroy",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_cond_signal(ares_thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  WakeConditionVariable(&cond->cond);\n}",
          "fn_code_pos": [
            [
              97,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_signal",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_cond_broadcast(ares_thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  WakeAllConditionVariable(&cond->cond);\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_broadcast",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_cond_wait(ares_thread_cond_t  *cond,\n                                    ares_thread_mutex_t *mut)\n{\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  SleepConditionVariableCS(&cond->cond, &mut->mutex, INFINITE);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_wait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_cond_timedwait(ares_thread_cond_t  *cond,\n                                         ares_thread_mutex_t *mut,\n                                         size_t               timeout_ms)\n{\n  DWORD tout;\n\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (timeout_ms == SIZE_MAX) {\n    tout = INFINITE;\n  } else {\n    tout = (DWORD)timeout_ms;\n  }\n\n  if (!SleepConditionVariableCS(&cond->cond, &mut->mutex, tout)) {\n    return ARES_ETIMEOUT;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_timedwait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t",
              "timeout_ms": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_thread_cond_t *ares_thread_cond_create(void)\n{\n  ares_thread_cond_t *cond;\n\n  cond = ares_malloc_zero(sizeof(*cond));\n  if (cond == NULL) {\n    return NULL;\n  }\n\n  cond->events[ARES_W32_COND_SIGNAL] = CreateEvent(NULL, FALSE, FALSE, NULL);\n  if (cond->events[ARES_W32_COND_SIGNAL] == NULL) {\n    goto fail;\n  }\n\n  cond->events[ARES_W32_COND_BROADCAST] = CreateEvent(NULL, TRUE, FALSE, NULL);\n  if (cond->events[ARES_W32_COND_BROADCAST] == NULL) {\n    goto fail;\n  }\n\n  /* Use a semaphore as a gate so we don't lose signals */\n  cond->gate = CreateSemaphore(NULL, 1, 1, NULL);\n  if (cond->gate == NULL) {\n    goto fail;\n  }\n\n  InitializeCriticalSection(&cond->mutex);\n  cond->waiters = 0;\n  cond->event   = ARES_W32_COND_NONE;\n\n  return cond;\n\nfail:\n  ares_thread_cond_destroy(cond);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": "ares_thread_cond_t"
          }
        },
        {
          "fn_code": "void ares_thread_cond_destroy(ares_thread_cond_t *cond)\n{\n  if (cond == NULL)\n    return;\n\n  if (cond->events[ARES_W32_COND_SIGNAL]) {\n    CloseHandle(cond->events[ARES_W32_COND_SIGNAL]);\n  }\n  if (cond->events[ARES_W32_COND_BROADCAST]) {\n    CloseHandle(cond->events[ARES_W32_COND_BROADCAST]);\n  }\n  if (cond->gate) {\n    CloseHandle(cond->gate);\n  }\n  DeleteCriticalSection(&cond->mutex);\n\n  ares_free(cond);\n}",
          "fn_code_pos": [
            [
              200,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_destroy",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_cond_timedwait(ares_thread_cond_t  *cond,\n                                         ares_thread_mutex_t *mut,\n                                         size_t               timeout_ms)\n{\n  DWORD rv;\n  DWORD dwMilliseconds;\n\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* We may only enter when no wakeups active this will prevent the lost\n   * wakeup */\n  WaitForSingleObject(cond->gate, INFINITE);\n\n  EnterCriticalSection(&cond->mutex);\n  /* count waiters passing through */\n  cond->waiters++;\n  LeaveCriticalSection(&cond->mutex);\n\n  /* Open Gate */\n  ReleaseSemaphore(cond->gate, 1, NULL);\n\n  /* Release passed in mutex */\n  ares_thread_mutex_unlock(mut);\n\n  if (timeout_ms == SIZE_MAX) {\n    dwMilliseconds = INFINITE;\n  } else {\n    dwMilliseconds = (DWORD)timeout_ms;\n  }\n  rv = WaitForMultipleObjects(ARES_W32_COND_EVMAX, cond->events, FALSE,\n                              dwMilliseconds);\n\n  /* We go into a critical section to make sure cond->waiters isn't checked\n   * while we decrement.  This is especially important for a timeout since the\n   * gate may not be closed. We need to check to see if a broadcast/signal was\n   * pending as this thread could have been preempted prior to\n   * EnterCriticalSection but after WaitForMultipleObjects() so we may be\n   * responsible for resetting the event and closing the gate */\n  EnterCriticalSection(&cond->mutex);\n  cond->waiters--;\n\n  if (cond->event != ARES_W32_COND_NONE && cond->waiters == 0) {\n    /* Last waiter needs to reset the event on(as a broadcast event is not\n     * automatic) and also re-open the gate */\n    if (cond->event == ARES_W32_COND_BROADCAST) {\n      ResetEvent(cond->events[ARES_W32_COND_BROADCAST]);\n    }\n\n    /* Open Gate (closed by ares_thread_cond_broadcast()) since there are no\n     * more waiters for the event */\n    ReleaseSemaphore(cond->gate, 1, NULL);\n    cond->event = ARES_W32_COND_NONE;\n  } else if (rv == WAIT_OBJECT_0 + ARES_W32_COND_SIGNAL) {\n    /* If specifically, this thread was signalled and there are more waiting,\n     * re-open the gate and reset the event */\n    ReleaseSemaphore(cond->gate, 1, NULL);\n    cond->event = ARES_W32_COND_NONE;\n  } else {\n    /* This could be a standard timeout with more waiters, don't do anything */\n  }\n  LeaveCriticalSection(&cond->mutex);\n\n  /* re-lock the passed in mutex */\n  ares_thread_mutex_lock(mut);\n\n  if (rv == WAIT_TIMEOUT) {\n    return ARES_ETIMEOUT;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              291,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_timedwait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t",
              "timeout_ms": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_cond_wait(ares_thread_cond_t  *cond,\n                                    ares_thread_mutex_t *mut)\n{\n  return ares_thread_cond_timedwait(cond, mut, SIZE_MAX);\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_wait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_thread_cond_broadcast(ares_thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n\n  /* close gate to prevent more waiters while broadcasting */\n  WaitForSingleObject(cond->gate, INFINITE);\n\n  /* If there are waiters, send a broadcast event,\n   * otherwise, just reopen the gate */\n  EnterCriticalSection(&cond->mutex);\n\n  cond->event = ARES_W32_COND_BROADCAST;\n  if (cond->waiters) {\n    /* wake all waiters */\n    SetEvent(cond->events[ARES_W32_COND_BROADCAST]);\n  } else {\n    /* if no waiters just reopen gate */\n    ReleaseSemaphore(cond->gate, 1, NULL);\n  }\n\n  LeaveCriticalSection(&cond->mutex);\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_broadcast",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_cond_signal(ares_thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n\n  /* close gate to prevent more waiters while signalling */\n  WaitForSingleObject(cond->gate, INFINITE);\n\n  EnterCriticalSection(&cond->mutex);\n  cond->event = ARES_W32_COND_SIGNAL;\n  if (cond->waiters) {\n    /* wake one waiter */\n    SetEvent(cond->events[ARES_W32_COND_SIGNAL]);\n  } else {\n    /* no waiters, just reopen the gate */\n    ReleaseSemaphore(cond->gate, 1, NULL);\n  }\n  LeaveCriticalSection(&cond->mutex);\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_signal",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static DWORD WINAPI ares_thread_func(LPVOID lpParameter)\n{\n  ares_thread_t *thread = lpParameter;\n\n  thread->rv = thread->func(thread->arg);\n  return 0;\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_func",
            "parameters": {
              "lpParameter": "LPVOID"
            },
            "return_type": "DWORD"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_create(ares_thread_t    **thread,\n                                 ares_thread_func_t func, void *arg)\n{\n  ares_thread_t *thr = NULL;\n\n  if (func == NULL || thread == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  thr = ares_malloc_zero(sizeof(*thr));\n  if (thr == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  thr->func   = func;\n  thr->arg    = arg;\n  thr->thread = CreateThread(NULL, 0, ares_thread_func, thr, 0, &thr->id);\n  if (thr->thread == NULL) {\n    ares_free(thr);\n    return ARES_ESERVFAIL;\n  }\n\n  *thread = thr;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_create",
            "parameters": {
              "thread": "ares_thread_t",
              "func": "ares_thread_func_t",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_join(ares_thread_t *thread, void **rv)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  if (thread == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (WaitForSingleObject(thread->thread, INFINITE) != WAIT_OBJECT_0) {\n    status = ARES_ENOTFOUND;\n  } else {\n    CloseHandle(thread->thread);\n  }\n\n  if (status == ARES_SUCCESS && rv != NULL) {\n    *rv = thread->rv;\n  }\n  ares_free(thread);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_join",
            "parameters": {
              "thread": "ares_thread_t",
              "rv": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_thread_mutex_t *ares_thread_mutex_create(void)\n{\n  pthread_mutexattr_t  attr;\n  ares_thread_mutex_t *mut = ares_malloc_zero(sizeof(*mut));\n  if (mut == NULL) {\n    return NULL;\n  }\n\n  if (pthread_mutexattr_init(&attr) != 0) {\n    ares_free(mut); /* LCOV_EXCL_LINE: UntestablePath */\n    return NULL;    /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) != 0) {\n    goto fail; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  if (pthread_mutex_init(&mut->mutex, &attr) != 0) {\n    goto fail; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  pthread_mutexattr_destroy(&attr);\n  return mut;\n\n/* LCOV_EXCL_START: UntestablePath */\nfail:\n  pthread_mutexattr_destroy(&attr);\n  ares_free(mut);\n  return NULL;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              430,
              0
            ],
            [
              460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_create",
            "parameters": {},
            "return_type": "ares_thread_mutex_t"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_destroy(ares_thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  pthread_mutex_destroy(&mut->mutex);\n  ares_free(mut);\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              469,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_destroy",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_lock(ares_thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  pthread_mutex_lock(&mut->mutex);\n}",
          "fn_code_pos": [
            [
              471,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_lock",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_unlock(ares_thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  pthread_mutex_unlock(&mut->mutex);\n}",
          "fn_code_pos": [
            [
              479,
              0
            ],
            [
              485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_unlock",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_cond_t *ares_thread_cond_create(void)\n{\n  ares_thread_cond_t *cond = ares_malloc_zero(sizeof(*cond));\n  if (cond == NULL) {\n    return NULL;\n  }\n  pthread_cond_init(&cond->cond, NULL);\n  return cond;\n}",
          "fn_code_pos": [
            [
              491,
              0
            ],
            [
              499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": "ares_thread_cond_t"
          }
        },
        {
          "fn_code": "void ares_thread_cond_destroy(ares_thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  pthread_cond_destroy(&cond->cond);\n  ares_free(cond);\n}",
          "fn_code_pos": [
            [
              501,
              0
            ],
            [
              508,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_destroy",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_cond_signal(ares_thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  pthread_cond_signal(&cond->cond);\n}",
          "fn_code_pos": [
            [
              510,
              0
            ],
            [
              516,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_signal",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_cond_broadcast(ares_thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  pthread_cond_broadcast(&cond->cond);\n}",
          "fn_code_pos": [
            [
              518,
              0
            ],
            [
              524,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_broadcast",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_cond_wait(ares_thread_cond_t  *cond,\n                                    ares_thread_mutex_t *mut)\n{\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  pthread_cond_wait(&cond->cond, &mut->mutex);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              526,
              0
            ],
            [
              535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_wait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void ares_timespec_timeout(struct timespec *ts, size_t add_ms)\n{\n#    if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_REALTIME)\n  clock_gettime(CLOCK_REALTIME, ts);\n#    elif defined(HAVE_GETTIMEOFDAY)\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  ts->tv_sec  = tv.tv_sec;\n  ts->tv_nsec = tv.tv_usec * 1000;\n#    else\n#      error cannot determine current system time\n#    endif\n\n  ts->tv_sec  += (time_t)(add_ms / 1000);\n  ts->tv_nsec += (long)((add_ms % 1000) * 1000000);\n\n  /* Normalize if needed */\n  if (ts->tv_nsec >= 1000000000) {\n    ts->tv_sec  += ts->tv_nsec / 1000000000;\n    ts->tv_nsec %= 1000000000;\n  }\n}",
          "fn_code_pos": [
            [
              537,
              0
            ],
            [
              558,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timespec_timeout",
            "parameters": {
              "ts": "struct timespec",
              "add_ms": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_cond_timedwait(ares_thread_cond_t  *cond,\n                                         ares_thread_mutex_t *mut,\n                                         size_t               timeout_ms)\n{\n  struct timespec ts;\n\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (timeout_ms == SIZE_MAX) {\n    return ares_thread_cond_wait(cond, mut);\n  }\n\n  ares_timespec_timeout(&ts, timeout_ms);\n\n  if (pthread_cond_timedwait(&cond->cond, &mut->mutex, &ts) != 0) {\n    return ARES_ETIMEOUT;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              560,
              0
            ],
            [
              581,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_timedwait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t",
              "timeout_ms": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_create(ares_thread_t    **thread,\n                                 ares_thread_func_t func, void *arg)\n{\n  ares_thread_t *thr = NULL;\n\n  if (func == NULL || thread == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  thr = ares_malloc_zero(sizeof(*thr));\n  if (thr == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  if (pthread_create(&thr->thread, NULL, func, arg) != 0) {\n    ares_free(thr);        /* LCOV_EXCL_LINE: UntestablePath */\n    return ARES_ESERVFAIL; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  *thread = thr;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              587,
              0
            ],
            [
              607,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_create",
            "parameters": {
              "thread": "ares_thread_t",
              "func": "ares_thread_func_t",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_join(ares_thread_t *thread, void **rv)\n{\n  void         *ret    = NULL;\n  ares_status_t status = ARES_SUCCESS;\n\n  if (thread == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (pthread_join(thread->thread, &ret) != 0) {\n    status = ARES_ENOTFOUND;\n  }\n  ares_free(thread);\n\n  if (status == ARES_SUCCESS && rv != NULL) {\n    *rv = ret;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              609,
              0
            ],
            [
              627,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_join",
            "parameters": {
              "thread": "ares_thread_t",
              "rv": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_threadsafety(void)\n{\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              631,
              0
            ],
            [
              634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_threadsafety",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_thread_mutex_t *ares_thread_mutex_create(void)\n{\n  return NULL;\n}",
          "fn_code_pos": [
            [
              639,
              0
            ],
            [
              642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_create",
            "parameters": {},
            "return_type": "ares_thread_mutex_t"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_destroy(ares_thread_mutex_t *mut)\n{\n  (void)mut;\n}",
          "fn_code_pos": [
            [
              644,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_destroy",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_lock(ares_thread_mutex_t *mut)\n{\n  (void)mut;\n}",
          "fn_code_pos": [
            [
              649,
              0
            ],
            [
              652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_lock",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_mutex_unlock(ares_thread_mutex_t *mut)\n{\n  (void)mut;\n}",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              657,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_unlock",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_cond_t *ares_thread_cond_create(void)\n{\n  return NULL;\n}",
          "fn_code_pos": [
            [
              659,
              0
            ],
            [
              662,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": "ares_thread_cond_t"
          }
        },
        {
          "fn_code": "void ares_thread_cond_destroy(ares_thread_cond_t *cond)\n{\n  (void)cond;\n}",
          "fn_code_pos": [
            [
              664,
              0
            ],
            [
              667,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_destroy",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_cond_signal(ares_thread_cond_t *cond)\n{\n  (void)cond;\n}",
          "fn_code_pos": [
            [
              669,
              0
            ],
            [
              672,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_signal",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_thread_cond_broadcast(ares_thread_cond_t *cond)\n{\n  (void)cond;\n}",
          "fn_code_pos": [
            [
              674,
              0
            ],
            [
              677,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_broadcast",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_cond_wait(ares_thread_cond_t  *cond,\n                                    ares_thread_mutex_t *mut)\n{\n  (void)cond;\n  (void)mut;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              679,
              0
            ],
            [
              685,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_wait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_cond_timedwait(ares_thread_cond_t  *cond,\n                                         ares_thread_mutex_t *mut,\n                                         size_t               timeout_ms)\n{\n  (void)cond;\n  (void)mut;\n  (void)timeout_ms;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              687,
              0
            ],
            [
              695,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_timedwait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t",
              "timeout_ms": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_create(ares_thread_t    **thread,\n                                 ares_thread_func_t func, void *arg)\n{\n  (void)thread;\n  (void)func;\n  (void)arg;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              697,
              0
            ],
            [
              704,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_create",
            "parameters": {
              "thread": "ares_thread_t",
              "func": "ares_thread_func_t",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_thread_join(ares_thread_t *thread, void **rv)\n{\n  (void)thread;\n  (void)rv;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              706,
              0
            ],
            [
              711,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_join",
            "parameters": {
              "thread": "ares_thread_t",
              "rv": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_threadsafety(void)\n{\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              713,
              0
            ],
            [
              716,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_threadsafety",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_channel_threading_init(ares_channel_t *channel)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  /* Threading is optional! */\n  if (!ares_threadsafety()) {\n    return ARES_SUCCESS;\n  }\n\n  channel->lock = ares_thread_mutex_create();\n  if (channel->lock == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->cond_empty = ares_thread_cond_create();\n  if (channel->cond_empty == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_channel_threading_destroy(channel);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              720,
              0
            ],
            [
              746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_channel_threading_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_channel_threading_destroy(ares_channel_t *channel)\n{\n  ares_thread_mutex_destroy(channel->lock);\n  channel->lock = NULL;\n  ares_thread_cond_destroy(channel->cond_empty);\n  channel->cond_empty = NULL;\n}",
          "fn_code_pos": [
            [
              748,
              0
            ],
            [
              754,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_channel_threading_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_channel_lock(const ares_channel_t *channel)\n{\n  ares_thread_mutex_lock(channel->lock);\n}",
          "fn_code_pos": [
            [
              756,
              0
            ],
            [
              759,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_channel_lock",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_channel_unlock(const ares_channel_t *channel)\n{\n  ares_thread_mutex_unlock(channel->lock);\n}",
          "fn_code_pos": [
            [
              761,
              0
            ],
            [
              764,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_channel_unlock",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_queue_wait_empty(ares_channel_t *channel, int timeout_ms)\n{\n  ares_status_t  status = ARES_SUCCESS;\n  ares_timeval_t tout;\n\n  if (!ares_threadsafety()) {\n    return ARES_ENOTIMP;\n  }\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (timeout_ms >= 0) {\n    ares_tvnow(&tout);\n    tout.sec  += (ares_int64_t)(timeout_ms / 1000);\n    tout.usec += (unsigned int)(timeout_ms % 1000) * 1000;\n  }\n\n  ares_thread_mutex_lock(channel->lock);\n  while (ares_llist_len(channel->all_queries)) {\n    if (timeout_ms < 0) {\n      ares_thread_cond_wait(channel->cond_empty, channel->lock);\n    } else {\n      ares_timeval_t tv_remaining;\n      ares_timeval_t tv_now;\n      unsigned long  tms;\n\n      ares_tvnow(&tv_now);\n      ares_timeval_remaining(&tv_remaining, &tv_now, &tout);\n      tms =\n        (unsigned long)((tv_remaining.sec * 1000) + (tv_remaining.usec / 1000));\n      if (tms == 0) {\n        status = ARES_ETIMEOUT;\n      } else {\n        status =\n          ares_thread_cond_timedwait(channel->cond_empty, channel->lock, tms);\n      }\n\n      /* If there was a timeout, don't loop.  Otherwise, make sure this wasn't\n       * a spurious wakeup by looping and checking the condition. */\n      if (status == ARES_ETIMEOUT) {\n        break;\n      }\n    }\n  }\n  ares_thread_mutex_unlock(channel->lock);\n  return status;\n}",
          "fn_code_pos": [
            [
              767,
              0
            ],
            [
              815,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_wait_empty",
            "parameters": {
              "channel": "ares_channel_t",
              "timeout_ms": "int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_queue_notify_empty(ares_channel_t *channel)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  /* We are guaranteed to be holding a channel lock already */\n  if (ares_llist_len(channel->all_queries)) {\n    return;\n  }\n\n  /* Notify all waiters of the conditional */\n  ares_thread_cond_broadcast(channel->cond_empty);\n}",
          "fn_code_pos": [
            [
              817,
              0
            ],
            [
              830,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_notify_empty",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_thread_mutex_create(void)",
          "fn_dec_pos": [
            [
              37,
              21
            ],
            [
              37,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_cond_create(void)",
          "fn_dec_pos": [
            [
              79,
              20
            ],
            [
              79,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_cond_create(void)",
          "fn_dec_pos": [
            [
              164,
              20
            ],
            [
              164,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*func)(void *arg)",
          "fn_dec_pos": [
            [
              351,
              8
            ],
            [
              351,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_mutex_create(void)",
          "fn_dec_pos": [
            [
              430,
              21
            ],
            [
              430,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_cond_create(void)",
          "fn_dec_pos": [
            [
              491,
              20
            ],
            [
              491,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_mutex_create(void)",
          "fn_dec_pos": [
            [
              639,
              21
            ],
            [
              639,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_cond_create(void)",
          "fn_dec_pos": [
            [
              659,
              20
            ],
            [
              659,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_thread_mutex {\n  CRITICAL_SECTION mutex;\n}",
          {
            "mutex": "CRITICAL_SECTION"
          },
          "ares_thread_mutex",
          [
            33,
            0
          ],
          [
            35,
            1
          ]
        ],
        [
          "struct ares_thread_cond {\n  CONDITION_VARIABLE cond;\n}",
          {
            "cond": "CONDITION_VARIABLE"
          },
          "ares_thread_cond",
          [
            75,
            0
          ],
          [
            77,
            1
          ]
        ],
        [
          "struct ares_thread_cond {\n  HANDLE                events[2];\n  HANDLE                gate;\n  CRITICAL_SECTION      mutex;\n  size_t                waiters;\n  ares_w32_cond_event_t event;\n}",
          {
            "events[2]": "HANDLE",
            "gate": "HANDLE",
            "mutex": "CRITICAL_SECTION",
            "waiters": "size_t",
            "event": "ares_w32_cond_event_t"
          },
          "ares_thread_cond",
          [
            156,
            0
          ],
          [
            162,
            1
          ]
        ],
        [
          "struct ares_thread {\n  HANDLE thread;\n  DWORD  id;\n\n  void *(*func)(void *arg);\n  void *arg;\n  void *rv;\n}",
          {
            "thread": "HANDLE",
            "id": "DWORD",
            "*(*func)(void *arg)": "void",
            "*arg": "void",
            "*rv": "void"
          },
          "ares_thread",
          [
            347,
            0
          ],
          [
            354,
            1
          ]
        ],
        [
          "struct ares_thread_mutex {\n  pthread_mutex_t mutex;\n}",
          {
            "mutex": "pthread_mutex_t"
          },
          "ares_thread_mutex",
          [
            426,
            0
          ],
          [
            428,
            1
          ]
        ],
        [
          "struct ares_thread_cond {\n  pthread_cond_t cond;\n}",
          {
            "cond": "pthread_cond_t"
          },
          "ares_thread_cond",
          [
            487,
            0
          ],
          [
            489,
            1
          ]
        ],
        [
          "struct ares_thread {\n  pthread_t thread;\n}",
          {
            "thread": "pthread_t"
          },
          "ares_thread",
          [
            583,
            0
          ],
          [
            585,
            1
          ]
        ],
        [
          "struct ares_thread_mutex {\n  CRITICAL_SECTION mutex;\n}",
          {
            "mutex": "CRITICAL_SECTION"
          },
          "ares_thread_mutex",
          [
            33,
            0
          ],
          [
            35,
            1
          ]
        ],
        [
          "struct ares_thread_cond {\n  CONDITION_VARIABLE cond;\n}",
          {
            "cond": "CONDITION_VARIABLE"
          },
          "ares_thread_cond",
          [
            75,
            0
          ],
          [
            77,
            1
          ]
        ],
        [
          "struct ares_thread_cond {\n  HANDLE                events[2];\n  HANDLE                gate;\n  CRITICAL_SECTION      mutex;\n  size_t                waiters;\n  ares_w32_cond_event_t event;\n}",
          {
            "events[2]": "HANDLE",
            "gate": "HANDLE",
            "mutex": "CRITICAL_SECTION",
            "waiters": "size_t",
            "event": "ares_w32_cond_event_t"
          },
          "ares_thread_cond",
          [
            156,
            0
          ],
          [
            162,
            1
          ]
        ],
        [
          "struct ares_thread {\n  HANDLE thread;\n  DWORD  id;\n\n  void *(*func)(void *arg);\n  void *arg;\n  void *rv;\n}",
          {
            "thread": "HANDLE",
            "id": "DWORD",
            "*(*func)(void *arg)": "void",
            "*arg": "void",
            "*rv": "void"
          },
          "ares_thread",
          [
            347,
            0
          ],
          [
            354,
            1
          ]
        ],
        [
          "struct ares_thread_mutex {\n  pthread_mutex_t mutex;\n}",
          {
            "mutex": "pthread_mutex_t"
          },
          "ares_thread_mutex",
          [
            426,
            0
          ],
          [
            428,
            1
          ]
        ],
        [
          "struct ares_thread_cond {\n  pthread_cond_t cond;\n}",
          {
            "cond": "pthread_cond_t"
          },
          "ares_thread_cond",
          [
            487,
            0
          ],
          [
            489,
            1
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            537,
            34
          ],
          [
            537,
            49
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            542,
            2
          ],
          [
            542,
            16
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            564,
            2
          ],
          [
            564,
            17
          ]
        ],
        [
          "struct ares_thread {\n  pthread_t thread;\n}",
          {
            "thread": "pthread_t"
          },
          "ares_thread",
          [
            583,
            0
          ],
          [
            585,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#    include <pthread.h>\n",
          [
            414,
            0
          ],
          [
            415,
            0
          ]
        ],
        [
          "#      include <time.h>\n",
          [
            418,
            0
          ],
          [
            419,
            0
          ]
        ],
        [
          "#      include <sys/time.h>\n",
          [
            423,
            0
          ],
          [
            424,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_W32_COND_SIGNAL    = 0,\n  ARES_W32_COND_BROADCAST,\n  ARES_W32_COND_EVMAX,\n  ARES_W32_COND_NONE = ARES_W32_COND_EVMAX\n} ares_w32_cond_event_t;",
          {
            "ARES_W32_COND_SIGNAL": "",
            "ARES_W32_COND_BROADCAST": "",
            "ARES_W32_COND_EVMAX": "",
            "ARES_W32_COND_NONE": ""
          },
          "ares_w32_cond_event_t",
          [
            149,
            0
          ],
          [
            154,
            24
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_math.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned int ares_round_up_pow2_u32(unsigned int n)\n{\n  /* NOTE: if already a power of 2, will return itself, not the next */\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n++;\n  return n;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_round_up_pow2_u32",
            "parameters": {
              "n": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_int64_t ares_round_up_pow2_u64(ares_int64_t n)\n{\n  /* NOTE: if already a power of 2, will return itself, not the next */\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  n++;\n  return n;\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_round_up_pow2_u64",
            "parameters": {
              "n": "ares_int64_t"
            },
            "return_type": "ares_int64_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_is_64bit(void)\n{\n#ifdef _MSC_VER\n#  pragma warning(push)\n#  pragma warning(disable : 4127)\n#endif\n\n  return (sizeof(size_t) == 4) ? ARES_FALSE : ARES_TRUE;\n\n#ifdef _MSC_VER\n#  pragma warning(pop)\n#endif\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_is_64bit",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_round_up_pow2(size_t n)\n{\n  if (ares_is_64bit()) {\n    return (size_t)ares_round_up_pow2_u64((ares_int64_t)n);\n  }\n\n  return (size_t)ares_round_up_pow2_u32((unsigned int)n);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_round_up_pow2",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_log2(size_t n)\n{\n  static const unsigned char tab32[32] = { 0,  1,  28, 2,  29, 14, 24, 3,\n                                           30, 22, 20, 15, 25, 17, 4,  8,\n                                           31, 27, 13, 23, 21, 19, 16, 7,\n                                           26, 12, 18, 6,  11, 5,  10, 9 };\n  static const unsigned char tab64[64] = {\n    63, 0,  58, 1,  59, 47, 53, 2,  60, 39, 48, 27, 54, 33, 42, 3,\n    61, 51, 37, 40, 49, 18, 28, 20, 55, 30, 34, 11, 43, 14, 22, 4,\n    62, 57, 46, 52, 38, 26, 32, 41, 50, 36, 17, 19, 29, 10, 13, 21,\n    56, 45, 25, 31, 35, 16, 9,  12, 44, 24, 15, 8,  23, 7,  6,  5\n  };\n\n  if (!ares_is_64bit()) {\n    return tab32[(n * 0x077CB531) >> 27];\n  }\n\n  return tab64[(n * 0x07EDD5E59A4E28C2) >> 58];\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_log2",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_pow(size_t x, size_t y)\n{\n  size_t res = 1;\n\n  while (y > 0) {\n    /* If y is odd, multiply x with result */\n    if (y & 1) {\n      res = res * x;\n    }\n\n    /* y must be even now */\n    y = y >> 1; /* y /= 2; */\n    x = x * x;  /* x^2 */\n  }\n\n  return res;\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pow",
            "parameters": {
              "x": "size_t",
              "y": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_count_digits(size_t n)\n{\n  size_t digits;\n\n  for (digits = 0; n > 0; digits++) {\n    n /= 10;\n  }\n  if (digits == 0) {\n    digits = 1;\n  }\n\n  return digits;\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_count_digits",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_count_hexdigits(size_t n)\n{\n  size_t digits;\n\n  for (digits = 0; n > 0; digits++) {\n    n /= 16;\n  }\n  if (digits == 0) {\n    digits = 1;\n  }\n\n  return digits;\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_count_hexdigits",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "unsigned char ares_count_bits_u8(unsigned char x)\n{\n  /* Implementation obtained from:\n   * http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetTable */\n#define B2(n) n, n + 1, n + 1, n + 2\n#define B4(n) B2(n), B2(n + 1), B2(n + 1), B2(n + 2)\n#define B6(n) B4(n), B4(n + 1), B4(n + 1), B4(n + 2)\n  static const unsigned char lookup[256] = { B6(0), B6(1), B6(1), B6(2) };\n  return lookup[x];\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              157,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_count_bits_u8",
            "parameters": {
              "x": "unsigned char"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_timeval.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_tvnow(ares_timeval_t *now)\n{\n  /* QueryPerformanceCounters() has been around since Windows 2000, though\n   * significant fixes were made in later versions.  Documentation states\n   * 1 microsecond or better resolution with a rollover not less than 100 years.\n   * This differs from GetTickCount{64}() which has a resolution between 10 and\n   * 16 ms. */\n  LARGE_INTEGER freq;\n  LARGE_INTEGER current;\n\n  /* Not sure how long it takes to get the frequency, I see it recommended to\n   * cache it */\n  QueryPerformanceFrequency(&freq);\n  QueryPerformanceCounter(&current);\n\n  now->sec = current.QuadPart / freq.QuadPart;\n  /* We want to prevent overflows so we get the remainder, then multiply to\n   * microseconds before dividing */\n  now->usec = (unsigned int)(((current.QuadPart % freq.QuadPart) * 1000000) /\n                             freq.QuadPart);\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_tvnow",
            "parameters": {
              "now": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_tvnow(ares_timeval_t *now)\n{\n  /* clock_gettime() is guaranteed to be increased monotonically when the\n   * monotonic clock is queried. Time starting point is unspecified, it\n   * could be the system start-up time, the Epoch, or something else,\n   * in any case the time starting point does not change once that the\n   * system has started up. */\n  struct timespec tsnow;\n\n  if (clock_gettime(CLOCK_MONOTONIC, &tsnow) == 0) {\n    now->sec  = (ares_int64_t)tsnow.tv_sec;\n    now->usec = (unsigned int)(tsnow.tv_nsec / 1000);\n  } else {\n    /* LCOV_EXCL_START: FallbackCode */\n    struct timeval tv;\n    (void)gettimeofday(&tv, NULL);\n    now->sec  = (ares_int64_t)tv.tv_sec;\n    now->usec = (unsigned int)tv.tv_usec;\n    /* LCOV_EXCL_STOP */\n  }\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_tvnow",
            "parameters": {
              "now": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_tvnow(ares_timeval_t *now)\n{\n  /* gettimeofday() is not granted to be increased monotonically, due to\n   * clock drifting and external source time synchronization it can jump\n   * forward or backward in time. */\n  struct timeval tv;\n\n  (void)gettimeofday(&tv, NULL);\n  now->sec  = (ares_int64_t)tv.tv_sec;\n  now->usec = (unsigned int)tv.tv_usec;\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              88,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_tvnow",
            "parameters": {
              "now": "ares_timeval_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timespec",
          {},
          "",
          [
            61,
            2
          ],
          [
            61,
            17
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            68,
            4
          ],
          [
            68,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            83,
            2
          ],
          [
            83,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_rand.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned int ares_u32_from_ptr(void *addr)\n{\n  /* LCOV_EXCL_START: FallbackCode */\n  if (ares_is_64bit()) {\n    return (unsigned int)((((ares_uint64_t)addr >> 32) & 0xFFFFFFFF) ^\n                          ((ares_uint64_t)addr & 0xFFFFFFFF));\n  }\n  return (unsigned int)((size_t)addr & 0xFFFFFFFF);\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_u32_from_ptr",
            "parameters": {
              "addr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void ares_rc4_generate_key(ares_rand_rc4 *rc4_state, unsigned char *key,\n                                  size_t key_len)\n{\n  /* LCOV_EXCL_START: FallbackCode */\n  size_t         i;\n  size_t         len = 0;\n  unsigned int   data;\n  ares_timeval_t tv;\n\n  if (key_len != ARES_RC4_KEY_LEN) {\n    return;\n  }\n\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  /* For fuzzing, random should be deterministic */\n  srand(0);\n#else\n  /* Randomness is hard to come by.  Maybe the system randomizes heap and stack\n   * addresses. Maybe the current timestamp give us some randomness. Use\n   * rc4_state (heap), &i (stack), and ares_tvnow()\n   */\n  data = ares_u32_from_ptr(rc4_state);\n  memcpy(key + len, &data, sizeof(data));\n  len += sizeof(data);\n\n  data = ares_u32_from_ptr(&i);\n  memcpy(key + len, &data, sizeof(data));\n  len += sizeof(data);\n\n  ares_tvnow(&tv);\n  data = (unsigned int)((tv.sec ^ tv.usec) & 0xFFFFFFFF);\n  memcpy(key + len, &data, sizeof(data));\n  len += sizeof(data);\n\n  srand(ares_u32_from_ptr(rc4_state) ^ ares_u32_from_ptr(&i) ^\n        (unsigned int)((tv.sec ^ tv.usec) & 0xFFFFFFFF));\n#endif\n\n  for (i = len; i < key_len; i++) {\n    key[i] = (unsigned char)(rand() % 256); /* LCOV_EXCL_LINE */\n  }\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rc4_generate_key",
            "parameters": {
              "rc4_state": "ares_rand_rc4",
              "key": "unsigned char",
              "key_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_rc4_init(ares_rand_rc4 *rc4_state)\n{\n  /* LCOV_EXCL_START: FallbackCode */\n  unsigned char key[ARES_RC4_KEY_LEN];\n  size_t        i;\n  size_t        j;\n\n  ares_rc4_generate_key(rc4_state, key, sizeof(key));\n\n  for (i = 0; i < sizeof(rc4_state->S); i++) {\n    rc4_state->S[i] = i & 0xFF;\n  }\n\n  for (i = 0, j = 0; i < 256; i++) {\n    j = (j + rc4_state->S[i] + key[i % sizeof(key)]) % 256;\n    ARES_SWAP_BYTE(&rc4_state->S[i], &rc4_state->S[j]);\n  }\n\n  rc4_state->i = 0;\n  rc4_state->j = 0;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rc4_init",
            "parameters": {
              "rc4_state": "ares_rand_rc4"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_rc4_prng(ares_rand_rc4 *rc4_state, unsigned char *buf,\n                          size_t len)\n{\n  /* LCOV_EXCL_START: FallbackCode */\n  unsigned char *S = rc4_state->S;\n  size_t         i = rc4_state->i;\n  size_t         j = rc4_state->j;\n  size_t         cnt;\n\n  for (cnt = 0; cnt < len; cnt++) {\n    i = (i + 1) % 256;\n    j = (j + S[i]) % 256;\n\n    ARES_SWAP_BYTE(&S[i], &S[j]);\n    buf[cnt] = S[(S[i] + S[j]) % 256];\n  }\n\n  rc4_state->i = i;\n  rc4_state->j = j;\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rc4_prng",
            "parameters": {
              "rc4_state": "ares_rand_rc4",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_init_rand_engine(ares_rand_state *state)\n{\n  state->cache_remaining = 0;\n\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  /* For fuzzing, random should be deterministic */\n  state->bad_backends |= ARES_RAND_OS | ARES_RAND_FILE;\n#endif\n\n#if defined(HAVE_ARC4RANDOM_BUF) || defined(HAVE_GETRANDOM) || defined(_WIN32)\n  if (!(state->bad_backends & ARES_RAND_OS)) {\n    state->type = ARES_RAND_OS;\n    return ARES_TRUE;\n  }\n#endif\n\n#if defined(CARES_RANDOM_FILE)\n  /* LCOV_EXCL_START: FallbackCode */\n  if (!(state->bad_backends & ARES_RAND_FILE)) {\n    state->type            = ARES_RAND_FILE;\n    state->state.rand_file = fopen(CARES_RANDOM_FILE, \"rb\");\n    if (state->state.rand_file) {\n      setvbuf(state->state.rand_file, NULL, _IONBF, 0);\n      return ARES_TRUE;\n    }\n  }\n  /* LCOV_EXCL_STOP */\n\n  /* Fall-Thru on failure to RC4 */\n#endif\n\n  /* LCOV_EXCL_START: FallbackCode */\n  state->type = ARES_RAND_RC4;\n  ares_rc4_init(&state->state.rc4);\n  /* LCOV_EXCL_STOP */\n\n  /* Currently cannot fail */\n  return ARES_TRUE; /* LCOV_EXCL_LINE: UntestablePath */\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_rand_engine",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_rand_state *ares_init_rand_state(void)\n{\n  ares_rand_state *state = NULL;\n\n  state = ares_malloc_zero(sizeof(*state));\n  if (!state) {\n    return NULL;\n  }\n\n  if (!ares_init_rand_engine(state)) {\n    ares_free(state); /* LCOV_EXCL_LINE: UntestablePath */\n    return NULL;      /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  return state;\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_rand_state",
            "parameters": {},
            "return_type": "ares_rand_state"
          }
        },
        {
          "fn_code": "static void ares_clear_rand_state(ares_rand_state *state)\n{\n  if (!state) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  switch (state->type) {\n    case ARES_RAND_OS:\n      break;\n    /* LCOV_EXCL_START: FallbackCode */\n    case ARES_RAND_FILE:\n      fclose(state->state.rand_file);\n      break;\n    case ARES_RAND_RC4:\n      break;\n      /* LCOV_EXCL_STOP */\n  }\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_clear_rand_state",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_reinit_rand(ares_rand_state *state)\n{\n  /* LCOV_EXCL_START: UntestablePath */\n  ares_clear_rand_state(state);\n  ares_init_rand_engine(state);\n  /* LCOV_EXCL_STOP */\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_reinit_rand",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_destroy_rand_state(ares_rand_state *state)\n{\n  if (!state) {\n    return;\n  }\n\n  ares_clear_rand_state(state);\n  ares_free(state);\n}",
          "fn_code_pos": [
            [
              279,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_rand_state",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_rand_bytes_fetch(ares_rand_state *state, unsigned char *buf,\n                                  size_t len)\n{\n  while (1) {\n    size_t bytes_read = 0;\n\n    switch (state->type) {\n      case ARES_RAND_OS:\n#ifdef _WIN32\n        RtlGenRandom(buf, (ULONG)len);\n        return;\n#elif defined(HAVE_ARC4RANDOM_BUF)\n        arc4random_buf(buf, len);\n        return;\n#elif defined(HAVE_GETRANDOM)\n        while (1) {\n          size_t  n = len - bytes_read;\n          /* getrandom() on Linux always succeeds and is never\n           * interrupted by a signal when requesting <= 256 bytes.\n           */\n          ssize_t rv = getrandom(buf + bytes_read, n > 256 ? 256 : n, 0);\n          if (rv <= 0) {\n            /* We need to fall back to another backend */\n            if (errno == ENOSYS) {\n              state->bad_backends |= ARES_RAND_OS;\n              break;\n            }\n            continue; /* Just retry. */\n          }\n\n          bytes_read += (size_t)rv;\n          if (bytes_read == len) {\n            return;\n          }\n        }\n        break;\n#else\n        /* Shouldn't be possible to be here */\n        break;\n#endif\n\n        /* LCOV_EXCL_START: FallbackCode */\n\n      case ARES_RAND_FILE:\n        while (1) {\n          size_t rv = fread(buf + bytes_read, 1, len - bytes_read,\n                            state->state.rand_file);\n          if (rv == 0) {\n            break; /* critical error, will reinit rand state */\n          }\n\n          bytes_read += rv;\n          if (bytes_read == len) {\n            return;\n          }\n        }\n        break;\n\n      case ARES_RAND_RC4:\n        ares_rc4_prng(&state->state.rc4, buf, len);\n        return;\n\n        /* LCOV_EXCL_STOP */\n    }\n\n    /* If we didn't return before we got here, that means we had a critical rand\n     * failure and need to reinitialized */\n    ares_reinit_rand(state); /* LCOV_EXCL_LINE: UntestablePath */\n  }\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rand_bytes_fetch",
            "parameters": {
              "state": "ares_rand_state",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_rand_bytes(ares_rand_state *state, unsigned char *buf, size_t len)\n{\n  /* See if we need to refill the cache to serve the request, but if len is\n   * excessive, we're not going to update our cache or serve from cache */\n  if (len > state->cache_remaining && len < sizeof(state->cache)) {\n    size_t fetch_size = sizeof(state->cache) - state->cache_remaining;\n    ares_rand_bytes_fetch(state, state->cache, fetch_size);\n    state->cache_remaining = sizeof(state->cache);\n  }\n\n  /* Serve from cache */\n  if (len <= state->cache_remaining) {\n    size_t offset = sizeof(state->cache) - state->cache_remaining;\n    memcpy(buf, state->cache + offset, len);\n    state->cache_remaining -= len;\n    return;\n  }\n\n  /* Serve direct due to excess size of request */\n  ares_rand_bytes_fetch(state, buf, len);\n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rand_bytes",
            "parameters": {
              "state": "ares_rand_state",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned short ares_generate_new_id(ares_rand_state *state)\n{\n  unsigned short r = 0;\n\n  ares_rand_bytes(state, (unsigned char *)&r, sizeof(r));\n  return r;\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_generate_new_id",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "SystemFunction036(PVOID RandomBuffer, ULONG RandomBufferLength)",
          "fn_dec_pos": [
            [
              188,
              15
            ],
            [
              188,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SystemFunction036",
            "parameters": {
              "RandomBuffer": "PVOID",
              "RandomBufferLength": "ULONG"
            },
            "return_type": "BOOLEAN"
          }
        },
        {
          "fn_code": "ares_init_rand_state(void)",
          "fn_dec_pos": [
            [
              235,
              17
            ],
            [
              235,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_rand_state",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct ares_rand_rc4 {\n  unsigned char S[256];\n  size_t        i;\n  size_t        j;\n} ares_rand_rc4;",
          {
            "S[256]": "unsigned char",
            "i": "size_t",
            "j": "size_t"
          },
          "ares_rand_rc4",
          [
            48,
            0
          ],
          [
            52,
            16
          ]
        ],
        [
          "struct ares_rand_state {\n  ares_rand_backend type;\n  ares_rand_backend bad_backends;\n\n  union {\n    FILE         *rand_file;\n    ares_rand_rc4 rc4;\n  } state;\n\n  /* Since except for RC4, random data will likely result in a syscall, lets\n   * pre-pull 256 bytes at a time.  Every query will pull 2 bytes off this so\n   * that means we should only need a syscall every 128 queries. 256bytes\n   * appears to be a sweet spot that may be able to be served without\n   * interruption */\n  unsigned char cache[256];\n  size_t        cache_remaining;\n}",
          {
            "type": "ares_rand_backend",
            "bad_backends": "ares_rand_backend",
            "state": "union {\n    FILE         *rand_file;\n    ares_rand_rc4 rc4;\n  }",
            "*rand_file": "FILE",
            "rc4": "ares_rand_rc4",
            "cache[256]": "unsigned char",
            "cache_remaining": "size_t"
          },
          "ares_rand_state",
          [
            164,
            0
          ],
          [
            180,
            1
          ]
        ],
        [
          "typedef struct ares_rand_rc4 {\n  unsigned char S[256];\n  size_t        i;\n  size_t        j;\n} ares_rand_rc4;",
          {
            "S[256]": "unsigned char",
            "i": "size_t",
            "j": "size_t"
          },
          "ares_rand_rc4",
          [
            48,
            0
          ],
          [
            52,
            16
          ]
        ],
        [
          "struct ares_rand_state {\n  ares_rand_backend type;\n  ares_rand_backend bad_backends;\n\n  union {\n    FILE         *rand_file;\n    ares_rand_rc4 rc4;\n  } state;\n\n  /* Since except for RC4, random data will likely result in a syscall, lets\n   * pre-pull 256 bytes at a time.  Every query will pull 2 bytes off this so\n   * that means we should only need a syscall every 128 queries. 256bytes\n   * appears to be a sweet spot that may be able to be served without\n   * interruption */\n  unsigned char cache[256];\n  size_t        cache_remaining;\n}",
          {
            "type": "ares_rand_backend",
            "bad_backends": "ares_rand_backend",
            "state": "union {\n    FILE         *rand_file;\n    ares_rand_rc4 rc4;\n  }",
            "*rand_file": "FILE",
            "rc4": "ares_rand_rc4",
            "cache[256]": "unsigned char",
            "cache_remaining": "size_t"
          },
          "ares_rand_state",
          [
            164,
            0
          ],
          [
            180,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <AvailabilityMacros.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <sys/random.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_RAND_OS   = 1 << 0, /* OS-provided such as RtlGenRandom or arc4random */\n  ARES_RAND_FILE = 1 << 1, /* OS file-backed random number generator */\n  ARES_RAND_RC4  = 1 << 2  /* Internal RC4 based PRNG */\n} ares_rand_backend;",
          {
            "ARES_RAND_OS": "",
            "ARES_RAND_FILE": "",
            "ARES_RAND_RC4": ""
          },
          "ares_rand_backend",
          [
            40,
            0
          ],
          [
            44,
            20
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_uri.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t ares_uri_chis_subdelim(char x)\n{\n  switch (x) {\n    case '!':\n      return ARES_TRUE;\n    case '$':\n      return ARES_TRUE;\n    case '&':\n      return ARES_TRUE;\n    case '\\'':\n      return ARES_TRUE;\n    case '(':\n      return ARES_TRUE;\n    case ')':\n      return ARES_TRUE;\n    case '*':\n      return ARES_TRUE;\n    case '+':\n      return ARES_TRUE;\n    case ',':\n      return ARES_TRUE;\n    case ';':\n      return ARES_TRUE;\n    case '=':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_subdelim",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_gendelim(char x)\n{\n  switch (x) {\n    case ':':\n      return ARES_TRUE;\n    case '/':\n      return ARES_TRUE;\n    case '?':\n      return ARES_TRUE;\n    case '#':\n      return ARES_TRUE;\n    case '[':\n      return ARES_TRUE;\n    case ']':\n      return ARES_TRUE;\n    case '@':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_gendelim",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_reserved(char x)\n{\n  return ares_uri_chis_gendelim(x) || ares_uri_chis_subdelim(x);\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_reserved",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_unreserved(char x)\n{\n  switch (x) {\n    case '-':\n      return ARES_TRUE;\n    case '.':\n      return ARES_TRUE;\n    case '_':\n      return ARES_TRUE;\n    case '~':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ares_isalpha(x) || ares_isdigit(x);\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_unreserved",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_scheme(char x)\n{\n  switch (x) {\n    case '+':\n      return ARES_TRUE;\n    case '-':\n      return ARES_TRUE;\n    case '.':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ares_isalpha(x) || ares_isdigit(x);\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_scheme",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_authority(char x)\n{\n  /* This one here isn't well defined.  We are going to include the valid\n   * characters of the subfields plus known delimiters */\n  return ares_uri_chis_unreserved(x) || ares_uri_chis_subdelim(x) || x == '%' ||\n         x == '[' || x == ']' || x == '@' || x == ':';\n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_authority",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_userinfo(char x)\n{\n  /* NOTE: we don't include ':' here since we are using that as our\n   *       username/password delimiter */\n  return ares_uri_chis_unreserved(x) || ares_uri_chis_subdelim(x);\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_userinfo",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_path(char x)\n{\n  switch (x) {\n    case ':':\n      return ARES_TRUE;\n    case '@':\n      return ARES_TRUE;\n    /* '/' isn't in the spec as a path character since its technically a\n     * delimiter but we're not splitting on '/' so we accept it as valid */\n    case '/':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ares_uri_chis_unreserved(x) || ares_uri_chis_subdelim(x);\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_path",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_path_enc(char x)\n{\n  return ares_uri_chis_path(x) || x == '%';\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_path_enc",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_query(char x)\n{\n  switch (x) {\n    case '/':\n      return ARES_TRUE;\n    case '?':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n\n  /* Exclude & and = used as delimiters, they're valid characters in the\n   * set, just not for the individual pieces */\n  return ares_uri_chis_path(x) && x != '&' && x != '=';\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              213,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_query",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_query_enc(char x)\n{\n  return ares_uri_chis_query(x) || x == '%';\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              218,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_query_enc",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_fragment(char x)\n{\n  switch (x) {\n    case '/':\n      return ARES_TRUE;\n    case '?':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ares_uri_chis_path(x);\n}",
          "fn_code_pos": [
            [
              220,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_fragment",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_chis_fragment_enc(char x)\n{\n  return ares_uri_chis_fragment(x) || x == '%';\n}",
          "fn_code_pos": [
            [
              233,
              0
            ],
            [
              236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_chis_fragment_enc",
            "parameters": {
              "x": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_uri_t *ares_uri_create(void)\n{\n  ares_uri_t *uri = ares_malloc_zero(sizeof(*uri));\n\n  if (uri == NULL) {\n    return NULL;\n  }\n\n  uri->query = ares_htable_dict_create();\n  if (uri->query == NULL) {\n    ares_free(uri);\n    return NULL;\n  }\n\n  return uri;\n}",
          "fn_code_pos": [
            [
              238,
              0
            ],
            [
              253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_create",
            "parameters": {},
            "return_type": "ares_uri_t"
          }
        },
        {
          "fn_code": "void ares_uri_destroy(ares_uri_t *uri)\n{\n  if (uri == NULL) {\n    return;\n  }\n\n  ares_free(uri->username);\n  ares_free(uri->password);\n  ares_free(uri->path);\n  ares_free(uri->fragment);\n  ares_htable_dict_destroy(uri->query);\n  ares_free(uri);\n}",
          "fn_code_pos": [
            [
              255,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_destroy",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_scheme_is_valid(const char *uri)\n{\n  size_t i;\n\n  if (ares_strlen(uri) == 0) {\n    return ARES_FALSE;\n  }\n\n  if (!ares_isalpha(*uri)) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; uri[i] != 0; i++) {\n    if (!ares_uri_chis_scheme(uri[i])) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_scheme_is_valid",
            "parameters": {
              "uri": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_uri_str_isvalid(const char *str, size_t max_len,\n                                        ares_bool_t (*ischr)(char))\n{\n  size_t i;\n\n  if (str == NULL) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; i != max_len && str[i] != 0; i++) {\n    if (!ischr(str[i])) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_str_isvalid",
            "parameters": {
              "str": "char",
              "max_len": "size_t",
              "ischr": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_set_scheme(ares_uri_t *uri, const char *scheme)\n{\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (!ares_uri_scheme_is_valid(scheme)) {\n    return ARES_EBADSTR;\n  }\n\n  ares_strcpy(uri->scheme, scheme, sizeof(uri->scheme));\n  ares_str_lower(uri->scheme);\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              306,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_scheme",
            "parameters": {
              "uri": "ares_uri_t",
              "scheme": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const char *ares_uri_get_scheme(const ares_uri_t *uri)\n{\n  if (uri == NULL) {\n    return NULL;\n  }\n\n  return uri->scheme;\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_scheme",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_set_username_own(ares_uri_t *uri, char *username)\n{\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (username != NULL && (!ares_str_isprint(username, ares_strlen(username)) ||\n                           ares_strlen(username) == 0)) {\n    return ARES_EBADSTR;\n  }\n\n\n  ares_free(uri->username);\n  uri->username = username;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_username_own",
            "parameters": {
              "uri": "ares_uri_t",
              "username": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_set_username(ares_uri_t *uri, const char *username)\n{\n  ares_status_t status;\n  char         *temp = NULL;\n\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (username != NULL) {\n    temp = ares_strdup(username);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  status = ares_uri_set_username_own(uri, temp);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              370,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_username",
            "parameters": {
              "uri": "ares_uri_t",
              "username": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const char *ares_uri_get_username(const ares_uri_t *uri)\n{\n  if (uri == NULL) {\n    return NULL;\n  }\n\n  return uri->username;\n}",
          "fn_code_pos": [
            [
              372,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_username",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_set_password_own(ares_uri_t *uri, char *password)\n{\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (password != NULL && !ares_str_isprint(password, ares_strlen(password))) {\n    return ARES_EBADSTR;\n  }\n\n  ares_free(uri->password);\n  uri->password = password;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              381,
              0
            ],
            [
              394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_password_own",
            "parameters": {
              "uri": "ares_uri_t",
              "password": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_set_password(ares_uri_t *uri, const char *password)\n{\n  ares_status_t status;\n  char         *temp = NULL;\n\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (password != NULL) {\n    temp = ares_strdup(password);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  status = ares_uri_set_password_own(uri, temp);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_password",
            "parameters": {
              "uri": "ares_uri_t",
              "password": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const char *ares_uri_get_password(const ares_uri_t *uri)\n{\n  if (uri == NULL) {\n    return NULL;\n  }\n\n  return uri->password;\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_password",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_set_host(ares_uri_t *uri, const char *host)\n{\n  struct ares_addr addr;\n  size_t           addrlen;\n  char             hoststr[256];\n  char            *ll_scope;\n\n  if (uri == NULL || ares_strlen(host) == 0 ||\n      ares_strlen(host) >= sizeof(hoststr)) {\n    return ARES_EFORMERR;\n  }\n\n  ares_strcpy(hoststr, host, sizeof(hoststr));\n\n  /* Look for '%' which could be a link-local scope for ipv6 addresses and\n   * parse it off */\n  ll_scope = strchr(hoststr, '%');\n  if (ll_scope != NULL) {\n    *ll_scope = 0;\n    ll_scope++;\n    if (!ares_str_isalnum(ll_scope)) {\n      return ARES_EBADNAME;\n    }\n  }\n\n  /* If its an IP address, normalize it */\n  memset(&addr, 0, sizeof(addr));\n  addr.family = AF_UNSPEC;\n  if (ares_dns_pton(hoststr, &addr, &addrlen) != NULL) {\n    char ipaddr[INET6_ADDRSTRLEN];\n    ares_inet_ntop(addr.family, &addr.addr, ipaddr, sizeof(ipaddr));\n    /* Only IPv6 is allowed to have a scope */\n    if (ll_scope != NULL && addr.family != AF_INET6) {\n      return ARES_EBADNAME;\n    }\n\n    if (ll_scope != NULL) {\n      snprintf(uri->host, sizeof(uri->host), \"%s%%%s\", ipaddr, ll_scope);\n    } else {\n      ares_strcpy(uri->host, ipaddr, sizeof(uri->host));\n    }\n    return ARES_SUCCESS;\n  }\n\n  /* If its a hostname, make sure its a valid charset */\n  if (!ares_is_hostname(host)) {\n    return ARES_EBADNAME;\n  }\n\n  ares_strcpy(uri->host, host, sizeof(uri->host));\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_host",
            "parameters": {
              "uri": "ares_uri_t",
              "host": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const char *ares_uri_get_host(const ares_uri_t *uri)\n{\n  if (uri == NULL) {\n    return NULL;\n  }\n\n  return uri->host;\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              489,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_host",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_set_port(ares_uri_t *uri, unsigned short port)\n{\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n  uri->port = port;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              491,
              0
            ],
            [
              498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_port",
            "parameters": {
              "uri": "ares_uri_t",
              "port": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "unsigned short ares_uri_get_port(const ares_uri_t *uri)\n{\n  if (uri == NULL) {\n    return 0;\n  }\n  return uri->port;\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_port",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static char *ares_uri_path_normalize(const char *path)\n{\n  ares_status_t status;\n  ares_array_t *arr     = NULL;\n  ares_buf_t   *outpath = NULL;\n  ares_buf_t   *inpath  = NULL;\n  ares_ssize_t  i;\n  size_t        j;\n  size_t        len;\n\n  inpath =\n    ares_buf_create_const((const unsigned char *)path, ares_strlen(path));\n  if (inpath == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  outpath = ares_buf_create();\n  if (outpath == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares_buf_split_str_array(inpath, (const unsigned char *)\"/\", 1,\n                                    ARES_BUF_SPLIT_TRIM, 0, &arr);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (i = 0; i < (ares_ssize_t)ares_array_len(arr); i++) {\n    const char **strptr = ares_array_at(arr, (size_t)i);\n    const char  *str    = *strptr;\n\n    if (ares_streq(str, \".\")) {\n      ares_array_remove_at(arr, (size_t)i);\n      i--;\n    } else if (ares_streq(str, \"..\")) {\n      if (i != 0) {\n        ares_array_remove_at(arr, (size_t)i - 1);\n        i--;\n      }\n      ares_array_remove_at(arr, (size_t)i);\n      i--;\n    }\n  }\n\n  status = ares_buf_append_byte(outpath, '/');\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  len = ares_array_len(arr);\n  for (j = 0; j < len; j++) {\n    const char **strptr = ares_array_at(arr, j);\n    const char  *str    = *strptr;\n    status              = ares_buf_append_str(outpath, str);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    /* Path separator, but on the last entry, we need to check if it was\n     * originally terminated or not because they have different meanings */\n    if (j != len - 1 || path[ares_strlen(path) - 1] == '/') {\n      status = ares_buf_append_byte(outpath, '/');\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n  }\n\ndone:\n  ares_array_destroy(arr);\n  ares_buf_destroy(inpath);\n  if (status != ARES_SUCCESS) {\n    ares_buf_destroy(outpath);\n    return NULL;\n  }\n\n  return ares_buf_finish_str(outpath, NULL);\n}",
          "fn_code_pos": [
            [
              509,
              0
            ],
            [
              588,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_path_normalize",
            "parameters": {
              "path": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_set_path(ares_uri_t *uri, const char *path)\n{\n  char *temp = NULL;\n\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (path != NULL && !ares_str_isprint(path, ares_strlen(path))) {\n    return ARES_EBADSTR;\n  }\n\n  if (path != NULL) {\n    temp = ares_uri_path_normalize(path);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  ares_free(uri->path);\n  uri->path = temp;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              590,
              0
            ],
            [
              613,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_path",
            "parameters": {
              "uri": "ares_uri_t",
              "path": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const char *ares_uri_get_path(const ares_uri_t *uri)\n{\n  if (uri == NULL) {\n    return NULL;\n  }\n\n  return uri->path;\n}",
          "fn_code_pos": [
            [
              615,
              0
            ],
            [
              622,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_path",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_set_query_key(ares_uri_t *uri, const char *key,\n                                     const char *val)\n{\n  if (uri == NULL || key == NULL || *key == 0) {\n    return ARES_EFORMERR;\n  }\n\n  if (!ares_str_isprint(key, ares_strlen(key)) ||\n      (val != NULL && !ares_str_isprint(val, ares_strlen(val)))) {\n    return ARES_EBADSTR;\n  }\n\n  if (!ares_htable_dict_insert(uri->query, key, val)) {\n    return ARES_ENOMEM;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              624,
              0
            ],
            [
              640,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_query_key",
            "parameters": {
              "uri": "ares_uri_t",
              "key": "char",
              "val": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_del_query_key(ares_uri_t *uri, const char *key)\n{\n  if (uri == NULL || key == NULL || *key == 0 ||\n      !ares_str_isprint(key, ares_strlen(key))) {\n    return ARES_EFORMERR;\n  }\n\n  if (!ares_htable_dict_remove(uri->query, key)) {\n    return ARES_ENOTFOUND;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              642,
              0
            ],
            [
              654,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_del_query_key",
            "parameters": {
              "uri": "ares_uri_t",
              "key": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const char *ares_uri_get_query_key(const ares_uri_t *uri, const char *key)\n{\n  if (uri == NULL || key == NULL || *key == 0 ||\n      !ares_str_isprint(key, ares_strlen(key))) {\n    return NULL;\n  }\n\n  return ares_htable_dict_get_direct(uri->query, key);\n}",
          "fn_code_pos": [
            [
              656,
              0
            ],
            [
              664,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_query_key",
            "parameters": {
              "uri": "ares_uri_t",
              "key": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "char **ares_uri_get_query_keys(const ares_uri_t *uri, size_t *num)\n{\n  if (uri == NULL || num == NULL) {\n    return NULL;\n  }\n\n  return ares_htable_dict_keys(uri->query, num);\n}",
          "fn_code_pos": [
            [
              666,
              0
            ],
            [
              673,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_set_fragment_own(ares_uri_t *uri, char *fragment)\n{\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (fragment != NULL && !ares_str_isprint(fragment, ares_strlen(fragment))) {\n    return ARES_EBADSTR;\n  }\n\n  ares_free(uri->fragment);\n  uri->fragment = fragment;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              675,
              0
            ],
            [
              688,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_fragment_own",
            "parameters": {
              "uri": "ares_uri_t",
              "fragment": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_set_fragment(ares_uri_t *uri, const char *fragment)\n{\n  ares_status_t status;\n  char         *temp = NULL;\n\n  if (uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (fragment != NULL) {\n    temp = ares_strdup(fragment);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  status = ares_uri_set_fragment_own(uri, temp);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              690,
              0
            ],
            [
              712,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_fragment",
            "parameters": {
              "uri": "ares_uri_t",
              "fragment": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const char *ares_uri_get_fragment(const ares_uri_t *uri)\n{\n  if (uri == NULL) {\n    return NULL;\n  }\n  return uri->fragment;\n}",
          "fn_code_pos": [
            [
              714,
              0
            ],
            [
              720,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_fragment",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_encode_buf(ares_buf_t *buf, const char *str,\n                                         ares_bool_t (*ischr)(char))\n{\n  size_t i;\n\n  if (buf == NULL || str == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  for (i = 0; str[i] != 0; i++) {\n    if (ischr(str[i])) {\n      if (ares_buf_append_byte(buf, (unsigned char)str[i]) != ARES_SUCCESS) {\n        return ARES_ENOMEM;\n      }\n    } else {\n      if (ares_buf_append_byte(buf, '%') != ARES_SUCCESS) {\n        return ARES_ENOMEM;\n      }\n      if (ares_buf_append_num_hex(buf, (size_t)str[i], 2) != ARES_SUCCESS) {\n        return ARES_ENOMEM;\n      }\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              722,
              0
            ],
            [
              746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_encode_buf",
            "parameters": {
              "buf": "ares_buf_t",
              "str": "char",
              "ischr": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_write_scheme(const ares_uri_t *uri,\n                                           ares_buf_t       *buf)\n{\n  ares_status_t status;\n\n  status = ares_buf_append_str(buf, uri->scheme);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_buf_append_str(buf, \"://\");\n\n  return status;\n}",
          "fn_code_pos": [
            [
              748,
              0
            ],
            [
              761,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write_scheme",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_write_authority(const ares_uri_t *uri,\n                                              ares_buf_t       *buf)\n{\n  ares_status_t status;\n  ares_bool_t   is_ipv6 = ARES_FALSE;\n\n  if (ares_strlen(uri->username)) {\n    status = ares_uri_encode_buf(buf, uri->username, ares_uri_chis_userinfo);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  if (ares_strlen(uri->password)) {\n    status = ares_buf_append_byte(buf, ':');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    status = ares_uri_encode_buf(buf, uri->password, ares_uri_chis_userinfo);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  if (ares_strlen(uri->username) || ares_strlen(uri->password)) {\n    status = ares_buf_append_byte(buf, '@');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* We need to write ipv6 addresses with [ ] */\n  if (strchr(uri->host, '%') != NULL) {\n    /* If we have a % in the name, it must be ipv6 link local scope, so we\n     * don't need to check anything else */\n    is_ipv6 = ARES_TRUE;\n  } else {\n    /* Parse the host to see if it is an ipv6 address */\n    struct ares_addr addr;\n    size_t           addrlen;\n    memset(&addr, 0, sizeof(addr));\n    addr.family = AF_INET6;\n    if (ares_dns_pton(uri->host, &addr, &addrlen) != NULL) {\n      is_ipv6 = ARES_TRUE;\n    }\n  }\n\n  if (is_ipv6) {\n    status = ares_buf_append_byte(buf, '[');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  status = ares_buf_append_str(buf, uri->host);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (is_ipv6) {\n    status = ares_buf_append_byte(buf, ']');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  if (uri->port > 0) {\n    status = ares_buf_append_byte(buf, ':');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n    status = ares_buf_append_num_dec(buf, uri->port, 0);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              763,
              0
            ],
            [
              842,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write_authority",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_write_path(const ares_uri_t *uri, ares_buf_t *buf)\n{\n  ares_status_t status;\n\n  if (ares_strlen(uri->path) == 0) {\n    return ARES_SUCCESS;\n  }\n\n  if (*uri->path != '/') {\n    status = ares_buf_append_byte(buf, '/');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  status = ares_uri_encode_buf(buf, uri->path, ares_uri_chis_path);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              844,
              0
            ],
            [
              865,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write_path",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_write_query(const ares_uri_t *uri,\n                                          ares_buf_t       *buf)\n{\n  ares_status_t status;\n  char        **keys;\n  size_t        num_keys = 0;\n  size_t        i;\n\n  if (ares_htable_dict_num_keys(uri->query) == 0) {\n    return ARES_SUCCESS;\n  }\n\n  keys = ares_uri_get_query_keys(uri, &num_keys);\n  if (keys == NULL || num_keys == 0) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_buf_append_byte(buf, '?');\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (i = 0; i < num_keys; i++) {\n    const char *val;\n\n    if (i != 0) {\n      status = ares_buf_append_byte(buf, '&');\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    status = ares_uri_encode_buf(buf, keys[i], ares_uri_chis_query);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    val = ares_uri_get_query_key(uri, keys[i]);\n    if (val != NULL) {\n      status = ares_buf_append_byte(buf, '=');\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n\n      status = ares_uri_encode_buf(buf, val, ares_uri_chis_query);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n  }\n\ndone:\n  ares_free_array(keys, num_keys, ares_free);\n  return status;\n}",
          "fn_code_pos": [
            [
              867,
              0
            ],
            [
              921,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write_query",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_write_fragment(const ares_uri_t *uri,\n                                             ares_buf_t       *buf)\n{\n  ares_status_t status;\n\n  if (!ares_strlen(uri->fragment)) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares_buf_append_byte(buf, '#');\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_uri_encode_buf(buf, uri->fragment, ares_uri_chis_fragment);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              923,
              0
            ],
            [
              943,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write_fragment",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_write_buf(const ares_uri_t *uri, ares_buf_t *buf)\n{\n  ares_status_t status;\n  size_t        orig_len;\n\n  if (uri == NULL || buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (ares_strlen(uri->scheme) == 0 || ares_strlen(uri->host) == 0) {\n    return ARES_ENODATA;\n  }\n\n  orig_len = ares_buf_len(buf);\n\n  status = ares_uri_write_scheme(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_write_authority(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_write_path(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_write_query(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_write_fragment(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_buf_set_length(buf, orig_len);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              945,
              0
            ],
            [
              990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write_buf",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_write(char **out, const ares_uri_t *uri)\n{\n  ares_buf_t   *buf;\n  ares_status_t status;\n\n  if (out == NULL || uri == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *out = NULL;\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_uri_write_buf(uri, buf);\n  if (status != ARES_SUCCESS) {\n    ares_buf_destroy(buf);\n    return status;\n  }\n\n  *out = ares_buf_finish_str(buf, NULL);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              992,
              0
            ],
            [
              1016,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write",
            "parameters": {
              "out": "char",
              "uri": "ares_uri_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_decode_inplace(char *str, ares_bool_t is_query,\n                                             ares_bool_t must_be_printable,\n                                             size_t     *out_len)\n{\n  size_t i;\n  size_t len = 0;\n\n  for (i = 0; str[i] != 0; i++) {\n    if (is_query && str[i] == '+') {\n      str[len++] = ' ';\n      continue;\n    }\n\n    if (str[i] != '%') {\n      str[len++] = str[i];\n      continue;\n    }\n\n    if (!ares_isxdigit(str[i + 1]) || !ares_isxdigit(str[i + 2])) {\n      return ARES_EBADSTR;\n    }\n\n    str[len] = (char)(xdigit_val(str[i + 1]) << 4 | xdigit_val(str[i + 2]));\n\n    if (must_be_printable && !ares_isprint(str[len])) {\n      return ARES_EBADSTR;\n    }\n\n    len++;\n\n    i += 2;\n  }\n\n  str[len] = 0;\n\n  *out_len = len;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1023,
              0
            ],
            [
              1060,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_decode_inplace",
            "parameters": {
              "str": "char",
              "is_query": "ares_bool_t",
              "must_be_printable": "ares_bool_t",
              "out_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_parse_scheme(ares_uri_t *uri, ares_buf_t *buf)\n{\n  ares_status_t status;\n  size_t        bytes;\n  char          scheme[sizeof(uri->scheme)];\n\n  ares_buf_tag(buf);\n\n  bytes =\n    ares_buf_consume_until_seq(buf, (const unsigned char *)\"://\", 3, ARES_TRUE);\n  if (bytes == SIZE_MAX || bytes > sizeof(uri->scheme)) {\n    return ARES_EBADSTR;\n  }\n\n  status = ares_buf_tag_fetch_string(buf, scheme, sizeof(scheme));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_uri_set_scheme(uri, scheme);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Consume :// */\n  ares_buf_consume(buf, 3);\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1062,
              0
            ],
            [
              1090,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_scheme",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_parse_userinfo(ares_uri_t *uri, ares_buf_t *buf)\n{\n  size_t        userinfo_len;\n  size_t        username_len;\n  ares_bool_t   has_password = ARES_FALSE;\n  char         *temp         = NULL;\n  ares_status_t status;\n  size_t        len;\n\n  ares_buf_tag(buf);\n\n  /* Search for @, if its not found, return */\n  userinfo_len = ares_buf_consume_until_charset(buf, (const unsigned char *)\"@\",\n                                                1, ARES_TRUE);\n\n  if (userinfo_len == SIZE_MAX) {\n    return ARES_SUCCESS;\n  }\n\n  /* Rollback since now we know there really is userinfo */\n  ares_buf_tag_rollback(buf);\n\n  /* Search for ':', if it isn't found or its past the '@' then we only have\n   * a username and no password */\n  ares_buf_tag(buf);\n  username_len = ares_buf_consume_until_charset(buf, (const unsigned char *)\":\",\n                                                1, ARES_TRUE);\n  if (username_len < userinfo_len) {\n    has_password = ARES_TRUE;\n    status       = ares_buf_tag_fetch_strdup(buf, &temp);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_uri_decode_inplace(temp, ARES_FALSE, ARES_TRUE, &len);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_uri_set_username_own(uri, temp);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n    temp = NULL;\n\n    /* Consume : */\n    ares_buf_consume(buf, 1);\n  }\n\n  ares_buf_tag(buf);\n  ares_buf_consume_until_charset(buf, (const unsigned char *)\"@\", 1, ARES_TRUE);\n  status = ares_buf_tag_fetch_strdup(buf, &temp);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_decode_inplace(temp, ARES_FALSE, ARES_TRUE, &len);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (has_password) {\n    status = ares_uri_set_password_own(uri, temp);\n  } else {\n    status = ares_uri_set_username_own(uri, temp);\n  }\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  temp = NULL;\n\n  /* Consume @ */\n  ares_buf_consume(buf, 1);\n\ndone:\n  ares_free(temp);\n  return status;\n}",
          "fn_code_pos": [
            [
              1092,
              0
            ],
            [
              1169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_userinfo",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_parse_hostport(ares_uri_t *uri, ares_buf_t *buf)\n{\n  unsigned char b;\n  char          host[256];\n  char          port[6];\n  size_t        len;\n  ares_status_t status;\n\n  status = ares_buf_peek_byte(buf, &b);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Bracketed syntax for ipv6 addresses */\n  if (b == '[') {\n    ares_buf_consume(buf, 1);\n    ares_buf_tag(buf);\n    len = ares_buf_consume_until_charset(buf, (const unsigned char *)\"]\", 1,\n                                         ARES_TRUE);\n    if (len == SIZE_MAX) {\n      return ARES_EBADSTR;\n    }\n\n    status = ares_buf_tag_fetch_string(buf, host, sizeof(host));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n    /* Consume ']' */\n    ares_buf_consume(buf, 1);\n  } else {\n    /* Either ipv4 or hostname */\n    ares_buf_tag(buf);\n    ares_buf_consume_until_charset(buf, (const unsigned char *)\":\", 1,\n                                   ARES_FALSE);\n\n    status = ares_buf_tag_fetch_string(buf, host, sizeof(host));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  status = ares_uri_set_host(uri, host);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* No port if nothing left to consume */\n  if (!ares_buf_len(buf)) {\n    return status;\n  }\n\n  status = ares_buf_peek_byte(buf, &b);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Only valid extra character at this point is ':' */\n  if (b != ':') {\n    return ARES_EBADSTR;\n  }\n  ares_buf_consume(buf, 1);\n\n  len = ares_buf_len(buf);\n  if (len == 0 || len > sizeof(port) - 1) {\n    return ARES_EBADSTR;\n  }\n\n  status = ares_buf_fetch_bytes(buf, (unsigned char *)port, len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n  port[len] = 0;\n\n  if (!ares_str_isnum(port)) {\n    return ARES_EBADSTR;\n  }\n\n  status = ares_uri_set_port(uri, (unsigned short)atoi(port));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1171,
              0
            ],
            [
              1254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_hostport",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_parse_authority(ares_uri_t *uri, ares_buf_t *buf)\n{\n  ares_status_t        status;\n  size_t               bytes;\n  ares_buf_t          *auth = NULL;\n  const unsigned char *ptr;\n  size_t               ptr_len;\n\n  ares_buf_tag(buf);\n\n  bytes = ares_buf_consume_until_charset(buf, (const unsigned char *)\"/?#\", 3,\n                                         ARES_FALSE);\n  if (bytes == 0) {\n    return ARES_EBADSTR;\n  }\n\n  status = ares_buf_tag_fetch_constbuf(buf, &auth);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ptr = ares_buf_peek(auth, &ptr_len);\n  if (!ares_uri_str_isvalid((const char *)ptr, ptr_len,\n                            ares_uri_chis_authority)) {\n    status = ARES_EBADSTR;\n    goto done;\n  }\n\n  status = ares_uri_parse_userinfo(uri, auth);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_parse_hostport(uri, auth);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* NOTE: the /, ?, or # is still in the buffer at this point so it can\n   *       be used to determine what parser should be called next */\n\ndone:\n  ares_buf_destroy(auth);\n  return status;\n}",
          "fn_code_pos": [
            [
              1256,
              0
            ],
            [
              1300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_authority",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_parse_path(ares_uri_t *uri, ares_buf_t *buf)\n{\n  unsigned char b;\n  char         *path = NULL;\n  ares_status_t status;\n  size_t        len;\n\n  if (ares_buf_len(buf) == 0) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares_buf_peek_byte(buf, &b);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Not a path, must be one of the others */\n  if (b != '/') {\n    return ARES_SUCCESS;\n  }\n\n  ares_buf_tag(buf);\n  ares_buf_consume_until_charset(buf, (const unsigned char *)\"?#\", 2,\n                                 ARES_FALSE);\n  status = ares_buf_tag_fetch_strdup(buf, &path);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (!ares_uri_str_isvalid(path, SIZE_MAX, ares_uri_chis_path_enc)) {\n    status = ARES_EBADSTR;\n    goto done;\n  }\n\n  status = ares_uri_decode_inplace(path, ARES_FALSE, ARES_TRUE, &len);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_set_path(uri, path);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_free(path);\n  return status;\n}",
          "fn_code_pos": [
            [
              1302,
              0
            ],
            [
              1349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_path",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_parse_query_buf(ares_uri_t *uri, ares_buf_t *buf)\n{\n  ares_status_t status = ARES_SUCCESS;\n  char         *key    = NULL;\n  char         *val    = NULL;\n\n  while (ares_buf_len(buf) > 0) {\n    unsigned char b = 0;\n    size_t        len;\n\n    ares_buf_tag(buf);\n\n    /* Its valid to have only a key with no value, so we search for both\n     * delims */\n    len = ares_buf_consume_until_charset(buf, (const unsigned char *)\"&=\", 2,\n                                         ARES_FALSE);\n    if (len == 0) {\n      /* If we're here, we have a zero length key which is invalid */\n      status = ARES_EBADSTR;\n      goto done;\n    }\n\n    if (ares_buf_len(buf) > 0) {\n      /* Determine if we stopped on & or = */\n      status = ares_buf_peek_byte(buf, &b);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    status = ares_buf_tag_fetch_strdup(buf, &key);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    if (!ares_uri_str_isvalid(key, SIZE_MAX, ares_uri_chis_query_enc)) {\n      status = ARES_EBADSTR;\n      goto done;\n    }\n\n    status = ares_uri_decode_inplace(key, ARES_TRUE, ARES_TRUE, &len);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    /* Fetch Value */\n    if (b == '=') {\n      /* Skip delimiter */\n      ares_buf_consume(buf, 1);\n      ares_buf_tag(buf);\n      len = ares_buf_consume_until_charset(buf, (const unsigned char *)\"&\", 1,\n                                           ARES_FALSE);\n      if (len > 0) {\n        status = ares_buf_tag_fetch_strdup(buf, &val);\n        if (status != ARES_SUCCESS) {\n          goto done;\n        }\n\n        if (!ares_uri_str_isvalid(val, SIZE_MAX, ares_uri_chis_query_enc)) {\n          status = ARES_EBADSTR;\n          goto done;\n        }\n\n        status = ares_uri_decode_inplace(val, ARES_TRUE, ARES_TRUE, &len);\n        if (status != ARES_SUCCESS) {\n          goto done;\n        }\n      }\n    }\n\n    if (b != 0) {\n      /* Consume '&' */\n      ares_buf_consume(buf, 1);\n    }\n\n    status = ares_uri_set_query_key(uri, key, val);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    ares_free(key);\n    key = NULL;\n    ares_free(val);\n    val = NULL;\n  }\n\ndone:\n  ares_free(key);\n  ares_free(val);\n  return status;\n}",
          "fn_code_pos": [
            [
              1351,
              0
            ],
            [
              1441,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_query_buf",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_parse_query(ares_uri_t *uri, ares_buf_t *buf)\n{\n  unsigned char b;\n  ares_status_t status;\n  ares_buf_t   *query = NULL;\n  size_t        len;\n\n  if (ares_buf_len(buf) == 0) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares_buf_peek_byte(buf, &b);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Not a query, must be one of the others */\n  if (b != '?') {\n    return ARES_SUCCESS;\n  }\n\n  /* Only possible terminator is fragment indicator of '#' */\n  ares_buf_consume(buf, 1);\n  ares_buf_tag(buf);\n  len = ares_buf_consume_until_charset(buf, (const unsigned char *)\"#\", 1,\n                                       ARES_FALSE);\n  if (len == 0) {\n    /* No data, return */\n    return ARES_SUCCESS;\n  }\n\n  status = ares_buf_tag_fetch_constbuf(buf, &query);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_uri_parse_query_buf(uri, query);\n  ares_buf_destroy(query);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1443,
              0
            ],
            [
              1483,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_query",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_uri_parse_fragment(ares_uri_t *uri, ares_buf_t *buf)\n{\n  unsigned char b;\n  char         *fragment = NULL;\n  ares_status_t status;\n  size_t        len;\n\n  if (ares_buf_len(buf) == 0) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares_buf_peek_byte(buf, &b);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Not a fragment, must be one of the others */\n  if (b != '#') {\n    return ARES_SUCCESS;\n  }\n\n  ares_buf_consume(buf, 1);\n\n  if (ares_buf_len(buf) == 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* Rest of the buffer is the fragment */\n  status = ares_buf_fetch_str_dup(buf, ares_buf_len(buf), &fragment);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (!ares_uri_str_isvalid(fragment, SIZE_MAX, ares_uri_chis_fragment_enc)) {\n    status = ARES_EBADSTR;\n    goto done;\n  }\n\n  status = ares_uri_decode_inplace(fragment, ARES_FALSE, ARES_TRUE, &len);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_set_fragment_own(uri, fragment);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  fragment = NULL;\n\ndone:\n  ares_free(fragment);\n  return status;\n}",
          "fn_code_pos": [
            [
              1485,
              0
            ],
            [
              1537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_fragment",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_parse_buf(ares_uri_t **out, ares_buf_t *buf)\n{\n  ares_status_t status;\n  ares_uri_t   *uri = NULL;\n  size_t        orig_pos;\n\n  if (out == NULL || buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *out = NULL;\n\n  orig_pos = ares_buf_get_position(buf);\n\n  uri = ares_uri_create();\n  if (uri == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares_uri_parse_scheme(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_parse_authority(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_parse_path(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_parse_query(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_parse_fragment(uri, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_buf_set_position(buf, orig_pos);\n    ares_uri_destroy(uri);\n  } else {\n    *out = uri;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              1539,
              0
            ],
            [
              1592,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_buf",
            "parameters": {
              "out": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_uri_parse(ares_uri_t **out, const char *str)\n{\n  ares_status_t status;\n  ares_buf_t   *buf = NULL;\n\n  if (out == NULL || str == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *out = NULL;\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares_buf_append_str(buf, str);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_uri_parse_buf(out, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_buf_destroy(buf);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1594,
              0
            ],
            [
              1625,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse",
            "parameters": {
              "out": "ares_uri_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_uri_create(void)",
          "fn_dec_pos": [
            [
              238,
              12
            ],
            [
              238,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*ischr)(char)",
          "fn_dec_pos": [
            [
              290,
              52
            ],
            [
              290,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_uri_get_scheme(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              322,
              12
            ],
            [
              322,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_scheme",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_get_username(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              372,
              12
            ],
            [
              372,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_username",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_get_password(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              420,
              12
            ],
            [
              420,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_password",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_get_host(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              482,
              12
            ],
            [
              482,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_host",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_path_normalize(const char *path)",
          "fn_dec_pos": [
            [
              509,
              13
            ],
            [
              509,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_path_normalize",
            "parameters": {
              "path": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_get_path(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              615,
              12
            ],
            [
              615,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_path",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_get_query_key(const ares_uri_t *uri, const char *key)",
          "fn_dec_pos": [
            [
              656,
              12
            ],
            [
              656,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_query_key",
            "parameters": {
              "uri": "ares_uri_t",
              "key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_get_query_keys(const ares_uri_t *uri, size_t *num)",
          "fn_dec_pos": [
            [
              666,
              7
            ],
            [
              666,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_query_keys",
            "parameters": {
              "uri": "ares_uri_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_get_fragment(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              714,
              12
            ],
            [
              714,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_fragment",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ischr)(char)",
          "fn_dec_pos": [
            [
              723,
              53
            ],
            [
              723,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_uri {\n  char                scheme[16];\n  char               *username;\n  char               *password;\n  unsigned short      port;\n  char                host[256];\n  char               *path;\n  ares_htable_dict_t *query;\n  char               *fragment;\n}",
          {
            "scheme[16]": "char",
            "*username": "char",
            "*password": "char",
            "port": "unsigned short",
            "host[256]": "char",
            "*path": "char",
            "*query": "ares_htable_dict_t",
            "*fragment": "char"
          },
          "ares_uri",
          [
            33,
            0
          ],
          [
            42,
            1
          ]
        ],
        [
          "struct ares_uri {\n  char                scheme[16];\n  char               *username;\n  char               *password;\n  unsigned short      port;\n  char                host[256];\n  char               *path;\n  ares_htable_dict_t *query;\n  char               *fragment;\n}",
          {
            "scheme[16]": "char",
            "*username": "char",
            "*password": "char",
            "port": "unsigned short",
            "host[256]": "char",
            "*path": "char",
            "*query": "ares_htable_dict_t",
            "*fragment": "char"
          },
          "ares_uri",
          [
            33,
            0
          ],
          [
            42,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            431,
            2
          ],
          [
            431,
            18
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            802,
            4
          ],
          [
            802,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_uri.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/str/ares_strsplit.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_strsplit_free(char **elms, size_t num_elm)\n{\n  ares_free_array(elms, num_elm, ares_free);\n}",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              30,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strsplit_free",
            "parameters": {
              "elms": "char",
              "num_elm": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char **ares_strsplit_duplicate(char **elms, size_t num_elm)\n{\n  size_t i;\n  char **out;\n\n  if (elms == NULL || num_elm == 0) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  out = ares_malloc_zero(sizeof(*elms) * num_elm);\n  if (out == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (i = 0; i < num_elm; i++) {\n    out[i] = ares_strdup(elms[i]);\n    if (out[i] == NULL) {\n      ares_strsplit_free(out, num_elm); /* LCOV_EXCL_LINE: OutOfMemory */\n      return NULL;                      /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return out;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "char **ares_strsplit(const char *in, const char *delms, size_t *num_elm)\n{\n  ares_status_t status;\n  ares_buf_t   *buf = NULL;\n  char        **out = NULL;\n\n  if (in == NULL || delms == NULL || num_elm == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *num_elm = 0;\n\n  buf = ares_buf_create_const((const unsigned char *)in, ares_strlen(in));\n  if (buf == NULL) {\n    return NULL;\n  }\n\n  status = ares_buf_split_str(\n    buf, (const unsigned char *)delms, ares_strlen(delms),\n    ARES_BUF_SPLIT_NO_DUPLICATES | ARES_BUF_SPLIT_CASE_INSENSITIVE, 0, &out,\n    num_elm);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_buf_destroy(buf);\n  if (status != ARES_SUCCESS) {\n    out = NULL;\n  }\n\n  return out;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_strsplit_duplicate(char **elms, size_t num_elm)",
          "fn_dec_pos": [
            [
              32,
              7
            ],
            [
              32,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strsplit_duplicate",
            "parameters": {
              "elms": "char",
              "num_elm": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_strsplit(const char *in, const char *delms, size_t *num_elm)",
          "fn_dec_pos": [
            [
              57,
              7
            ],
            [
              57,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strsplit",
            "parameters": {
              "in": "char",
              "delms": "char",
              "num_elm": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/str/ares_str.c": {
      "fn_def_list": [
        {
          "fn_code": "size_t ares_strnlen(const char *str, size_t maxlen) {\n  const char *p = NULL;\n  if (str == NULL) {\n    return 0;\n  }\n#ifdef HAVE_STRNLEN\n  (void)p;\n  return strnlen(str, maxlen);\n#else\n  if ((p = memchr(str, 0, maxlen)) == NULL) {\n    return maxlen;\n  } else {\n    return (size_t)(p - str);\n  }\n#endif /* HAVE_STRNLEN */\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strnlen",
            "parameters": {
              "str": "char",
              "maxlen": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_strlen(const char *str)\n{\n  if (str == NULL) {\n    return 0;\n  }\n\n  return strlen(str);\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strlen",
            "parameters": {
              "str": "char"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "char *ares_strdup(const char *s1)\n{\n  size_t len;\n  char  *out;\n\n  if (s1 == NULL) {\n    return NULL;\n  }\n\n  len = ares_strlen(s1);\n\n  /* Don't see how this is possible */\n  if (len == SIZE_MAX) {\n    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  out = ares_malloc(len + 1);\n  if (out == NULL) {\n    return NULL;\n  }\n\n  if (len) {\n    memcpy(out, s1, len);\n  }\n\n  out[len] = 0;\n  return out;\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strdup",
            "parameters": {
              "s1": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "size_t ares_strcpy(char *dest, const char *src, size_t dest_size)\n{\n  size_t len = 0;\n\n  if (dest == NULL || dest_size == 0) {\n    return 0; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  len = ares_strlen(src);\n\n  if (len >= dest_size) {\n    len = dest_size - 1;\n  }\n\n  if (len) {\n    memcpy(dest, src, len);\n  }\n\n  dest[len] = 0;\n  return len;\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcpy",
            "parameters": {
              "dest": "char",
              "src": "char",
              "dest_size": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_str_isnum(const char *str)\n{\n  size_t i;\n\n  if (str == NULL || *str == 0) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; str[i] != 0; i++) {\n    if (!ares_isdigit(str[i])) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_isnum",
            "parameters": {
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_str_isalnum(const char *str)\n{\n  size_t i;\n\n  if (str == NULL || *str == 0) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; str[i] != 0; i++) {\n    if (!ares_isdigit(str[i]) && !ares_isalpha(str[i])) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_isalnum",
            "parameters": {
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void ares_str_rtrim(char *str)\n{\n  size_t len;\n  size_t i;\n\n  if (str == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  len = ares_strlen(str);\n  for (i = len; i > 0; i--) {\n    if (!ares_isspace(str[i - 1])) {\n      break;\n    }\n  }\n  str[i] = 0;\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_rtrim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_str_ltrim(char *str)\n{\n  size_t i;\n  size_t len;\n\n  if (str == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  for (i = 0; str[i] != 0 && ares_isspace(str[i]); i++) {\n    /* Do nothing */\n  }\n\n  if (i == 0) {\n    return;\n  }\n\n  len = ares_strlen(str);\n  if (i != len) {\n    memmove(str, str + i, len - i);\n  }\n  str[len - i] = 0;\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_ltrim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_str_trim(char *str)\n{\n  ares_str_ltrim(str);\n  ares_str_rtrim(str);\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_trim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned char ares_tolower(unsigned char c)\n{\n  return ares_tolower_lookup[c];\n}",
          "fn_code_pos": [
            [
              216,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_tolower",
            "parameters": {
              "c": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void ares_str_lower(char *str)\n{\n  size_t i;\n\n  if (str == NULL) {\n    return;\n  }\n\n  for (i = 0; str[i] != 0; i++) {\n    str[i] = (char)ares_tolower((unsigned char)str[i]);\n  }\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_lower",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned char *ares_memmem(const unsigned char *big, size_t big_len,\n                           const unsigned char *little, size_t little_len)\n{\n  unsigned char *ptr;\n\n  if (big == NULL || little == NULL || big_len == 0 || little_len == 0) {\n    return NULL;\n  }\n\n#ifdef HAVE_MEMMEM\n  ptr = memmem(big, big_len, little, little_len);\n  return ptr;\n#else\n  while (1) {\n    ptr = memchr(big, little[0], big_len);\n    if (ptr == NULL) {\n      break;\n    }\n\n    big_len -= (size_t)(ptr - big);\n    big      = ptr;\n    if (big_len < little_len) {\n      break;\n    }\n\n    if (memcmp(big, little, little_len) == 0) {\n      return ptr;\n    }\n\n    big++;\n    big_len--;\n  }\n\n  return NULL;\n#endif\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_memmem",
            "parameters": {
              "big": "unsigned char",
              "big_len": "size_t",
              "little": "unsigned char",
              "little_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_memeq(const unsigned char *ptr, const unsigned char *val,\n                       size_t len)\n{\n  return memcmp(ptr, val, len) == 0 ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_memeq",
            "parameters": {
              "ptr": "unsigned char",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_memeq_ci(const unsigned char *ptr, const unsigned char *val,\n                          size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i++) {\n    if (ares_tolower_lookup[ptr[i]] != ares_tolower_lookup[val[i]]) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              277,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_memeq_ci",
            "parameters": {
              "ptr": "unsigned char",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_is_hostname(const char *str)\n{\n  size_t i;\n\n  if (str == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  for (i = 0; str[i] != 0; i++) {\n    if (!ares_is_hostnamech(str[i])) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_is_hostname",
            "parameters": {
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_str_isprint(const char *str, size_t len)\n{\n  size_t i;\n\n  if (str == NULL && len != 0) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (!ares_isprint(str[i])) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_isprint",
            "parameters": {
              "str": "char",
              "len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "int ares_strcmp(const char *a, const char *b)\n{\n  if (a == NULL && b == NULL) {\n    return 0;\n  }\n\n  if (a != NULL && b == NULL) {\n    if (*a == 0) {\n      return 0;\n    }\n    return 1;\n  }\n\n  if (a == NULL && b != NULL) {\n    if (*b == 0) {\n      return 0;\n    }\n    return -1;\n  }\n\n  return strcmp(a, b);\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcmp",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_strncmp(const char *a, const char *b, size_t n)\n{\n  if (n == 0) {\n    return 0;\n  }\n\n  if (a == NULL && b == NULL) {\n    return 0;\n  }\n\n  if (a != NULL && b == NULL) {\n    if (*a == 0) {\n      return 0;\n    }\n    return 1;\n  }\n\n  if (a == NULL && b != NULL) {\n    if (*b == 0) {\n      return 0;\n    }\n    return -1;\n  }\n\n  return strncmp(a, b, n);\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              369,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strncmp",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_strcasecmp(const char *a, const char *b)\n{\n  if (a == NULL && b == NULL) {\n    return 0;\n  }\n\n  if (a != NULL && b == NULL) {\n    if (*a == 0) {\n      return 0;\n    }\n    return 1;\n  }\n\n  if (a == NULL && b != NULL) {\n    if (*b == 0) {\n      return 0;\n    }\n    return -1;\n  }\n\n#if defined(HAVE_STRCASECMP)\n  return strcasecmp(a, b);\n#elif defined(HAVE_STRCMPI)\n  return strcmpi(a, b);\n#elif defined(HAVE_STRICMP)\n  return stricmp(a, b);\n#else\n  {\n    size_t i;\n\n    for (i = 0; i < (size_t)-1; i++) {\n      int c1 = ares_tolower(a[i]);\n      int c2 = ares_tolower(b[i]);\n      if (c1 != c2) {\n        return c1 - c2;\n      }\n      if (!c1) {\n        break;\n      }\n    }\n  }\n  return 0;\n#endif\n}",
          "fn_code_pos": [
            [
              371,
              0
            ],
            [
              414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcasecmp",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_strncasecmp(const char *a, const char *b, size_t n)\n{\n  if (n == 0) {\n    return 0;\n  }\n\n  if (a == NULL && b == NULL) {\n    return 0;\n  }\n\n  if (a != NULL && b == NULL) {\n    if (*a == 0) {\n      return 0;\n    }\n    return 1;\n  }\n\n  if (a == NULL && b != NULL) {\n    if (*b == 0) {\n      return 0;\n    }\n    return -1;\n  }\n\n#if defined(HAVE_STRNCASECMP)\n  return strncasecmp(a, b, n);\n#elif defined(HAVE_STRNCMPI)\n  return strncmpi(a, b, n);\n#elif defined(HAVE_STRNICMP)\n  return strnicmp(a, b, n);\n#else\n  {\n    size_t i;\n\n    for (i = 0; i < n; i++) {\n      int c1 = ares_tolower(a[i]);\n      int c2 = ares_tolower(b[i]);\n      if (c1 != c2) {\n        return c1 - c2;\n      }\n      if (!c1) {\n        break;\n      }\n    }\n  }\n  return 0;\n#endif\n}",
          "fn_code_pos": [
            [
              416,
              0
            ],
            [
              463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strncasecmp",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_bool_t ares_strcaseeq(const char *a, const char *b)\n{\n  return ares_strcasecmp(a, b) == 0 ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              465,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcaseeq",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_strcaseeq_max(const char *a, const char *b, size_t n)\n{\n  return ares_strncasecmp(a, b, n) == 0 ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcaseeq_max",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_streq(const char *a, const char *b)\n{\n  return ares_strcmp(a, b) == 0 ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              475,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_streq",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_streq_max(const char *a, const char *b, size_t n)\n{\n  return ares_strncmp(a, b, n) == 0 ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              483,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_streq_max",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void ares_free_array(void *arrp, size_t nmembers, void (*freefunc)(void *))\n{\n  size_t i;\n  void **arr = arrp;\n\n  if (arr == NULL) {\n    return;\n  }\n\n  if (freefunc != NULL) {\n    if (nmembers == SIZE_MAX) {\n      for (i = 0; arr[i] != NULL; i++) {\n        freefunc(arr[i]);\n      }\n    } else {\n      for (i = 0; i < nmembers; i++) {\n        freefunc(arr[i]);\n      }\n    }\n  }\n\n  ares_free(arr);\n}",
          "fn_code_pos": [
            [
              485,
              0
            ],
            [
              507,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_array",
            "parameters": {
              "arrp": "void",
              "nmembers": "size_t",
              "freefunc": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_strdup(const char *s1)",
          "fn_dec_pos": [
            [
              60,
              6
            ],
            [
              60,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strdup",
            "parameters": {
              "s1": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_memmem(const unsigned char *big, size_t big_len,\n                           const unsigned char *little, size_t little_len)",
          "fn_dec_pos": [
            [
              234,
              15
            ],
            [
              235,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_memmem",
            "parameters": {
              "big": "unsigned char",
              "big_len": "size_t",
              "little": "unsigned char",
              "little_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*freefunc)(void *)",
          "fn_dec_pos": [
            [
              485,
              55
            ],
            [
              485,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_str.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/str/ares_buf.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_buf_t *ares_buf_create(void)\n{\n  ares_buf_t *buf = ares_malloc_zero(sizeof(*buf));\n  if (buf == NULL) {\n    return NULL;\n  }\n\n  buf->tag_offset = SIZE_MAX;\n  return buf;\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_create",
            "parameters": {},
            "return_type": "ares_buf_t"
          }
        },
        {
          "fn_code": "ares_buf_t *ares_buf_create_const(const unsigned char *data, size_t data_len)\n{\n  ares_buf_t *buf;\n\n  if (data == NULL || data_len == 0) {\n    return NULL;\n  }\n\n  buf = ares_buf_create();\n  if (buf == NULL) {\n    return NULL;\n  }\n\n  buf->data     = data;\n  buf->data_len = data_len;\n\n  return buf;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_create_const",
            "parameters": {
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "ares_buf_t"
          }
        },
        {
          "fn_code": "void ares_buf_destroy(ares_buf_t *buf)\n{\n  if (buf == NULL) {\n    return;\n  }\n  ares_free(buf->alloc_buf);\n  ares_free(buf);\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_destroy",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_buf_is_const(const ares_buf_t *buf)\n{\n  if (buf == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (buf->data != NULL && buf->alloc_buf == NULL) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_is_const",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void ares_buf_reclaim(ares_buf_t *buf)\n{\n  size_t prefix_size;\n  size_t data_size;\n\n  if (buf == NULL) {\n    return;\n  }\n\n  if (ares_buf_is_const(buf)) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Silence coverity.  All lengths are zero so would bail out later but\n   * coverity doesn't know this */\n  if (buf->alloc_buf == NULL) {\n    return;\n  }\n\n  if (buf->tag_offset != SIZE_MAX && buf->tag_offset < buf->offset) {\n    prefix_size = buf->tag_offset;\n  } else {\n    prefix_size = buf->offset;\n  }\n\n  if (prefix_size == 0) {\n    return;\n  }\n\n  data_size = buf->data_len - prefix_size;\n\n  memmove(buf->alloc_buf, buf->alloc_buf + prefix_size, data_size);\n  buf->data      = buf->alloc_buf;\n  buf->data_len  = data_size;\n  buf->offset   -= prefix_size;\n  if (buf->tag_offset != SIZE_MAX) {\n    buf->tag_offset -= prefix_size;\n  }\n}",
          "fn_code_pos": [
            [
              97,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_reclaim",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_buf_ensure_space(ares_buf_t *buf, size_t needed_size)\n{\n  size_t         remaining_size;\n  size_t         alloc_size;\n  unsigned char *ptr;\n\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (ares_buf_is_const(buf)) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* When calling ares_buf_finish_str() we end up adding a null terminator,\n   * so we want to ensure the size is always sufficient for this as we don't\n   * want an ARES_ENOMEM at that point */\n  needed_size++;\n\n  /* No need to do an expensive move operation, we have enough to just append */\n  remaining_size = buf->alloc_buf_len - buf->data_len;\n  if (remaining_size >= needed_size) {\n    return ARES_SUCCESS;\n  }\n\n  /* See if just moving consumed data frees up enough space */\n  ares_buf_reclaim(buf);\n\n  remaining_size = buf->alloc_buf_len - buf->data_len;\n  if (remaining_size >= needed_size) {\n    return ARES_SUCCESS;\n  }\n\n  alloc_size = buf->alloc_buf_len;\n\n  /* Not yet started */\n  if (alloc_size == 0) {\n    alloc_size = 16; /* Always shifts 1, so ends up being 32 minimum */\n  }\n\n  /* Increase allocation by powers of 2 */\n  do {\n    alloc_size     <<= 1;\n    remaining_size   = alloc_size - buf->data_len;\n  } while (remaining_size < needed_size);\n\n  ptr = ares_realloc(buf->alloc_buf, alloc_size);\n  if (ptr == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  buf->alloc_buf     = ptr;\n  buf->alloc_buf_len = alloc_size;\n  buf->data          = ptr;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_ensure_space",
            "parameters": {
              "buf": "ares_buf_t",
              "needed_size": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_set_length(ares_buf_t *buf, size_t len)\n{\n  if (buf == NULL || ares_buf_is_const(buf)) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (len >= buf->alloc_buf_len - buf->offset) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  buf->data_len = len + buf->offset;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_set_length",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_append(ares_buf_t *buf, const unsigned char *data,\n                              size_t data_len)\n{\n  ares_status_t status;\n\n  if (data == NULL && data_len != 0) {\n    return ARES_EFORMERR;\n  }\n\n  if (data_len == 0) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares_buf_ensure_space(buf, data_len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  memcpy(buf->alloc_buf + buf->data_len, data, data_len);\n  buf->data_len += data_len;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              209,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append",
            "parameters": {
              "buf": "ares_buf_t",
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_append_byte(ares_buf_t *buf, unsigned char b)\n{\n  return ares_buf_append(buf, &b, 1);\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_byte",
            "parameters": {
              "buf": "ares_buf_t",
              "b": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_append_be16(ares_buf_t *buf, unsigned short u16)\n{\n  ares_status_t status;\n\n  status = ares_buf_append_byte(buf, (unsigned char)((u16 >> 8) & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_buf_append_byte(buf, (unsigned char)(u16 & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_be16",
            "parameters": {
              "buf": "ares_buf_t",
              "u16": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_append_be32(ares_buf_t *buf, unsigned int u32)\n{\n  ares_status_t status;\n\n  status = ares_buf_append_byte(buf, ((unsigned char)(u32 >> 24) & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_buf_append_byte(buf, ((unsigned char)(u32 >> 16) & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_buf_append_byte(buf, ((unsigned char)(u32 >> 8) & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  status = ares_buf_append_byte(buf, ((unsigned char)u32 & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              254,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_be32",
            "parameters": {
              "buf": "ares_buf_t",
              "u32": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "unsigned char *ares_buf_append_start(ares_buf_t *buf, size_t *len)\n{\n  ares_status_t status;\n\n  if (len == NULL || *len == 0) {\n    return NULL;\n  }\n\n  status = ares_buf_ensure_space(buf, *len);\n  if (status != ARES_SUCCESS) {\n    return NULL;\n  }\n\n  /* -1 for possible null terminator for ares_buf_finish_str() */\n  *len = buf->alloc_buf_len - buf->data_len - 1;\n  return buf->alloc_buf + buf->data_len;\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_start",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void ares_buf_append_finish(ares_buf_t *buf, size_t len)\n{\n  if (buf == NULL) {\n    return;\n  }\n\n  buf->data_len += len;\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_finish",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned char *ares_buf_finish_bin(ares_buf_t *buf, size_t *len)\n{\n  unsigned char *ptr = NULL;\n  if (buf == NULL || len == NULL || ares_buf_is_const(buf)) {\n    return NULL;\n  }\n\n  ares_buf_reclaim(buf);\n\n  /* We don't want to return NULL except on failure, may be zero-length */\n  if (buf->alloc_buf == NULL && ares_buf_ensure_space(buf, 1) != ARES_SUCCESS) {\n    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  ptr  = buf->alloc_buf;\n  *len = buf->data_len;\n  ares_free(buf);\n  return ptr;\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_finish_bin",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "char *ares_buf_finish_str(ares_buf_t *buf, size_t *len)\n{\n  char  *ptr;\n  size_t mylen;\n\n  ptr = (char *)ares_buf_finish_bin(buf, &mylen);\n  if (ptr == NULL) {\n    return NULL;\n  }\n\n  if (len != NULL) {\n    *len = mylen;\n  }\n\n  /* NOTE: ensured via ares_buf_ensure_space() that there is always at least\n   *       1 extra byte available for this specific use-case */\n  ptr[mylen] = 0;\n\n  return ptr;\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_finish_str",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void ares_buf_tag(ares_buf_t *buf)\n{\n  if (buf == NULL) {\n    return;\n  }\n\n  buf->tag_offset = buf->offset;\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_rollback(ares_buf_t *buf)\n{\n  if (buf == NULL || buf->tag_offset == SIZE_MAX) {\n    return ARES_EFORMERR;\n  }\n\n  buf->offset     = buf->tag_offset;\n  buf->tag_offset = SIZE_MAX;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_rollback",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_clear(ares_buf_t *buf)\n{\n  if (buf == NULL || buf->tag_offset == SIZE_MAX) {\n    return ARES_EFORMERR;\n  }\n\n  buf->tag_offset = SIZE_MAX;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              376,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_clear",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const unsigned char *ares_buf_tag_fetch(const ares_buf_t *buf, size_t *len)\n{\n  if (buf == NULL || buf->tag_offset == SIZE_MAX || len == NULL) {\n    return NULL;\n  }\n\n  *len = buf->offset - buf->tag_offset;\n  return buf->data + buf->tag_offset;\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              386,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_fetch",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "size_t ares_buf_tag_length(const ares_buf_t *buf)\n{\n  if (buf == NULL || buf->tag_offset == SIZE_MAX) {\n    return 0;\n  }\n  return buf->offset - buf->tag_offset;\n}",
          "fn_code_pos": [
            [
              388,
              0
            ],
            [
              394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_length",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_fetch_bytes(const ares_buf_t *buf,\n                                       unsigned char *bytes, size_t *len)\n{\n  size_t               ptr_len = 0;\n  const unsigned char *ptr     = ares_buf_tag_fetch(buf, &ptr_len);\n\n  if (ptr == NULL || bytes == NULL || len == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*len < ptr_len) {\n    return ARES_EFORMERR;\n  }\n\n  *len = ptr_len;\n\n  if (ptr_len > 0) {\n    memcpy(bytes, ptr, ptr_len);\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_fetch_bytes",
            "parameters": {
              "buf": "ares_buf_t",
              "bytes": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_fetch_constbuf(const ares_buf_t *buf,\n                                          ares_buf_t      **newbuf)\n{\n  size_t               ptr_len = 0;\n  const unsigned char *ptr     = ares_buf_tag_fetch(buf, &ptr_len);\n\n  if (ptr == NULL || newbuf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *newbuf = ares_buf_create_const(ptr, ptr_len);\n  if (*newbuf == NULL) {\n    return ARES_ENOMEM;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              418,
              0
            ],
            [
              433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_fetch_constbuf",
            "parameters": {
              "buf": "ares_buf_t",
              "newbuf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_fetch_string(const ares_buf_t *buf, char *str,\n                                        size_t len)\n{\n  size_t        out_len;\n  ares_status_t status;\n  size_t        i;\n\n  if (str == NULL || len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  /* Space for NULL terminator */\n  out_len = len - 1;\n\n  status = ares_buf_tag_fetch_bytes(buf, (unsigned char *)str, &out_len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* NULL terminate */\n  str[out_len] = 0;\n\n  /* Validate string is printable */\n  for (i = 0; i < out_len; i++) {\n    if (!ares_isprint(str[i])) {\n      return ARES_EBADSTR;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              435,
              0
            ],
            [
              465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_fetch_string",
            "parameters": {
              "buf": "ares_buf_t",
              "str": "char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_fetch_strdup(const ares_buf_t *buf, char **str)\n{\n  size_t               ptr_len = 0;\n  const unsigned char *ptr     = ares_buf_tag_fetch(buf, &ptr_len);\n\n  if (ptr == NULL || str == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (!ares_str_isprint((const char *)ptr, ptr_len)) {\n    return ARES_EBADSTR;\n  }\n\n  *str = ares_malloc(ptr_len + 1);\n  if (*str == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  if (ptr_len > 0) {\n    memcpy(*str, ptr, ptr_len);\n  }\n  (*str)[ptr_len] = 0;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              467,
              0
            ],
            [
              490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_fetch_strdup",
            "parameters": {
              "buf": "ares_buf_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static const unsigned char *ares_buf_fetch(const ares_buf_t *buf, size_t *len)\n{\n  if (len != NULL) {\n    *len = 0;\n  }\n\n  if (buf == NULL || len == NULL || buf->data == NULL) {\n    return NULL;\n  }\n\n  *len = buf->data_len - buf->offset;\n  if (*len == 0) {\n    return NULL;\n  }\n\n  return buf->data + buf->offset;\n}",
          "fn_code_pos": [
            [
              492,
              0
            ],
            [
              508,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_fetch",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_consume(ares_buf_t *buf, size_t len)\n{\n  size_t remaining_len = ares_buf_len(buf);\n\n  if (remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  buf->offset += len;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              510,
              0
            ],
            [
              520,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_be16(ares_buf_t *buf, unsigned short *u16)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);\n  unsigned int         u32;\n\n  if (buf == NULL || u16 == NULL || remaining_len < sizeof(*u16)) {\n    return ARES_EBADRESP;\n  }\n\n  /* Do math in an unsigned int in order to prevent warnings due to automatic\n   * conversion by the compiler from short to int during shifts */\n  u32  = ((unsigned int)(ptr[0]) << 8 | (unsigned int)ptr[1]);\n  *u16 = (unsigned short)(u32 & 0xFFFF);\n\n  return ares_buf_consume(buf, sizeof(*u16));\n}",
          "fn_code_pos": [
            [
              522,
              0
            ],
            [
              538,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_fetch_be16",
            "parameters": {
              "buf": "ares_buf_t",
              "u16": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_be32(ares_buf_t *buf, unsigned int *u32)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || u32 == NULL || remaining_len < sizeof(*u32)) {\n    return ARES_EBADRESP;\n  }\n\n  *u32 = ((unsigned int)(ptr[0]) << 24 | (unsigned int)(ptr[1]) << 16 |\n          (unsigned int)(ptr[2]) << 8 | (unsigned int)(ptr[3]));\n\n  return ares_buf_consume(buf, sizeof(*u32));\n}",
          "fn_code_pos": [
            [
              540,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_fetch_be32",
            "parameters": {
              "buf": "ares_buf_t",
              "u32": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_bytes(ares_buf_t *buf, unsigned char *bytes,\n                                   size_t len)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || bytes == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  memcpy(bytes, ptr, len);\n  return ares_buf_consume(buf, len);\n}",
          "fn_code_pos": [
            [
              555,
              0
            ],
            [
              567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_fetch_bytes",
            "parameters": {
              "buf": "ares_buf_t",
              "bytes": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_bytes_dup(ares_buf_t *buf, size_t len,\n                                       ares_bool_t     null_term,\n                                       unsigned char **bytes)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || bytes == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  *bytes = ares_malloc(null_term ? len + 1 : len);\n  if (*bytes == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  memcpy(*bytes, ptr, len);\n  if (null_term) {\n    (*bytes)[len] = 0;\n  }\n  return ares_buf_consume(buf, len);\n}",
          "fn_code_pos": [
            [
              569,
              0
            ],
            [
              590,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_fetch_bytes_dup",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t",
              "null_term": "ares_bool_t",
              "bytes": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_str_dup(ares_buf_t *buf, size_t len, char **str)\n{\n  size_t               remaining_len;\n  size_t               i;\n  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || str == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  /* Validate string is printable */\n  for (i = 0; i < len; i++) {\n    if (!ares_isprint(ptr[i])) {\n      return ARES_EBADSTR;\n    }\n  }\n\n  *str = ares_malloc(len + 1);\n  if (*str == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  memcpy(*str, ptr, len);\n  (*str)[len] = 0;\n\n  return ares_buf_consume(buf, len);\n}",
          "fn_code_pos": [
            [
              592,
              0
            ],
            [
              618,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_fetch_str_dup",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_bytes_into_buf(ares_buf_t *buf, ares_buf_t *dest,\n                                            size_t len)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);\n  ares_status_t        status;\n\n  if (buf == NULL || dest == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  status = ares_buf_append(dest, ptr, len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_buf_consume(buf, len);\n}",
          "fn_code_pos": [
            [
              620,
              0
            ],
            [
              637,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_fetch_bytes_into_buf",
            "parameters": {
              "buf": "ares_buf_t",
              "dest": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_is_whitespace(unsigned char c,\n                                      ares_bool_t   include_linefeed)\n{\n  switch (c) {\n    case '\\r':\n    case '\\t':\n    case ' ':\n    case '\\v':\n    case '\\f':\n      return ARES_TRUE;\n    case '\\n':\n      return include_linefeed;\n    default:\n      break;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              639,
              0
            ],
            [
              655,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_is_whitespace",
            "parameters": {
              "c": "unsigned char",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_buf_consume_whitespace(ares_buf_t *buf,\n                                   ares_bool_t include_linefeed)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);\n  size_t               i;\n\n  if (ptr == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    if (!ares_is_whitespace(ptr[i], include_linefeed)) {\n      break;\n    }\n  }\n\n  if (i > 0) {\n    ares_buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              657,
              0
            ],
            [
              678,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_whitespace",
            "parameters": {
              "buf": "ares_buf_t",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_buf_consume_nonwhitespace(ares_buf_t *buf)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);\n  size_t               i;\n\n  if (ptr == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    if (ares_is_whitespace(ptr[i], ARES_TRUE)) {\n      break;\n    }\n  }\n\n  if (i > 0) {\n    ares_buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              680,
              0
            ],
            [
              700,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_nonwhitespace",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_buf_consume_line(ares_buf_t *buf, ares_bool_t include_linefeed)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);\n  size_t               i;\n\n  if (ptr == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    if (ptr[i] == '\\n') {\n      goto done;\n    }\n  }\n\ndone:\n  if (include_linefeed && i < remaining_len && ptr[i] == '\\n') {\n    i++;\n  }\n\n  if (i > 0) {\n    ares_buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              702,
              0
            ],
            [
              727,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_line",
            "parameters": {
              "buf": "ares_buf_t",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_buf_consume_until_charset(ares_buf_t          *buf,\n                                      const unsigned char *charset, size_t len,\n                                      ares_bool_t require_charset)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);\n  size_t               pos;\n  ares_bool_t          found = ARES_FALSE;\n\n  if (ptr == NULL || charset == NULL || len == 0) {\n    return 0;\n  }\n\n  /* Optimize for single character searches */\n  if (len == 1) {\n    const unsigned char *p = memchr(ptr, charset[0], remaining_len);\n    if (p != NULL) {\n      found = ARES_TRUE;\n      pos   = (size_t)(p - ptr);\n    } else {\n      pos = remaining_len;\n    }\n    goto done;\n  }\n\n  for (pos = 0; pos < remaining_len; pos++) {\n    size_t j;\n    for (j = 0; j < len; j++) {\n      if (ptr[pos] == charset[j]) {\n        found = ARES_TRUE;\n        goto done;\n      }\n    }\n  }\n\ndone:\n  if (require_charset && !found) {\n    return SIZE_MAX;\n  }\n\n  if (pos > 0) {\n    ares_buf_consume(buf, pos);\n  }\n  return pos;\n}",
          "fn_code_pos": [
            [
              729,
              0
            ],
            [
              773,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_until_charset",
            "parameters": {
              "buf": "ares_buf_t",
              "charset": "unsigned char",
              "len": "size_t",
              "require_charset": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_buf_consume_until_seq(ares_buf_t *buf, const unsigned char *seq,\n                                  size_t len, ares_bool_t require_seq)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);\n  const unsigned char *p;\n  size_t               consume_len = 0;\n\n  if (ptr == NULL || seq == NULL || len == 0) {\n    return 0;\n  }\n\n  p = ares_memmem(ptr, remaining_len, seq, len);\n  if (require_seq && p == NULL) {\n    return SIZE_MAX;\n  }\n\n  if (p != NULL) {\n    consume_len = (size_t)(p - ptr);\n  } else {\n    consume_len = remaining_len;\n  }\n\n  if (consume_len > 0) {\n    ares_buf_consume(buf, consume_len);\n  }\n\n  return consume_len;\n}",
          "fn_code_pos": [
            [
              775,
              0
            ],
            [
              803,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_until_seq",
            "parameters": {
              "buf": "ares_buf_t",
              "seq": "unsigned char",
              "len": "size_t",
              "require_seq": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares_buf_consume_charset(ares_buf_t *buf, const unsigned char *charset,\n                                size_t len)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);\n  size_t               i;\n\n  if (ptr == NULL || charset == NULL || len == 0) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    size_t j;\n    for (j = 0; j < len; j++) {\n      if (ptr[i] == charset[j]) {\n        break;\n      }\n    }\n    /* Not found */\n    if (j == len) {\n      break;\n    }\n  }\n\n  if (i > 0) {\n    ares_buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              805,
              0
            ],
            [
              833,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_charset",
            "parameters": {
              "buf": "ares_buf_t",
              "charset": "unsigned char",
              "len": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static void ares_buf_destroy_cb(void *arg)\n{\n  ares_buf_t **buf = arg;\n  ares_buf_destroy(*buf);\n}",
          "fn_code_pos": [
            [
              835,
              0
            ],
            [
              839,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_destroy_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_buf_split_isduplicate(ares_array_t        *arr,\n                                              const unsigned char *val,\n                                              size_t               len,\n                                              ares_buf_split_t     flags)\n{\n  size_t i;\n  size_t num = ares_array_len(arr);\n\n  for (i = 0; i < num; i++) {\n    ares_buf_t         **bufptr = ares_array_at(arr, i);\n    const ares_buf_t    *buf    = *bufptr;\n    size_t               plen   = 0;\n    const unsigned char *ptr    = ares_buf_peek(buf, &plen);\n\n    /* Can't be duplicate if lengths mismatch */\n    if (plen != len) {\n      continue;\n    }\n\n    if (flags & ARES_BUF_SPLIT_CASE_INSENSITIVE) {\n      if (ares_memeq_ci(ptr, val, len)) {\n        return ARES_TRUE;\n      }\n    } else {\n      if (ares_memeq(ptr, val, len)) {\n        return ARES_TRUE;\n      }\n    }\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              841,
              0
            ],
            [
              872,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_split_isduplicate",
            "parameters": {
              "arr": "ares_array_t",
              "val": "unsigned char",
              "len": "size_t",
              "flags": "ares_buf_split_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_split(ares_buf_t *buf, const unsigned char *delims,\n                             size_t delims_len, ares_buf_split_t flags,\n                             size_t max_sections, ares_array_t **arr)\n{\n  ares_status_t status = ARES_SUCCESS;\n  ares_bool_t   first  = ARES_TRUE;\n\n  if (buf == NULL || delims == NULL || delims_len == 0 || arr == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  *arr = ares_array_create(sizeof(ares_buf_t *), ares_buf_destroy_cb);\n  if (*arr == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  while (ares_buf_len(buf)) {\n    size_t               len = 0;\n    const unsigned char *ptr;\n\n    if (first) {\n      /* No delimiter yet, just tag the start */\n      ares_buf_tag(buf);\n    } else {\n      if (flags & ARES_BUF_SPLIT_KEEP_DELIMS) {\n        /* tag then eat delimiter so its first byte in buffer */\n        ares_buf_tag(buf);\n        ares_buf_consume(buf, 1);\n      } else {\n        /* throw away delimiter */\n        ares_buf_consume(buf, 1);\n        ares_buf_tag(buf);\n      }\n    }\n\n    if (max_sections && ares_array_len(*arr) >= max_sections - 1) {\n      ares_buf_consume(buf, ares_buf_len(buf));\n    } else {\n      ares_buf_consume_until_charset(buf, delims, delims_len, ARES_FALSE);\n    }\n\n    ptr = ares_buf_tag_fetch(buf, &len);\n\n    /* Shouldn't be possible */\n    if (ptr == NULL) {\n      status = ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;\n    }\n\n    if (flags & ARES_BUF_SPLIT_LTRIM) {\n      size_t i;\n      for (i = 0; i < len; i++) {\n        if (!ares_is_whitespace(ptr[i], ARES_TRUE)) {\n          break;\n        }\n      }\n      ptr += i;\n      len -= i;\n    }\n\n    if (flags & ARES_BUF_SPLIT_RTRIM) {\n      while (len > 0 && ares_is_whitespace(ptr[len - 1], ARES_TRUE)) {\n        len--;\n      }\n    }\n\n    if (len != 0 || flags & ARES_BUF_SPLIT_ALLOW_BLANK) {\n      ares_buf_t *data;\n\n      if (!(flags & ARES_BUF_SPLIT_NO_DUPLICATES) ||\n          !ares_buf_split_isduplicate(*arr, ptr, len, flags)) {\n        /* Since we don't allow const buffers of 0 length, and user wants\n         * 0-length buffers, swap what we do here */\n        if (len) {\n          data = ares_buf_create_const(ptr, len);\n        } else {\n          data = ares_buf_create();\n        }\n\n        if (data == NULL) {\n          status = ARES_ENOMEM;\n          goto done;\n        }\n\n        status = ares_array_insertdata_last(*arr, &data);\n        if (status != ARES_SUCCESS) {\n          ares_buf_destroy(data);\n          goto done;\n        }\n      }\n    }\n\n    first = ARES_FALSE;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_array_destroy(*arr);\n    *arr = NULL;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              874,
              0
            ],
            [
              977,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_split",
            "parameters": {
              "buf": "ares_buf_t",
              "delims": "unsigned char",
              "delims_len": "size_t",
              "flags": "ares_buf_split_t",
              "max_sections": "size_t",
              "arr": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void ares_free_split_array(void *arg)\n{\n  void **ptr = arg;\n  ares_free(*ptr);\n}",
          "fn_code_pos": [
            [
              979,
              0
            ],
            [
              983,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_split_array",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_split_str_array(ares_buf_t          *buf,\n                                       const unsigned char *delims,\n                                       size_t               delims_len,\n                                       ares_buf_split_t     flags,\n                                       size_t max_sections, ares_array_t **arr)\n{\n  ares_status_t status;\n  ares_array_t *split = NULL;\n  size_t        i;\n  size_t        len;\n\n  if (arr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *arr = NULL;\n\n  status = ares_buf_split(buf, delims, delims_len, flags, max_sections, &split);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  *arr = ares_array_create(sizeof(char *), ares_free_split_array);\n  if (*arr == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  len = ares_array_len(split);\n  for (i = 0; i < len; i++) {\n    ares_buf_t **bufptr = ares_array_at(split, i);\n    ares_buf_t  *lbuf   = *bufptr;\n    char        *str    = NULL;\n\n    status = ares_buf_fetch_str_dup(lbuf, ares_buf_len(lbuf), &str);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_array_insertdata_last(*arr, &str);\n    if (status != ARES_SUCCESS) {\n      ares_free(str);\n      goto done;\n    }\n  }\n\ndone:\n  ares_array_destroy(split);\n  if (status != ARES_SUCCESS) {\n    ares_array_destroy(*arr);\n    *arr = NULL;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              985,
              0
            ],
            [
              1038,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_split_str_array",
            "parameters": {
              "buf": "ares_buf_t",
              "delims": "unsigned char",
              "delims_len": "size_t",
              "flags": "ares_buf_split_t",
              "max_sections": "size_t",
              "arr": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_split_str(ares_buf_t *buf, const unsigned char *delims,\n                                 size_t delims_len, ares_buf_split_t flags,\n                                 size_t max_sections, char ***strs,\n                                 size_t *nstrs)\n{\n  ares_status_t status;\n  ares_array_t *arr = NULL;\n\n  if (strs == NULL || nstrs == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *strs  = NULL;\n  *nstrs = 0;\n\n  status = ares_buf_split_str_array(buf, delims, delims_len, flags,\n                                    max_sections, &arr);\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  if (status == ARES_SUCCESS) {\n    *strs = ares_array_finish(arr, nstrs);\n  } else {\n    ares_array_destroy(arr);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              1040,
              0
            ],
            [
              1069,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_split_str",
            "parameters": {
              "buf": "ares_buf_t",
              "delims": "unsigned char",
              "delims_len": "size_t",
              "flags": "ares_buf_split_t",
              "max_sections": "size_t",
              "strs": "char",
              "nstrs": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_buf_begins_with(const ares_buf_t    *buf,\n                                 const unsigned char *data, size_t data_len)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);\n\n  if (ptr == NULL || data == NULL || data_len == 0) {\n    return ARES_FALSE;\n  }\n\n  if (data_len > remaining_len) {\n    return ARES_FALSE;\n  }\n\n  if (memcmp(ptr, data, data_len) != 0) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              1071,
              0
            ],
            [
              1090,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_begins_with",
            "parameters": {
              "buf": "ares_buf_t",
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares_buf_len(const ares_buf_t *buf)\n{\n  if (buf == NULL) {\n    return 0;\n  }\n\n  return buf->data_len - buf->offset;\n}",
          "fn_code_pos": [
            [
              1092,
              0
            ],
            [
              1099,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_len",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "const unsigned char *ares_buf_peek(const ares_buf_t *buf, size_t *len)\n{\n  return ares_buf_fetch(buf, len);\n}",
          "fn_code_pos": [
            [
              1101,
              0
            ],
            [
              1104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_peek",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_replace(ares_buf_t *buf, const unsigned char *srch,\n                               size_t srch_size, const unsigned char *rplc,\n                               size_t rplc_size)\n{\n  size_t        processed_len = 0;\n  ares_status_t status;\n\n  if (buf->alloc_buf == NULL || srch == NULL || srch_size == 0 ||\n      (rplc == NULL && rplc_size != 0)) {\n    return ARES_EFORMERR;\n  }\n\n  while (1) {\n    unsigned char *ptr           = buf->alloc_buf + buf->offset + processed_len;\n    size_t         remaining_len = buf->data_len - buf->offset - processed_len;\n    size_t         found_offset  = 0;\n    size_t         move_data_len;\n\n    /* Find pattern */\n    ptr = ares_memmem(ptr, remaining_len, srch, srch_size);\n    if (ptr == NULL) {\n      break;\n    }\n\n    /* Store the offset this was found because our actual pointer might be\n     * switched out from under us by the call to ensure_space() if the\n     * replacement pattern is larger than the search pattern */\n    found_offset   = (size_t)(ptr - (size_t)(buf->alloc_buf + buf->offset));\n    if (rplc_size > srch_size) {\n      status = ares_buf_ensure_space(buf, rplc_size - srch_size);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n\n    /* Impossible, but silence clang */\n    if (buf->alloc_buf == NULL) {\n      return ARES_ENOMEM;\n    }\n\n    /* Recalculate actual pointer */\n    ptr = buf->alloc_buf + buf->offset + found_offset;\n\n    /* Move the data */\n    move_data_len = buf->data_len - buf->offset - found_offset - srch_size;\n    memmove(ptr + rplc_size,\n            ptr + srch_size,\n            move_data_len);\n\n    /* Copy in the replacement data */\n    if (rplc != NULL && rplc_size > 0) {\n      memcpy(ptr, rplc, rplc_size);\n    }\n\n    if (rplc_size > srch_size) {\n      buf->data_len += rplc_size - srch_size;\n    } else {\n      buf->data_len -= srch_size - rplc_size;\n    }\n\n    processed_len = found_offset + rplc_size;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1106,
              0
            ],
            [
              1170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_replace",
            "parameters": {
              "buf": "ares_buf_t",
              "srch": "unsigned char",
              "srch_size": "size_t",
              "rplc": "unsigned char",
              "rplc_size": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_peek_byte(const ares_buf_t *buf, unsigned char *b)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || b == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (remaining_len == 0) {\n    return ARES_EBADRESP;\n  }\n  *b = ptr[0];\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1172,
              0
            ],
            [
              1186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_peek_byte",
            "parameters": {
              "buf": "ares_buf_t",
              "b": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "size_t ares_buf_get_position(const ares_buf_t *buf)\n{\n  if (buf == NULL) {\n    return 0;\n  }\n  return buf->offset;\n}",
          "fn_code_pos": [
            [
              1188,
              0
            ],
            [
              1194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_get_position",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_set_position(ares_buf_t *buf, size_t idx)\n{\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (idx > buf->data_len) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  buf->offset = idx;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1196,
              0
            ],
            [
              1208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_set_position",
            "parameters": {
              "buf": "ares_buf_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_buf_parse_dns_binstr_int(ares_buf_t *buf, size_t remaining_len,\n                                unsigned char **bin, size_t *bin_len,\n                                ares_bool_t validate_printable)\n{\n  unsigned char len;\n  ares_status_t status = ARES_EBADRESP;\n  ares_buf_t   *binbuf = NULL;\n\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (remaining_len == 0) {\n    return ARES_EBADRESP;\n  }\n\n  binbuf = ares_buf_create();\n  if (binbuf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_buf_fetch_bytes(buf, &len, 1);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  remaining_len--;\n\n  if (len > remaining_len) {\n    status = ARES_EBADRESP;\n    goto done;\n  }\n\n  if (len) {\n    /* When used by the _str() parser, it really needs to be validated to\n     * be a valid printable ascii string.  Do that here */\n    if (validate_printable && ares_buf_len(buf) >= len) {\n      size_t      mylen;\n      const char *data = (const char *)ares_buf_peek(buf, &mylen);\n      if (!ares_str_isprint(data, len)) {\n        status = ARES_EBADSTR;\n        goto done;\n      }\n    }\n\n    if (bin != NULL) {\n      status = ares_buf_fetch_bytes_into_buf(buf, binbuf, len);\n    } else {\n      status = ares_buf_consume(buf, len);\n    }\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_buf_destroy(binbuf);\n  } else {\n    if (bin != NULL) {\n      size_t mylen = 0;\n      /* NOTE: we use ares_buf_finish_str() here as we guarantee NULL\n       *       Termination even though we are technically returning binary data.\n       */\n      *bin     = (unsigned char *)ares_buf_finish_str(binbuf, &mylen);\n      *bin_len = mylen;\n    }\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1210,
              0
            ],
            [
              1278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_parse_dns_binstr_int",
            "parameters": {
              "buf": "ares_buf_t",
              "remaining_len": "size_t",
              "bin": "unsigned char",
              "bin_len": "size_t",
              "validate_printable": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_parse_dns_binstr(ares_buf_t *buf, size_t remaining_len,\n                                        unsigned char **bin, size_t *bin_len)\n{\n  return ares_buf_parse_dns_binstr_int(buf, remaining_len, bin, bin_len,\n                                       ARES_FALSE);\n}",
          "fn_code_pos": [
            [
              1280,
              0
            ],
            [
              1285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_parse_dns_binstr",
            "parameters": {
              "buf": "ares_buf_t",
              "remaining_len": "size_t",
              "bin": "unsigned char",
              "bin_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_parse_dns_str(ares_buf_t *buf, size_t remaining_len,\n                                     char **str)\n{\n  size_t len;\n\n  return ares_buf_parse_dns_binstr_int(buf, remaining_len,\n                                       (unsigned char **)str, &len, ARES_TRUE);\n}",
          "fn_code_pos": [
            [
              1287,
              0
            ],
            [
              1294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_parse_dns_str",
            "parameters": {
              "buf": "ares_buf_t",
              "remaining_len": "size_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_append_num_dec(ares_buf_t *buf, size_t num, size_t len)\n{\n  size_t i;\n  size_t mod;\n\n  if (len == 0) {\n    len = ares_count_digits(num);\n  }\n\n  mod = ares_pow(10, len);\n\n  for (i = len; i > 0; i--) {\n    size_t        digit = (num % mod);\n    ares_status_t status;\n\n    mod /= 10;\n\n    /* Silence coverity.  Shouldn't be possible since we calculate it above */\n    if (mod == 0) {\n      return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    digit  /= mod;\n    status  = ares_buf_append_byte(buf, '0' + (unsigned char)(digit & 0xFF));\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1296,
              0
            ],
            [
              1325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_num_dec",
            "parameters": {
              "buf": "ares_buf_t",
              "num": "size_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_append_num_hex(ares_buf_t *buf, size_t num, size_t len)\n{\n  size_t                     i;\n  static const unsigned char hexbytes[] = \"0123456789ABCDEF\";\n\n  if (len == 0) {\n    len = ares_count_hexdigits(num);\n  }\n\n  for (i = len; i > 0; i--) {\n    ares_status_t status;\n    status = ares_buf_append_byte(buf, hexbytes[(num >> ((i - 1) * 4)) & 0xF]);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1327,
              0
            ],
            [
              1344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_num_hex",
            "parameters": {
              "buf": "ares_buf_t",
              "num": "size_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_append_str(ares_buf_t *buf, const char *str)\n{\n  return ares_buf_append(buf, (const unsigned char *)str, ares_strlen(str));\n}",
          "fn_code_pos": [
            [
              1346,
              0
            ],
            [
              1349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_str",
            "parameters": {
              "buf": "ares_buf_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_buf_hexdump_line(ares_buf_t *buf, size_t idx,\n                                           const unsigned char *data,\n                                           size_t               len)\n{\n  size_t        i;\n  ares_status_t status;\n\n  /* Address */\n  status = ares_buf_append_num_hex(buf, idx, 6);\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* | */\n  status = ares_buf_append_str(buf, \" | \");\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (i = 0; i < 16; i++) {\n    if (i >= len) {\n      status = ares_buf_append_str(buf, \"  \");\n    } else {\n      status = ares_buf_append_num_hex(buf, data[i], 2);\n    }\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    status = ares_buf_append_byte(buf, ' ');\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  /* | */\n  status = ares_buf_append_str(buf, \" | \");\n  if (status != ARES_SUCCESS) {\n    return status; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  for (i = 0; i < 16; i++) {\n    if (i >= len) {\n      break;\n    }\n    status = ares_buf_append_byte(buf, ares_isprint(data[i]) ? data[i] : '.');\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return ares_buf_append_byte(buf, '\\n');\n}",
          "fn_code_pos": [
            [
              1351,
              0
            ],
            [
              1403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_hexdump_line",
            "parameters": {
              "buf": "ares_buf_t",
              "idx": "size_t",
              "data": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_hexdump(ares_buf_t *buf, const unsigned char *data,\n                               size_t len)\n{\n  size_t i;\n\n  /* Each line is 16 bytes */\n  for (i = 0; i < len; i += 16) {\n    ares_status_t status;\n    status = ares_buf_hexdump_line(buf, i, data + i, len - i);\n    if (status != ARES_SUCCESS) {\n      return status; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1405,
              0
            ],
            [
              1420,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_hexdump",
            "parameters": {
              "buf": "ares_buf_t",
              "data": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_load_file(const char *filename, ares_buf_t *buf)\n{\n  FILE          *fp        = NULL;\n  unsigned char *ptr       = NULL;\n  size_t         len       = 0;\n  size_t         ptr_len   = 0;\n  long           ftell_len = 0;\n  ares_status_t  status;\n\n  if (filename == NULL || buf == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  fp = fopen(filename, \"rb\");\n  if (fp == NULL) {\n    int error = errno;\n    switch (error) {\n      case ENOENT:\n      case ESRCH:\n        status = ARES_ENOTFOUND;\n        goto done;\n      default:\n        DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\", error,\n                       strerror(error)));\n        DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", filename));\n        status = ARES_EFILE;\n        goto done;\n    }\n  }\n\n  if (setvbuf(fp, NULL, _IONBF, 0) != 0) {\n    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */\n    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Get length portably, fstat() is POSIX, not C */\n  if (fseek(fp, 0, SEEK_END) != 0) {\n    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */\n    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ftell_len = ftell(fp);\n  if (ftell_len < 0) {\n    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */\n    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  len = (size_t)ftell_len;\n\n  if (fseek(fp, 0, SEEK_SET) != 0) {\n    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */\n    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (len == 0) {\n    status = ARES_SUCCESS; /* LCOV_EXCL_LINE: DefensiveCoding */\n    goto done;             /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Read entire data into buffer */\n  ptr_len = len;\n  ptr     = ares_buf_append_start(buf, &ptr_len);\n  if (ptr == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  ptr_len = fread(ptr, 1, len, fp);\n  if (ptr_len != len) {\n    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */\n    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_buf_append_finish(buf, len);\n  status = ARES_SUCCESS;\n\ndone:\n  if (fp != NULL) {\n    fclose(fp);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              1422,
              0
            ],
            [
              1502,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_load_file",
            "parameters": {
              "filename": "char",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_buf_create(void)",
          "fn_dec_pos": [
            [
              45,
              12
            ],
            [
              45,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_create_const(const unsigned char *data, size_t data_len)",
          "fn_dec_pos": [
            [
              56,
              12
            ],
            [
              56,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_create_const",
            "parameters": {
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_append_start(ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              281,
              15
            ],
            [
              281,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_start",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_finish_bin(ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              308,
              15
            ],
            [
              308,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_finish_bin",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_finish_str(ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              327,
              6
            ],
            [
              327,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_finish_str",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_tag_fetch(const ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              378,
              21
            ],
            [
              378,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_fetch",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_fetch(const ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              492,
              28
            ],
            [
              492,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_fetch",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_peek(const ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              1101,
              21
            ],
            [
              1101,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_peek",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_buf {\n  const unsigned char *data;          /*!< pointer to start of data buffer */\n  size_t               data_len;      /*!< total size of data in buffer */\n\n  unsigned char       *alloc_buf;     /*!< Pointer to allocated data buffer,\n                                       *   not used for const buffers */\n  size_t               alloc_buf_len; /*!< Size of allocated data buffer */\n\n  size_t               offset;        /*!< Current working offset in buffer */\n  size_t               tag_offset;    /*!< Tagged offset in buffer. Uses\n                                       *   SIZE_MAX if not set. */\n}",
          {
            "unsigned char": "const",
            "data_len": "size_t",
            "*alloc_buf": "unsigned char",
            "alloc_buf_len": "size_t",
            "offset": "size_t",
            "tag_offset": "size_t"
          },
          "ares_buf",
          [
            32,
            0
          ],
          [
            43,
            1
          ]
        ],
        [
          "struct ares_buf {\n  const unsigned char *data;          /*!< pointer to start of data buffer */\n  size_t               data_len;      /*!< total size of data in buffer */\n\n  unsigned char       *alloc_buf;     /*!< Pointer to allocated data buffer,\n                                       *   not used for const buffers */\n  size_t               alloc_buf_len; /*!< Size of allocated data buffer */\n\n  size_t               offset;        /*!< Current working offset in buffer */\n  size_t               tag_offset;    /*!< Tagged offset in buffer. Uses\n                                       *   SIZE_MAX if not set. */\n}",
          {
            "unsigned char": "const",
            "data_len": "size_t",
            "*alloc_buf": "unsigned char",
            "alloc_buf_len": "size_t",
            "offset": "size_t",
            "tag_offset": "size_t"
          },
          "ares_buf",
          [
            32,
            0
          ],
          [
            43,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_buf.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_expand_string.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_expand_string_ex(const unsigned char *encoded,\n                                    const unsigned char *abuf, size_t alen,\n                                    unsigned char **s, size_t *enclen)\n{\n  ares_status_t status;\n  ares_buf_t   *buf = NULL;\n  size_t        start_len;\n  size_t        len = 0;\n\n  if (encoded == NULL || abuf == NULL || alen == 0 || enclen == NULL) {\n    return ARES_EBADSTR; /* EFORMERR would be better */\n  }\n\n  if (encoded < abuf || encoded >= abuf + alen) {\n    return ARES_EBADSTR; /* EFORMERR would be better */\n  }\n\n  *enclen = 0;\n\n  /* NOTE: we allow 's' to be NULL to skip it */\n  if (s) {\n    *s = NULL;\n  }\n\n  buf = ares_buf_create_const(abuf, alen);\n\n  if (buf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_buf_set_position(buf, (size_t)(encoded - abuf));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  start_len = ares_buf_len(buf);\n  status    = ares_buf_parse_dns_binstr(buf, ares_buf_len(buf), s, &len);\n  /* hrm, no way to pass back 'len' with the prototype */\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  *enclen = start_len - ares_buf_len(buf);\n\ndone:\n  ares_buf_destroy(buf);\n  if (status == ARES_EBADNAME || status == ARES_EBADRESP) {\n    status = ARES_EBADSTR;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_string_ex",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "unsigned char",
              "enclen": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_expand_string(const unsigned char *encoded, const unsigned char *abuf,\n                       int alen, unsigned char **s, long *enclen)\n{\n  ares_status_t status;\n  size_t        temp_enclen = 0;\n\n  if (encoded == NULL || abuf == NULL || alen <= 0 || enclen == NULL) {\n    return ARES_EBADRESP;\n  }\n\n  status = ares_expand_string_ex(encoded, abuf, (size_t)alen, s, &temp_enclen);\n\n  *enclen = (long)temp_enclen;\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_string",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "int",
              "s": "unsigned char",
              "enclen": "long"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_naptr_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_naptr_reply(const unsigned char *abuf, int alen_int,\n                           struct ares_naptr_reply **naptr_out)\n{\n  ares_status_t            status;\n  size_t                   alen;\n  struct ares_naptr_reply *naptr_head = NULL;\n  struct ares_naptr_reply *naptr_last = NULL;\n  struct ares_naptr_reply *naptr_curr;\n  ares_dns_record_t       *dnsrec = NULL;\n  size_t                   i;\n\n  *naptr_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_NAPTR) {\n      continue;\n    }\n\n    /* Allocate storage for this NAPTR answer appending it to the list */\n    naptr_curr = ares_malloc_data(ARES_DATATYPE_NAPTR_REPLY);\n    if (naptr_curr == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Link in the record */\n    if (naptr_last) {\n      naptr_last->next = naptr_curr;\n    } else {\n      naptr_head = naptr_curr;\n    }\n    naptr_last = naptr_curr;\n\n    naptr_curr->order      = ares_dns_rr_get_u16(rr, ARES_RR_NAPTR_ORDER);\n    naptr_curr->preference = ares_dns_rr_get_u16(rr, ARES_RR_NAPTR_PREFERENCE);\n\n    /* XXX: Why is this unsigned char * ? */\n    naptr_curr->flags = (unsigned char *)ares_strdup(\n      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_FLAGS));\n    if (naptr_curr->flags == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    /* XXX: Why is this unsigned char * ? */\n    naptr_curr->service = (unsigned char *)ares_strdup(\n      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_SERVICES));\n    if (naptr_curr->service == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    /* XXX: Why is this unsigned char * ? */\n    naptr_curr->regexp = (unsigned char *)ares_strdup(\n      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_REGEXP));\n    if (naptr_curr->regexp == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    naptr_curr->replacement =\n      ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_NAPTR_REPLACEMENT));\n    if (naptr_curr->replacement == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (naptr_head) {\n      ares_free_data(naptr_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *naptr_out = naptr_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_naptr_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "naptr_out": "struct ares_naptr_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            29,
            27
          ],
          [
            29,
            50
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            33,
            2
          ],
          [
            33,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            34,
            2
          ],
          [
            34,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_soa_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_soa_reply(const unsigned char *abuf, int alen_int,\n                         struct ares_soa_reply **soa_out)\n{\n  ares_status_t          status;\n  size_t                 alen;\n  struct ares_soa_reply *soa    = NULL;\n  ares_dns_record_t     *dnsrec = NULL;\n  size_t                 i;\n\n  *soa_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_EBADRESP; /* ENODATA might make more sense */\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_SOA) {\n      continue;\n    }\n\n    /* allocate result struct */\n    soa = ares_malloc_data(ARES_DATATYPE_SOA_REPLY);\n    if (soa == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    soa->serial  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_SERIAL);\n    soa->refresh = ares_dns_rr_get_u32(rr, ARES_RR_SOA_REFRESH);\n    soa->retry   = ares_dns_rr_get_u32(rr, ARES_RR_SOA_RETRY);\n    soa->expire  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_EXPIRE);\n    soa->minttl  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_MINIMUM);\n    soa->nsname  = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SOA_MNAME));\n    if (soa->nsname == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    soa->hostmaster = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SOA_RNAME));\n    if (soa->hostmaster == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    break;\n  }\n\n  if (soa == NULL) {\n    status = ARES_EBADRESP;\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    ares_free_data(soa);\n    /* Compatibility */\n    if (status == ARES_EBADNAME) {\n      status = ARES_EBADRESP;\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *soa_out = soa;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_soa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "soa_out": "struct ares_soa_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            30,
            25
          ],
          [
            30,
            46
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            34,
            2
          ],
          [
            34,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_expand_name.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_expand_name_validated(const unsigned char *encoded,\n                                         const unsigned char *abuf, size_t alen,\n                                         char **s, size_t *enclen,\n                                         ares_bool_t is_hostname)\n{\n  ares_status_t status;\n  ares_buf_t   *buf = NULL;\n  size_t        start_len;\n\n  if (encoded == NULL || abuf == NULL || alen == 0 || enclen == NULL) {\n    return ARES_EBADNAME; /* EFORMERR would be better */\n  }\n\n  if (encoded < abuf || encoded >= abuf + alen) {\n    return ARES_EBADNAME; /* EFORMERR would be better */\n  }\n\n  *enclen = 0;\n\n  /* NOTE: we allow 's' to be NULL to skip it */\n  if (s) {\n    *s = NULL;\n  }\n\n  buf = ares_buf_create_const(abuf, alen);\n\n  if (buf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_buf_set_position(buf, (size_t)(encoded - abuf));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  start_len = ares_buf_len(buf);\n  status    = ares_dns_name_parse(buf, s, is_hostname);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  *enclen = start_len - ares_buf_len(buf);\n\ndone:\n  ares_buf_destroy(buf);\n  return status;\n}",
          "fn_code_pos": [
            [
              35,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_name_validated",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "char",
              "enclen": "size_t",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_expand_name(const unsigned char *encoded, const unsigned char *abuf,\n                     int alen, char **s, long *enclen)\n{\n  /* Keep public API compatible */\n  size_t        enclen_temp = 0;\n  ares_status_t status;\n\n  if (encoded == NULL || abuf == NULL || alen <= 0 || enclen == NULL) {\n    return ARES_EBADNAME;\n  }\n\n  status  = ares_expand_name_validated(encoded, abuf, (size_t)alen, s,\n                                       &enclen_temp, ARES_FALSE);\n  *enclen = (long)enclen_temp;\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_name",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "int",
              "s": "char",
              "enclen": "long"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_srv_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_srv_reply(const unsigned char *abuf, int alen_int,\n                         struct ares_srv_reply **srv_out)\n{\n  ares_status_t          status;\n  size_t                 alen;\n  struct ares_srv_reply *srv_head = NULL;\n  struct ares_srv_reply *srv_last = NULL;\n  struct ares_srv_reply *srv_curr;\n  ares_dns_record_t     *dnsrec = NULL;\n  size_t                 i;\n\n  *srv_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_SRV) {\n      continue;\n    }\n\n    /* Allocate storage for this SRV answer appending it to the list */\n    srv_curr = ares_malloc_data(ARES_DATATYPE_SRV_REPLY);\n    if (srv_curr == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Link in the record */\n    if (srv_last) {\n      srv_last->next = srv_curr;\n    } else {\n      srv_head = srv_curr;\n    }\n    srv_last = srv_curr;\n\n\n    srv_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_SRV_PRIORITY);\n    srv_curr->weight   = ares_dns_rr_get_u16(rr, ARES_RR_SRV_WEIGHT);\n    srv_curr->port     = ares_dns_rr_get_u16(rr, ARES_RR_SRV_PORT);\n\n    srv_curr->host = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SRV_TARGET));\n\n    if (srv_curr->host == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (srv_head) {\n      ares_free_data(srv_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *srv_out = srv_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_srv_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "srv_out": "struct ares_srv_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            30,
            25
          ],
          [
            30,
            46
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            34,
            2
          ],
          [
            34,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_caa_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_caa_reply(const unsigned char *abuf, int alen_int,\n                         struct ares_caa_reply **caa_out)\n{\n  ares_status_t          status;\n  size_t                 alen;\n  struct ares_caa_reply *caa_head = NULL;\n  struct ares_caa_reply *caa_last = NULL;\n  struct ares_caa_reply *caa_curr;\n  ares_dns_record_t     *dnsrec = NULL;\n  size_t                 i;\n\n  *caa_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const unsigned char *ptr;\n    size_t               ptr_len;\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    /* XXX: Why do we allow Chaos class? */\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN &&\n        ares_dns_rr_get_class(rr) != ARES_CLASS_CHAOS) {\n      continue;\n    }\n\n    /* Only looking for CAA records */\n    if (ares_dns_rr_get_type(rr) != ARES_REC_TYPE_CAA) {\n      continue;\n    }\n\n    /* Allocate storage for this CAA answer appending it to the list */\n    caa_curr = ares_malloc_data(ARES_DATATYPE_CAA_REPLY);\n    if (caa_curr == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Link in the record */\n    if (caa_last) {\n      caa_last->next = caa_curr;\n    } else {\n      caa_head = caa_curr;\n    }\n    caa_last = caa_curr;\n\n    caa_curr->critical = ares_dns_rr_get_u8(rr, ARES_RR_CAA_CRITICAL);\n    caa_curr->property =\n      (unsigned char *)ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_CAA_TAG));\n    if (caa_curr->property == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      break;                /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    /* RFC6844 says this can only be ascii, so not sure why we're recording a\n     * length */\n    caa_curr->plength = ares_strlen((const char *)caa_curr->property);\n\n    ptr = ares_dns_rr_get_bin(rr, ARES_RR_CAA_VALUE, &ptr_len);\n    if (ptr == NULL) {\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    /* Wants NULL termination for some reason */\n    caa_curr->value = ares_malloc(ptr_len + 1);\n    if (caa_curr->value == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    memcpy(caa_curr->value, ptr, ptr_len);\n    caa_curr->value[ptr_len] = 0;\n    caa_curr->length         = ptr_len;\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (caa_head) {\n      ares_free_data(caa_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *caa_out = caa_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_caa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "caa_out": "struct ares_caa_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            30,
            25
          ],
          [
            30,
            46
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            34,
            2
          ],
          [
            34,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_create_query.c": {
      "fn_def_list": [
        {
          "fn_code": "static int ares_create_query_int(const char *name, int dnsclass, int type,\n                                 unsigned short id, int rd,\n                                 unsigned char **bufp, int *buflenp,\n                                 int max_udp_size)\n{\n  ares_status_t      status;\n  ares_dns_record_t *dnsrec = NULL;\n  size_t             len;\n  ares_dns_flags_t   rd_flag = rd ? ARES_FLAG_RD : 0;\n\n  if (name == NULL || bufp == NULL || buflenp == NULL) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\n  *bufp    = NULL;\n  *buflenp = 0;\n\n  status = ares_dns_record_create_query(\n    &dnsrec, name, (ares_dns_class_t)dnsclass, (ares_dns_rec_type_t)type, id,\n    rd_flag, (size_t)max_udp_size);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write(dnsrec, bufp, &len);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  *buflenp = (int)len;\n\ndone:\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_create_query_int",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "bufp": "unsigned char",
              "buflenp": "int",
              "max_udp_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_create_query(const char *name, int dnsclass, int type,\n                      unsigned short id, int rd, unsigned char **bufp,\n                      int *buflenp, int max_udp_size)\n{\n  return ares_create_query_int(name, dnsclass, type, id, rd, bufp, buflenp,\n                               max_udp_size);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_create_query",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "bufp": "unsigned char",
              "buflenp": "int",
              "max_udp_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_mkquery(const char *name, int dnsclass, int type, unsigned short id,\n                 int rd, unsigned char **buf, int *buflen)\n{\n  return ares_create_query_int(name, dnsclass, type, id, rd, buf, buflen, 0);\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_mkquery",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "buf": "unsigned char",
              "buflen": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_fds.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_fds(const ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)\n{\n  ares_socket_t      nfds;\n  ares_slist_node_t *snode;\n  /* Are there any active queries? */\n  size_t             active_queries;\n\n  if (channel == NULL || read_fds == NULL || write_fds == NULL) {\n    return 0;\n  }\n\n  ares_channel_lock(channel);\n\n  active_queries = ares_llist_len(channel->all_queries);\n\n  nfds = 0;\n  for (snode = ares_slist_node_first(channel->servers); snode != NULL;\n       snode = ares_slist_node_next(snode)) {\n    ares_server_t     *server = ares_slist_node_val(snode);\n    ares_llist_node_t *node;\n\n    for (node = ares_llist_node_first(server->connections); node != NULL;\n         node = ares_llist_node_next(node)) {\n      const ares_conn_t *conn = ares_llist_node_val(node);\n\n      if (!active_queries && !(conn->flags & ARES_CONN_FLAG_TCP)) {\n        continue;\n      }\n\n      /* Silence coverity, shouldn't be possible */\n      if (conn->fd == ARES_SOCKET_BAD) {\n        continue;\n      }\n\n      /* Always wait on read */\n      FD_SET(conn->fd, read_fds);\n\n      if (conn->fd >= nfds) {\n        nfds = conn->fd + 1;\n      }\n\n      /* TCP only wait on write if we have the flag set */\n      if (conn->state_flags & ARES_CONN_STATE_WRITE) {\n        FD_SET(conn->fd, write_fds);\n      }\n    }\n  }\n\n  ares_channel_unlock(channel);\n  return (int)nfds;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_fds",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "write_fds": "fd_set"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_ptr_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_parse_ptr_reply_dnsrec(const ares_dns_record_t *dnsrec,\n                                          const void *addr, int addrlen,\n                                          int family, struct hostent **host)\n{\n  ares_status_t   status;\n  size_t          ptrcount = 0;\n  struct hostent *hostent  = NULL;\n  const char     *hostname = NULL;\n  const char     *ptrname  = NULL;\n  size_t          i;\n  size_t          ancount;\n\n  *host = NULL;\n\n  /* Fetch name from query as we will use it to compare later on.  Old code\n   * did this check, so we'll retain it. */\n  status = ares_dns_record_query_get(dnsrec, 0, &ptrname, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  if (ancount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  /* Response structure */\n  hostent = ares_malloc(sizeof(*hostent));\n  if (hostent == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  memset(hostent, 0, sizeof(*hostent));\n\n  hostent->h_addr_list = ares_malloc(2 * sizeof(*hostent->h_addr_list));\n  if (hostent->h_addr_list == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n  memset(hostent->h_addr_list, 0, 2 * sizeof(*hostent->h_addr_list));\n  if (addr != NULL && addrlen > 0) {\n    hostent->h_addr_list[0] = ares_malloc((size_t)addrlen);\n    if (hostent->h_addr_list[0] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    memcpy(hostent->h_addr_list[0], addr, (size_t)addrlen);\n  }\n  hostent->h_addrtype = (HOSTENT_ADDRTYPE_TYPE)family;\n  hostent->h_length   = (HOSTENT_LENGTH_TYPE)addrlen;\n\n  /* Preallocate the maximum number + 1 */\n  hostent->h_aliases = ares_malloc((ancount + 1) * sizeof(*hostent->h_aliases));\n  if (hostent->h_aliases == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n  memset(hostent->h_aliases, 0, (ancount + 1) * sizeof(*hostent->h_aliases));\n\n\n  /* Cycle through answers */\n  for (i = 0; i < ancount; i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get_const(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN) {\n      continue;\n    }\n\n    /* Any time we see a CNAME, replace our ptrname with its value */\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_CNAME) {\n      ptrname = ares_dns_rr_get_str(rr, ARES_RR_CNAME_CNAME);\n      if (ptrname == NULL) {\n        status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n        goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n      }\n    }\n\n    /* Handling for PTR records below this, otherwise skip */\n    if (ares_dns_rr_get_type(rr) != ARES_REC_TYPE_PTR) {\n      continue;\n    }\n\n    /* Issue #683\n     * Old code compared the name in the rr to the ptrname, but I think this\n     * is wrong since it was proven wrong for A & AAAA records.  Leaving\n     * this code commented out for future reference\n     *\n     * rname = ares_dns_rr_get_name(rr);\n     * if (rname == NULL) {\n     *   status = ARES_EBADRESP;\n     *   goto done;\n     * }\n     * if (!ares_strcaseeq(ptrname, rname)) {\n     *   continue;\n     * }\n     */\n\n    /* Save most recent PTR record as the hostname */\n    hostname = ares_dns_rr_get_str(rr, ARES_RR_PTR_DNAME);\n    if (hostname == NULL) {\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    /* Append as an alias */\n    hostent->h_aliases[ptrcount] = ares_strdup(hostname);\n    if (hostent->h_aliases[ptrcount] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    ptrcount++;\n  }\n\n  if (ptrcount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  } else {\n    status = ARES_SUCCESS;\n  }\n\n  /* Fill in hostname */\n  hostent->h_name = ares_strdup(hostname);\n  if (hostent->h_name == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_free_hostent(hostent);\n    /* Compatibility */\n    if (status == ARES_EBADNAME) {\n      status = ARES_EBADRESP;\n    }\n  } else {\n    *host = hostent;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ptr_reply_dnsrec",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_parse_ptr_reply(const unsigned char *abuf, int alen_int,\n                         const void *addr, int addrlen, int family,\n                         struct hostent **host)\n{\n  size_t             alen;\n  ares_dns_record_t *dnsrec = NULL;\n  ares_status_t      status;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_parse_ptr_reply_dnsrec(dnsrec, addr, addrlen, family, host);\n\ndone:\n  ares_dns_record_destroy(dnsrec);\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ptr_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            38,
            54
          ],
          [
            38,
            68
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            187,
            25
          ],
          [
            187,
            39
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_txt_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "static int ares_parse_txt_reply_int(const unsigned char *abuf, size_t alen,\n                                    ares_bool_t ex, void **txt_out)\n{\n  ares_status_t        status;\n  struct ares_txt_ext *txt_head = NULL;\n  struct ares_txt_ext *txt_last = NULL;\n  struct ares_txt_ext *txt_curr;\n  ares_dns_record_t   *dnsrec = NULL;\n  size_t               i;\n\n  *txt_out = NULL;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n    size_t j;\n    size_t cnt;\n\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    /* XXX: Why Chaos? */\n    if ((ares_dns_rr_get_class(rr) != ARES_CLASS_IN &&\n         ares_dns_rr_get_class(rr) != ARES_CLASS_CHAOS) ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_TXT) {\n      continue;\n    }\n\n    cnt = ares_dns_rr_get_abin_cnt(rr, ARES_RR_TXT_DATA);\n\n    for (j = 0; j < cnt; j++) {\n      const unsigned char *ptr;\n      size_t               ptr_len;\n\n      /* Allocate storage for this TXT answer appending it to the list */\n      txt_curr =\n        ares_malloc_data(ex ? ARES_DATATYPE_TXT_EXT : ARES_DATATYPE_TXT_REPLY);\n      if (txt_curr == NULL) {\n        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n\n      /* Link in the record */\n      if (txt_last) {\n        txt_last->next = txt_curr;\n      } else {\n        txt_head = txt_curr;\n      }\n      txt_last = txt_curr;\n\n      /* Tag start on first for each TXT record */\n      if (ex && j == 0) {\n        txt_curr->record_start = 1;\n      }\n\n      ptr = ares_dns_rr_get_abin(rr, ARES_RR_TXT_DATA, j, &ptr_len);\n\n      txt_curr->txt = ares_malloc(ptr_len + 1);\n      if (txt_curr->txt == NULL) {\n        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n      }\n      memcpy(txt_curr->txt, ptr, ptr_len);\n      txt_curr->txt[ptr_len] = 0;\n      txt_curr->length       = ptr_len;\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (txt_head) {\n      ares_free_data(txt_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *txt_out = txt_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply_int",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "size_t",
              "ex": "ares_bool_t",
              "txt_out": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_parse_txt_reply(const unsigned char *abuf, int alen,\n                         struct ares_txt_reply **txt_out)\n{\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n  return ares_parse_txt_reply_int(abuf, (size_t)alen, ARES_FALSE,\n                                  (void **)txt_out);\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "txt_out": "struct ares_txt_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_parse_txt_reply_ext(const unsigned char *abuf, int alen,\n                             struct ares_txt_ext **txt_out)\n{\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n  return ares_parse_txt_reply_int(abuf, (size_t)alen, ARES_TRUE,\n                                  (void **)txt_out);\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply_ext",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "txt_out": "struct ares_txt_ext"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            33,
            2
          ],
          [
            33,
            21
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            34,
            2
          ],
          [
            34,
            21
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            21
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            126,
            25
          ],
          [
            126,
            46
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            136,
            29
          ],
          [
            136,
            48
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_aaaa_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_aaaa_reply(const unsigned char *abuf, int alen,\n                          struct hostent **host, struct ares_addr6ttl *addrttls,\n                          int *naddrttls)\n{\n  struct ares_addrinfo ai;\n  char                *question_hostname = NULL;\n  ares_status_t        status;\n  size_t               req_naddrttls = 0;\n  ares_dns_record_t   *dnsrec        = NULL;\n\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n\n  if (naddrttls) {\n    req_naddrttls = (size_t)*naddrttls;\n    *naddrttls    = 0;\n  }\n\n  memset(&ai, 0, sizeof(ai));\n\n  status = ares_dns_parse(abuf, (size_t)alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares_parse_into_addrinfo(dnsrec, 0, 0, &ai);\n  if (status != ARES_SUCCESS && status != ARES_ENODATA) {\n    goto fail;\n  }\n\n  if (host != NULL) {\n    *host  = NULL;\n    status = ares_addrinfo2hostent(&ai, AF_INET6, host);\n    if (status != ARES_SUCCESS && status != ARES_ENODATA) {\n      goto fail; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n  }\n\n  if (addrttls != NULL && req_naddrttls) {\n    size_t temp_naddrttls = 0;\n    ares_addrinfo2addrttl(&ai, AF_INET6, req_naddrttls, NULL, addrttls,\n                          &temp_naddrttls);\n    *naddrttls = (int)temp_naddrttls;\n  }\n\nfail:\n  ares_freeaddrinfo_cnames(ai.cnames);\n  ares_freeaddrinfo_nodes(ai.nodes);\n  ares_free(question_hostname);\n  ares_free(ai.name);\n  ares_dns_record_destroy(dnsrec);\n\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_aaaa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent",
              "addrttls": "struct ares_addr6ttl",
              "naddrttls": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            51,
            26
          ],
          [
            51,
            40
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            51,
            49
          ],
          [
            51,
            69
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            54,
            2
          ],
          [
            54,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_a_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_a_reply(const unsigned char *abuf, int alen,\n                       struct hostent **host, struct ares_addrttl *addrttls,\n                       int *naddrttls)\n{\n  struct ares_addrinfo ai;\n  char                *question_hostname = NULL;\n  ares_status_t        status;\n  size_t               req_naddrttls = 0;\n  ares_dns_record_t   *dnsrec        = NULL;\n\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n\n  if (naddrttls) {\n    req_naddrttls = (size_t)*naddrttls;\n    *naddrttls    = 0;\n  }\n\n  memset(&ai, 0, sizeof(ai));\n\n  status = ares_dns_parse(abuf, (size_t)alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares_parse_into_addrinfo(dnsrec, 0, 0, &ai);\n  if (status != ARES_SUCCESS && status != ARES_ENODATA) {\n    goto fail;\n  }\n\n  if (host != NULL) {\n    *host  = NULL;\n    status = ares_addrinfo2hostent(&ai, AF_INET, host);\n    if (status != ARES_SUCCESS && status != ARES_ENODATA) {\n      goto fail; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n  }\n\n  if (addrttls != NULL && req_naddrttls) {\n    size_t temp_naddrttls = 0;\n    ares_addrinfo2addrttl(&ai, AF_INET, req_naddrttls, addrttls, NULL,\n                          &temp_naddrttls);\n    *naddrttls = (int)temp_naddrttls;\n  }\n\n\nfail:\n  ares_freeaddrinfo_cnames(ai.cnames);\n  ares_freeaddrinfo_nodes(ai.nodes);\n  ares_free(ai.name);\n  ares_free(question_hostname);\n  ares_dns_record_destroy(dnsrec);\n\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_a_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent",
              "addrttls": "struct ares_addrttl",
              "naddrttls": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            48,
            23
          ],
          [
            48,
            37
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            48,
            46
          ],
          [
            48,
            65
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            51,
            2
          ],
          [
            51,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_uri_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_uri_reply(const unsigned char *abuf, int alen_int,\n                         struct ares_uri_reply **uri_out)\n{\n  ares_status_t          status;\n  size_t                 alen;\n  struct ares_uri_reply *uri_head = NULL;\n  struct ares_uri_reply *uri_last = NULL;\n  struct ares_uri_reply *uri_curr;\n  ares_dns_record_t     *dnsrec = NULL;\n  size_t                 i;\n\n  *uri_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_URI) {\n      continue;\n    }\n\n    /* Allocate storage for this URI answer appending it to the list */\n    uri_curr = ares_malloc_data(ARES_DATATYPE_URI_REPLY);\n    if (uri_curr == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Link in the record */\n    if (uri_last) {\n      uri_last->next = uri_curr;\n    } else {\n      uri_head = uri_curr;\n    }\n    uri_last = uri_curr;\n\n\n    uri_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_URI_PRIORITY);\n    uri_curr->weight   = ares_dns_rr_get_u16(rr, ARES_RR_URI_WEIGHT);\n    uri_curr->uri = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_URI_TARGET));\n    uri_curr->ttl = (int)ares_dns_rr_get_ttl(rr);\n\n    if (uri_curr->uri == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (uri_head) {\n      ares_free_data(uri_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *uri_out = uri_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_uri_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "uri_out": "struct ares_uri_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            30,
            25
          ],
          [
            30,
            46
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            34,
            2
          ],
          [
            34,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_ns_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_ns_reply(const unsigned char *abuf, int alen_int,\n                        struct hostent **host)\n{\n  ares_status_t      status;\n  size_t             alen;\n  size_t             nscount  = 0;\n  struct hostent    *hostent  = NULL;\n  const char        *hostname = NULL;\n  ares_dns_record_t *dnsrec   = NULL;\n  size_t             i;\n  size_t             ancount;\n\n  *host = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  if (ancount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  /* Response structure */\n  hostent = ares_malloc(sizeof(*hostent));\n  if (hostent == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  memset(hostent, 0, sizeof(*hostent));\n\n  hostent->h_addr_list = ares_malloc(sizeof(*hostent->h_addr_list));\n  if (hostent->h_addr_list == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  hostent->h_addr_list[0] = NULL;\n  hostent->h_addrtype     = AF_INET;\n  hostent->h_length       = sizeof(struct in_addr);\n\n  /* Fill in hostname */\n  status = ares_dns_record_query_get(dnsrec, 0, &hostname, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  hostent->h_name = ares_strdup(hostname);\n  if (hostent->h_name == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  /* Preallocate the maximum number + 1 */\n  hostent->h_aliases = ares_malloc((ancount + 1) * sizeof(*hostent->h_aliases));\n  if (hostent->h_aliases == NULL) {\n    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n  memset(hostent->h_aliases, 0, (ancount + 1) * sizeof(*hostent->h_aliases));\n\n  for (i = 0; i < ancount; i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_NS) {\n      continue;\n    }\n\n    hostname = ares_dns_rr_get_str(rr, ARES_RR_NS_NSDNAME);\n    if (hostname == NULL) {\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    hostent->h_aliases[nscount] = ares_strdup(hostname);\n    if (hostent->h_aliases[nscount] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    nscount++;\n  }\n\n  if (nscount == 0) {\n    status = ARES_ENODATA;\n  } else {\n    status = ARES_SUCCESS;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_free_hostent(hostent);\n    /* Compatibility */\n    if (status == ARES_EBADNAME) {\n      status = ARES_EBADRESP;\n    }\n  } else {\n    *host = hostent;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ns_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            39,
            24
          ],
          [
            39,
            38
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            85,
            35
          ],
          [
            85,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_parse_mx_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_mx_reply(const unsigned char *abuf, int alen_int,\n                        struct ares_mx_reply **mx_out)\n{\n  ares_status_t         status;\n  size_t                alen;\n  struct ares_mx_reply *mx_head = NULL;\n  struct ares_mx_reply *mx_last = NULL;\n  struct ares_mx_reply *mx_curr;\n  ares_dns_record_t    *dnsrec = NULL;\n  size_t                i;\n\n  *mx_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */\n      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_MX) {\n      continue;\n    }\n\n    /* Allocate storage for this MX answer appending it to the list */\n    mx_curr = ares_malloc_data(ARES_DATATYPE_MX_REPLY);\n    if (mx_curr == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    /* Link in the record */\n    if (mx_last) {\n      mx_last->next = mx_curr;\n    } else {\n      mx_head = mx_curr;\n    }\n    mx_last = mx_curr;\n\n    mx_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_MX_PREFERENCE);\n    mx_curr->host = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_MX_EXCHANGE));\n\n    if (mx_curr->host == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (mx_head) {\n      ares_free_data(mx_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *mx_out = mx_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_mx_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "mx_out": "struct ares_mx_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            30,
            24
          ],
          [
            30,
            44
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            34,
            2
          ],
          [
            34,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/legacy/ares_getsock.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_getsock(const ares_channel_t *channel, ares_socket_t *socks,\n                 int numsocks) /* size of the 'socks' array */\n{\n  ares_slist_node_t *snode;\n  size_t             sockindex = 0;\n  unsigned int       bitmap    = 0;\n  unsigned int       setbits   = 0xffffffff;\n\n  /* Are there any active queries? */\n  size_t             active_queries;\n\n  if (channel == NULL || numsocks <= 0) {\n    return 0;\n  }\n\n  ares_channel_lock(channel);\n\n  active_queries = ares_llist_len(channel->all_queries);\n\n  for (snode = ares_slist_node_first(channel->servers); snode != NULL;\n       snode = ares_slist_node_next(snode)) {\n    ares_server_t     *server = ares_slist_node_val(snode);\n    ares_llist_node_t *node;\n\n    for (node = ares_llist_node_first(server->connections); node != NULL;\n         node = ares_llist_node_next(node)) {\n      const ares_conn_t *conn = ares_llist_node_val(node);\n\n      if (sockindex >= (size_t)numsocks || sockindex >= ARES_GETSOCK_MAXNUM) {\n        break;\n      }\n\n      /* We only need to register interest in UDP sockets if we have\n       * outstanding queries.\n       */\n      if (!active_queries && !(conn->flags & ARES_CONN_FLAG_TCP)) {\n        continue;\n      }\n\n      socks[sockindex] = conn->fd;\n\n      if (active_queries || conn->flags & ARES_CONN_FLAG_TCP) {\n        bitmap |= ARES_GETSOCK_READABLE(setbits, sockindex);\n      }\n\n      if (conn->state_flags & ARES_CONN_STATE_WRITE) {\n        /* then the tcp socket is also writable! */\n        bitmap |= ARES_GETSOCK_WRITABLE(setbits, sockindex);\n      }\n\n      sockindex++;\n    }\n  }\n\n  ares_channel_unlock(channel);\n  return (int)bitmap;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getsock",
            "parameters": {
              "channel": "ares_channel_t",
              "socks": "ares_socket_t",
              "numsocks": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_poll.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t ares_evsys_poll_init(ares_event_thread_t *e)\n{\n  e->ev_signal = ares_pipeevent_create(e);\n  if (e->ev_signal == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_poll_destroy(ares_event_thread_t *e)\n{\n  (void)e;\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_poll_event_add(ares_event_t *event)\n{\n  (void)event;\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_poll_event_del(ares_event_t *event)\n{\n  (void)event;\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_poll_event_mod(ares_event_t      *event,\n                                      ares_event_flags_t new_flags)\n{\n  (void)event;\n  (void)new_flags;\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_poll_wait(ares_event_thread_t *e,\n                                   unsigned long        timeout_ms)\n{\n  size_t         num_fds = 0;\n  ares_socket_t *fdlist  = ares_htable_asvp_keys(e->ev_sock_handles, &num_fds);\n  struct pollfd *pollfd  = NULL;\n  int            rv;\n  size_t         cnt = 0;\n  size_t         i;\n\n  if (fdlist != NULL && num_fds) {\n    pollfd = ares_malloc_zero(sizeof(*pollfd) * num_fds);\n    if (pollfd == NULL) {\n      goto done; /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n    for (i = 0; i < num_fds; i++) {\n      const ares_event_t *ev =\n        ares_htable_asvp_get_direct(e->ev_sock_handles, fdlist[i]);\n      pollfd[i].fd = ev->fd;\n      if (ev->flags & ARES_EVENT_FLAG_READ) {\n        pollfd[i].events |= POLLIN;\n      }\n      if (ev->flags & ARES_EVENT_FLAG_WRITE) {\n        pollfd[i].events |= POLLOUT;\n      }\n    }\n  }\n  ares_free(fdlist);\n\n  rv = poll(pollfd, (nfds_t)num_fds, (timeout_ms == 0) ? -1 : (int)timeout_ms);\n  if (rv <= 0) {\n    goto done;\n  }\n\n  for (i = 0; pollfd != NULL && i < num_fds; i++) {\n    ares_event_t      *ev;\n    ares_event_flags_t flags = 0;\n\n    if (pollfd[i].revents == 0) {\n      continue;\n    }\n\n    cnt++;\n\n    ev = ares_htable_asvp_get_direct(e->ev_sock_handles, pollfd[i].fd);\n    if (ev == NULL || ev->cb == NULL) {\n      continue; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    if (pollfd[i].revents & (POLLERR | POLLHUP | POLLIN)) {\n      flags |= ARES_EVENT_FLAG_READ;\n    }\n\n    if (pollfd[i].revents & POLLOUT) {\n      flags |= ARES_EVENT_FLAG_WRITE;\n    }\n\n    ev->cb(e, pollfd[i].fd, ev->data, flags);\n  }\n\ndone:\n  ares_free(pollfd);\n  return cnt;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pollfd",
          {},
          "",
          [
            71,
            2
          ],
          [
            71,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <poll.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_wake_pipe.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_pipeevent_destroy(ares_pipeevent_t *p)\n{\n  if (p->filedes[0] != -1) {\n    close(p->filedes[0]);\n  }\n  if (p->filedes[1] != -1) {\n    close(p->filedes[1]);\n  }\n\n  ares_free(p);\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_destroy",
            "parameters": {
              "p": "ares_pipeevent_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_pipeevent_destroy_cb(void *arg)\n{\n  ares_pipeevent_destroy(arg);\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_destroy_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_pipeevent_t *ares_pipeevent_init(void)\n{\n  ares_pipeevent_t *p = ares_malloc_zero(sizeof(*p));\n  if (p == NULL) {\n    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  p->filedes[0] = -1;\n  p->filedes[1] = -1;\n\n#  ifdef HAVE_PIPE2\n  if (pipe2(p->filedes, O_NONBLOCK | O_CLOEXEC) != 0) {\n    ares_pipeevent_destroy(p); /* LCOV_EXCL_LINE: UntestablePath */\n    return NULL;               /* LCOV_EXCL_LINE: UntestablePath */\n  }\n#  else\n  if (pipe(p->filedes) != 0) {\n    ares_pipeevent_destroy(p);\n    return NULL;\n  }\n\n#    ifdef O_NONBLOCK\n  {\n    int val;\n    val = fcntl(p->filedes[0], F_GETFL, 0);\n    if (val >= 0) {\n      val |= O_NONBLOCK;\n    }\n    fcntl(p->filedes[0], F_SETFL, val);\n\n    val = fcntl(p->filedes[1], F_GETFL, 0);\n    if (val >= 0) {\n      val |= O_NONBLOCK;\n    }\n    fcntl(p->filedes[1], F_SETFL, val);\n  }\n#    endif\n\n#    ifdef FD_CLOEXEC\n  fcntl(p->filedes[0], F_SETFD, FD_CLOEXEC);\n  fcntl(p->filedes[1], F_SETFD, FD_CLOEXEC);\n#    endif\n#  endif\n\n#  ifdef F_SETNOSIGPIPE\n  fcntl(p->filedes[0], F_SETNOSIGPIPE, 1);\n  fcntl(p->filedes[1], F_SETNOSIGPIPE, 1);\n#  endif\n\n  return p;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_init",
            "parameters": {},
            "return_type": "ares_pipeevent_t"
          }
        },
        {
          "fn_code": "static void ares_pipeevent_signal(const ares_event_t *e)\n{\n  const ares_pipeevent_t *p;\n\n  if (e == NULL || e->data == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  p = e->data;\n  (void)write(p->filedes[1], \"1\", 1);\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_signal",
            "parameters": {
              "e": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_pipeevent_cb(ares_event_thread_t *e, ares_socket_t fd,\n                              void *data, ares_event_flags_t flags)\n{\n  unsigned char           buf[32];\n  const ares_pipeevent_t *p = NULL;\n\n  (void)e;\n  (void)fd;\n  (void)flags;\n\n  if (data == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  p = data;\n\n  while (read(p->filedes[0], buf, sizeof(buf)) == sizeof(buf)) {\n    /* Do nothing */\n  }\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_cb",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_event_t *ares_pipeevent_create(ares_event_thread_t *e)\n{\n  ares_event_t     *event = NULL;\n  ares_pipeevent_t *p     = NULL;\n  ares_status_t     status;\n\n  p = ares_pipeevent_init();\n  if (p == NULL) {\n    return NULL;\n  }\n\n  status = ares_event_update(&event, e, ARES_EVENT_FLAG_READ, ares_pipeevent_cb,\n                             p->filedes[0], p, ares_pipeevent_destroy_cb,\n                             ares_pipeevent_signal);\n  if (status != ARES_SUCCESS) {\n    ares_pipeevent_destroy(p); /* LCOV_EXCL_LINE: DefensiveCoding */\n    return NULL;               /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  return event;\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_event_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_pipeevent_init(void)",
          "fn_dec_pos": [
            [
              58,
              25
            ],
            [
              58,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_init",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_pipeevent_create(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              143,
              14
            ],
            [
              143,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  int filedes[2];\n} ares_pipeevent_t;",
          {
            "filedes[2]": "int"
          },
          "ares_pipeevent_t",
          [
            37,
            0
          ],
          [
            39,
            19
          ]
        ],
        [
          "typedef struct {\n  int filedes[2];\n} ares_pipeevent_t;",
          {
            "filedes[2]": "int"
          },
          "ares_pipeevent_t",
          [
            37,
            0
          ],
          [
            39,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#    include <unistd.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#    include <fcntl.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_thread.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_event_destroy_cb(void *arg)\n{\n  ares_event_t *event = arg;\n  if (event == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Unregister from the event thread if it was registered with one */\n  if (event->e) {\n    const ares_event_thread_t *e = event->e;\n    e->ev_sys->event_del(event);\n    event->e = NULL;\n  }\n\n  if (event->free_data_cb && event->data) {\n    event->free_data_cb(event->data);\n  }\n\n  ares_free(event);\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_destroy_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_signal(const ares_event_t *event)\n{\n  if (event == NULL || event->signal_cb == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n  event->signal_cb(event);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_signal",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_thread_wake(const ares_event_thread_t *e)\n{\n  if (e == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_event_signal(e->ev_signal);\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_wake",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_event_t *ares_event_update_find(ares_event_thread_t *e,\n                                            ares_socket_t fd, const void *data)\n{\n  ares_llist_node_t *node;\n\n  for (node = ares_llist_node_first(e->ev_updates); node != NULL;\n       node = ares_llist_node_next(node)) {\n    ares_event_t *ev = ares_llist_node_val(node);\n\n    if (fd != ARES_SOCKET_BAD && fd == ev->fd && ev->flags != 0) {\n      return ev;\n    }\n\n    if (fd == ARES_SOCKET_BAD && ev->fd == ARES_SOCKET_BAD &&\n        data == ev->data && ev->flags != 0) {\n      return ev;\n    }\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_update_find",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void"
            },
            "return_type": "ares_event_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_update(ares_event_t **event, ares_event_thread_t *e,\n                                ares_event_flags_t flags, ares_event_cb_t cb,\n                                ares_socket_t fd, void *data,\n                                ares_event_free_data_t free_data_cb,\n                                ares_event_signal_cb_t signal_cb)\n{\n  ares_event_t *ev = NULL;\n  ares_status_t status;\n\n  if (e == NULL) {\n    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Callback must be specified if not a removal event. */\n  if (flags != ARES_EVENT_FLAG_NONE && cb == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (event != NULL) {\n    *event = NULL;\n  }\n\n  /* Validate flags */\n  if (fd == ARES_SOCKET_BAD) {\n    if (flags & (ARES_EVENT_FLAG_READ | ARES_EVENT_FLAG_WRITE)) {\n      return ARES_EFORMERR;\n    }\n    if (!(flags & ARES_EVENT_FLAG_OTHER)) {\n      return ARES_EFORMERR;\n    }\n  } else {\n    if (flags & ARES_EVENT_FLAG_OTHER) {\n      return ARES_EFORMERR;\n    }\n  }\n\n  /* That's all the validation we can really do */\n\n  ares_thread_mutex_lock(e->mutex);\n\n  /* See if we have a queued update already */\n  ev = ares_event_update_find(e, fd, data);\n  if (ev == NULL) {\n    /* Allocate a new one */\n    ev = ares_malloc_zero(sizeof(*ev));\n    if (ev == NULL) {\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n\n    if (ares_llist_insert_last(e->ev_updates, ev) == NULL) {\n      ares_free(ev);        /* LCOV_EXCL_LINE: OutOfMemory */\n      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */\n    }\n  }\n\n  ev->flags = flags;\n  ev->fd    = fd;\n  if (ev->cb == NULL) {\n    ev->cb = cb;\n  }\n  if (ev->data == NULL) {\n    ev->data = data;\n  }\n  if (ev->free_data_cb == NULL) {\n    ev->free_data_cb = free_data_cb;\n  }\n  if (ev->signal_cb == NULL) {\n    ev->signal_cb = signal_cb;\n  }\n\n  if (event != NULL) {\n    *event = ev;\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  if (status == ARES_SUCCESS) {\n    /* Wake event thread if successful so it can pull the updates */\n    ares_event_thread_wake(e);\n  }\n\n  ares_thread_mutex_unlock(e->mutex);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_update",
            "parameters": {
              "event": "ares_event_t",
              "e": "ares_event_thread_t",
              "flags": "ares_event_flags_t",
              "cb": "ares_event_cb_t",
              "fd": "ares_socket_t",
              "data": "void",
              "free_data_cb": "ares_event_free_data_t",
              "signal_cb": "ares_event_signal_cb_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void ares_event_thread_process_fd(ares_event_thread_t *e,\n                                         ares_socket_t fd, void *data,\n                                         ares_event_flags_t flags)\n{\n  ares_fd_events_t event;\n  (void)data;\n\n  event.fd     = fd;\n  event.events = 0;\n  if (flags & ARES_EVENT_FLAG_READ) {\n    event.events |= ARES_FD_EVENT_READ;\n  }\n  if (flags & ARES_EVENT_FLAG_WRITE) {\n    event.events |= ARES_FD_EVENT_WRITE;\n  }\n  ares_process_fds(e->channel, &event, 1, ARES_PROCESS_FLAG_SKIP_NON_FD);\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_process_fd",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_thread_sockstate_cb(void *data, ares_socket_t socket_fd,\n                                           int readable, int writable)\n{\n  ares_event_thread_t *e     = data;\n  ares_event_flags_t   flags = ARES_EVENT_FLAG_NONE;\n\n  if (readable) {\n    flags |= ARES_EVENT_FLAG_READ;\n  }\n\n  if (writable) {\n    flags |= ARES_EVENT_FLAG_WRITE;\n  }\n\n  /* Update channel fd.  This function will lock e->mutex and also wake the\n   * event thread to process the update */\n  ares_event_update(NULL, e, flags, ares_event_thread_process_fd, socket_fd,\n                    NULL, NULL, NULL);\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_sockstate_cb",
            "parameters": {
              "data": "void",
              "socket_fd": "ares_socket_t",
              "readable": "int",
              "writable": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void notifywrite_cb(void *data)\n{\n  ares_event_thread_t *e = data;\n\n  ares_thread_mutex_lock(e->mutex);\n  e->process_pending_write = ARES_TRUE;\n  ares_thread_mutex_unlock(e->mutex);\n\n  ares_event_thread_wake(e);\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "notifywrite_cb",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void notifyenqueue_cb(void *data)\n{\n  ares_event_thread_t *e = data;\n  ares_event_thread_wake(e);\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "notifyenqueue_cb",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_process_updates(ares_event_thread_t *e)\n{\n  ares_llist_node_t *node;\n\n  /* Iterate across all updates and apply to internal list, removing from update\n   * list */\n  while ((node = ares_llist_node_first(e->ev_updates)) != NULL) {\n    ares_event_t *newev = ares_llist_node_claim(node);\n    ares_event_t *oldev;\n\n    if (newev->fd == ARES_SOCKET_BAD) {\n      oldev = ares_htable_vpvp_get_direct(e->ev_cust_handles, newev->data);\n    } else {\n      oldev = ares_htable_asvp_get_direct(e->ev_sock_handles, newev->fd);\n    }\n\n    /* Adding new */\n    if (oldev == NULL) {\n      newev->e = e;\n      /* Don't try to add a new event if all flags are cleared, that's basically\n       * someone trying to delete something already deleted.  Also if it fails\n       * to add, cleanup. */\n      if (newev->flags == ARES_EVENT_FLAG_NONE ||\n          !e->ev_sys->event_add(newev)) {\n        newev->e = NULL;\n        ares_event_destroy_cb(newev);\n      } else {\n        if (newev->fd == ARES_SOCKET_BAD) {\n          ares_htable_vpvp_insert(e->ev_cust_handles, newev->data, newev);\n        } else {\n          ares_htable_asvp_insert(e->ev_sock_handles, newev->fd, newev);\n        }\n      }\n      continue;\n    }\n\n    /* Removal request */\n    if (newev->flags == ARES_EVENT_FLAG_NONE) {\n      /* the callback for the removal will call e->ev_sys->event_del(e, event)\n       */\n      if (newev->fd == ARES_SOCKET_BAD) {\n        ares_htable_vpvp_remove(e->ev_cust_handles, newev->data);\n      } else {\n        ares_htable_asvp_remove(e->ev_sock_handles, newev->fd);\n      }\n      ares_free(newev);\n      continue;\n    }\n\n    /* Modify request -- only flags can be changed */\n    e->ev_sys->event_mod(oldev, newev->flags);\n    oldev->flags = newev->flags;\n    ares_free(newev);\n  }\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_process_updates",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_thread_cleanup(ares_event_thread_t *e)\n{\n  /* Manually free any updates that weren't processed */\n  if (e->ev_updates != NULL) {\n    ares_llist_node_t *node;\n\n    while ((node = ares_llist_node_first(e->ev_updates)) != NULL) {\n      ares_event_destroy_cb(ares_llist_node_claim(node));\n    }\n    ares_llist_destroy(e->ev_updates);\n    e->ev_updates = NULL;\n  }\n\n  if (e->ev_sock_handles != NULL) {\n    ares_htable_asvp_destroy(e->ev_sock_handles);\n    e->ev_sock_handles = NULL;\n  }\n\n  if (e->ev_cust_handles != NULL) {\n    ares_htable_vpvp_destroy(e->ev_cust_handles);\n    e->ev_cust_handles = NULL;\n  }\n\n  if (e->ev_sys != NULL && e->ev_sys->destroy != NULL) {\n    e->ev_sys->destroy(e);\n    e->ev_sys = NULL;\n  }\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_cleanup",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void *ares_event_thread(void *arg)\n{\n  ares_event_thread_t *e = arg;\n  ares_thread_mutex_lock(e->mutex);\n\n  while (e->isup) {\n    struct timeval        tv;\n    const struct timeval *tvout;\n    unsigned long         timeout_ms = 0; /* 0 = unlimited */\n    ares_bool_t           process_pending_write;\n\n    ares_event_process_updates(e);\n\n    /* Don't hold a mutex while waiting on events or calling into anything\n     * that might require a c-ares channel lock since a callback could be\n     * triggered cross-thread */\n    ares_thread_mutex_unlock(e->mutex);\n\n    tvout = ares_timeout(e->channel, NULL, &tv);\n    if (tvout != NULL) {\n      timeout_ms =\n        (unsigned long)((tvout->tv_sec * 1000) + (tvout->tv_usec / 1000) + 1);\n    }\n\n    e->ev_sys->wait(e, timeout_ms);\n\n    /* Process pending write operation */\n    ares_thread_mutex_lock(e->mutex);\n    process_pending_write    = e->process_pending_write;\n    e->process_pending_write = ARES_FALSE;\n    ares_thread_mutex_unlock(e->mutex);\n    if (process_pending_write) {\n      ares_process_pending_write(e->channel);\n    }\n\n    /* Relock before we loop again */\n    ares_thread_mutex_lock(e->mutex);\n\n    /* Each iteration should do timeout processing and any other cleanup\n     * that may not have been performed */\n    if (e->isup) {\n      ares_thread_mutex_unlock(e->mutex);\n      ares_process_fds(e->channel, NULL, 0, ARES_PROCESS_FLAG_NONE);\n      ares_thread_mutex_lock(e->mutex);\n    }\n  }\n\n  /* Lets cleanup while we're in the thread itself */\n  ares_event_thread_cleanup(e);\n\n  ares_thread_mutex_unlock(e->mutex);\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              328,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_thread_destroy_int(ares_event_thread_t *e)\n{\n  /* Wake thread and tell it to shutdown if it exists */\n  ares_thread_mutex_lock(e->mutex);\n  if (e->isup) {\n    e->isup = ARES_FALSE;\n    ares_event_thread_wake(e);\n  }\n  ares_thread_mutex_unlock(e->mutex);\n\n  /* Wait for thread to shutdown */\n  if (e->thread) {\n    void *rv = NULL;\n    ares_thread_join(e->thread, &rv);\n    e->thread = NULL;\n  }\n\n  /* If the event thread ever got to the point of starting, this is a no-op\n   * as it runs this same cleanup when it shuts down */\n  ares_event_thread_cleanup(e);\n\n  ares_thread_mutex_destroy(e->mutex);\n  e->mutex = NULL;\n\n  ares_free(e);\n}",
          "fn_code_pos": [
            [
              383,
              0
            ],
            [
              408,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_destroy_int",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_event_thread_destroy(ares_channel_t *channel)\n{\n  ares_event_thread_t *e = channel->sock_state_cb_data;\n\n  if (e == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ares_event_thread_destroy_int(e);\n  channel->sock_state_cb_data           = NULL;\n  channel->sock_state_cb                = NULL;\n  channel->notify_pending_write_cb      = NULL;\n  channel->notify_pending_write_cb_data = NULL;\n  ares_set_query_enqueue_cb(channel, NULL, NULL);\n}",
          "fn_code_pos": [
            [
              410,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static const ares_event_sys_t *ares_event_fetch_sys(ares_evsys_t evsys)\n{\n  switch (evsys) {\n    case ARES_EVSYS_WIN32:\n#if defined(USE_WINSOCK)\n      return &ares_evsys_win32;\n#else\n      return NULL;\n#endif\n\n    case ARES_EVSYS_EPOLL:\n#if defined(HAVE_EPOLL)\n      return &ares_evsys_epoll;\n#else\n      return NULL;\n#endif\n\n    case ARES_EVSYS_KQUEUE:\n#if defined(HAVE_KQUEUE)\n      return &ares_evsys_kqueue;\n#else\n      return NULL;\n#endif\n\n    case ARES_EVSYS_POLL:\n#if defined(HAVE_POLL)\n      return &ares_evsys_poll;\n#else\n      return NULL;\n#endif\n\n    case ARES_EVSYS_SELECT:\n#if defined(HAVE_PIPE)\n      return &ares_evsys_select;\n#else\n      return NULL;\n#endif\n\n    /* case ARES_EVSYS_DEFAULT: */\n    default:\n      break;\n  }\n\n    /* default */\n#if defined(USE_WINSOCK)\n  return &ares_evsys_win32;\n#elif defined(HAVE_KQUEUE)\n  return &ares_evsys_kqueue;\n#elif defined(HAVE_EPOLL)\n  return &ares_evsys_epoll;\n#elif defined(HAVE_POLL)\n  return &ares_evsys_poll;\n#elif defined(HAVE_PIPE)\n  return &ares_evsys_select;\n#else\n  return NULL;\n#endif\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              483,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_fetch_sys",
            "parameters": {
              "evsys": "ares_evsys_t"
            },
            "return_type": "ares_event_sys_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_thread_init(ares_channel_t *channel)\n{\n  ares_event_thread_t *e;\n\n  e = ares_malloc_zero(sizeof(*e));\n  if (e == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  e->mutex = ares_thread_mutex_create();\n  if (e->mutex == NULL) {\n    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: OutOfMemory */\n    return ARES_ENOMEM;               /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  e->ev_updates = ares_llist_create(NULL);\n  if (e->ev_updates == NULL) {\n    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: OutOfMemory */\n    return ARES_ENOMEM;               /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  e->ev_sock_handles = ares_htable_asvp_create(ares_event_destroy_cb);\n  if (e->ev_sock_handles == NULL) {\n    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: OutOfMemory */\n    return ARES_ENOMEM;               /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  e->ev_cust_handles = ares_htable_vpvp_create(NULL, ares_event_destroy_cb);\n  if (e->ev_cust_handles == NULL) {\n    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: OutOfMemory */\n    return ARES_ENOMEM;               /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  e->channel = channel;\n  e->isup    = ARES_TRUE;\n  e->ev_sys  = ares_event_fetch_sys(channel->evsys);\n  if (e->ev_sys == NULL) {\n    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: UntestablePath */\n    return ARES_ENOTIMP;              /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  channel->sock_state_cb                = ares_event_thread_sockstate_cb;\n  channel->sock_state_cb_data           = e;\n  channel->notify_pending_write_cb      = notifywrite_cb;\n  channel->notify_pending_write_cb_data = e;\n  ares_set_query_enqueue_cb(channel, notifyenqueue_cb, e);\n\n  if (!e->ev_sys->init(e)) {\n    /* LCOV_EXCL_START: UntestablePath */\n    ares_event_thread_destroy_int(e);\n    channel->sock_state_cb      = NULL;\n    channel->sock_state_cb_data = NULL;\n    return ARES_ESERVFAIL;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* Before starting the thread, process any possible events the initialization\n   * might have enqueued as we may actually depend on these being valid\n   * immediately upon return, which may mean before the thread is fully spawned\n   * and processed the list itself. We don't want any sort of race conditions\n   * (like the event system wake handle itself). */\n  ares_event_process_updates(e);\n\n  /* Start thread */\n  if (ares_thread_create(&e->thread, ares_event_thread, e) != ARES_SUCCESS) {\n    /* LCOV_EXCL_START: UntestablePath */\n    ares_event_thread_destroy_int(e);\n    channel->sock_state_cb      = NULL;\n    channel->sock_state_cb_data = NULL;\n    return ARES_ESERVFAIL;\n    /* LCOV_EXCL_STOP */\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              485,
              0
            ],
            [
              559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_thread_init(ares_channel_t *channel)\n{\n  (void)channel;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              563,
              0
            ],
            [
              567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_event_thread_destroy(ares_channel_t *channel)\n{\n  (void)channel;\n}",
          "fn_code_pos": [
            [
              569,
              0
            ],
            [
              572,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_event_update_find(ares_event_thread_t *e,\n                                            ares_socket_t fd, const void *data)",
          "fn_dec_pos": [
            [
              77,
              21
            ],
            [
              78,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_update_find",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_event_thread(void *arg)",
          "fn_dec_pos": [
            [
              328,
              13
            ],
            [
              328,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread",
            "parameters": {
              "arg": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_event_fetch_sys(ares_evsys_t evsys)",
          "fn_dec_pos": [
            [
              426,
              31
            ],
            [
              426,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_fetch_sys",
            "parameters": {
              "evsys": "ares_evsys_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            334,
            4
          ],
          [
            334,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            335,
            10
          ],
          [
            335,
            24
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_configchg.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,\n                                        ares_event_thread_t     *e)\n{\n  (void)configchg;\n  (void)e;\n  /* No ability */\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_init",
            "parameters": {
              "configchg": "ares_event_configchg_t",
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_event_configchg_destroy(ares_event_configchg_t *configchg)\n{\n  /* No-op */\n  (void)configchg;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_destroy",
            "parameters": {
              "configchg": "ares_event_configchg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_event_configchg_destroy(ares_event_configchg_t *configchg)\n{\n  if (configchg == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  /* Tell event system to stop monitoring for changes.  This will cause the\n   * cleanup to be called */\n  ares_event_update(NULL, configchg->e, ARES_EVENT_FLAG_NONE, NULL,\n                    configchg->inotify_fd, NULL, NULL, NULL);\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_destroy",
            "parameters": {
              "configchg": "ares_event_configchg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_configchg_free(void *data)\n{\n  ares_event_configchg_t *configchg = data;\n  if (configchg == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (configchg->inotify_fd >= 0) {\n    close(configchg->inotify_fd);\n    configchg->inotify_fd = -1;\n  }\n\n  ares_free(configchg);\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_free",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_configchg_cb(ares_event_thread_t *e, ares_socket_t fd,\n                                    void *data, ares_event_flags_t flags)\n{\n  const ares_event_configchg_t *configchg = data;\n\n  /* Some systems cannot read integer variables if they are not\n   * properly aligned. On other systems, incorrect alignment may\n   * decrease performance. Hence, the buffer used for reading from\n   * the inotify file descriptor should have the same alignment as\n   * struct inotify_event. */\n  unsigned char                 buf[4096]\n    __attribute__((aligned(__alignof__(struct inotify_event))));\n  const struct inotify_event *event;\n  ssize_t                     len;\n  ares_bool_t                 triggered = ARES_FALSE;\n\n  (void)fd;\n  (void)flags;\n\n  while (1) {\n    const unsigned char *ptr;\n\n    len = read(configchg->inotify_fd, buf, sizeof(buf));\n    if (len <= 0) {\n      break;\n    }\n\n    /* Loop over all events in the buffer. Says kernel will check the buffer\n     * size provided, so I assume it won't ever return partial events. */\n    for (ptr  = buf; ptr < buf + len;\n         ptr += sizeof(struct inotify_event) + event->len) {\n      event = (const struct inotify_event *)((const void *)ptr);\n\n      if (event->len == 0 || ares_strlen(event->name) == 0) {\n        continue;\n      }\n\n      if (ares_strcaseeq(event->name, \"resolv.conf\") ||\n          ares_strcaseeq(event->name, \"nsswitch.conf\")) {\n        triggered = ARES_TRUE;\n      }\n    }\n  }\n\n  /* Only process after all events are read.  No need to process more often as\n   * we don't want to reload the config back to back */\n  if (triggered) {\n    ares_reinit(e->channel);\n  }\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_cb",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,\n                                        ares_event_thread_t     *e)\n{\n  ares_status_t           status = ARES_SUCCESS;\n  ares_event_configchg_t *c;\n\n  (void)e;\n\n  /* Not used by this implementation */\n  *configchg = NULL;\n\n  c = ares_malloc_zero(sizeof(*c));\n  if (c == NULL) {\n    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  c->e          = e;\n  c->inotify_fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);\n  if (c->inotify_fd == -1) {\n    status = ARES_ESERVFAIL; /* LCOV_EXCL_LINE: UntestablePath */\n    goto done;               /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  /* We need to monitor /etc/resolv.conf, /etc/nsswitch.conf */\n  if (inotify_add_watch(c->inotify_fd, \"/etc\",\n                        IN_CREATE | IN_MODIFY | IN_MOVED_TO | IN_ONLYDIR) ==\n      -1) {\n    status = ARES_ESERVFAIL; /* LCOV_EXCL_LINE: UntestablePath */\n    goto done;               /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  status =\n    ares_event_update(NULL, e, ARES_EVENT_FLAG_READ, ares_event_configchg_cb,\n                      c->inotify_fd, c, ares_event_configchg_free, NULL);\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_event_configchg_free(c);\n  } else {\n    *configchg = c;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_init",
            "parameters": {
              "configchg": "ares_event_configchg_t",
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_event_configchg_destroy(ares_event_configchg_t *configchg)\n{\n  if (configchg == NULL) {\n    return;\n  }\n\n#  ifdef HAVE_NOTIFYIPINTERFACECHANGE\n  if (configchg->ifchg_hnd != NULL) {\n    CancelMibChangeNotify2(configchg->ifchg_hnd);\n    configchg->ifchg_hnd = NULL;\n  }\n#  endif\n\n#  ifdef HAVE_REGISTERWAITFORSINGLEOBJECT\n  if (configchg->regip4_wait != NULL) {\n    UnregisterWait(configchg->regip4_wait);\n    configchg->regip4_wait = NULL;\n  }\n\n  if (configchg->regip6_wait != NULL) {\n    UnregisterWait(configchg->regip6_wait);\n    configchg->regip6_wait = NULL;\n  }\n\n  if (configchg->regip4 != NULL) {\n    RegCloseKey(configchg->regip4);\n    configchg->regip4 = NULL;\n  }\n\n  if (configchg->regip6 != NULL) {\n    RegCloseKey(configchg->regip6);\n    configchg->regip6 = NULL;\n  }\n\n  if (configchg->regip4_event != NULL) {\n    CloseHandle(configchg->regip4_event);\n    configchg->regip4_event = NULL;\n  }\n\n  if (configchg->regip6_event != NULL) {\n    CloseHandle(configchg->regip6_event);\n    configchg->regip6_event = NULL;\n  }\n#  endif\n\n  ares_free(configchg);\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_destroy",
            "parameters": {
              "configchg": "ares_event_configchg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void NETIOAPI_API_\n  ares_event_configchg_ip_cb(PVOID CallerContext, PMIB_IPINTERFACE_ROW Row,\n                             MIB_NOTIFICATION_TYPE NotificationType)\n{\n  ares_event_configchg_t *configchg = CallerContext;\n  (void)Row;\n  (void)NotificationType;\n  ares_reinit(configchg->e->channel);\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NETIOAPI_API_\n  ares_event_configchg_ip_cb",
            "parameters": {
              "CallerContext": "PVOID",
              "Row": "PMIB_IPINTERFACE_ROW",
              "NotificationType": "MIB_NOTIFICATION_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t\n  ares_event_configchg_regnotify(ares_event_configchg_t *configchg)\n{\n#  if defined(HAVE_REGISTERWAITFORSINGLEOBJECT) && defined(HAVE_REGNOTIFYCHANGEKEYVALUE)\n#    if defined(__WATCOMC__) && !defined(REG_NOTIFY_THREAD_AGNOSTIC)\n#      define REG_NOTIFY_THREAD_AGNOSTIC 0x10000000L\n#    endif\n  DWORD flags = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET |\n                REG_NOTIFY_THREAD_AGNOSTIC;\n\n  if (RegNotifyChangeKeyValue(configchg->regip4, TRUE, flags,\n                              configchg->regip4_event, TRUE) != ERROR_SUCCESS) {\n    return ARES_FALSE;\n  }\n\n  if (RegNotifyChangeKeyValue(configchg->regip6, TRUE, flags,\n                              configchg->regip6_event, TRUE) != ERROR_SUCCESS) {\n    return ARES_FALSE;\n  }\n#  else\n  (void)configchg;\n#  endif\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              255,
              0
            ],
            [
              278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_regnotify",
            "parameters": {
              "configchg": "ares_event_configchg_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static VOID CALLBACK ares_event_configchg_reg_cb(PVOID   lpParameter,\n                                                 BOOLEAN TimerOrWaitFired)\n{\n  ares_event_configchg_t *configchg = lpParameter;\n  (void)TimerOrWaitFired;\n\n  ares_reinit(configchg->e->channel);\n\n  /* Re-arm, as its single-shot.  However, we don't know which one needs to\n   * be re-armed, so we just do both */\n  ares_event_configchg_regnotify(configchg);\n}",
          "fn_code_pos": [
            [
              280,
              0
            ],
            [
              291,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_reg_cb",
            "parameters": {
              "lpParameter": "PVOID",
              "TimerOrWaitFired": "BOOLEAN"
            },
            "return_type": "VOID"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,\n                                        ares_event_thread_t     *e)\n{\n  ares_status_t           status = ARES_SUCCESS;\n  ares_event_configchg_t *c      = NULL;\n\n  c = ares_malloc_zero(sizeof(**configchg));\n  if (c == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  c->e = e;\n\n#  ifdef HAVE_NOTIFYIPINTERFACECHANGE\n  /* NOTE: If a user goes into the control panel and changes the network\n   *       adapter DNS addresses manually, this will NOT trigger a notification.\n   *       We've also tried listening on NotifyUnicastIpAddressChange(), but\n   *       that didn't get triggered either.\n   */\n  if (NotifyIpInterfaceChange(AF_UNSPEC, ares_event_configchg_ip_cb, c, FALSE,\n                              &c->ifchg_hnd) != NO_ERROR) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n#  endif\n\n#  ifdef HAVE_REGISTERWAITFORSINGLEOBJECT\n  /* Monitor HKLM\\SYSTEM\\CurrentControlSet\\Services\\Tcpip6\\Parameters\\Interfaces\n   * and HKLM\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\n   * for changes via RegNotifyChangeKeyValue() */\n  if (RegOpenKeyExW(\n        HKEY_LOCAL_MACHINE,\n        L\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\\\\Interfaces\",\n        0, KEY_NOTIFY, &c->regip4) != ERROR_SUCCESS) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  if (RegOpenKeyExW(\n        HKEY_LOCAL_MACHINE,\n        L\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip6\\\\Parameters\\\\Interfaces\",\n        0, KEY_NOTIFY, &c->regip6) != ERROR_SUCCESS) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  c->regip4_event = CreateEvent(NULL, TRUE, FALSE, NULL);\n  if (c->regip4_event == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  c->regip6_event = CreateEvent(NULL, TRUE, FALSE, NULL);\n  if (c->regip6_event == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  if (!RegisterWaitForSingleObject(&c->regip4_wait, c->regip4_event,\n                                   ares_event_configchg_reg_cb, c, INFINITE,\n                                   WT_EXECUTEDEFAULT)) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  if (!RegisterWaitForSingleObject(&c->regip6_wait, c->regip6_event,\n                                   ares_event_configchg_reg_cb, c, INFINITE,\n                                   WT_EXECUTEDEFAULT)) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n#  endif\n\n  if (!ares_event_configchg_regnotify(c)) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_event_configchg_destroy(c);\n  } else {\n    *configchg = c;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_init",
            "parameters": {
              "configchg": "ares_event_configchg_t",
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_event_configchg_destroy(ares_event_configchg_t *configchg)\n{\n  (void)configchg;\n\n  /* Cleanup happens automatically */\n}",
          "fn_code_pos": [
            [
              395,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_destroy",
            "parameters": {
              "configchg": "ares_event_configchg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_configchg_free(void *data)\n{\n  ares_event_configchg_t *configchg = data;\n  if (configchg == NULL) {\n    return;\n  }\n\n  if (configchg->fd >= 0) {\n    notify_cancel(configchg->token);\n    /* automatically closes fd */\n    configchg->fd = -1;\n  }\n\n  ares_free(configchg);\n}",
          "fn_code_pos": [
            [
              402,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_free",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_configchg_cb(ares_event_thread_t *e, ares_socket_t fd,\n                                    void *data, ares_event_flags_t flags)\n{\n  ares_event_configchg_t *configchg = data;\n  ares_bool_t             triggered = ARES_FALSE;\n\n  (void)fd;\n  (void)flags;\n\n  while (1) {\n    int     t = 0;\n    ssize_t len;\n\n    len = read(configchg->fd, &t, sizeof(t));\n\n    if (len < (ssize_t)sizeof(t)) {\n      break;\n    }\n\n    /* Token is read in network byte order (yeah, docs don't mention this) */\n    t = (int)ntohl(t);\n\n    if (t != configchg->token) {\n      continue;\n    }\n\n    triggered = ARES_TRUE;\n  }\n\n  /* Only process after all events are read.  No need to process more often as\n   * we don't want to reload the config back to back */\n  if (triggered) {\n    ares_reinit(e->channel);\n  }\n}",
          "fn_code_pos": [
            [
              418,
              0
            ],
            [
              452,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_cb",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,\n                                        ares_event_thread_t     *e)\n{\n  ares_status_t status                               = ARES_SUCCESS;\n  void         *handle                               = NULL;\n  const char *(*pdns_configuration_notify_key)(void) = NULL;\n  const char *notify_key                             = NULL;\n  int         flags;\n  size_t      i;\n  const char *searchlibs[] = {\n    \"/usr/lib/libSystem.dylib\",\n    \"/System/Library/Frameworks/SystemConfiguration.framework/\"\n    \"SystemConfiguration\",\n    NULL\n  };\n\n  *configchg = ares_malloc_zero(sizeof(**configchg));\n  if (*configchg == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  /* Load symbol as it isn't normally public */\n  for (i = 0; searchlibs[i] != NULL; i++) {\n    handle = dlopen(searchlibs[i], RTLD_LAZY);\n    if (handle == NULL) {\n      /* Fail, loop! */\n      continue;\n    }\n\n    pdns_configuration_notify_key =\n      (const char *(*)(void))dlsym(handle, \"dns_configuration_notify_key\");\n    if (pdns_configuration_notify_key != NULL) {\n      break;\n    }\n\n    /* Fail, loop! */\n    dlclose(handle);\n    handle = NULL;\n  }\n\n  if (pdns_configuration_notify_key == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  notify_key = pdns_configuration_notify_key();\n  if (notify_key == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  if (notify_register_file_descriptor(notify_key, &(*configchg)->fd, 0,\n                                      &(*configchg)->token) !=\n      NOTIFY_STATUS_OK) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  /* Set file descriptor to non-blocking */\n  flags = fcntl((*configchg)->fd, F_GETFL, 0);\n  fcntl((*configchg)->fd, F_SETFL, flags | O_NONBLOCK);\n\n  /* Register file descriptor with event subsystem */\n  status = ares_event_update(NULL, e, ARES_EVENT_FLAG_READ,\n                             ares_event_configchg_cb, (*configchg)->fd,\n                             *configchg, ares_event_configchg_free, NULL);\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_event_configchg_free(*configchg);\n    *configchg = NULL;\n  }\n\n  if (handle) {\n    dlclose(handle);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              454,
              0
            ],
            [
              532,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_init",
            "parameters": {
              "configchg": "ares_event_configchg_t",
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t config_change_check(ares_htable_strvp_t *filestat,\n                                         const char          *resolvconf_path)\n{\n  size_t      i;\n  const char *configfiles[16];\n  ares_bool_t changed = ARES_FALSE;\n  size_t      cnt = 0;\n\n  memset(configfiles, 0, sizeof(configfiles));\n\n  configfiles[cnt++] = resolvconf_path;\n  configfiles[cnt++] = \"/etc/nsswitch.conf\";\n#ifdef _AIX\n  configfiles[cnt++] = \"/etc/netsvc.conf\";\n#endif\n#ifdef __osf /* Tru64 */\n  configfiles[cnt++] = \"/etc/svc.conf\";\n#endif\n#ifdef __QNX__\n  configfiles[cnt++] = \"/etc/net.cfg\";\n#endif\n  configfiles[cnt++] = NULL;\n\n  for (i = 0; configfiles[i] != NULL; i++) {\n    fileinfo_t *fi = ares_htable_strvp_get_direct(filestat, configfiles[i]);\n    struct stat st;\n\n    if (stat(configfiles[i], &st) == 0) {\n      if (fi == NULL) {\n        fi = ares_malloc_zero(sizeof(*fi));\n        if (fi == NULL) {\n          return ARES_ENOMEM;\n        }\n        if (!ares_htable_strvp_insert(filestat, configfiles[i], fi)) {\n          ares_free(fi);\n          return ARES_ENOMEM;\n        }\n      }\n      if (fi->size != (size_t)st.st_size || fi->mtime != (time_t)st.st_mtime) {\n        changed = ARES_TRUE;\n      }\n      fi->size  = (size_t)st.st_size;\n      fi->mtime = (time_t)st.st_mtime;\n    } else if (fi != NULL) {\n      /* File no longer exists, remove */\n      ares_htable_strvp_remove(filestat, configfiles[i]);\n      changed = ARES_TRUE;\n    }\n  }\n\n  if (changed) {\n    return ARES_SUCCESS;\n  }\n  return ARES_ENOTFOUND;\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              611,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "config_change_check",
            "parameters": {
              "filestat": "ares_htable_strvp_t",
              "resolvconf_path": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void *ares_event_configchg_thread(void *arg)\n{\n  ares_event_configchg_t *c = arg;\n\n  ares_thread_mutex_lock(c->lock);\n  while (c->isup) {\n    ares_status_t status;\n\n    if (ares_thread_cond_timedwait(c->wake, c->lock, 30000) != ARES_ETIMEOUT) {\n      continue;\n    }\n\n    /* make sure status didn't change even though we got a timeout */\n    if (!c->isup) {\n      break;\n    }\n\n    status = config_change_check(c->filestat, c->resolvconf_path);\n    if (status == ARES_SUCCESS) {\n      ares_reinit(c->e->channel);\n    }\n  }\n\n  ares_thread_mutex_unlock(c->lock);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              613,
              0
            ],
            [
              638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_thread",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,\n                                        ares_event_thread_t     *e)\n{\n  ares_status_t           status = ARES_SUCCESS;\n  ares_event_configchg_t *c      = NULL;\n\n  *configchg = NULL;\n\n  c = ares_malloc_zero(sizeof(*c));\n  if (c == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  c->e = e;\n\n  c->filestat = ares_htable_strvp_create(ares_free);\n  if (c->filestat == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  c->wake = ares_thread_cond_create();\n  if (c->wake == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  c->lock = ares_thread_mutex_create();\n  if (c->lock == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  c->resolvconf_path = c->e->channel->resolvconf_path;\n  if (c->resolvconf_path == NULL) {\n    c->resolvconf_path = PATH_RESOLV_CONF;\n  }\n\n  status = config_change_check(c->filestat, c->resolvconf_path);\n  if (status == ARES_ENOMEM) {\n    goto done;\n  }\n\n  c->isup = ARES_TRUE;\n  status  = ares_thread_create(&c->thread, ares_event_configchg_thread, c);\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_event_configchg_destroy(c);\n  } else {\n    *configchg = c;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              640,
              0
            ],
            [
              694,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_init",
            "parameters": {
              "configchg": "ares_event_configchg_t",
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_event_configchg_destroy(ares_event_configchg_t *configchg)\n{\n  if (configchg == NULL) {\n    return;\n  }\n\n  if (configchg->lock) {\n    ares_thread_mutex_lock(configchg->lock);\n  }\n\n  configchg->isup = ARES_FALSE;\n  if (configchg->wake) {\n    ares_thread_cond_signal(configchg->wake);\n  }\n\n  if (configchg->lock) {\n    ares_thread_mutex_unlock(configchg->lock);\n  }\n\n  if (configchg->thread) {\n    void *rv = NULL;\n    ares_thread_join(configchg->thread, &rv);\n  }\n\n  ares_thread_mutex_destroy(configchg->lock);\n  ares_thread_cond_destroy(configchg->wake);\n  ares_htable_strvp_destroy(configchg->filestat);\n  ares_free(configchg);\n}",
          "fn_code_pos": [
            [
              696,
              0
            ],
            [
              724,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_destroy",
            "parameters": {
              "configchg": "ares_event_configchg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,\n                                        ares_event_thread_t     *e)\n{\n  (void)configchg;\n  (void)e;\n  /* No ability */\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              728,
              0
            ],
            [
              735,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_init",
            "parameters": {
              "configchg": "ares_event_configchg_t",
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_event_configchg_destroy(ares_event_configchg_t *configchg)\n{\n  /* No-op */\n  (void)configchg;\n}",
          "fn_code_pos": [
            [
              737,
              0
            ],
            [
              741,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_destroy",
            "parameters": {
              "configchg": "ares_event_configchg_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*pdns_configuration_notify_key)(void)",
          "fn_dec_pos": [
            [
              459,
              14
            ],
            [
              459,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_event_configchg_thread(void *arg)",
          "fn_dec_pos": [
            [
              613,
              13
            ],
            [
              613,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_thread",
            "parameters": {
              "arg": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_event_configchg {\n  int                  inotify_fd;\n  ares_event_thread_t *e;\n}",
          {
            "inotify_fd": "int",
            "*e": "ares_event_thread_t"
          },
          "ares_event_configchg",
          [
            49,
            0
          ],
          [
            52,
            1
          ]
        ],
        [
          "struct ares_event_configchg {\n  HANDLE               ifchg_hnd;\n  HKEY                 regip4;\n  HANDLE               regip4_event;\n  HANDLE               regip4_wait;\n  HKEY                 regip6;\n  HANDLE               regip6_event;\n  HANDLE               regip6_wait;\n  ares_event_thread_t *e;\n}",
          {
            "ifchg_hnd": "HANDLE",
            "regip4": "HKEY",
            "regip4_event": "HANDLE",
            "regip4_wait": "HANDLE",
            "regip6": "HKEY",
            "regip6_event": "HANDLE",
            "regip6_wait": "HANDLE",
            "*e": "ares_event_thread_t"
          },
          "ares_event_configchg",
          [
            183,
            0
          ],
          [
            192,
            1
          ]
        ],
        [
          "struct ares_event_configchg {\n  int fd;\n  int token;\n}",
          {
            "fd": "int",
            "token": "int"
          },
          "ares_event_configchg",
          [
            390,
            0
          ],
          [
            393,
            1
          ]
        ],
        [
          "typedef struct {\n  size_t size;\n  time_t mtime;\n} fileinfo_t;",
          {
            "size": "size_t",
            "mtime": "time_t"
          },
          "fileinfo_t",
          [
            542,
            0
          ],
          [
            545,
            13
          ]
        ],
        [
          "struct ares_event_configchg {\n  ares_bool_t          isup;\n  ares_thread_t       *thread;\n  ares_htable_strvp_t *filestat;\n  ares_thread_mutex_t *lock;\n  ares_thread_cond_t  *wake;\n  const char          *resolvconf_path;\n  ares_event_thread_t *e;\n}",
          {
            "isup": "ares_bool_t",
            "*thread": "ares_thread_t",
            "*filestat": "ares_htable_strvp_t",
            "*lock": "ares_thread_mutex_t",
            "*wake": "ares_thread_cond_t",
            "char": "const",
            "*e": "ares_event_thread_t"
          },
          "ares_event_configchg",
          [
            547,
            0
          ],
          [
            555,
            1
          ]
        ],
        [
          "struct ares_event_configchg {\n  int                  inotify_fd;\n  ares_event_thread_t *e;\n}",
          {
            "inotify_fd": "int",
            "*e": "ares_event_thread_t"
          },
          "ares_event_configchg",
          [
            49,
            0
          ],
          [
            52,
            1
          ]
        ],
        [
          "struct inotify_event",
          {},
          "",
          [
            92,
            39
          ],
          [
            92,
            59
          ]
        ],
        [
          "struct inotify_event",
          {},
          "",
          [
            93,
            8
          ],
          [
            93,
            28
          ]
        ],
        [
          "struct inotify_event",
          {},
          "",
          [
            111,
            23
          ],
          [
            111,
            43
          ]
        ],
        [
          "struct inotify_event",
          {},
          "",
          [
            112,
            21
          ],
          [
            112,
            41
          ]
        ],
        [
          "struct ares_event_configchg {\n  HANDLE               ifchg_hnd;\n  HKEY                 regip4;\n  HANDLE               regip4_event;\n  HANDLE               regip4_wait;\n  HKEY                 regip6;\n  HANDLE               regip6_event;\n  HANDLE               regip6_wait;\n  ares_event_thread_t *e;\n}",
          {
            "ifchg_hnd": "HANDLE",
            "regip4": "HKEY",
            "regip4_event": "HANDLE",
            "regip4_wait": "HANDLE",
            "regip6": "HKEY",
            "regip6_event": "HANDLE",
            "regip6_wait": "HANDLE",
            "*e": "ares_event_thread_t"
          },
          "ares_event_configchg",
          [
            183,
            0
          ],
          [
            192,
            1
          ]
        ],
        [
          "struct ares_event_configchg {\n  int fd;\n  int token;\n}",
          {
            "fd": "int",
            "token": "int"
          },
          "ares_event_configchg",
          [
            390,
            0
          ],
          [
            393,
            1
          ]
        ],
        [
          "typedef struct {\n  size_t size;\n  time_t mtime;\n} fileinfo_t;",
          {
            "size": "size_t",
            "mtime": "time_t"
          },
          "fileinfo_t",
          [
            542,
            0
          ],
          [
            545,
            13
          ]
        ],
        [
          "struct ares_event_configchg {\n  ares_bool_t          isup;\n  ares_thread_t       *thread;\n  ares_htable_strvp_t *filestat;\n  ares_thread_mutex_t *lock;\n  ares_thread_cond_t  *wake;\n  const char          *resolvconf_path;\n  ares_event_thread_t *e;\n}",
          {
            "isup": "ares_bool_t",
            "*thread": "ares_thread_t",
            "*filestat": "ares_htable_strvp_t",
            "*lock": "ares_thread_mutex_t",
            "*wake": "ares_thread_cond_t",
            "char": "const",
            "*e": "ares_event_thread_t"
          },
          "ares_event_configchg",
          [
            547,
            0
          ],
          [
            555,
            1
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            582,
            4
          ],
          [
            582,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <sys/inotify.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <winsock2.h>\n",
          [
            178,
            0
          ],
          [
            179,
            0
          ]
        ],
        [
          "#  include <iphlpapi.h>\n",
          [
            179,
            0
          ],
          [
            180,
            0
          ]
        ],
        [
          "#  include <stdio.h>\n",
          [
            180,
            0
          ],
          [
            181,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            181,
            0
          ],
          [
            182,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            383,
            0
          ],
          [
            384,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            384,
            0
          ],
          [
            385,
            0
          ]
        ],
        [
          "#  include <stdbool.h>\n",
          [
            385,
            0
          ],
          [
            386,
            0
          ]
        ],
        [
          "#  include <notify.h>\n",
          [
            386,
            0
          ],
          [
            387,
            0
          ]
        ],
        [
          "#  include <dlfcn.h>\n",
          [
            387,
            0
          ],
          [
            388,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            388,
            0
          ],
          [
            389,
            0
          ]
        ],
        [
          "#    include <sys/types.h>\n",
          [
            536,
            0
          ],
          [
            537,
            0
          ]
        ],
        [
          "#    include <sys/stat.h>\n",
          [
            539,
            0
          ],
          [
            540,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_epoll.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_evsys_epoll_destroy(ares_event_thread_t *e)\n{\n  ares_evsys_epoll_t *ep = NULL;\n\n  if (e == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  ep = e->ev_sys_data;\n  if (ep == NULL) {\n    return; /* LCOV_EXCL_LINE: DefensiveCoding */\n  }\n\n  if (ep->epoll_fd != -1) {\n    close(ep->epoll_fd);\n  }\n\n  ares_free(ep);\n  e->ev_sys_data = NULL;\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_epoll_init(ares_event_thread_t *e)\n{\n  ares_evsys_epoll_t *ep = NULL;\n\n  ep = ares_malloc_zero(sizeof(*ep));\n  if (ep == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: OutOfMemory */\n  }\n\n  e->ev_sys_data = ep;\n\n  ep->epoll_fd = epoll_create1(EPOLL_CLOEXEC);\n  if (ep->epoll_fd == -1) {\n    ares_evsys_epoll_destroy(e); /* LCOV_EXCL_LINE: UntestablePath */\n    return ARES_FALSE;           /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  e->ev_signal = ares_pipeevent_create(e);\n  if (e->ev_signal == NULL) {\n    ares_evsys_epoll_destroy(e); /* LCOV_EXCL_LINE: UntestablePath */\n    return ARES_FALSE;           /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_epoll_event_add(ares_event_t *event)\n{\n  const ares_event_thread_t *e  = event->e;\n  const ares_evsys_epoll_t  *ep = e->ev_sys_data;\n  struct epoll_event         epev;\n\n  memset(&epev, 0, sizeof(epev));\n  epev.data.fd = event->fd;\n  epev.events  = EPOLLRDHUP | EPOLLERR | EPOLLHUP;\n  if (event->flags & ARES_EVENT_FLAG_READ) {\n    epev.events |= EPOLLIN;\n  }\n  if (event->flags & ARES_EVENT_FLAG_WRITE) {\n    epev.events |= EPOLLOUT;\n  }\n  if (epoll_ctl(ep->epoll_fd, EPOLL_CTL_ADD, event->fd, &epev) != 0) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_epoll_event_del(ares_event_t *event)\n{\n  const ares_event_thread_t *e  = event->e;\n  const ares_evsys_epoll_t  *ep = e->ev_sys_data;\n  struct epoll_event         epev;\n\n  memset(&epev, 0, sizeof(epev));\n  epev.data.fd = event->fd;\n  epoll_ctl(ep->epoll_fd, EPOLL_CTL_DEL, event->fd, &epev);\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_epoll_event_mod(ares_event_t      *event,\n                                       ares_event_flags_t new_flags)\n{\n  const ares_event_thread_t *e  = event->e;\n  const ares_evsys_epoll_t  *ep = e->ev_sys_data;\n  struct epoll_event         epev;\n\n  memset(&epev, 0, sizeof(epev));\n  epev.data.fd = event->fd;\n  epev.events  = EPOLLRDHUP | EPOLLERR | EPOLLHUP;\n  if (new_flags & ARES_EVENT_FLAG_READ) {\n    epev.events |= EPOLLIN;\n  }\n  if (new_flags & ARES_EVENT_FLAG_WRITE) {\n    epev.events |= EPOLLOUT;\n  }\n  epoll_ctl(ep->epoll_fd, EPOLL_CTL_MOD, event->fd, &epev);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_epoll_wait(ares_event_thread_t *e,\n                                    unsigned long        timeout_ms)\n{\n  struct epoll_event        events[8];\n  size_t                    nevents = sizeof(events) / sizeof(*events);\n  const ares_evsys_epoll_t *ep      = e->ev_sys_data;\n  int                       rv;\n  size_t                    i;\n  size_t                    cnt = 0;\n\n  memset(events, 0, sizeof(events));\n\n  rv = epoll_wait(ep->epoll_fd, events, (int)nevents,\n                  (timeout_ms == 0) ? -1 : (int)timeout_ms);\n  if (rv < 0) {\n    return 0; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n\n  nevents = (size_t)rv;\n\n  for (i = 0; i < nevents; i++) {\n    ares_event_t      *ev;\n    ares_event_flags_t flags = 0;\n\n    ev = ares_htable_asvp_get_direct(e->ev_sock_handles,\n                                     (ares_socket_t)events[i].data.fd);\n    if (ev == NULL || ev->cb == NULL) {\n      continue; /* LCOV_EXCL_LINE: DefensiveCoding */\n    }\n\n    cnt++;\n\n    if (events[i].events & (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLERR)) {\n      flags |= ARES_EVENT_FLAG_READ;\n    }\n    if (events[i].events & EPOLLOUT) {\n      flags |= ARES_EVENT_FLAG_WRITE;\n    }\n\n    ev->cb(e, ev->fd, ev->data, flags);\n  }\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              139,
              0
            ],
            [
              182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  int epoll_fd;\n} ares_evsys_epoll_t;",
          {
            "epoll_fd": "int"
          },
          "ares_evsys_epoll_t",
          [
            37,
            0
          ],
          [
            39,
            21
          ]
        ],
        [
          "typedef struct {\n  int epoll_fd;\n} ares_evsys_epoll_t;",
          {
            "epoll_fd": "int"
          },
          "ares_evsys_epoll_t",
          [
            37,
            0
          ],
          [
            39,
            21
          ]
        ],
        [
          "struct epoll_event",
          {},
          "",
          [
            92,
            2
          ],
          [
            92,
            20
          ]
        ],
        [
          "struct epoll_event",
          {},
          "",
          [
            113,
            2
          ],
          [
            113,
            20
          ]
        ],
        [
          "struct epoll_event",
          {},
          "",
          [
            125,
            2
          ],
          [
            125,
            20
          ]
        ],
        [
          "struct epoll_event",
          {},
          "",
          [
            142,
            2
          ],
          [
            142,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <sys/epoll.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_kqueue.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_evsys_kqueue_destroy(ares_event_thread_t *e)\n{\n  ares_evsys_kqueue_t *kq = NULL;\n\n  if (e == NULL) {\n    return;\n  }\n\n  kq = e->ev_sys_data;\n  if (kq == NULL) {\n    return;\n  }\n\n  if (kq->kqueue_fd != -1) {\n    close(kq->kqueue_fd);\n  }\n\n  ares_free(kq->changelist);\n  ares_free(kq);\n  e->ev_sys_data = NULL;\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_kqueue_init(ares_event_thread_t *e)\n{\n  ares_evsys_kqueue_t *kq = NULL;\n\n  kq = ares_malloc_zero(sizeof(*kq));\n  if (kq == NULL) {\n    return ARES_FALSE;\n  }\n\n  e->ev_sys_data = kq;\n\n  kq->kqueue_fd = kqueue();\n  if (kq->kqueue_fd == -1) {\n    ares_evsys_kqueue_destroy(e);\n    return ARES_FALSE;\n  }\n\n#  ifdef FD_CLOEXEC\n  fcntl(kq->kqueue_fd, F_SETFD, FD_CLOEXEC);\n#  endif\n\n  kq->nchanges_alloc = 8;\n  kq->changelist =\n    ares_malloc_zero(kq->nchanges_alloc * sizeof(*kq->changelist));\n  if (kq->changelist == NULL) {\n    ares_evsys_kqueue_destroy(e);\n    return ARES_FALSE;\n  }\n\n  e->ev_signal = ares_pipeevent_create(e);\n  if (e->ev_signal == NULL) {\n    ares_evsys_kqueue_destroy(e);\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_kqueue_enqueue(ares_evsys_kqueue_t *kq, int fd,\n                                      int16_t filter, uint16_t flags)\n{\n  size_t idx;\n\n  if (kq == NULL) {\n    return;\n  }\n\n  idx = kq->nchanges;\n\n  kq->nchanges++;\n\n  if (kq->nchanges > kq->nchanges_alloc) {\n    kq->nchanges_alloc <<= 1;\n    kq->changelist       = ares_realloc_zero(\n      kq->changelist, (kq->nchanges_alloc >> 1) * sizeof(*kq->changelist),\n      kq->nchanges_alloc * sizeof(*kq->changelist));\n  }\n\n  EV_SET(&kq->changelist[idx], fd, filter, flags, 0, 0, 0);\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_enqueue",
            "parameters": {
              "kq": "ares_evsys_kqueue_t",
              "fd": "int",
              "filter": "int16_t",
              "flags": "uint16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_kqueue_event_process(ares_event_t      *event,\n                                            ares_event_flags_t old_flags,\n                                            ares_event_flags_t new_flags)\n{\n  ares_event_thread_t *e = event->e;\n  ares_evsys_kqueue_t *kq;\n\n  if (e == NULL) {\n    return;\n  }\n\n  kq = e->ev_sys_data;\n  if (kq == NULL) {\n    return;\n  }\n\n  if (new_flags & ARES_EVENT_FLAG_READ && !(old_flags & ARES_EVENT_FLAG_READ)) {\n    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_READ, EV_ADD | EV_ENABLE);\n  }\n\n  if (!(new_flags & ARES_EVENT_FLAG_READ) && old_flags & ARES_EVENT_FLAG_READ) {\n    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_READ, EV_DELETE);\n  }\n\n  if (new_flags & ARES_EVENT_FLAG_WRITE &&\n      !(old_flags & ARES_EVENT_FLAG_WRITE)) {\n    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_WRITE, EV_ADD | EV_ENABLE);\n  }\n\n  if (!(new_flags & ARES_EVENT_FLAG_WRITE) &&\n      old_flags & ARES_EVENT_FLAG_WRITE) {\n    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_WRITE, EV_DELETE);\n  }\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_event_process",
            "parameters": {
              "event": "ares_event_t",
              "old_flags": "ares_event_flags_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_kqueue_event_add(ares_event_t *event)\n{\n  ares_evsys_kqueue_event_process(event, 0, event->flags);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_kqueue_event_del(ares_event_t *event)\n{\n  ares_evsys_kqueue_event_process(event, event->flags, 0);\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_kqueue_event_mod(ares_event_t      *event,\n                                        ares_event_flags_t new_flags)\n{\n  ares_evsys_kqueue_event_process(event, event->flags, new_flags);\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_kqueue_wait(ares_event_thread_t *e,\n                                     unsigned long        timeout_ms)\n{\n  struct kevent        events[8];\n  size_t               nevents = sizeof(events) / sizeof(*events);\n  ares_evsys_kqueue_t *kq      = e->ev_sys_data;\n  int                  rv;\n  size_t               i;\n  struct timespec      ts;\n  struct timespec     *timeout = NULL;\n  size_t               cnt     = 0;\n\n  if (timeout_ms != 0) {\n    ts.tv_sec  = (time_t)timeout_ms / 1000;\n    ts.tv_nsec = (timeout_ms % 1000) * 1000 * 1000;\n    timeout    = &ts;\n  }\n\n  memset(events, 0, sizeof(events));\n\n  rv = kevent(kq->kqueue_fd, kq->changelist, (int)kq->nchanges, events,\n              (int)nevents, timeout);\n  if (rv < 0) {\n    return 0;\n  }\n\n  /* Changelist was consumed */\n  kq->nchanges = 0;\n  nevents      = (size_t)rv;\n\n  for (i = 0; i < nevents; i++) {\n    ares_event_t      *ev;\n    ares_event_flags_t flags = 0;\n\n    ev = ares_htable_asvp_get_direct(e->ev_sock_handles,\n                                     (ares_socket_t)events[i].ident);\n    if (ev == NULL || ev->cb == NULL) {\n      continue;\n    }\n\n    cnt++;\n\n    if (events[i].filter == EVFILT_READ ||\n        events[i].flags & (EV_EOF | EV_ERROR)) {\n      flags |= ARES_EVENT_FLAG_READ;\n    } else {\n      flags |= ARES_EVENT_FLAG_WRITE;\n    }\n\n    ev->cb(e, ev->fd, ev->data, flags);\n  }\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  int            kqueue_fd;\n  struct kevent *changelist;\n  size_t         nchanges;\n  size_t         nchanges_alloc;\n} ares_evsys_kqueue_t;",
          {
            "kqueue_fd": "int",
            "*changelist": "struct kevent",
            "nchanges": "size_t",
            "nchanges_alloc": "size_t"
          },
          "ares_evsys_kqueue_t",
          [
            43,
            0
          ],
          [
            48,
            22
          ]
        ],
        [
          "typedef struct {\n  int            kqueue_fd;\n  struct kevent *changelist;\n  size_t         nchanges;\n  size_t         nchanges_alloc;\n} ares_evsys_kqueue_t;",
          {
            "kqueue_fd": "int",
            "*changelist": "struct kevent",
            "nchanges": "size_t",
            "nchanges_alloc": "size_t"
          },
          "ares_evsys_kqueue_t",
          [
            43,
            0
          ],
          [
            48,
            22
          ]
        ],
        [
          "struct kevent",
          {},
          "",
          [
            45,
            2
          ],
          [
            45,
            15
          ]
        ],
        [
          "struct kevent",
          {},
          "",
          [
            188,
            2
          ],
          [
            188,
            15
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            193,
            2
          ],
          [
            193,
            17
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            194,
            2
          ],
          [
            194,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <sys/event.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <sys/time.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_select.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t ares_evsys_select_init(ares_event_thread_t *e)\n{\n  e->ev_signal = ares_pipeevent_create(e);\n  if (e->ev_signal == NULL) {\n    return ARES_FALSE; /* LCOV_EXCL_LINE: UntestablePath */\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_select_destroy(ares_event_thread_t *e)\n{\n  (void)e;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_select_event_add(ares_event_t *event)\n{\n  (void)event;\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_select_event_del(ares_event_t *event)\n{\n  (void)event;\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_select_event_mod(ares_event_t      *event,\n                                        ares_event_flags_t new_flags)\n{\n  (void)event;\n  (void)new_flags;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_select_wait(ares_event_thread_t *e,\n                                     unsigned long        timeout_ms)\n{\n  size_t          num_fds = 0;\n  ares_socket_t  *fdlist  = ares_htable_asvp_keys(e->ev_sock_handles, &num_fds);\n  int             rv;\n  size_t          cnt = 0;\n  size_t          i;\n  fd_set          read_fds;\n  fd_set          write_fds;\n  fd_set          except_fds;\n  int             nfds = 0;\n  struct timeval  tv;\n  struct timeval *tout = NULL;\n\n  FD_ZERO(&read_fds);\n  FD_ZERO(&write_fds);\n  FD_ZERO(&except_fds);\n\n  for (i = 0; i < num_fds; i++) {\n    const ares_event_t *ev =\n      ares_htable_asvp_get_direct(e->ev_sock_handles, fdlist[i]);\n    if (ev->flags & ARES_EVENT_FLAG_READ) {\n      FD_SET(ev->fd, &read_fds);\n    }\n    if (ev->flags & ARES_EVENT_FLAG_WRITE) {\n      FD_SET(ev->fd, &write_fds);\n    }\n    FD_SET(ev->fd, &except_fds);\n    if (ev->fd + 1 > nfds) {\n      nfds = ev->fd + 1;\n    }\n  }\n\n  if (timeout_ms) {\n    tv.tv_sec  = (int)(timeout_ms / 1000);\n    tv.tv_usec = (int)((timeout_ms % 1000) * 1000);\n    tout       = &tv;\n  }\n\n  rv = select(nfds, &read_fds, &write_fds, &except_fds, tout);\n  if (rv > 0) {\n    for (i = 0; i < num_fds; i++) {\n      ares_event_t      *ev;\n      ares_event_flags_t flags = 0;\n\n      ev = ares_htable_asvp_get_direct(e->ev_sock_handles, fdlist[i]);\n      if (ev == NULL || ev->cb == NULL) {\n        continue; /* LCOV_EXCL_LINE: DefensiveCoding */\n      }\n\n      if (FD_ISSET(fdlist[i], &read_fds) || FD_ISSET(fdlist[i], &except_fds)) {\n        flags |= ARES_EVENT_FLAG_READ;\n      }\n\n      if (FD_ISSET(fdlist[i], &write_fds)) {\n        flags |= ARES_EVENT_FLAG_WRITE;\n      }\n\n      if (flags == 0) {\n        continue;\n      }\n\n      cnt++;\n\n      ev->cb(e, fdlist[i], ev->data, flags);\n    }\n  }\n\n  ares_free(fdlist);\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            86,
            2
          ],
          [
            86,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            87,
            2
          ],
          [
            87,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <sys/select.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_win32.c": {
      "fn_def_list": [
        {
          "fn_code": "static void CARES_DEBUG_LOG(const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start(ap, fmt);\n#  ifdef CARES_DEBUG\n  vfprintf(stderr, fmt, ap);\n  fflush(stderr);\n#  endif\n  va_end(ap);\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CARES_DEBUG_LOG",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void   ares_iocpevent_signal(const ares_event_t *event)\n{\n  ares_event_thread_t          *e           = event->e;\n  ares_evsys_win32_t           *ew          = e->ev_sys_data;\n  ares_evsys_win32_eventdata_t *ed          = event->data;\n  ares_bool_t                   queue_event = ARES_FALSE;\n\n  ares_thread_mutex_lock(ed->lock);\n  if (ed->poll_status != POLL_STATUS_PENDING) {\n    ed->poll_status = POLL_STATUS_PENDING;\n    queue_event     = ARES_TRUE;\n  }\n  ares_thread_mutex_unlock(ed->lock);\n\n  if (!queue_event) {\n    return;\n  }\n\n  PostQueuedCompletionStatus(ew->iocp_handle, 0, (ULONG_PTR)event->data, NULL);\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iocpevent_signal",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_iocpevent_cb(ares_event_thread_t *e, ares_socket_t fd,\n                              void *data, ares_event_flags_t flags)\n{\n  ares_evsys_win32_eventdata_t *ed = data;\n  (void)e;\n  (void)fd;\n  (void)flags;\n  ares_thread_mutex_lock(ed->lock);\n  ed->poll_status = POLL_STATUS_NONE;\n  ares_thread_mutex_unlock(ed->lock);\n}",
          "fn_code_pos": [
            [
              274,
              0
            ],
            [
              284,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iocpevent_cb",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_event_t *ares_iocpevent_create(ares_event_thread_t *e)\n{\n  ares_event_t *event = NULL;\n  ares_status_t status;\n\n  status =\n    ares_event_update(&event, e, ARES_EVENT_FLAG_OTHER, ares_iocpevent_cb,\n                      ARES_SOCKET_BAD, NULL, NULL, ares_iocpevent_signal);\n  if (status != ARES_SUCCESS) {\n    return NULL;\n  }\n\n  return event;\n}",
          "fn_code_pos": [
            [
              286,
              0
            ],
            [
              299,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iocpevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_event_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_win32_destroy(ares_event_thread_t *e)\n{\n  ares_evsys_win32_t *ew = NULL;\n\n  if (e == NULL) {\n    return;\n  }\n\n  CARES_DEBUG_LOG(\"** Win32 Event Destroy\\n\");\n\n  ew = e->ev_sys_data;\n  if (ew == NULL) {\n    return;\n  }\n\n  ew->is_shutdown = ARES_TRUE;\n  CARES_DEBUG_LOG(\"  ** waiting on %lu remaining sockets to be destroyed\\n\",\n                  (unsigned long)ares_htable_vpvp_num_keys(ew->sockets));\n  while (ares_htable_vpvp_num_keys(ew->sockets)) {\n    ares_evsys_win32_wait(e, 0);\n  }\n  CARES_DEBUG_LOG(\"  ** all sockets cleaned up\\n\");\n\n\n  if (ew->iocp_handle != NULL) {\n    CloseHandle(ew->iocp_handle);\n  }\n\n  ares_slist_destroy(ew->afd_handles);\n\n  ares_htable_vpvp_destroy(ew->sockets);\n\n  ares_free(ew);\n  e->ev_sys_data = NULL;\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_afd_handle_destroy(void *arg)\n{\n  ares_afd_handle_t *hnd = arg;\n  if (hnd != NULL && hnd->afd_handle != NULL) {\n    CloseHandle(hnd->afd_handle);\n  }\n  ares_free(hnd);\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_afd_handle_destroy",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int ares_afd_handle_cmp(const void *data1, const void *data2)\n{\n  const ares_afd_handle_t *hnd1 = data1;\n  const ares_afd_handle_t *hnd2 = data2;\n\n  if (hnd1->poll_cnt > hnd2->poll_cnt) {\n    return 1;\n  }\n  if (hnd1->poll_cnt < hnd2->poll_cnt) {\n    return -1;\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_afd_handle_cmp",
            "parameters": {
              "data1": "void",
              "data2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void fill_object_attributes(OBJECT_ATTRIBUTES *attr,\n                                   UNICODE_STRING *name, ULONG attributes)\n{\n  memset(attr, 0, sizeof(*attr));\n  attr->Length     = sizeof(*attr);\n  attr->ObjectName = name;\n  attr->Attributes = attributes;\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_object_attributes",
            "parameters": {
              "attr": "OBJECT_ATTRIBUTES",
              "name": "UNICODE_STRING",
              "attributes": "ULONG"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_slist_node_t *ares_afd_handle_create(ares_evsys_win32_t *ew)\n{\n  UNICODE_STRING     afd_device_name = UNICODE_STRING_CONSTANT(\"\\\\Device\\\\Afd\");\n  OBJECT_ATTRIBUTES  afd_attributes;\n  NTSTATUS           status;\n  IO_STATUS_BLOCK    iosb;\n  ares_afd_handle_t *afd  = ares_malloc_zero(sizeof(*afd));\n  ares_slist_node_t *node = NULL;\n  if (afd == NULL) {\n    goto fail;\n  }\n\n  /* Open a handle to the AFD subsystem */\n  fill_object_attributes(&afd_attributes, &afd_device_name, 0);\n  memset(&iosb, 0, sizeof(iosb));\n  iosb.Status = STATUS_PENDING;\n  status      = ew->NtCreateFile(&afd->afd_handle, SYNCHRONIZE, &afd_attributes,\n                                 &iosb, NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,\n                                 FILE_OPEN, 0, NULL, 0);\n  if (status != STATUS_SUCCESS) {\n    CARES_DEBUG_LOG(\"** Failed to create AFD endpoint\\n\");\n    goto fail;\n  }\n\n  if (CreateIoCompletionPort(afd->afd_handle, ew->iocp_handle,\n                             0 /* CompletionKey */, 0) == NULL) {\n    goto fail;\n  }\n\n#ifdef HAVE_SETFILECOMPLETIONNOTIFICATIONMODES\n  if (!SetFileCompletionNotificationModes(afd->afd_handle,\n                                          FILE_SKIP_SET_EVENT_ON_HANDLE)) {\n    goto fail;\n  }\n#endif\n\n  node = ares_slist_insert(ew->afd_handles, afd);\n  if (node == NULL) {\n    goto fail;\n  }\n\n  return node;\n\nfail:\n\n  ares_afd_handle_destroy(afd);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              377,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_afd_handle_create",
            "parameters": {
              "ew": "ares_evsys_win32_t"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "static ares_slist_node_t *ares_afd_handle_fetch(ares_evsys_win32_t *ew)\n{\n  ares_slist_node_t *node = ares_slist_node_first(ew->afd_handles);\n  ares_afd_handle_t *afd  = ares_slist_node_val(node);\n\n  if (afd != NULL && afd->poll_cnt < AFD_POLL_PER_HANDLE) {\n    return node;\n  }\n\n  return ares_afd_handle_create(ew);\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              438,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_afd_handle_fetch",
            "parameters": {
              "ew": "ares_evsys_win32_t"
            },
            "return_type": "ares_slist_node_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_init(ares_event_thread_t *e)\n{\n  ares_evsys_win32_t *ew = NULL;\n  HMODULE             ntdll;\n\n  CARES_DEBUG_LOG(\"** Win32 Event Init\\n\");\n\n  ew = ares_malloc_zero(sizeof(*ew));\n  if (ew == NULL) {\n    return ARES_FALSE;\n  }\n\n  e->ev_sys_data = ew;\n\n  /* All apps should have ntdll.dll already loaded, so just get a handle to\n   * this */\n  ntdll = GetModuleHandleA(\"ntdll.dll\");\n  if (ntdll == NULL) {\n    goto fail;\n  }\n\n#  ifdef __GNUC__\n#    pragma GCC diagnostic push\n#    pragma GCC diagnostic ignored \"-Wpedantic\"\n/* Without the (void *) cast we get:\n *  warning: cast between incompatible function types from 'FARPROC' {aka 'long\n * long int (*)()'} to 'NTSTATUS (*)(...)'} [-Wcast-function-type] but with it\n * we get: warning: ISO C forbids conversion of function pointer to object\n * pointer type [-Wpedantic] look unsolvable short of killing the warning.\n */\n#  endif\n\n  /* Load Internal symbols not typically accessible */\n  ew->NtCreateFile =\n    (NtCreateFile_t)(void *)GetProcAddress(ntdll, \"NtCreateFile\");\n  ew->NtDeviceIoControlFile = (NtDeviceIoControlFile_t)(void *)GetProcAddress(\n    ntdll, \"NtDeviceIoControlFile\");\n  ew->NtCancelIoFileEx =\n    (NtCancelIoFileEx_t)(void *)GetProcAddress(ntdll, \"NtCancelIoFileEx\");\n\n#  ifdef __GNUC__\n#    pragma GCC diagnostic pop\n#  endif\n\n  if (ew->NtCreateFile == NULL || ew->NtCancelIoFileEx == NULL ||\n      ew->NtDeviceIoControlFile == NULL) {\n    goto fail;\n  }\n\n  ew->iocp_handle = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);\n  if (ew->iocp_handle == NULL) {\n    goto fail;\n  }\n\n  ew->afd_handles = ares_slist_create(\n    e->channel->rand_state, ares_afd_handle_cmp, ares_afd_handle_destroy);\n  if (ew->afd_handles == NULL) {\n    goto fail;\n  }\n\n  /* Create at least the first afd handle, so we know of any critical system\n   * issues during startup */\n  if (ares_afd_handle_create(ew) == NULL) {\n    goto fail;\n  }\n\n  e->ev_signal = ares_iocpevent_create(e);\n  if (e->ev_signal == NULL) {\n    goto fail;\n  }\n\n  ew->sockets = ares_htable_vpvp_create(NULL, NULL);\n  if (ew->sockets == NULL) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  ares_evsys_win32_destroy(e);\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              440,
              0
            ],
            [
              521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_socket_t ares_evsys_win32_basesocket(ares_socket_t socket)\n{\n#ifndef HAVE_WSAIOCTL\n  /* Assume we don't have an LSP and return the provided socket as the base\n   * socket.  WSAIoctl() isn't supported on Windows XP or below */\n  return socket;\n#else\n  while (1) {\n    DWORD         bytes; /* Not used */\n    ares_socket_t base_socket = ARES_SOCKET_BAD;\n    int           rv;\n\n    rv = WSAIoctl(socket, SIO_BASE_HANDLE, NULL, 0, &base_socket,\n                  sizeof(base_socket), &bytes, NULL, NULL);\n    if (rv != SOCKET_ERROR && base_socket != ARES_SOCKET_BAD) {\n      socket = base_socket;\n      break;\n    }\n\n    /* If we're here, an error occurred */\n    if (GetLastError() == WSAENOTSOCK) {\n      /* This is critical, exit */\n      return ARES_SOCKET_BAD;\n    }\n\n    /* Work around known bug in Komodia based LSPs, use ARES_BSP_HANDLE_POLL\n     * to retrieve the underlying socket to then loop and get the base socket:\n     *  https://docs.microsoft.com/en-us/windows/win32/winsock/winsock-ioctls\n     *  https://www.komodia.com/newwiki/index.php?title=Komodia%27s_Redirector_bug_fixes#Version_2.2.2.6\n     */\n    base_socket = ARES_SOCKET_BAD;\n    rv          = WSAIoctl(socket, SIO_BSP_HANDLE_POLL, NULL, 0, &base_socket,\n                           sizeof(base_socket), &bytes, NULL, NULL);\n\n    if (rv != SOCKET_ERROR && base_socket != ARES_SOCKET_BAD &&\n        base_socket != socket) {\n      socket = base_socket;\n      continue; /* loop! */\n    }\n\n    return ARES_SOCKET_BAD;\n  }\n\n  return socket;\n#endif\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_basesocket",
            "parameters": {
              "socket": "ares_socket_t"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_afd_enqueue(ares_event_t      *event,\n                                                ares_event_flags_t flags)\n{\n  ares_event_thread_t          *e  = event->e;\n  ares_evsys_win32_t           *ew = e->ev_sys_data;\n  ares_evsys_win32_eventdata_t *ed = event->data;\n  ares_afd_handle_t            *afd;\n  NTSTATUS                      status;\n\n  if (e == NULL || ed == NULL || ew == NULL) {\n    return ARES_FALSE;\n  }\n\n  /* Misuse */\n  if (ed->poll_status != POLL_STATUS_NONE) {\n    return ARES_FALSE;\n  }\n\n  ed->afd_handle_node = ares_afd_handle_fetch(ew);\n  /* System resource issue? */\n  if (ed->afd_handle_node == NULL) {\n    return ARES_FALSE;\n  }\n\n  afd = ares_slist_node_val(ed->afd_handle_node);\n\n  /* Enqueue AFD Poll */\n  ed->afd_poll_info.Exclusive         = FALSE;\n  ed->afd_poll_info.NumberOfHandles   = 1;\n  ed->afd_poll_info.Timeout.QuadPart  = LLONG_MAX;\n  ed->afd_poll_info.Handles[0].Handle = (HANDLE)ed->base_socket;\n  ed->afd_poll_info.Handles[0].Status = 0;\n  ed->afd_poll_info.Handles[0].Events = AFD_POLL_LOCAL_CLOSE;\n\n  if (flags & ARES_EVENT_FLAG_READ) {\n    ed->afd_poll_info.Handles[0].Events |=\n      (AFD_POLL_RECEIVE | AFD_POLL_DISCONNECT | AFD_POLL_ACCEPT |\n       AFD_POLL_ABORT);\n  }\n  if (flags & ARES_EVENT_FLAG_WRITE) {\n    ed->afd_poll_info.Handles[0].Events |=\n      (AFD_POLL_SEND | AFD_POLL_CONNECT_FAIL);\n  }\n  if (flags == 0) {\n    ed->afd_poll_info.Handles[0].Events |= AFD_POLL_DISCONNECT;\n  }\n\n  memset(&ed->iosb, 0, sizeof(ed->iosb));\n  ed->iosb.Status = STATUS_PENDING;\n\n  status = ew->NtDeviceIoControlFile(\n    afd->afd_handle, NULL, NULL, &ed->iosb, &ed->iosb, IOCTL_AFD_POLL,\n    &ed->afd_poll_info, sizeof(ed->afd_poll_info), &ed->afd_poll_info,\n    sizeof(ed->afd_poll_info));\n  if (status != STATUS_SUCCESS && status != STATUS_PENDING) {\n    CARES_DEBUG_LOG(\"** afd_enqueue ed=%p FAILED\\n\", (void *)ed);\n    ed->afd_handle_node = NULL;\n    return ARES_FALSE;\n  }\n\n  /* Record that we submitted a poll request to this handle and tell it to\n   * re-sort the node since we changed its sort value */\n  afd->poll_cnt++;\n  ares_slist_node_reinsert(ed->afd_handle_node);\n\n  ed->poll_status = POLL_STATUS_PENDING;\n  CARES_DEBUG_LOG(\"++ afd_enqueue ed=%p flags=%X\\n\", (void *)ed,\n                  (unsigned int)flags);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              570,
              0
            ],
            [
              639,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_afd_enqueue",
            "parameters": {
              "event": "ares_event_t",
              "flags": "ares_event_flags_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_afd_cancel(ares_evsys_win32_eventdata_t *ed)\n{\n  IO_STATUS_BLOCK     cancel_iosb;\n  ares_evsys_win32_t *ew;\n  NTSTATUS            status;\n  ares_afd_handle_t  *afd;\n\n  ew = ed->event->e->ev_sys_data;\n\n  /* Misuse */\n  if (ed->poll_status != POLL_STATUS_PENDING) {\n    return ARES_FALSE;\n  }\n\n  afd = ares_slist_node_val(ed->afd_handle_node);\n\n  /* Misuse */\n  if (afd == NULL) {\n    return ARES_FALSE;\n  }\n\n  ed->poll_status = POLL_STATUS_CANCEL;\n\n  /* Not pending, nothing to do. Most likely that means there is a pending\n   * event that hasn't yet been delivered otherwise it would be re-armed\n   * already */\n  if (ed->iosb.Status != STATUS_PENDING) {\n    CARES_DEBUG_LOG(\"** cancel not needed for ed=%p\\n\", (void *)ed);\n    return ARES_FALSE;\n  }\n\n  status = ew->NtCancelIoFileEx(afd->afd_handle, &ed->iosb, &cancel_iosb);\n\n  CARES_DEBUG_LOG(\"** Enqueued cancel for ed=%p, status = %lX\\n\", (void *)ed,\n                  status);\n\n  /* NtCancelIoFileEx() may return STATUS_NOT_FOUND if the operation completed\n   * just before calling NtCancelIoFileEx(), but we have not yet received the\n   * notification (but it should be queued for the next IOCP event).  */\n  if (status == STATUS_SUCCESS || status == STATUS_NOT_FOUND) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              641,
              0
            ],
            [
              685,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_afd_cancel",
            "parameters": {
              "ed": "ares_evsys_win32_eventdata_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_win32_eventdata_destroy(ares_evsys_win32_t           *ew,\n                                               ares_evsys_win32_eventdata_t *ed)\n{\n  if (ew == NULL || ed == NULL) {\n    return;\n  }\n  CARES_DEBUG_LOG(\"-- deleting ed=%p (%s)\\n\", (void *)ed,\n                  (ed->socket == ARES_SOCKET_BAD) ? \"data\" : \"socket\");\n  /* These type of handles are deferred destroy. Update tracking. */\n  if (ed->socket != ARES_SOCKET_BAD) {\n    ares_htable_vpvp_remove(ew->sockets, &ed->iosb);\n  }\n\n  ares_thread_mutex_destroy(ed->lock);\n\n  if (ed->event != NULL) {\n    ed->event->data = NULL;\n  }\n\n  ares_free(ed);\n}",
          "fn_code_pos": [
            [
              687,
              0
            ],
            [
              707,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_eventdata_destroy",
            "parameters": {
              "ew": "ares_evsys_win32_t",
              "ed": "ares_evsys_win32_eventdata_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_event_add(ares_event_t *event)\n{\n  ares_event_thread_t          *e  = event->e;\n  ares_evsys_win32_t           *ew = e->ev_sys_data;\n  ares_evsys_win32_eventdata_t *ed;\n  ares_bool_t                   rc = ARES_FALSE;\n\n  ed              = ares_malloc_zero(sizeof(*ed));\n  ed->event       = event;\n  ed->socket      = event->fd;\n  ed->base_socket = ARES_SOCKET_BAD;\n  event->data     = ed;\n\n  CARES_DEBUG_LOG(\"++ add ed=%p (%s) flags=%X\\n\", (void *)ed,\n                  (ed->socket == ARES_SOCKET_BAD) ? \"data\" : \"socket\",\n                  (unsigned int)event->flags);\n\n  /* Likely a signal event, not something we will directly handle.  We create\n   * the ares_evsys_win32_eventdata_t as the placeholder to use as the\n   * IOCP Completion Key */\n  if (ed->socket == ARES_SOCKET_BAD) {\n    ed->lock = ares_thread_mutex_create();\n    if (ed->lock == NULL) {\n      goto done;\n    }\n    rc = ARES_TRUE;\n    goto done;\n  }\n\n  ed->base_socket = ares_evsys_win32_basesocket(ed->socket);\n  if (ed->base_socket == ARES_SOCKET_BAD) {\n    goto done;\n  }\n\n  if (!ares_htable_vpvp_insert(ew->sockets, &ed->iosb, ed)) {\n    goto done;\n  }\n\n  if (!ares_evsys_win32_afd_enqueue(event, event->flags)) {\n    goto done;\n  }\n\n  rc = ARES_TRUE;\n\ndone:\n  if (!rc) {\n    ares_evsys_win32_eventdata_destroy(ew, ed);\n    event->data = NULL;\n  }\n  return rc;\n}",
          "fn_code_pos": [
            [
              709,
              0
            ],
            [
              759,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_win32_event_del(ares_event_t *event)\n{\n  ares_evsys_win32_eventdata_t *ed = event->data;\n\n  /* Already cleaned up, likely a LOCAL_CLOSE */\n  if (ed == NULL) {\n    return;\n  }\n\n  CARES_DEBUG_LOG(\"-- DELETE requested for ed=%p (%s)\\n\", (void *)ed,\n                  (ed->socket != ARES_SOCKET_BAD) ? \"socket\" : \"data\");\n\n  /*\n   * Cancel pending AFD Poll operation.\n   */\n  if (ed->socket != ARES_SOCKET_BAD) {\n    ares_evsys_win32_afd_cancel(ed);\n    ed->poll_status = POLL_STATUS_DESTROY;\n    ed->event       = NULL;\n  } else {\n    ares_evsys_win32_eventdata_destroy(event->e->ev_sys_data, ed);\n  }\n\n  event->data = NULL;\n}",
          "fn_code_pos": [
            [
              761,
              0
            ],
            [
              785,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_win32_event_mod(ares_event_t      *event,\n                                       ares_event_flags_t new_flags)\n{\n  ares_evsys_win32_eventdata_t *ed = event->data;\n\n  /* Not for us */\n  if (event->fd == ARES_SOCKET_BAD || ed == NULL) {\n    return;\n  }\n\n  CARES_DEBUG_LOG(\"** mod ed=%p new_flags=%X\\n\", (void *)ed,\n                  (unsigned int)new_flags);\n\n  /* All we need to do is cancel the pending operation.  When the event gets\n   * delivered for the cancellation, it will automatically re-enqueue a new\n   * event */\n  ares_evsys_win32_afd_cancel(ed);\n}",
          "fn_code_pos": [
            [
              787,
              0
            ],
            [
              804,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_process_other_event(\n  ares_evsys_win32_t *ew, ares_evsys_win32_eventdata_t *ed, size_t i)\n{\n  ares_event_t *event;\n\n  /* NOTE: do NOT dereference 'ed' if during shutdown as this could be an\n   * invalid pointer if the signal handle was cleaned up, but there was still a\n   * pending event! */\n\n  if (ew->is_shutdown) {\n    CARES_DEBUG_LOG(\"\\t\\t** i=%lu, skip non-socket handle during shutdown\\n\",\n                    (unsigned long)i);\n    return ARES_FALSE;\n  }\n\n  event = ed->event;\n  CARES_DEBUG_LOG(\"\\t\\t** i=%lu, ed=%p (data)\\n\", (unsigned long)i, (void *)ed);\n\n  event->cb(event->e, event->fd, event->data, ARES_EVENT_FLAG_OTHER);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              806,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_process_other_event",
            "parameters": {
              "ew": "ares_evsys_win32_t",
              "ed": "ares_evsys_win32_eventdata_t",
              "i": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_process_socket_event(\n  ares_evsys_win32_t *ew, ares_evsys_win32_eventdata_t *ed, size_t i)\n{\n  ares_event_flags_t flags = 0;\n  ares_event_t      *event = NULL;\n  ares_afd_handle_t *afd   = NULL;\n\n  /* Shouldn't be possible */\n  if (ed == NULL) {\n    CARES_DEBUG_LOG(\"\\t\\t** i=%lu, Invalid handle.\\n\", (unsigned long)i);\n    return ARES_FALSE;\n  }\n\n  event = ed->event;\n\n  CARES_DEBUG_LOG(\"\\t\\t** i=%lu, ed=%p (socket)\\n\", (unsigned long)i,\n                  (void *)ed);\n\n  /* Process events */\n  if (ed->poll_status == POLL_STATUS_PENDING &&\n      ed->iosb.Status == STATUS_SUCCESS &&\n      ed->afd_poll_info.NumberOfHandles > 0) {\n    if (ed->afd_poll_info.Handles[0].Events &\n        (AFD_POLL_RECEIVE | AFD_POLL_DISCONNECT | AFD_POLL_ACCEPT |\n         AFD_POLL_ABORT)) {\n      flags |= ARES_EVENT_FLAG_READ;\n    }\n    if (ed->afd_poll_info.Handles[0].Events &\n        (AFD_POLL_SEND | AFD_POLL_CONNECT_FAIL)) {\n      flags |= ARES_EVENT_FLAG_WRITE;\n    }\n    if (ed->afd_poll_info.Handles[0].Events & AFD_POLL_LOCAL_CLOSE) {\n      CARES_DEBUG_LOG(\"\\t\\t** ed=%p LOCAL CLOSE\\n\", (void *)ed);\n      ed->poll_status = POLL_STATUS_DESTROY;\n    }\n  }\n\n  CARES_DEBUG_LOG(\"\\t\\t** ed=%p, iosb status=%lX, poll_status=%d, flags=%X\\n\",\n                  (void *)ed, (unsigned long)ed->iosb.Status,\n                  (int)ed->poll_status, (unsigned int)flags);\n\n  /* Decrement poll count for AFD handle then resort, also disassociate\n   * with socket */\n  afd = ares_slist_node_val(ed->afd_handle_node);\n  afd->poll_cnt--;\n  ares_slist_node_reinsert(ed->afd_handle_node);\n  ed->afd_handle_node = NULL;\n\n  /* Pending destroy, go ahead and kill it */\n  if (ed->poll_status == POLL_STATUS_DESTROY) {\n    ares_evsys_win32_eventdata_destroy(ew, ed);\n    return ARES_FALSE;\n  }\n\n  ed->poll_status = POLL_STATUS_NONE;\n\n  /* Mask flags against current desired flags.  We could have an event\n   * queued that is outdated. */\n  flags &= event->flags;\n\n  /* Don't actually do anything with the event that was delivered as we are\n   * in a shutdown/cleanup process.  Mostly just handling the delayed\n   * destruction of sockets */\n  if (ew->is_shutdown) {\n    return ARES_FALSE;\n  }\n\n  /* Re-enqueue so we can get more events on the socket, we either\n   * received a real event, or a cancellation notice.  Both cases we\n   * re-queue using the current configured event flags.\n   *\n   * If we can't re-enqueue, that likely means the socket has been\n   * closed, so we want to kill our reference to it\n   */\n  if (!ares_evsys_win32_afd_enqueue(event, event->flags)) {\n    ares_evsys_win32_eventdata_destroy(ew, ed);\n    return ARES_FALSE;\n  }\n\n  /* No events we recognize to deliver */\n  if (flags == 0) {\n    return ARES_FALSE;\n  }\n\n  event->cb(event->e, event->fd, event->data, flags);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              828,
              0
            ],
            [
              914,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_process_socket_event",
            "parameters": {
              "ew": "ares_evsys_win32_t",
              "ed": "ares_evsys_win32_eventdata_t",
              "i": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static BOOL ares_GetQueuedCompletionStatusEx(\n  HANDLE CompletionPort,\n  LPOVERLAPPED_ENTRY lpCompletionPortEntries,\n  ULONG ulCount,\n  PULONG ulNumEntriesRemoved,\n  DWORD dwMilliseconds,\n  BOOL fAlertable)\n{\n#ifdef HAVE_GETQUEUEDCOMPLETIONSTATUSEX\n  return GetQueuedCompletionStatusEx(CompletionPort, lpCompletionPortEntries,\n    ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);\n#else\n  ULONG i;\n\n  (void)fAlertable;\n\n  memset(lpCompletionPortEntries, 0,\n         ulCount * sizeof(*lpCompletionPortEntries));\n  (*ulNumEntriesRemoved) = 0;\n\n  for (i=0; i<ulCount; i++) {\n    if (!GetQueuedCompletionStatus(CompletionPort,\n         &lpCompletionPortEntries[i].dwNumberOfBytesTransferred,\n         &lpCompletionPortEntries[i].lpCompletionKey,\n         &lpCompletionPortEntries[i].lpOverlapped,\n         (i == 0)?dwMilliseconds:0)) {\n      break;\n    }\n\n    (*ulNumEntriesRemoved)++;\n  }\n\n  if (*ulNumEntriesRemoved > 0) {\n    return TRUE;\n  }\n\n  return FALSE;\n#endif\n}",
          "fn_code_pos": [
            [
              916,
              0
            ],
            [
              954,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_GetQueuedCompletionStatusEx",
            "parameters": {
              "CompletionPort": "HANDLE",
              "lpCompletionPortEntries": "LPOVERLAPPED_ENTRY",
              "ulCount": "ULONG",
              "ulNumEntriesRemoved": "PULONG",
              "dwMilliseconds": "DWORD",
              "fAlertable": "BOOL"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_win32_wait(ares_event_thread_t *e,\n                                    unsigned long        timeout_ms)\n{\n  ares_evsys_win32_t *ew = e->ev_sys_data;\n  OVERLAPPED_ENTRY    entries[16];\n  ULONG               maxentries = sizeof(entries) / sizeof(*entries);\n  ULONG               nentries;\n  BOOL                status;\n  size_t              i;\n  size_t              cnt  = 0;\n  DWORD               tout = (timeout_ms == 0) ? INFINITE : (DWORD)timeout_ms;\n\n  CARES_DEBUG_LOG(\"** Wait Enter\\n\");\n  /* Process in a loop for as long as it fills the entire entries buffer, and\n   * on subsequent attempts, ensure the timeout is 0 */\n  do {\n    nentries = maxentries;\n    status   = ares_GetQueuedCompletionStatusEx(ew->iocp_handle, entries,\n                                                nentries, &nentries, tout,\n                                                FALSE);\n\n    /* Next loop around, we want to return instantly if there are no events to\n     * be processed */\n    tout = 0;\n\n    if (!status) {\n      break;\n    }\n\n    CARES_DEBUG_LOG(\"\\t** GetQueuedCompletionStatusEx returned %lu entries\\n\",\n                    (unsigned long)nentries);\n    for (i = 0; i < (size_t)nentries; i++) {\n      ares_evsys_win32_eventdata_t *ed = NULL;\n      ares_bool_t                   rc;\n\n      /* For things triggered via PostQueuedCompletionStatus() we have an\n       * lpCompletionKey we can just use.  Otherwise we need to dereference the\n       * pointer returned in lpOverlapped to determine the referenced\n       * socket */\n      if (entries[i].lpCompletionKey) {\n        ed = (ares_evsys_win32_eventdata_t *)entries[i].lpCompletionKey;\n        rc = ares_evsys_win32_process_other_event(ew, ed, i);\n      } else {\n        ed = ares_htable_vpvp_get_direct(ew->sockets, entries[i].lpOverlapped);\n        rc = ares_evsys_win32_process_socket_event(ew, ed, i);\n      }\n\n      /* We processed actual events */\n      if (rc) {\n        cnt++;\n      }\n    }\n  } while (nentries == maxentries);\n\n  CARES_DEBUG_LOG(\"** Wait Exit\\n\");\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              956,
              0
            ],
            [
              1013,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "CARES_DEBUG_LOG(const char *fmt, ...)",
          "fn_dec_pos": [
            [
              187,
              12
            ],
            [
              187,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CARES_DEBUG_LOG",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_evsys_win32_wait(ares_event_thread_t *e,\n                                    unsigned long        timeout_ms)",
          "fn_dec_pos": [
            [
              250,
              14
            ],
            [
              251,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_iocpevent_create(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              286,
              21
            ],
            [
              286,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iocpevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_afd_handle_create(ares_evsys_win32_t *ew)",
          "fn_dec_pos": [
            [
              377,
              26
            ],
            [
              377,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_afd_handle_create",
            "parameters": {
              "ew": "ares_evsys_win32_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_afd_handle_fetch(ares_evsys_win32_t *ew)",
          "fn_dec_pos": [
            [
              428,
              26
            ],
            [
              428,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_afd_handle_fetch",
            "parameters": {
              "ew": "ares_evsys_win32_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  /* Dynamically loaded symbols */\n  NtCreateFile_t          NtCreateFile;\n  NtDeviceIoControlFile_t NtDeviceIoControlFile;\n  NtCancelIoFileEx_t      NtCancelIoFileEx;\n\n  /* Implementation details */\n  ares_slist_t           *afd_handles;\n  HANDLE                  iocp_handle;\n\n  /* IO_STATUS_BLOCK * -> ares_evsys_win32_eventdata_t * mapping.  There is\n   * no completion key passed to IOCP with this method so we have to look\n   * up based on the lpOverlapped returned (which is mapped to IO_STATUS_BLOCK)\n   */\n  ares_htable_vpvp_t     *sockets;\n\n  /* Flag about whether or not we are shutting down */\n  ares_bool_t             is_shutdown;\n} ares_evsys_win32_t;",
          {
            "NtCreateFile": "NtCreateFile_t",
            "NtDeviceIoControlFile": "NtDeviceIoControlFile_t",
            "NtCancelIoFileEx": "NtCancelIoFileEx_t",
            "*afd_handles": "ares_slist_t",
            "iocp_handle": "HANDLE",
            "*sockets": "ares_htable_vpvp_t",
            "is_shutdown": "ares_bool_t"
          },
          "ares_evsys_win32_t",
          [
            201,
            0
          ],
          [
            219,
            21
          ]
        ],
        [
          "typedef struct {\n  /*! Pointer to parent event container */\n  ares_event_t        *event;\n  /*! Socket passed in to monitor */\n  SOCKET               socket;\n  /*! Base socket derived from provided socket */\n  SOCKET               base_socket;\n  /*! Structure for submitting AFD POLL requests (Internals!) */\n  AFD_POLL_INFO        afd_poll_info;\n  /*! Status of current polling operation */\n  poll_status_t        poll_status;\n  /*! IO Status Block structure submitted with AFD POLL requests and returned\n   *  with IOCP results as lpOverlapped (even though its a different structure)\n   */\n  IO_STATUS_BLOCK      iosb;\n  /*! AFD handle node an outstanding poll request is associated with */\n  ares_slist_node_t   *afd_handle_node;\n  /* Lock is only for PostQueuedCompletionStatus() to prevent multiple\n   * signals. Tracking via POLL_STATUS_PENDING/POLL_STATUS_NONE */\n  ares_thread_mutex_t *lock;\n} ares_evsys_win32_eventdata_t;",
          {
            "*event": "ares_event_t",
            "socket": "SOCKET",
            "base_socket": "SOCKET",
            "afd_poll_info": "AFD_POLL_INFO",
            "poll_status": "poll_status_t",
            "iosb": "IO_STATUS_BLOCK",
            "*afd_handle_node": "ares_slist_node_t",
            "*lock": "ares_thread_mutex_t"
          },
          "ares_evsys_win32_eventdata_t",
          [
            228,
            0
          ],
          [
            248,
            31
          ]
        ],
        [
          "typedef struct {\n  size_t poll_cnt;\n  HANDLE afd_handle;\n} ares_afd_handle_t;",
          {
            "poll_cnt": "size_t",
            "afd_handle": "HANDLE"
          },
          "ares_afd_handle_t",
          [
            337,
            0
          ],
          [
            340,
            20
          ]
        ],
        [
          "typedef struct {\n  /* Dynamically loaded symbols */\n  NtCreateFile_t          NtCreateFile;\n  NtDeviceIoControlFile_t NtDeviceIoControlFile;\n  NtCancelIoFileEx_t      NtCancelIoFileEx;\n\n  /* Implementation details */\n  ares_slist_t           *afd_handles;\n  HANDLE                  iocp_handle;\n\n  /* IO_STATUS_BLOCK * -> ares_evsys_win32_eventdata_t * mapping.  There is\n   * no completion key passed to IOCP with this method so we have to look\n   * up based on the lpOverlapped returned (which is mapped to IO_STATUS_BLOCK)\n   */\n  ares_htable_vpvp_t     *sockets;\n\n  /* Flag about whether or not we are shutting down */\n  ares_bool_t             is_shutdown;\n} ares_evsys_win32_t;",
          {
            "NtCreateFile": "NtCreateFile_t",
            "NtDeviceIoControlFile": "NtDeviceIoControlFile_t",
            "NtCancelIoFileEx": "NtCancelIoFileEx_t",
            "*afd_handles": "ares_slist_t",
            "iocp_handle": "HANDLE",
            "*sockets": "ares_htable_vpvp_t",
            "is_shutdown": "ares_bool_t"
          },
          "ares_evsys_win32_t",
          [
            201,
            0
          ],
          [
            219,
            21
          ]
        ],
        [
          "typedef struct {\n  /*! Pointer to parent event container */\n  ares_event_t        *event;\n  /*! Socket passed in to monitor */\n  SOCKET               socket;\n  /*! Base socket derived from provided socket */\n  SOCKET               base_socket;\n  /*! Structure for submitting AFD POLL requests (Internals!) */\n  AFD_POLL_INFO        afd_poll_info;\n  /*! Status of current polling operation */\n  poll_status_t        poll_status;\n  /*! IO Status Block structure submitted with AFD POLL requests and returned\n   *  with IOCP results as lpOverlapped (even though its a different structure)\n   */\n  IO_STATUS_BLOCK      iosb;\n  /*! AFD handle node an outstanding poll request is associated with */\n  ares_slist_node_t   *afd_handle_node;\n  /* Lock is only for PostQueuedCompletionStatus() to prevent multiple\n   * signals. Tracking via POLL_STATUS_PENDING/POLL_STATUS_NONE */\n  ares_thread_mutex_t *lock;\n} ares_evsys_win32_eventdata_t;",
          {
            "*event": "ares_event_t",
            "socket": "SOCKET",
            "base_socket": "SOCKET",
            "afd_poll_info": "AFD_POLL_INFO",
            "poll_status": "poll_status_t",
            "iosb": "IO_STATUS_BLOCK",
            "*afd_handle_node": "ares_slist_node_t",
            "*lock": "ares_thread_mutex_t"
          },
          "ares_evsys_win32_eventdata_t",
          [
            228,
            0
          ],
          [
            248,
            31
          ]
        ],
        [
          "typedef struct {\n  size_t poll_cnt;\n  HANDLE afd_handle;\n} ares_afd_handle_t;",
          {
            "poll_cnt": "size_t",
            "afd_handle": "HANDLE"
          },
          "ares_afd_handle_t",
          [
            337,
            0
          ],
          [
            340,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"ares_event_win32.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <stdarg.h>\n",
          [
            176,
            0
          ],
          [
            177,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  POLL_STATUS_NONE    = 0,\n  POLL_STATUS_PENDING = 1,\n  POLL_STATUS_CANCEL  = 2,\n  POLL_STATUS_DESTROY = 3\n} poll_status_t;",
          {
            "POLL_STATUS_NONE": "",
            "POLL_STATUS_PENDING": "",
            "POLL_STATUS_CANCEL": "",
            "POLL_STATUS_DESTROY": ""
          },
          "poll_status_t",
          [
            221,
            0
          ],
          [
            226,
            16
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/tools/adig.c": {
      "fn_def_list": [
        {
          "fn_code": "static void free_config(void)\n{\n  free(global_config.servers);\n  free(global_config.name);\n  free(global_config.opts.search);\n  memset(&global_config, 0, sizeof(global_config));\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_config",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_help(void)\n{\n  size_t i;\n  printf(\"adig version %s\\n\\n\", ares_version(NULL));\n  for (i = 0; helpstr[i] != NULL; i++) {\n    printf(\"%s\\n\", helpstr[i]);\n  }\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_help",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_flags(ares_dns_flags_t flags)\n{\n  if (flags & ARES_FLAG_QR) {\n    printf(\" qr\");\n  }\n  if (flags & ARES_FLAG_AA) {\n    printf(\" aa\");\n  }\n  if (flags & ARES_FLAG_TC) {\n    printf(\" tc\");\n  }\n  if (flags & ARES_FLAG_RD) {\n    printf(\" rd\");\n  }\n  if (flags & ARES_FLAG_RA) {\n    printf(\" ra\");\n  }\n  if (flags & ARES_FLAG_AD) {\n    printf(\" ad\");\n  }\n  if (flags & ARES_FLAG_CD) {\n    printf(\" cd\");\n  }\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_flags",
            "parameters": {
              "flags": "ares_dns_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_header(const ares_dns_record_t *dnsrec)\n{\n  printf(\";; ->>HEADER<<- opcode: %s, status: %s, id: %u\\n\",\n         ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)),\n         ares_dns_rcode_tostr(ares_dns_record_get_rcode(dnsrec)),\n         ares_dns_record_get_id(dnsrec));\n  printf(\";; flags:\");\n  print_flags(ares_dns_record_get_flags(dnsrec));\n  printf(\"; QUERY: %u, ANSWER: %u, AUTHORITY: %u, ADDITIONAL: %u\\n\\n\",\n         (unsigned int)ares_dns_record_query_cnt(dnsrec),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_header",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_question(const ares_dns_record_t *dnsrec)\n{\n  size_t i;\n\n  if (global_config.opts.display_comments) {\n    printf(\";; QUESTION SECTION:\\n\");\n  }\n\n  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    const char         *name;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n    size_t              len;\n    if (ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass) !=\n        ARES_SUCCESS) {\n      return;\n    }\n    if (name == NULL) {\n      return;\n    }\n    len = strlen(name);\n    printf(\";%s.\\t\", name);\n    if (len + 1 < 24) {\n      printf(\"\\t\");\n    }\n    if (len + 1 < 16) {\n      printf(\"\\t\");\n    }\n\n    if (global_config.opts.display_class) {\n      printf(\"%s\\t\", ares_dns_class_tostr(qclass));\n    }\n\n    printf(\"%s\\n\", ares_dns_rec_type_tostr(qtype));\n  }\n\n  if (global_config.opts.display_comments) {\n    printf(\"\\n\");\n  }\n}",
          "fn_code_pos": [
            [
              246,
              0
            ],
            [
              285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_question",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_none(const unsigned char *val, size_t val_len)\n{\n  (void)val;\n  if (val_len != 0) {\n    printf(\"INVALID!\");\n  }\n}",
          "fn_code_pos": [
            [
              287,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_none",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_addr_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len % 4 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 4) {\n    char buf[256] = \"\";\n    ares_inet_ntop(AF_INET, val + i, buf, sizeof(buf));\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%s\", buf);\n  }\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_addr_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_addr6_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len % 16 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 16) {\n    char buf[256] = \"\";\n\n    ares_inet_ntop(AF_INET6, val + i, buf, sizeof(buf));\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%s\", buf);\n  }\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_addr6_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_u8_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n\n  for (i = 0; i < val_len; i++) {\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", (unsigned int)val[i]);\n  }\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_u8_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_u16_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len < 2 || val_len % 2 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 2) {\n    unsigned short u16 = 0;\n    unsigned short c;\n    /* Jumping over backwards to try to avoid odd compiler warnings */\n    c    = (unsigned short)val[i];\n    u16 |= (unsigned short)((c << 8) & 0xFFFF);\n    c    = (unsigned short)val[i + 1];\n    u16 |= c;\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", (unsigned int)u16);\n  }\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_u16_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_u32_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len < 4 || val_len % 4 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 4) {\n    unsigned int u32 = 0;\n\n    u32 |= (unsigned int)(val[i] << 24);\n    u32 |= (unsigned int)(val[i + 1] << 16);\n    u32 |= (unsigned int)(val[i + 2] << 8);\n    u32 |= (unsigned int)(val[i + 3]);\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", u32);\n  }\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_u32_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_str_list(const unsigned char *val, size_t val_len)\n{\n  size_t cnt = 0;\n\n  printf(\"\\\"\");\n  while (val_len) {\n    long           read_len = 0;\n    unsigned char *str      = NULL;\n    ares_status_t  status;\n\n    if (cnt) {\n      printf(\",\");\n    }\n\n    status = (ares_status_t)ares_expand_string(val, val, (int)val_len, &str,\n                                               &read_len);\n    if (status != ARES_SUCCESS) {\n      printf(\"INVALID\");\n      break;\n    }\n    printf(\"%s\", str);\n    ares_free_string(str);\n    val_len -= (size_t)read_len;\n    val     += read_len;\n    cnt++;\n  }\n  printf(\"\\\"\");\n}",
          "fn_code_pos": [
            [
              385,
              0
            ],
            [
              412,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_str_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_name(const unsigned char *val, size_t val_len)\n{\n  char *str      = NULL;\n  long  read_len = 0;\n\n  if (ares_expand_name(val, val, (int)val_len, &str, &read_len) !=\n      ARES_SUCCESS) {\n    printf(\"INVALID!\");\n    return;\n  }\n\n  printf(\"%s.\", str);\n  ares_free_string(str);\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_name",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_bin(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n\n  for (i = 0; i < val_len; i++) {\n    printf(\"%02x\", (unsigned int)val[i]);\n  }\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              436,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_bin",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t adig_isprint(int ch)\n{\n  if (ch >= 0x20 && ch <= 0x7E) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              438,
              0
            ],
            [
              444,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adig_isprint",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void print_opt_binp(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  printf(\"\\\"\");\n  for (i = 0; i < val_len; i++) {\n    if (adig_isprint(val[i])) {\n      printf(\"%c\", val[i]);\n    } else {\n      printf(\"\\\\%03d\", val[i]);\n    }\n  }\n  printf(\"\\\"\");\n}",
          "fn_code_pos": [
            [
              446,
              0
            ],
            [
              458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_binp",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opts(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t i;\n\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, key); i++) {\n    size_t               val_len = 0;\n    const unsigned char *val     = NULL;\n    unsigned short       opt;\n    const char          *name;\n\n    if (i != 0) {\n      printf(\" \");\n    }\n\n    opt  = ares_dns_rr_get_opt(rr, key, i, &val, &val_len);\n    name = ares_dns_opt_get_name(key, opt);\n    if (name == NULL) {\n      printf(\"key%u\", (unsigned int)opt);\n    } else {\n      printf(\"%s\", name);\n    }\n    if (val_len == 0) {\n      return;\n    }\n\n    printf(\"=\");\n\n    switch (ares_dns_opt_get_datatype(key, opt)) {\n      case ARES_OPT_DATATYPE_NONE:\n        print_opt_none(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U8_LIST:\n        print_opt_u8_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_INADDR4_LIST:\n        print_opt_addr_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_INADDR6_LIST:\n        print_opt_addr6_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U16:\n      case ARES_OPT_DATATYPE_U16_LIST:\n        print_opt_u16_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U32:\n      case ARES_OPT_DATATYPE_U32_LIST:\n        print_opt_u32_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_STR_LIST:\n        print_opt_str_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_BIN:\n        print_opt_bin(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_NAME:\n        print_opt_name(val, val_len);\n        break;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              460,
              0
            ],
            [
              519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opts",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_addr(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const struct in_addr *addr     = ares_dns_rr_get_addr(rr, key);\n  char                  buf[256] = \"\";\n\n  ares_inet_ntop(AF_INET, addr, buf, sizeof(buf));\n  printf(\"%s\", buf);\n}",
          "fn_code_pos": [
            [
              521,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_addr",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_addr6(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const struct ares_in6_addr *addr     = ares_dns_rr_get_addr6(rr, key);\n  char                        buf[256] = \"\";\n\n  ares_inet_ntop(AF_INET6, addr, buf, sizeof(buf));\n  printf(\"%s\", buf);\n}",
          "fn_code_pos": [
            [
              530,
              0
            ],
            [
              537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_addr6",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_u8(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned char u8 = ares_dns_rr_get_u8(rr, key);\n  printf(\"%u\", (unsigned int)u8);\n}",
          "fn_code_pos": [
            [
              539,
              0
            ],
            [
              543,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_u8",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_u16(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned short u16 = ares_dns_rr_get_u16(rr, key);\n  printf(\"%u\", (unsigned int)u16);\n}",
          "fn_code_pos": [
            [
              545,
              0
            ],
            [
              549,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_u16",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_u32(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned int u32 = ares_dns_rr_get_u32(rr, key);\n  printf(\"%u\", u32);\n}",
          "fn_code_pos": [
            [
              551,
              0
            ],
            [
              555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_u32",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_name(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const char *str = ares_dns_rr_get_str(rr, key);\n  printf(\"%s.\", str);\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              561,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_name",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_str(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const char *str = ares_dns_rr_get_str(rr, key);\n  printf(\"\\\"%s\\\"\", str);\n}",
          "fn_code_pos": [
            [
              563,
              0
            ],
            [
              567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_str",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_bin(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t               len  = 0;\n  const unsigned char *binp = ares_dns_rr_get_bin(rr, key, &len);\n  print_opt_bin(binp, len);\n}",
          "fn_code_pos": [
            [
              569,
              0
            ],
            [
              574,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_bin",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_binp(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t               len;\n  const unsigned char *binp = ares_dns_rr_get_bin(rr, key, &len);\n\n  print_opt_binp(binp, len);\n}",
          "fn_code_pos": [
            [
              576,
              0
            ],
            [
              582,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_binp",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_abinp(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t i;\n  size_t cnt = ares_dns_rr_get_abin_cnt(rr, key);\n\n  for (i = 0; i < cnt; i++) {\n    size_t               len;\n    const unsigned char *binp = ares_dns_rr_get_abin(rr, key, i, &len);\n    if (i != 0) {\n      printf(\" \");\n    }\n    print_opt_binp(binp, len);\n  }\n}",
          "fn_code_pos": [
            [
              584,
              0
            ],
            [
              597,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_abinp",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_rr(const ares_dns_rr_t *rr)\n{\n  const char              *name     = ares_dns_rr_get_name(rr);\n  size_t                   len      = 0;\n  size_t                   keys_cnt = 0;\n  ares_dns_rec_type_t      rtype    = ares_dns_rr_get_type(rr);\n  const ares_dns_rr_key_t *keys     = ares_dns_rr_get_keys(rtype, &keys_cnt);\n  size_t                   i;\n\n  if (name == NULL) {\n    return;\n  }\n\n  len = strlen(name);\n\n  printf(\"%s.\\t\", name);\n  if (len < 24) {\n    printf(\"\\t\");\n  }\n\n  if (global_config.opts.display_ttl) {\n    printf(\"%u\\t\", ares_dns_rr_get_ttl(rr));\n  }\n\n  if (global_config.opts.display_class) {\n    printf(\"%s\\t\", ares_dns_class_tostr(ares_dns_rr_get_class(rr)));\n  }\n\n  printf(\"%s\\t\", ares_dns_rec_type_tostr(rtype));\n\n  /* Output params here */\n  for (i = 0; i < keys_cnt; i++) {\n    ares_dns_datatype_t datatype = ares_dns_rr_key_datatype(keys[i]);\n    if (i != 0) {\n      printf(\" \");\n    }\n\n    switch (datatype) {\n      case ARES_DATATYPE_INADDR:\n        print_addr(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_INADDR6:\n        print_addr6(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U8:\n        print_u8(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U16:\n        print_u16(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U32:\n        print_u32(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_NAME:\n        print_name(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_STR:\n        print_str(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_BIN:\n        print_bin(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_BINP:\n        print_binp(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_ABINP:\n        print_abinp(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_OPT:\n        print_opts(rr, keys[i]);\n        break;\n    }\n  }\n\n  printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              599,
              0
            ],
            [
              674,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_rr",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static const ares_dns_rr_t *has_opt(const ares_dns_record_t *dnsrec,\n                                    ares_dns_section_t       section)\n{\n  size_t i;\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {\n    const ares_dns_rr_t *rr = ares_dns_record_rr_get_const(dnsrec, section, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      return rr;\n    }\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              676,
              0
            ],
            [
              687,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "has_opt",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "section": "ares_dns_section_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "static void print_section(const ares_dns_record_t *dnsrec,\n                          ares_dns_section_t       section)\n{\n  size_t i;\n\n  if (ares_dns_record_rr_cnt(dnsrec, section) == 0 ||\n      (ares_dns_record_rr_cnt(dnsrec, section) == 1 &&\n       has_opt(dnsrec, section) != NULL)) {\n    return;\n  }\n\n  if (global_config.opts.display_comments) {\n    printf(\";; %s SECTION:\\n\", ares_dns_section_tostr(section));\n  }\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {\n    const ares_dns_rr_t *rr = ares_dns_record_rr_get_const(dnsrec, section, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      continue;\n    }\n    print_rr(rr);\n  }\n  if (global_config.opts.display_comments) {\n    printf(\"\\n\");\n  }\n}",
          "fn_code_pos": [
            [
              689,
              0
            ],
            [
              713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_section",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "section": "ares_dns_section_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_psuedosection(const ares_dns_record_t *dnsrec)\n{\n  const ares_dns_rr_t *rr         = has_opt(dnsrec, ARES_SECTION_ADDITIONAL);\n  const unsigned char *cookie     = NULL;\n  size_t               cookie_len = 0;\n\n  if (rr == NULL) {\n    return;\n  }\n\n  if (!ares_dns_rr_get_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE,\n                                &cookie, &cookie_len)) {\n    cookie = NULL;\n  }\n\n  printf(\";; OPT PSEUDOSECTION:\\n\");\n  printf(\"; EDNS: version: %u, flags: %u; udp: %u\\n\",\n         (unsigned int)ares_dns_rr_get_u8(rr, ARES_RR_OPT_VERSION),\n         (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_FLAGS),\n         (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_UDP_SIZE));\n\n  if (cookie) {\n    printf(\"; COOKIE: \");\n    print_opt_bin(cookie, cookie_len);\n    printf(\" (good)\\n\");\n  }\n}",
          "fn_code_pos": [
            [
              715,
              0
            ],
            [
              741,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_psuedosection",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_record(const ares_dns_record_t *dnsrec)\n{\n  if (global_config.opts.display_comments) {\n    print_header(dnsrec);\n    print_opt_psuedosection(dnsrec);\n  }\n\n  if (global_config.opts.display_question) {\n    print_question(dnsrec);\n  }\n\n  if (global_config.opts.display_answer) {\n    print_section(dnsrec, ARES_SECTION_ANSWER);\n  }\n\n  if (global_config.opts.display_additional) {\n    print_section(dnsrec, ARES_SECTION_ADDITIONAL);\n  }\n\n  if (global_config.opts.display_authority) {\n    print_section(dnsrec, ARES_SECTION_AUTHORITY);\n  }\n\n  if (global_config.opts.display_stats) {\n    unsigned char *abuf = NULL;\n    size_t         alen = 0;\n    ares_dns_write(dnsrec, &abuf, &alen);\n    printf(\";; MSG SIZE  rcvd: %d\\n\\n\", (int)alen);\n    ares_free_string(abuf);\n  }\n}",
          "fn_code_pos": [
            [
              743,
              0
            ],
            [
              773,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_record",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void callback(void *arg, ares_status_t status, size_t timeouts,\n                     const ares_dns_record_t *dnsrec)\n{\n  (void)arg;\n  (void)timeouts;\n\n  if (status != ARES_SUCCESS) {\n    final_rv = RV_FAIL;\n  }\n\n  if (global_config.opts.display_comments) {\n    /* We got a \"Server status\" */\n    if (status >= ARES_SUCCESS && status <= ARES_EREFUSED) {\n      printf(\";; Got answer:\");\n    } else {\n      printf(\";;\");\n    }\n    if (status != ARES_SUCCESS) {\n      printf(\" %s\", ares_strerror((int)status));\n    }\n    printf(\"\\n\");\n  }\n\n  print_record(dnsrec);\n}",
          "fn_code_pos": [
            [
              775,
              0
            ],
            [
              799,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t enqueue_query(ares_channel_t *channel)\n{\n  ares_dns_record_t *dnsrec = NULL;\n  ares_dns_rr_t     *rr     = NULL;\n  ares_status_t      status;\n  unsigned short     flags    = 0;\n  char              *nametemp = NULL;\n  const char        *name     = global_config.name;\n\n  if (global_config.opts.aa_flag) {\n    flags |= ARES_FLAG_AA;\n  }\n\n  if (global_config.opts.ad_flag) {\n    flags |= ARES_FLAG_AD;\n  }\n\n  if (global_config.opts.cd_flag) {\n    flags |= ARES_FLAG_CD;\n  }\n\n  if (global_config.opts.rd_flag) {\n    flags |= ARES_FLAG_RD;\n  }\n\n  status = ares_dns_record_create(&dnsrec, 0, flags, ARES_OPCODE_QUERY,\n                                  ARES_RCODE_NOERROR);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* If it is a PTR record, convert from ip address into in-arpa form\n   * automatically */\n  if (global_config.qtype == ARES_REC_TYPE_PTR) {\n    struct ares_addr addr;\n    size_t           len;\n    addr.family = AF_UNSPEC;\n\n    if (ares_dns_pton(name, &addr, &len) != NULL) {\n      nametemp = ares_dns_addr_to_ptr(&addr);\n      name     = nametemp;\n    }\n  }\n\n  status = ares_dns_record_query_add(dnsrec, name, global_config.qtype,\n                                     global_config.qclass);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (global_config.opts.edns) {\n    status = ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n                                    ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n    ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE,\n                        (unsigned short)global_config.opts.udp_size);\n    ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0);\n  }\n\n  if (global_config.opts.display_query) {\n    printf(\";; Sending:\\n\");\n    print_record(dnsrec);\n  }\n\n  if (global_config.opts.do_search) {\n    status = ares_search_dnsrec(channel, dnsrec, callback, NULL);\n  } else {\n    status = ares_send_dnsrec(channel, dnsrec, callback, NULL, NULL);\n  }\n\ndone:\n  ares_free_string(nametemp);\n  ares_dns_record_destroy(dnsrec);\n  return status;\n}",
          "fn_code_pos": [
            [
              801,
              0
            ],
            [
              877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "enqueue_query",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static int event_loop(ares_channel_t *channel)\n{\n  while (1) {\n    fd_set          read_fds;\n    fd_set          write_fds;\n    int             nfds;\n    struct timeval  tv;\n    struct timeval *tvp;\n    int             count;\n\n    FD_ZERO(&read_fds);\n    FD_ZERO(&write_fds);\n    memset(&tv, 0, sizeof(tv));\n\n    nfds = ares_fds(channel, &read_fds, &write_fds);\n    if (nfds == 0) {\n      break;\n    }\n    tvp = ares_timeout(channel, NULL, &tv);\n    if (tvp == NULL) {\n      break;\n    }\n    count = select(nfds, &read_fds, &write_fds, NULL, tvp);\n    if (count < 0) {\n#ifdef USE_WINSOCK\n      int err = WSAGetLastError();\n#else\n      int err = errno;\n#endif\n      if (err != EAGAIN && err != EINTR) {\n        fprintf(stderr, \"select fail: %d\", err);\n        return 1;\n      }\n    }\n    ares_process(channel, &read_fds, &write_fds);\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              879,
              0
            ],
            [
              916,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "event_loop",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_bool_t opt_class_cb(char prefix, const char *name,\n                                ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n\n  if (!ares_dns_class_fromstr(&global_config.qclass, value)) {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"unrecognized class %s\", value);\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              936,
              0
            ],
            [
              950,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_class_cb",
            "parameters": {
              "prefix": "char",
              "name": "char",
              "is_true": "ares_bool_t",
              "value": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t opt_type_cb(char prefix, const char *name,\n                               ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n\n  if (!ares_dns_rec_type_fromstr(&global_config.qtype, value)) {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"unrecognized record type %s\", value);\n    return ARES_FALSE;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              952,
              0
            ],
            [
              965,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_type_cb",
            "parameters": {
              "prefix": "char",
              "name": "char",
              "is_true": "ares_bool_t",
              "value": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t opt_ptr_cb(char prefix, const char *name,\n                              ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n  global_config.qtype = ARES_REC_TYPE_PTR;\n  ares_free(global_config.name);\n  global_config.name = strdup(value);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              967,
              0
            ],
            [
              977,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_ptr_cb",
            "parameters": {
              "prefix": "char",
              "name": "char",
              "is_true": "ares_bool_t",
              "value": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t opt_all_cb(char prefix, const char *name,\n                              ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)value;\n\n  global_config.opts.display_command    = is_true;\n  global_config.opts.display_stats      = is_true;\n  global_config.opts.display_question   = is_true;\n  global_config.opts.display_answer     = is_true;\n  global_config.opts.display_authority  = is_true;\n  global_config.opts.display_additional = is_true;\n  global_config.opts.display_comments   = is_true;\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              979,
              0
            ],
            [
              994,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_all_cb",
            "parameters": {
              "prefix": "char",
              "name": "char",
              "is_true": "ares_bool_t",
              "value": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t opt_edns_cb(char prefix, const char *name,\n                               ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n\n  global_config.opts.edns = is_true;\n  if (is_true && value != NULL && atoi(value) > 0) {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"edns 0 only supported\");\n    return ARES_FALSE;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              996,
              0
            ],
            [
              1009,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_edns_cb",
            "parameters": {
              "prefix": "char",
              "name": "char",
              "is_true": "ares_bool_t",
              "value": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t opt_retry_cb(char prefix, const char *name,\n                                ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n\n  if (!ares_str_isnum(value)) {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"value not numeric\");\n    return ARES_FALSE;\n  }\n\n  global_config.opts.tries = strtoul(value, NULL, 10) + 1;\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              1011,
              0
            ],
            [
              1026,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_retry_cb",
            "parameters": {
              "prefix": "char",
              "name": "char",
              "is_true": "ares_bool_t",
              "value": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t opt_dig_bare_cb(char prefix, const char *name,\n                                   ares_bool_t is_true, const char *value)\n{\n  (void)prefix;\n  (void)name;\n  (void)is_true;\n\n  /* Handle @servers */\n  if (*value == '@') {\n    free(global_config.servers);\n    global_config.servers = strdup(value + 1);\n    return ARES_TRUE;\n  }\n\n  /* Make sure we don't pass options */\n  if (*value == '-' || *value == '+') {\n    snprintf(global_config.error, sizeof(global_config.error),\n             \"unrecognized argument %s\", value);\n    return ARES_FALSE;\n  }\n\n  /* See if it is a DNS class */\n  if (ares_dns_class_fromstr(&global_config.qclass, value)) {\n    return ARES_TRUE;\n  }\n\n  /* See if it is a DNS record type */\n  if (ares_dns_rec_type_fromstr(&global_config.qtype, value)) {\n    return ARES_TRUE;\n  }\n\n  /* See if it is a domain name */\n  if (ares_is_hostname(value)) {\n    free(global_config.name);\n    global_config.name = strdup(value);\n    return ARES_TRUE;\n  }\n\n  snprintf(global_config.error, sizeof(global_config.error),\n           \"unrecognized argument %s\", value);\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              1028,
              0
            ],
            [
              1069,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_dig_bare_cb",
            "parameters": {
              "prefix": "char",
              "name": "char",
              "is_true": "ares_bool_t",
              "value": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t read_cmdline(int argc, const char * const *argv,\n                                int start_idx)\n{\n  int    arg;\n  size_t opt;\n\n  for (arg = start_idx; arg < argc; arg++) {\n    ares_bool_t option_handled = ARES_FALSE;\n\n    for (opt = 0; !option_handled &&\n                  (dig_options[opt].opt != NULL || dig_options[opt].cb != NULL);\n         opt++) {\n      ares_bool_t is_true = ARES_TRUE;\n      const char *value   = NULL;\n      const char *nameptr = NULL;\n      size_t      namelen;\n\n      /* Match prefix character */\n      if (dig_options[opt].prefix != 0 &&\n          dig_options[opt].prefix != *(argv[arg])) {\n        continue;\n      }\n\n      nameptr = argv[arg];\n\n      /* skip prefix */\n      if (dig_options[opt].prefix != 0) {\n        nameptr++;\n      }\n\n      /* Negated option if it has a 'no' prefix */\n      if (ares_streq_max(nameptr, \"no\", 2)) {\n        is_true  = ARES_FALSE;\n        nameptr += 2;\n      }\n\n      if (dig_options[opt].separator != 0) {\n        const char *ptr = strchr(nameptr, dig_options[opt].separator);\n        if (ptr == NULL) {\n          namelen = ares_strlen(nameptr);\n        } else {\n          namelen = (size_t)(ptr - nameptr);\n          value   = ptr + 1;\n        }\n      } else {\n        namelen = ares_strlen(nameptr);\n      }\n\n      /* Match name */\n      if (dig_options[opt].name != NULL &&\n          !ares_streq_max(nameptr, dig_options[opt].name, namelen)) {\n        continue;\n      }\n\n      if (dig_options[opt].name == NULL) {\n        value = nameptr;\n      }\n\n      /* We need another argument for the value */\n      if (dig_options[opt].type != OPT_TYPE_BOOL &&\n          dig_options[opt].prefix != 0 && dig_options[opt].separator == 0) {\n        if (arg == argc - 1) {\n          snprintf(global_config.error, sizeof(global_config.error),\n                   \"insufficient arguments for %c%s\", dig_options[opt].prefix,\n                   dig_options[opt].name);\n          return ARES_FALSE;\n        }\n        arg++;\n        value = argv[arg];\n      }\n\n      switch (dig_options[opt].type) {\n        case OPT_TYPE_BOOL:\n          {\n            ares_bool_t *b = dig_options[opt].opt;\n            if (b == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"invalid use for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            *b = is_true;\n          }\n          break;\n        case OPT_TYPE_STRING:\n          {\n            char **str = dig_options[opt].opt;\n            if (str == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"invalid use for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (value == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"missing value for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (*str != NULL) {\n              free(*str);\n            }\n            *str = strdup(value);\n            break;\n          }\n        case OPT_TYPE_SIZE_T:\n          {\n            size_t *s = dig_options[opt].opt;\n            if (s == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"invalid use for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (value == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"missing value for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (!ares_str_isnum(value)) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"%c%s is not a numeric value\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            *s = strtoul(value, NULL, 10);\n            break;\n          }\n        case OPT_TYPE_U16:\n          {\n            unsigned short *s = dig_options[opt].opt;\n            if (s == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"invalid use for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (value == NULL) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"missing value for %c%s\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            if (!ares_str_isnum(value)) {\n              snprintf(global_config.error, sizeof(global_config.error),\n                       \"%c%s is not a numeric value\", dig_options[opt].prefix,\n                       dig_options[opt].name);\n              return ARES_FALSE;\n            }\n            *s = (unsigned short)strtoul(value, NULL, 10);\n            break;\n          }\n        case OPT_TYPE_FUNC:\n          if (dig_options[opt].cb == NULL) {\n            snprintf(global_config.error, sizeof(global_config.error),\n                     \"missing callback\");\n            return ARES_FALSE;\n          }\n          if (!dig_options[opt].cb(dig_options[opt].prefix,\n                                   dig_options[opt].name, is_true, value)) {\n            return ARES_FALSE;\n          }\n          break;\n      }\n      option_handled = ARES_TRUE;\n    }\n\n    if (!option_handled) {\n      snprintf(global_config.error, sizeof(global_config.error),\n               \"unrecognized option %s\", argv[arg]);\n      return ARES_FALSE;\n    }\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              1146,
              0
            ],
            [
              1322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_cmdline",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "start_idx": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t read_rcfile(void)\n{\n  char         configdir[PATH_MAX];\n  unsigned int cdlen = 0;\n\n#if !defined(WIN32)\n#  if !defined(__APPLE__)\n  char *configdir_xdg;\n#  endif\n  char *homedir;\n#endif\n\n  char          rcfile[PATH_MAX];\n  unsigned int  rclen;\n\n  size_t        rcargc;\n  char        **rcargv;\n  ares_buf_t   *rcbuf;\n  ares_status_t rcstatus;\n\n#if defined(WIN32)\n  cdlen = (unsigned int)snprintf(configdir, sizeof(configdir), \"%s/%s\",\n                                 getenv(\"APPDATA\"), \"c-ares\");\n\n#elif defined(__APPLE__)\n  homedir = getenv(\"HOME\");\n  if (homedir != NULL) {\n    cdlen = (unsigned int)snprintf(configdir, sizeof(configdir), \"%s/%s/%s/%s\",\n                                   homedir, \"Library\", \"Application Support\",\n                                   \"c-ares\");\n  }\n\n#else\n  configdir_xdg = getenv(\"XDG_CONFIG_HOME\");\n\n  if (configdir_xdg == NULL) {\n    homedir = getenv(\"HOME\");\n    if (homedir != NULL) {\n      cdlen = (unsigned int)snprintf(configdir, sizeof(configdir), \"%s/%s\",\n                                     homedir, \".config\");\n    }\n  } else {\n    cdlen =\n      (unsigned int)snprintf(configdir, sizeof(configdir), \"%s\", configdir_xdg);\n  }\n\n#endif\n\n  DEBUGF(fprintf(stderr, \"read_cmdline() configdir: %s\\n\", configdir));\n\n  if (cdlen == 0 || cdlen > sizeof(configdir)) {\n    DEBUGF(\n      fprintf(stderr, \"read_cmdline() skipping rcfile parsing on directory\\n\"));\n    return ARES_TRUE;\n  }\n\n  rclen =\n    (unsigned int)snprintf(rcfile, sizeof(rcfile), \"%s/adigrc\", configdir);\n\n  if (rclen > sizeof(rcfile)) {\n    DEBUGF(fprintf(stderr, \"read_cmdline() skipping rcfile parsing on file\\n\"));\n    return ARES_TRUE;\n  }\n\n  rcbuf = ares_buf_create();\n  if (ares_buf_load_file(rcfile, rcbuf) == ARES_SUCCESS) {\n    rcstatus = ares_buf_split_str(rcbuf, (const unsigned char *)\"\\n \", 2,\n                                  ARES_BUF_SPLIT_TRIM, 0, &rcargv, &rcargc);\n\n    if (rcstatus == ARES_SUCCESS) {\n      read_cmdline((int)rcargc, (const char * const *)rcargv, 0);\n\n    } else {\n      snprintf(global_config.error, sizeof(global_config.error),\n               \"rcfile is invalid: %s\", ares_strerror((int)rcstatus));\n    }\n\n    ares_free_array(rcargv, rcargc, ares_free);\n\n    if (rcstatus != ARES_SUCCESS) {\n      ares_buf_destroy(rcbuf);\n      return ARES_FALSE;\n    }\n\n  } else {\n    DEBUGF(fprintf(stderr, \"read_cmdline() failed to load rcfile\"));\n  }\n  ares_buf_destroy(rcbuf);\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              1324,
              0
            ],
            [
              1414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_rcfile",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void config_defaults(void)\n{\n  memset(&global_config, 0, sizeof(global_config));\n\n  global_config.opts.tries              = 3;\n  global_config.opts.ndots              = 1;\n  global_config.opts.rd_flag            = ARES_TRUE;\n  global_config.opts.edns               = ARES_TRUE;\n  global_config.opts.udp_size           = 1232;\n  global_config.opts.aliases            = ARES_TRUE;\n  global_config.opts.display_class      = ARES_TRUE;\n  global_config.opts.display_ttl        = ARES_TRUE;\n  global_config.opts.display_command    = ARES_TRUE;\n  global_config.opts.display_stats      = ARES_TRUE;\n  global_config.opts.display_question   = ARES_TRUE;\n  global_config.opts.display_answer     = ARES_TRUE;\n  global_config.opts.display_authority  = ARES_TRUE;\n  global_config.opts.display_additional = ARES_TRUE;\n  global_config.opts.display_comments   = ARES_TRUE;\n  global_config.qclass                  = ARES_CLASS_IN;\n  global_config.qtype                   = ARES_REC_TYPE_A;\n}",
          "fn_code_pos": [
            [
              1416,
              0
            ],
            [
              1437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "config_defaults",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void config_opts(void)\n{\n  global_config.optmask = ARES_OPT_FLAGS;\n  if (global_config.opts.tcp) {\n    global_config.options.flags |= ARES_FLAG_USEVC;\n  }\n  if (global_config.opts.primary) {\n    global_config.options.flags |= ARES_FLAG_PRIMARY;\n  }\n  if (global_config.opts.edns) {\n    global_config.options.flags |= ARES_FLAG_EDNS;\n  }\n  if (global_config.opts.stayopen) {\n    global_config.options.flags |= ARES_FLAG_STAYOPEN;\n  }\n  if (global_config.opts.dns0x20) {\n    global_config.options.flags |= ARES_FLAG_DNS0x20;\n  }\n  if (!global_config.opts.aliases) {\n    global_config.options.flags |= ARES_FLAG_NOALIASES;\n  }\n  if (!global_config.opts.rd_flag) {\n    global_config.options.flags |= ARES_FLAG_NORECURSE;\n  }\n  if (!global_config.opts.do_search) {\n    global_config.options.flags |= ARES_FLAG_NOSEARCH;\n  }\n  if (global_config.opts.ignore_tc) {\n    global_config.options.flags |= ARES_FLAG_IGNTC;\n  }\n  if (global_config.opts.port) {\n    global_config.optmask          |= ARES_OPT_UDP_PORT;\n    global_config.optmask          |= ARES_OPT_TCP_PORT;\n    global_config.options.udp_port  = global_config.opts.port;\n    global_config.options.tcp_port  = global_config.opts.port;\n  }\n\n  global_config.optmask       |= ARES_OPT_TRIES;\n  global_config.options.tries  = (int)global_config.opts.tries;\n\n  global_config.optmask       |= ARES_OPT_NDOTS;\n  global_config.options.ndots  = (int)global_config.opts.ndots;\n\n  global_config.optmask         |= ARES_OPT_EDNSPSZ;\n  global_config.options.ednspsz  = (int)global_config.opts.udp_size;\n\n  if (global_config.opts.search != NULL) {\n    global_config.optmask          |= ARES_OPT_DOMAINS;\n    global_config.options.domains   = &global_config.opts.search;\n    global_config.options.ndomains  = 1;\n  }\n}",
          "fn_code_pos": [
            [
              1439,
              0
            ],
            [
              1490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "config_opts",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv)\n{\n  ares_channel_t *channel = NULL;\n  ares_status_t   status;\n\n#ifdef USE_WINSOCK\n  WORD    wVersionRequested = MAKEWORD(USE_WINSOCK, USE_WINSOCK);\n  WSADATA wsaData;\n  WSAStartup(wVersionRequested, &wsaData);\n#endif\n\n  status = (ares_status_t)ares_library_init(ARES_LIB_INIT_ALL);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_library_init: %s\\n\", ares_strerror((int)status));\n    return RV_SYSERR;\n  }\n\n  config_defaults();\n\n  if (!read_cmdline(argc, (const char * const *)argv, 1)) {\n    printf(\"\\n** ERROR: %s\\n\\n\", global_config.error);\n    print_help();\n    final_rv = RV_MISUSE;\n    goto done;\n  }\n\n  if (global_config.no_rcfile && !read_rcfile()) {\n    fprintf(stderr, \"\\n** ERROR: %s\\n\", global_config.error);\n  }\n\n  if (global_config.is_help) {\n    print_help();\n    goto done;\n  }\n\n  if (global_config.name == NULL) {\n    printf(\"missing query name\\n\");\n    print_help();\n    final_rv = RV_MISUSE;\n    goto done;\n  }\n\n  config_opts();\n\n  status = (ares_status_t)ares_init_options(&channel, &global_config.options,\n                                            global_config.optmask);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_init_options: %s\\n\", ares_strerror((int)status));\n    final_rv = RV_SYSERR;\n    goto done;\n  }\n\n  if (global_config.servers) {\n    status =\n      (ares_status_t)ares_set_servers_ports_csv(channel, global_config.servers);\n    if (status != ARES_SUCCESS) {\n      fprintf(stderr, \"ares_set_servers_ports_csv: %s: %s\\n\",\n              ares_strerror((int)status), global_config.servers);\n      final_rv = RV_MISUSE;\n      goto done;\n    }\n  }\n\n  /* Debug */\n  if (global_config.opts.display_command) {\n    printf(\"\\n; <<>> c-ares DiG %s <<>>\", ares_version(NULL));\n    printf(\" %s\", global_config.name);\n    printf(\"\\n\");\n  }\n\n  /* Enqueue a query for each separate name */\n  status = enqueue_query(channel);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"Failed to create query for %s: %s\\n\", global_config.name,\n            ares_strerror((int)status));\n    final_rv = RV_MISUSE;\n    goto done;\n  }\n\n  /* Process events */\n  if (event_loop(channel) != 0) {\n    final_rv = RV_SYSERR;\n  }\n\ndone:\n  free_config();\n  ares_destroy(channel);\n  ares_library_cleanup();\n\n#ifdef USE_WINSOCK\n  WSACleanup();\n#endif\n  return final_rv;\n}",
          "fn_code_pos": [
            [
              1492,
              0
            ],
            [
              1585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "has_opt(const ares_dns_record_t *dnsrec,\n                                    ares_dns_section_t       section)",
          "fn_dec_pos": [
            [
              676,
              28
            ],
            [
              677,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "has_opt",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "section": "ares_dns_section_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*dig_opt_cb_t)(char prefix, const char *name,\n                                    ares_bool_t is_true, const char *value)",
          "fn_dec_pos": [
            [
              933,
              20
            ],
            [
              934,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "prefix": "char",
              "name": "char",
              "is_true": "ares_bool_t",
              "value": "char"
            },
            "return_type": "ares_bool_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  unsigned short port;\n  size_t         tries;\n  size_t         ndots;\n  ares_bool_t    tcp;\n  ares_bool_t    ignore_tc;\n  char          *search;\n  ares_bool_t    do_search;\n  ares_bool_t    aa_flag;\n  ares_bool_t    ad_flag;\n  ares_bool_t    cd_flag;\n  ares_bool_t    rd_flag;\n  /* ares_bool_t do_flag; */\n  ares_bool_t    edns;\n  size_t         udp_size;\n  ares_bool_t    primary;\n  ares_bool_t    aliases;\n  ares_bool_t    stayopen;\n  ares_bool_t    dns0x20;\n  ares_bool_t    display_class;\n  ares_bool_t    display_ttl;\n  ares_bool_t    display_command;\n  ares_bool_t    display_stats;\n  ares_bool_t    display_query;\n  ares_bool_t    display_question;\n  ares_bool_t    display_answer;\n  ares_bool_t    display_authority;\n  ares_bool_t    display_additional;\n  ares_bool_t    display_comments;\n} dns_options_t;",
          {
            "port": "unsigned short",
            "tries": "size_t",
            "ndots": "size_t",
            "tcp": "ares_bool_t",
            "ignore_tc": "ares_bool_t",
            "*search": "char",
            "do_search": "ares_bool_t",
            "aa_flag": "ares_bool_t",
            "ad_flag": "ares_bool_t",
            "cd_flag": "ares_bool_t",
            "rd_flag": "ares_bool_t",
            "edns": "ares_bool_t",
            "udp_size": "size_t",
            "primary": "ares_bool_t",
            "aliases": "ares_bool_t",
            "stayopen": "ares_bool_t",
            "dns0x20": "ares_bool_t",
            "display_class": "ares_bool_t",
            "display_ttl": "ares_bool_t",
            "display_command": "ares_bool_t",
            "display_stats": "ares_bool_t",
            "display_query": "ares_bool_t",
            "display_question": "ares_bool_t",
            "display_answer": "ares_bool_t",
            "display_authority": "ares_bool_t",
            "display_additional": "ares_bool_t",
            "display_comments": "ares_bool_t"
          },
          "dns_options_t",
          [
            64,
            0
          ],
          [
            93,
            16
          ]
        ],
        [
          "typedef struct {\n  dns_options_t       opts;\n  ares_bool_t         is_help;\n  ares_bool_t         no_rcfile;\n  struct ares_options options;\n  int                 optmask;\n  ares_dns_class_t    qclass;\n  ares_dns_rec_type_t qtype;\n  char               *name;\n  char               *servers;\n  char                error[256];\n} adig_config_t;",
          {
            "opts": "dns_options_t",
            "is_help": "ares_bool_t",
            "no_rcfile": "ares_bool_t",
            "options": "struct ares_options",
            "optmask": "int",
            "qclass": "ares_dns_class_t",
            "qtype": "ares_dns_rec_type_t",
            "*name": "char",
            "*servers": "char",
            "error[256]": "char"
          },
          "adig_config_t",
          [
            95,
            0
          ],
          [
            106,
            16
          ]
        ],
        [
          "struct {\n  /* Prefix for option.  If 0 then this param is a non-option and type must be\n   * OPT_TYPE_FUNC where the entire value for the param will be passed */\n  char         prefix;\n  /* Name of option.  If null, there is none and the value is expected to be\n   * immediately after the prefix character */\n  const char  *name;\n  /* Separator between key and value.  If 0 then uses the next argument as the\n   * value, otherwise splits on the separator. BOOL types won't ever use a\n   * separator and is ignored.*/\n  char         separator;\n  /* Type of parameter passed in.  If it is OPT_TYPE_FUNC, then it calls the\n   * dig_opt_cb_t callback */\n  opt_type_t   type;\n  /* Pointer to argument to fill in */\n  void        *opt;\n  /* Callback if OPT_TYPE_FUNC */\n  dig_opt_cb_t cb;\n}",
          {
            "prefix": "char",
            "char": "const",
            "separator": "char",
            "type": "opt_type_t",
            "*opt": "void",
            "cb": "dig_opt_cb_t"
          },
          "",
          [
            1071,
            13
          ],
          [
            1089,
            1
          ]
        ],
        [
          "typedef struct {\n  unsigned short port;\n  size_t         tries;\n  size_t         ndots;\n  ares_bool_t    tcp;\n  ares_bool_t    ignore_tc;\n  char          *search;\n  ares_bool_t    do_search;\n  ares_bool_t    aa_flag;\n  ares_bool_t    ad_flag;\n  ares_bool_t    cd_flag;\n  ares_bool_t    rd_flag;\n  /* ares_bool_t do_flag; */\n  ares_bool_t    edns;\n  size_t         udp_size;\n  ares_bool_t    primary;\n  ares_bool_t    aliases;\n  ares_bool_t    stayopen;\n  ares_bool_t    dns0x20;\n  ares_bool_t    display_class;\n  ares_bool_t    display_ttl;\n  ares_bool_t    display_command;\n  ares_bool_t    display_stats;\n  ares_bool_t    display_query;\n  ares_bool_t    display_question;\n  ares_bool_t    display_answer;\n  ares_bool_t    display_authority;\n  ares_bool_t    display_additional;\n  ares_bool_t    display_comments;\n} dns_options_t;",
          {
            "port": "unsigned short",
            "tries": "size_t",
            "ndots": "size_t",
            "tcp": "ares_bool_t",
            "ignore_tc": "ares_bool_t",
            "*search": "char",
            "do_search": "ares_bool_t",
            "aa_flag": "ares_bool_t",
            "ad_flag": "ares_bool_t",
            "cd_flag": "ares_bool_t",
            "rd_flag": "ares_bool_t",
            "edns": "ares_bool_t",
            "udp_size": "size_t",
            "primary": "ares_bool_t",
            "aliases": "ares_bool_t",
            "stayopen": "ares_bool_t",
            "dns0x20": "ares_bool_t",
            "display_class": "ares_bool_t",
            "display_ttl": "ares_bool_t",
            "display_command": "ares_bool_t",
            "display_stats": "ares_bool_t",
            "display_query": "ares_bool_t",
            "display_question": "ares_bool_t",
            "display_answer": "ares_bool_t",
            "display_authority": "ares_bool_t",
            "display_additional": "ares_bool_t",
            "display_comments": "ares_bool_t"
          },
          "dns_options_t",
          [
            64,
            0
          ],
          [
            93,
            16
          ]
        ],
        [
          "typedef struct {\n  dns_options_t       opts;\n  ares_bool_t         is_help;\n  ares_bool_t         no_rcfile;\n  struct ares_options options;\n  int                 optmask;\n  ares_dns_class_t    qclass;\n  ares_dns_rec_type_t qtype;\n  char               *name;\n  char               *servers;\n  char                error[256];\n} adig_config_t;",
          {
            "opts": "dns_options_t",
            "is_help": "ares_bool_t",
            "no_rcfile": "ares_bool_t",
            "options": "struct ares_options",
            "optmask": "int",
            "qclass": "ares_dns_class_t",
            "qtype": "ares_dns_rec_type_t",
            "*name": "char",
            "*servers": "char",
            "error[256]": "char"
          },
          "adig_config_t",
          [
            95,
            0
          ],
          [
            106,
            16
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            99,
            2
          ],
          [
            99,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            523,
            8
          ],
          [
            523,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            532,
            8
          ],
          [
            532,
            28
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            835,
            4
          ],
          [
            835,
            20
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            885,
            4
          ],
          [
            885,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            886,
            4
          ],
          [
            886,
            18
          ]
        ],
        [
          "struct {\n  /* Prefix for option.  If 0 then this param is a non-option and type must be\n   * OPT_TYPE_FUNC where the entire value for the param will be passed */\n  char         prefix;\n  /* Name of option.  If null, there is none and the value is expected to be\n   * immediately after the prefix character */\n  const char  *name;\n  /* Separator between key and value.  If 0 then uses the next argument as the\n   * value, otherwise splits on the separator. BOOL types won't ever use a\n   * separator and is ignored.*/\n  char         separator;\n  /* Type of parameter passed in.  If it is OPT_TYPE_FUNC, then it calls the\n   * dig_opt_cb_t callback */\n  opt_type_t   type;\n  /* Pointer to argument to fill in */\n  void        *opt;\n  /* Callback if OPT_TYPE_FUNC */\n  dig_opt_cb_t cb;\n}",
          {
            "prefix": "char",
            "char": "const",
            "separator": "char",
            "type": "opt_type_t",
            "*opt": "void",
            "cb": "dig_opt_cb_t"
          },
          "",
          [
            1071,
            13
          ],
          [
            1089,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"ares_array.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"ares_buf.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"ares_getopt.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"ares_mem.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"ares_str.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"limits.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  OPT_TYPE_BOOL,\n  OPT_TYPE_STRING,\n  OPT_TYPE_SIZE_T,\n  OPT_TYPE_U16,\n  OPT_TYPE_FUNC\n} opt_type_t;",
          {
            "OPT_TYPE_BOOL": "",
            "OPT_TYPE_STRING": "",
            "OPT_TYPE_SIZE_T": "",
            "OPT_TYPE_U16": "",
            "OPT_TYPE_FUNC": ""
          },
          "opt_type_t",
          [
            918,
            0
          ],
          [
            924,
            13
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/tools/ares_getopt.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_getopt_init(ares_getopt_state_t *state, int nargc,\n                      const char * const *nargv)\n{\n  memset(state, 0, sizeof(*state));\n  state->opterr = 1;\n  state->optind = 1;\n  state->place  = EMSG;\n  state->argc   = nargc;\n  state->argv   = nargv;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getopt_init",
            "parameters": {
              "state": "ares_getopt_state_t",
              "nargc": "int",
              "nargv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_getopt(ares_getopt_state_t *state, const char *ostr)\n{\n  const char *oli; /* option letter list index */\n\n  /* update scanning pointer */\n  if (!*state->place) {\n    if (state->optind >= state->argc) {\n      return -1;\n    }\n    state->place = state->argv[state->optind];\n    if (*(state->place) != '-') {\n      return -1;\n    }\n    state->place++;\n\n    /* found \"--\" */\n    if (*(state->place) == '-') {\n      state->optind++;\n      return -1;\n    }\n\n    /* Found just - */\n    if (!*(state->place)) {\n      state->optopt = 0;\n      return BADCH;\n    }\n  }\n\n  /* option letter okay? */\n  state->optopt = *(state->place);\n  state->place++;\n  oli = strchr(ostr, state->optopt);\n\n  if (oli == NULL) {\n    if (!(*state->place)) {\n      ++state->optind;\n    }\n    if (state->opterr) {\n      (void)fprintf(stderr, \"%s: illegal option -- %c\\n\", __FILE__,\n                    state->optopt);\n    }\n    return BADCH;\n  }\n\n  /* don't need argument */\n  if (*++oli != ':') {\n    state->optarg = NULL;\n    if (!*state->place) {\n      ++state->optind;\n    }\n  } else {\n    /* need an argument */\n    if (*state->place) {                         /* no white space */\n      state->optarg = state->place;\n    } else if (state->argc <= ++state->optind) { /* no arg */\n      state->place = EMSG;\n      if (*ostr == ':') {\n        return BADARG;\n      }\n      if (state->opterr) {\n        (void)fprintf(stderr, \"%s: option requires an argument -- %c\\n\",\n                      __FILE__, state->optopt);\n      }\n      return BADARG;\n    } else { /* white space */\n      state->optarg = state->argv[state->optind];\n    }\n    state->place = EMSG;\n    ++state->optind;\n  }\n  return state->optopt; /* dump back option letter */\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getopt",
            "parameters": {
              "state": "ares_getopt_state_t",
              "ostr": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"ares_getopt.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/tools/ahost.c": {
      "fn_def_list": [
        {
          "fn_code": "int         main(int argc, char **argv)\n{\n  struct ares_options  options;\n  int                  optmask = 0;\n  ares_channel_t      *channel;\n  int                  status;\n  int                  nfds;\n  int                  c;\n  int                  addr_family = AF_UNSPEC;\n  fd_set               read_fds;\n  fd_set               write_fds;\n  struct timeval      *tvp;\n  struct timeval       tv;\n  struct in_addr       addr4;\n  struct ares_in6_addr addr6;\n  ares_getopt_state_t  state;\n  char                *servers = NULL;\n\n#ifdef USE_WINSOCK\n  WORD    wVersionRequested = MAKEWORD(USE_WINSOCK, USE_WINSOCK);\n  WSADATA wsaData;\n  WSAStartup(wVersionRequested, &wsaData);\n#endif\n\n  memset(&options, 0, sizeof(options));\n\n  status = ares_library_init(ARES_LIB_INIT_ALL);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_library_init: %s\\n\", ares_strerror(status));\n    return RV_SYSERR;\n  }\n\n  ares_getopt_init(&state, argc, (const char * const *)argv);\n  while ((c = ares_getopt(&state, \"dt:h?D:s:\")) != -1) {\n    switch (c) {\n      case 'd':\n#ifdef WATT32\n        dbug_init();\n#endif\n        break;\n      case 'D':\n        optmask |= ARES_OPT_DOMAINS;\n        options.ndomains++;\n        options.domains = (char **)realloc(\n          options.domains, (size_t)options.ndomains * sizeof(char *));\n        options.domains[options.ndomains - 1] = strdup(state.optarg);\n        break;\n      case 't':\n        if (ares_strcaseeq(state.optarg, \"a\")) {\n          addr_family = AF_INET;\n        } else if (ares_strcaseeq(state.optarg, \"aaaa\")) {\n          addr_family = AF_INET6;\n        } else if (ares_strcaseeq(state.optarg, \"u\")) {\n          addr_family = AF_UNSPEC;\n        } else {\n          usage();\n        }\n        break;\n      case 's':\n        if (state.optarg == NULL) {\n          fprintf(stderr, \"%s\", \"missing servers\");\n          usage();\n          break;\n        }\n        if (servers) {\n          free(servers);\n        }\n        servers = strdup(state.optarg);\n        break;\n      case 'h':\n      case '?':\n        print_help_info_ahost();\n        break;\n      default:\n        usage();\n        break;\n    }\n  }\n\n  argc -= state.optind;\n  argv += state.optind;\n  if (argc < 1) {\n    usage();\n  }\n\n  status = ares_init_options(&channel, &options, optmask);\n  if (status != ARES_SUCCESS) {\n    free(servers);\n    fprintf(stderr, \"ares_init: %s\\n\", ares_strerror(status));\n    return RV_SYSERR;\n  }\n\n  if (servers) {\n    status = ares_set_servers_csv(channel, servers);\n    if (status != ARES_SUCCESS) {\n      fprintf(stderr, \"ares_set_serveres_csv: %s\\n\", ares_strerror(status));\n      free(servers);\n      usage();\n      return RV_MISUSE;\n    }\n    free(servers);\n  }\n\n  /* Initiate the queries, one per command-line argument. */\n  for (; *argv; argv++) {\n    if (ares_inet_pton(AF_INET, *argv, &addr4) == 1) {\n      ares_gethostbyaddr(channel, &addr4, sizeof(addr4), AF_INET, callback,\n                         *argv);\n    } else if (ares_inet_pton(AF_INET6, *argv, &addr6) == 1) {\n      ares_gethostbyaddr(channel, &addr6, sizeof(addr6), AF_INET6, callback,\n                         *argv);\n    } else {\n      struct ares_addrinfo_hints hints;\n      memset(&hints, 0, sizeof(hints));\n      hints.ai_family = addr_family;\n      ares_getaddrinfo(channel, *argv, NULL, &hints, ai_callback, *argv);\n    }\n  }\n\n  /* Wait for all queries to complete. */\n  for (;;) {\n    int res;\n    FD_ZERO(&read_fds);\n    FD_ZERO(&write_fds);\n    nfds = ares_fds(channel, &read_fds, &write_fds);\n    if (nfds == 0) {\n      break;\n    }\n    tvp = ares_timeout(channel, NULL, &tv);\n    if (tvp == NULL) {\n      break;\n    }\n    res = select(nfds, &read_fds, &write_fds, NULL, tvp);\n    if (-1 == res) {\n      break;\n    }\n    ares_process(channel, &read_fds, &write_fds);\n  }\n\n  ares_destroy(channel);\n\n  ares_library_cleanup();\n\n#ifdef USE_WINSOCK\n  WSACleanup();\n#endif\n\n  return final_rv;\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void callback(void *arg, int status, int timeouts, struct hostent *host)\n{\n  char **p;\n\n  (void)timeouts;\n\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"%s: %s\\n\", (char *)arg, ares_strerror(status));\n    final_rv = RV_FAIL;\n    return;\n  }\n\n  for (p = host->h_addr_list; *p; p++) {\n    char addr_buf[46] = \"??\";\n\n    ares_inet_ntop(host->h_addrtype, *p, addr_buf, sizeof(addr_buf));\n    printf(\"%-32s\\t%s\", host->h_name, addr_buf);\n    puts(\"\");\n  }\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ai_callback(void *arg, int status, int timeouts,\n                        struct ares_addrinfo *result)\n{\n  struct ares_addrinfo_node *node = NULL;\n  (void)timeouts;\n\n\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"%s: %s\\n\", (char *)arg, ares_strerror(status));\n    final_rv = RV_FAIL;\n    return;\n  }\n\n  for (node = result->nodes; node != NULL; node = node->ai_next) {\n    char        addr_buf[64] = \"\";\n    const void *ptr          = NULL;\n    if (node->ai_family == AF_INET) {\n      const struct sockaddr_in *in_addr =\n        (const struct sockaddr_in *)((void *)node->ai_addr);\n      ptr = &in_addr->sin_addr;\n    } else if (node->ai_family == AF_INET6) {\n      const struct sockaddr_in6 *in_addr =\n        (const struct sockaddr_in6 *)((void *)node->ai_addr);\n      ptr = &in_addr->sin6_addr;\n    } else {\n      continue;\n    }\n    ares_inet_ntop(node->ai_family, ptr, addr_buf, sizeof(addr_buf));\n    printf(\"%-32s\\t%s\\n\", result->name, addr_buf);\n  }\n\n  ares_freeaddrinfo(result);\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ai_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "result": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void usage(void)\n{\n  fprintf(stderr, \"usage: ahost [-h] [-d] [[-D {domain}] ...] [-s {server}] \"\n                  \"[-t {a|aaaa|u}] {host|addr} ...\\n\");\n  exit(RV_MISUSE);\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_help_info_ahost(void)\n{\n  /* Split due to maximum c89 string literal of 509 bytes */\n  printf(\"ahost, version %s\\n\\n\", ARES_VERSION_STR);\n  printf(\n    \"usage: ahost [-h] [-d] [-D domain] [-s server] [-t a|aaaa|u] host|addr \"\n    \"...\\n\\n\");\n  printf(\n    \"  -h : Display this help and exit.\\n\"\n    \"  -d : Print some extra debugging output.\\n\\n\"\n    \"  -D domain : Specify the domain to search instead of using the default \"\n    \"values\\n\");\n  printf(\n    \"  -s server : Connect to the specified DNS server, instead of the\\n\"\n    \"              system's default one(s). Servers are tried in round-robin,\\n\"\n    \"              if the previous one failed.\\n\"\n    \"  -t type   : If type is \\\"a\\\", print the A record.\\n\");\n  printf(\n    \"              If type is \\\"aaaa\\\", print the AAAA record.\\n\"\n    \"              If type is \\\"u\\\" (default), print both A and AAAA records.\\n\"\n    \"\\n\");\n  exit(RV_OK);\n}",
          "fn_code_pos": [
            [
              274,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_help_info_ahost",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "callback(void *arg, int status, int timeouts, struct hostent *host)",
          "fn_dec_pos": [
            [
              53,
              12
            ],
            [
              53,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ai_callback(void *arg, int status, int timeouts,\n                        struct ares_addrinfo *result)",
          "fn_dec_pos": [
            [
              54,
              12
            ],
            [
              55,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ai_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "result": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              56,
              12
            ],
            [
              56,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "print_help_info_ahost(void)",
          "fn_dec_pos": [
            [
              57,
              12
            ],
            [
              57,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_help_info_ahost",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            53,
            58
          ],
          [
            53,
            72
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            55,
            24
          ],
          [
            55,
            44
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            63,
            2
          ],
          [
            63,
            21
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            72,
            2
          ],
          [
            72,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            73,
            2
          ],
          [
            73,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            74,
            2
          ],
          [
            74,
            16
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            75,
            2
          ],
          [
            75,
            22
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            173,
            6
          ],
          [
            173,
            32
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            211,
            58
          ],
          [
            211,
            72
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            233,
            24
          ],
          [
            233,
            44
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            235,
            2
          ],
          [
            235,
            27
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            249,
            12
          ],
          [
            249,
            30
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            250,
            15
          ],
          [
            250,
            33
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            253,
            12
          ],
          [
            253,
            31
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            254,
            15
          ],
          [
            254,
            34
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"ares_getopt.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_str.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_inet_net_pton.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_inet_net_pton(int af, const char *src, void *dst, size_t size)",
          "fn_dec_pos": [
            [
              28,
              4
            ],
            [
              28,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_net_pton",
            "parameters": {
              "af": "int",
              "src": "char",
              "dst": "void",
              "size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_socket.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_sockaddr_addr_eq(const struct sockaddr  *sa,\n                                      const struct ares_addr *aa)",
          "fn_dec_pos": [
            [
              141,
              16
            ],
            [
              142,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sockaddr_addr_eq",
            "parameters": {
              "sa": "struct sockaddr",
              "aa": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_socket_configure(ares_channel_t *channel, int family,\n                                      ares_bool_t is_tcp, ares_socket_t fd)",
          "fn_dec_pos": [
            [
              143,
              16
            ],
            [
              144,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_configure",
            "parameters": {
              "channel": "ares_channel_t",
              "family": "int",
              "is_tcp": "ares_bool_t",
              "fd": "ares_socket_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_socket_enable_tfo(const ares_channel_t *channel,\n                                       ares_socket_t         fd)",
          "fn_dec_pos": [
            [
              145,
              16
            ],
            [
              146,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_enable_tfo",
            "parameters": {
              "channel": "ares_channel_t",
              "fd": "ares_socket_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_socket_open(ares_socket_t *sock, ares_channel_t *channel,\n                                 int af, int type, int protocol)",
          "fn_dec_pos": [
            [
              147,
              16
            ],
            [
              148,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_open",
            "parameters": {
              "sock": "ares_socket_t",
              "channel": "ares_channel_t",
              "af": "int",
              "type": "int",
              "protocol": "int"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_socket_try_again(int errnum)",
          "fn_dec_pos": [
            [
              149,
              16
            ],
            [
              149,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_try_again",
            "parameters": {
              "errnum": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_socket_close(ares_channel_t *channel, ares_socket_t s)",
          "fn_dec_pos": [
            [
              150,
              16
            ],
            [
              150,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_close",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_socket_connect(ares_channel_t *channel,\n                                    ares_socket_t sockfd, ares_bool_t is_tfo,\n                                    const struct sockaddr *addr,\n                                    ares_socklen_t         addrlen)",
          "fn_dec_pos": [
            [
              151,
              16
            ],
            [
              154,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_connect",
            "parameters": {
              "channel": "ares_channel_t",
              "sockfd": "ares_socket_t",
              "is_tfo": "ares_bool_t",
              "addr": "struct sockaddr",
              "addrlen": "ares_socklen_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_sockaddr_to_ares_addr(struct ares_addr      *ares_addr,\n                                           unsigned short        *port,\n                                           const struct sockaddr *sockaddr)",
          "fn_dec_pos": [
            [
              155,
              16
            ],
            [
              157,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sockaddr_to_ares_addr",
            "parameters": {
              "ares_addr": "struct ares_addr",
              "port": "unsigned short",
              "sockaddr": "struct sockaddr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_socket_write(ares_channel_t *channel, ares_socket_t fd,\n                                  const void *data, size_t len, size_t *written,\n                                  const struct sockaddr *sa,\n                                  ares_socklen_t         salen)",
          "fn_dec_pos": [
            [
              158,
              16
            ],
            [
              161,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_write",
            "parameters": {
              "channel": "ares_channel_t",
              "fd": "ares_socket_t",
              "data": "void",
              "len": "size_t",
              "written": "size_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t"
            },
            "return_type": "ares_conn_err_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sockaddr",
          {},
          "",
          [
            141,
            44
          ],
          [
            141,
            59
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            142,
            44
          ],
          [
            142,
            60
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            153,
            42
          ],
          [
            153,
            57
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            155,
            43
          ],
          [
            155,
            59
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            157,
            49
          ],
          [
            157,
            64
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            160,
            40
          ],
          [
            160,
            55
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_CONN_ERR_SUCCESS      = 0,  /*!< Success */\n  ARES_CONN_ERR_WOULDBLOCK   = 1,  /*!< Operation would block */\n  ARES_CONN_ERR_CONNCLOSED   = 2,  /*!< Connection closed (gracefully) */\n  ARES_CONN_ERR_CONNABORTED  = 3,  /*!< Connection Aborted */\n  ARES_CONN_ERR_CONNRESET    = 4,  /*!< Connection Reset */\n  ARES_CONN_ERR_CONNREFUSED  = 5,  /*!< Connection Refused */\n  ARES_CONN_ERR_CONNTIMEDOUT = 6,  /*!< Connection Timed Out */\n  ARES_CONN_ERR_HOSTDOWN     = 7,  /*!< Host Down */\n  ARES_CONN_ERR_HOSTUNREACH  = 8,  /*!< Host Unreachable */\n  ARES_CONN_ERR_NETDOWN      = 9,  /*!< Network Down */\n  ARES_CONN_ERR_NETUNREACH   = 10, /*!< Network Unreachable */\n  ARES_CONN_ERR_INTERRUPT    = 11, /*!< Call interrupted by signal, repeat */\n  ARES_CONN_ERR_AFNOSUPPORT  = 12, /*!< Address family not supported */\n  ARES_CONN_ERR_BADADDR      = 13, /*!< Bad Address / Unavailable */\n  ARES_CONN_ERR_NOMEM        = 14, /*!< Out of memory */\n  ARES_CONN_ERR_INVALID      = 15, /*!< Invalid Usage */\n  ARES_CONN_ERR_TOOLARGE     = 16, /*!< Request size too large */\n  ARES_CONN_ERR_NOTIMP       = 17, /*!< Not implemented */\n  ARES_CONN_ERR_FAILURE      = 99  /*!< Generic failure */\n} ares_conn_err_t;",
          {
            "ARES_CONN_ERR_SUCCESS": "",
            "ARES_CONN_ERR_WOULDBLOCK": "",
            "ARES_CONN_ERR_CONNCLOSED": "",
            "ARES_CONN_ERR_CONNABORTED": "",
            "ARES_CONN_ERR_CONNRESET": "",
            "ARES_CONN_ERR_CONNREFUSED": "",
            "ARES_CONN_ERR_CONNTIMEDOUT": "",
            "ARES_CONN_ERR_HOSTDOWN": "",
            "ARES_CONN_ERR_HOSTUNREACH": "",
            "ARES_CONN_ERR_NETDOWN": "",
            "ARES_CONN_ERR_NETUNREACH": "",
            "ARES_CONN_ERR_INTERRUPT": "",
            "ARES_CONN_ERR_AFNOSUPPORT": "",
            "ARES_CONN_ERR_BADADDR": "",
            "ARES_CONN_ERR_NOMEM": "",
            "ARES_CONN_ERR_INVALID": "",
            "ARES_CONN_ERR_TOOLARGE": "",
            "ARES_CONN_ERR_NOTIMP": "",
            "ARES_CONN_ERR_FAILURE": ""
          },
          "ares_conn_err_t",
          [
            119,
            0
          ],
          [
            139,
            18
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_private.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "_w32_GetHostsFile(void)",
          "fn_dec_pos": [
            [
              90,
              21
            ],
            [
              90,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_w32_GetHostsFile",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_is_onion_domain(const char *name)",
          "fn_dec_pos": [
            [
              304,
              14
            ],
            [
              304,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_is_onion_domain",
            "parameters": {
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_send_query(ares_server_t *requested_server /* Optional */,\n                              ares_query_t *query, const ares_timeval_t *now)",
          "fn_dec_pos": [
            [
              307,
              14
            ],
            [
              308,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send_query",
            "parameters": {
              "requested_server": "ares_server_t",
              "query": "ares_query_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_requeue_query(ares_query_t *query, const ares_timeval_t *now,\n                                 ares_status_t            status,\n                                 ares_bool_t              inc_try_count,\n                                 ares_dns_record_t       *dnsrec,\n                                 ares_array_t           **requeue)",
          "fn_dec_pos": [
            [
              309,
              14
            ],
            [
              313,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_requeue_query",
            "parameters": {
              "query": "ares_query_t",
              "now": "ares_timeval_t",
              "status": "ares_status_t",
              "inc_try_count": "ares_bool_t",
              "dnsrec": "ares_dns_record_t",
              "requeue": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_name_label_cnt(const char *name)",
          "fn_dec_pos": [
            [
              316,
              14
            ],
            [
              316,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_name_label_cnt",
            "parameters": {
              "name": "char"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_search_name_list(const ares_channel_t *channel,\n                                    const char *name, char ***names,\n                                    size_t *names_len)",
          "fn_dec_pos": [
            [
              329,
              14
            ],
            [
              331,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_name_list",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "names": "char",
              "names_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dnsrec_convert_arg(ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              335,
              14
            ],
            [
              335,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dnsrec_convert_arg",
            "parameters": {
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dnsrec_convert_cb(void *arg, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              341,
              5
            ],
            [
              342,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dnsrec_convert_cb",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_free_query(ares_query_t *query)",
          "fn_dec_pos": [
            [
              344,
              5
            ],
            [
              344,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_query",
            "parameters": {
              "query": "ares_query_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_generate_new_id(ares_rand_state *state)",
          "fn_dec_pos": [
            [
              346,
              15
            ],
            [
              346,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_generate_new_id",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_expand_name_validated(const unsigned char *encoded,\n                                          const unsigned char *abuf, size_t alen,\n                                          char **s, size_t *enclen,\n                                          ares_bool_t is_hostname)",
          "fn_dec_pos": [
            [
              347,
              15
            ],
            [
              350,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_name_validated",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "char",
              "enclen": "size_t",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_expand_string_ex(const unsigned char *encoded,\n                                     const unsigned char *abuf, size_t alen,\n                                     unsigned char **s, size_t *enclen)",
          "fn_dec_pos": [
            [
              351,
              15
            ],
            [
              353,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_string_ex",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "unsigned char",
              "enclen": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_init_servers_state(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              354,
              15
            ],
            [
              354,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_servers_state",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_init_by_options(ares_channel_t            *channel,\n                                    const struct ares_options *options,\n                                    int                        optmask)",
          "fn_dec_pos": [
            [
              355,
              15
            ],
            [
              357,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_by_options",
            "parameters": {
              "channel": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_init_by_sysconfig(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              358,
              15
            ],
            [
              358,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_by_sysconfig",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_set_socket_functions_def(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              359,
              15
            ],
            [
              359,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_functions_def",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_sysconfig_set_options(ares_sysconfig_t *sysconfig,\n                                         const char       *str)",
          "fn_dec_pos": [
            [
              375,
              14
            ],
            [
              376,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_set_options",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_init_by_environment(ares_sysconfig_t *sysconfig)",
          "fn_dec_pos": [
            [
              378,
              14
            ],
            [
              378,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_by_environment",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "(*ares_sysconfig_line_cb_t)(const ares_channel_t *channel,\n                                                  ares_sysconfig_t     *sysconfig,\n                                                  ares_buf_t           *line)",
          "fn_dec_pos": [
            [
              381,
              22
            ],
            [
              383,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "line": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_sysconfig_parse_resolv_line(const ares_channel_t *channel,\n                                               ares_sysconfig_t     *sysconfig,\n                                               ares_buf_t           *line)",
          "fn_dec_pos": [
            [
              385,
              14
            ],
            [
              387,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_parse_resolv_line",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "line": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_sysconfig_process_buf(const ares_channel_t    *channel,\n                                         ares_sysconfig_t        *sysconfig,\n                                         ares_buf_t              *buf,\n                                         ares_sysconfig_line_cb_t cb)",
          "fn_dec_pos": [
            [
              389,
              14
            ],
            [
              392,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_process_buf",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "buf": "ares_buf_t",
              "cb": "ares_sysconfig_line_cb_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_init_sysconfig_files(const ares_channel_t *channel,\n                                        ares_sysconfig_t     *sysconfig,\n                                        ares_bool_t process_resolvconf)",
          "fn_dec_pos": [
            [
              394,
              14
            ],
            [
              396,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_files",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t",
              "process_resolvconf": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_init_sysconfig_macos(const ares_channel_t *channel,\n                                        ares_sysconfig_t     *sysconfig)",
          "fn_dec_pos": [
            [
              398,
              14
            ],
            [
              399,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_macos",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_init_sysconfig_windows(const ares_channel_t *channel,\n                                          ares_sysconfig_t     *sysconfig)",
          "fn_dec_pos": [
            [
              402,
              14
            ],
            [
              403,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_sysconfig_windows",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_parse_sortlist(struct apattern **sortlist, size_t *nsort,\n                                  const char *str)",
          "fn_dec_pos": [
            [
              406,
              14
            ],
            [
              407,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_sortlist",
            "parameters": {
              "sortlist": "struct apattern",
              "nsort": "size_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_lookup_hostaliases(const ares_channel_t *channel,\n                                      const char *name, char **alias)",
          "fn_dec_pos": [
            [
              412,
              14
            ],
            [
              413,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_lookup_hostaliases",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "alias": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_cat_domain(const char *name, const char *domain, char **s)",
          "fn_dec_pos": [
            [
              415,
              14
            ],
            [
              415,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cat_domain",
            "parameters": {
              "name": "char",
              "domain": "char",
              "s": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_sortaddrinfo(ares_channel_t            *channel,\n                                struct ares_addrinfo_node *ai_node)",
          "fn_dec_pos": [
            [
              416,
              14
            ],
            [
              417,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sortaddrinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "ai_node": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_freeaddrinfo_nodes(struct ares_addrinfo_node *ai_node)",
          "fn_dec_pos": [
            [
              419,
              14
            ],
            [
              419,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_freeaddrinfo_nodes",
            "parameters": {
              "ai_node": "struct ares_addrinfo_node"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_is_localhost(const char *name)",
          "fn_dec_pos": [
            [
              420,
              14
            ],
            [
              420,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_is_localhost",
            "parameters": {
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_append_addrinfo_node(struct ares_addrinfo_node **ai_node)",
          "fn_dec_pos": [
            [
              423,
              2
            ],
            [
              423,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_addrinfo_node",
            "parameters": {
              "ai_node": "struct ares_addrinfo_node"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_addrinfo_cat_nodes(struct ares_addrinfo_node **head,\n                             struct ares_addrinfo_node  *tail)",
          "fn_dec_pos": [
            [
              424,
              5
            ],
            [
              425,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo_cat_nodes",
            "parameters": {
              "head": "struct ares_addrinfo_node",
              "tail": "struct ares_addrinfo_node"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_freeaddrinfo_cnames(struct ares_addrinfo_cname *ai_cname)",
          "fn_dec_pos": [
            [
              427,
              5
            ],
            [
              427,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_freeaddrinfo_cnames",
            "parameters": {
              "ai_cname": "struct ares_addrinfo_cname"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_append_addrinfo_cname(struct ares_addrinfo_cname **ai_cname)",
          "fn_dec_pos": [
            [
              430,
              2
            ],
            [
              430,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_addrinfo_cname",
            "parameters": {
              "ai_cname": "struct ares_addrinfo_cname"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_append_ai_node(int aftype, unsigned short port,\n                                  unsigned int ttl, const void *adata,\n                                  struct ares_addrinfo_node **nodes)",
          "fn_dec_pos": [
            [
              432,
              14
            ],
            [
              434,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_ai_node",
            "parameters": {
              "aftype": "int",
              "port": "unsigned short",
              "ttl": "unsigned int",
              "adata": "void",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_addrinfo_cat_cnames(struct ares_addrinfo_cname **head,\n                                       struct ares_addrinfo_cname  *tail)",
          "fn_dec_pos": [
            [
              436,
              14
            ],
            [
              437,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo_cat_cnames",
            "parameters": {
              "head": "struct ares_addrinfo_cname",
              "tail": "struct ares_addrinfo_cname"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_parse_into_addrinfo(const ares_dns_record_t *dnsrec,\n                                       ares_bool_t    cname_only_is_enodata,\n                                       unsigned short port,\n                                       struct ares_addrinfo *ai)",
          "fn_dec_pos": [
            [
              439,
              14
            ],
            [
              442,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_into_addrinfo",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "cname_only_is_enodata": "ares_bool_t",
              "port": "unsigned short",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_parse_ptr_reply_dnsrec(const ares_dns_record_t *dnsrec,\n                                          const void *addr, int addrlen,\n                                          int family, struct hostent **host)",
          "fn_dec_pos": [
            [
              443,
              14
            ],
            [
              445,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ptr_reply_dnsrec",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_addrinfo2hostent(const struct ares_addrinfo *ai, int family,\n                                    struct hostent **host)",
          "fn_dec_pos": [
            [
              448,
              14
            ],
            [
              449,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo2hostent",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_addrinfo2addrttl(const struct ares_addrinfo *ai, int family,\n                                    size_t                req_naddrttls,\n                                    struct ares_addrttl  *addrttls,\n                                    struct ares_addr6ttl *addr6ttls,\n                                    size_t               *naddrttls)",
          "fn_dec_pos": [
            [
              451,
              14
            ],
            [
              455,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo2addrttl",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "family": "int",
              "req_naddrttls": "size_t",
              "addrttls": "struct ares_addrttl",
              "addr6ttls": "struct ares_addr6ttl",
              "naddrttls": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_addrinfo_localhost(const char *name, unsigned short port,\n                                      const struct ares_addrinfo_hints *hints,\n                                      struct ares_addrinfo             *ai)",
          "fn_dec_pos": [
            [
              456,
              14
            ],
            [
              458,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addrinfo_localhost",
            "parameters": {
              "name": "char",
              "port": "unsigned short",
              "hints": "struct ares_addrinfo_hints",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_servers_update(ares_channel_t *channel,\n                                  ares_llist_t   *server_list,\n                                  ares_bool_t     user_specified)",
          "fn_dec_pos": [
            [
              460,
              14
            ],
            [
              462,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_servers_update",
            "parameters": {
              "channel": "ares_channel_t",
              "server_list": "ares_llist_t",
              "user_specified": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_sconfig_append(const ares_channel_t *channel, ares_llist_t **sconfig,\n                      const struct ares_addr *addr, unsigned short udp_port,\n                      unsigned short tcp_port, const char *ll_iface)",
          "fn_dec_pos": [
            [
              464,
              2
            ],
            [
              466,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sconfig_append",
            "parameters": {
              "channel": "ares_channel_t",
              "sconfig": "ares_llist_t",
              "addr": "struct ares_addr",
              "udp_port": "unsigned short",
              "tcp_port": "unsigned short",
              "ll_iface": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_sconfig_append_fromstr(const ares_channel_t *channel,\n                                          ares_llist_t        **sconfig,\n                                          const char           *str,\n                                          ares_bool_t           ignore_invalid)",
          "fn_dec_pos": [
            [
              467,
              14
            ],
            [
              470,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sconfig_append_fromstr",
            "parameters": {
              "channel": "ares_channel_t",
              "sconfig": "ares_llist_t",
              "str": "char",
              "ignore_invalid": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_in_addr_to_sconfig_llist(const struct in_addr *servers,\n                                            size_t                nservers,\n                                            ares_llist_t        **llist)",
          "fn_dec_pos": [
            [
              471,
              14
            ],
            [
              473,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_in_addr_to_sconfig_llist",
            "parameters": {
              "servers": "struct in_addr",
              "nservers": "size_t",
              "llist": "ares_llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_get_server_addr(const ares_server_t *server,\n                                   ares_buf_t          *buf)",
          "fn_dec_pos": [
            [
              474,
              14
            ],
            [
              475,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_server_addr",
            "parameters": {
              "server": "ares_server_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_hosts_file_destroy(ares_hosts_file_t *hf)",
          "fn_dec_pos": [
            [
              480,
              32
            ],
            [
              480,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_file_destroy",
            "parameters": {
              "hf": "ares_hosts_file_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_hosts_search_ipaddr(ares_channel_t *channel,\n                                       ares_bool_t use_env, const char *ipaddr,\n                                       const ares_hosts_entry_t **entry)",
          "fn_dec_pos": [
            [
              481,
              14
            ],
            [
              483,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_search_ipaddr",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "ipaddr": "char",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_hosts_search_host(ares_channel_t *channel,\n                                     ares_bool_t use_env, const char *host,\n                                     const ares_hosts_entry_t **entry)",
          "fn_dec_pos": [
            [
              484,
              14
            ],
            [
              486,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_search_host",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "host": "char",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_hosts_entry_to_hostent(const ares_hosts_entry_t *entry,\n                                          int family, struct hostent **hostent)",
          "fn_dec_pos": [
            [
              487,
              14
            ],
            [
              488,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_entry_to_hostent",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "family": "int",
              "hostent": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_hosts_entry_to_addrinfo(const ares_hosts_entry_t *entry,\n                                           const char *name, int family,\n                                           unsigned short        port,\n                                           ares_bool_t           want_cnames,\n                                           struct ares_addrinfo *ai)",
          "fn_dec_pos": [
            [
              489,
              14
            ],
            [
              493,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_hosts_entry_to_addrinfo",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "name": "char",
              "family": "int",
              "port": "unsigned short",
              "want_cnames": "ares_bool_t",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_query_nolock(ares_channel_t *channel, const char *name,\n                                ares_dns_class_t     dnsclass,\n                                ares_dns_rec_type_t  type,\n                                ares_callback_dnsrec callback, void *arg,\n                                unsigned short *qid)",
          "fn_dec_pos": [
            [
              497,
              14
            ],
            [
              501,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_nolock",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_send_nolock(ares_channel_t *channel, ares_server_t *server,\n                               ares_send_flags_t        flags,\n                               const ares_dns_record_t *dnsrec,\n                               ares_callback_dnsrec callback, void *arg,\n                               unsigned short *qid)",
          "fn_dec_pos": [
            [
              512,
              14
            ],
            [
              516,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send_nolock",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "flags": "ares_send_flags_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_gethostbyaddr_nolock(ares_channel_t *channel, const void *addr,\n                               int addrlen, int family,\n                               ares_host_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              520,
              5
            ],
            [
              522,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyaddr_nolock",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_dns_name_parse(ares_buf_t *buf, char **name,\n                                  ares_bool_t is_hostname)",
          "fn_dec_pos": [
            [
              538,
              14
            ],
            [
              539,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_name_parse",
            "parameters": {
              "buf": "ares_buf_t",
              "name": "char",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_name_write(ares_buf_t *buf, ares_llist_t **list,\n                                  ares_bool_t validate_hostname,\n                                  const char *name)",
          "fn_dec_pos": [
            [
              558,
              14
            ],
            [
              560,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_name_write",
            "parameters": {
              "buf": "ares_buf_t",
              "list": "ares_llist_t",
              "validate_hostname": "ares_bool_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_queue_notify_empty(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              569,
              14
            ],
            [
              569,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_notify_empty",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_subnet_match(const struct ares_addr *addr,\n                                const struct ares_addr *subnet,\n                                unsigned char           netmask)",
          "fn_dec_pos": [
            [
              575,
              14
            ],
            [
              577,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_subnet_match",
            "parameters": {
              "addr": "struct ares_addr",
              "subnet": "struct ares_addr",
              "netmask": "unsigned char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_addr_is_linklocal(const struct ares_addr *addr)",
          "fn_dec_pos": [
            [
              578,
              14
            ],
            [
              578,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addr_is_linklocal",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_qcache_destroy(ares_qcache_t *cache)",
          "fn_dec_pos": [
            [
              580,
              14
            ],
            [
              580,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_destroy",
            "parameters": {
              "cache": "ares_qcache_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_qcache_create(ares_rand_state *rand_state,\n                                 unsigned int     max_ttl,\n                                 ares_qcache_t  **cache_out)",
          "fn_dec_pos": [
            [
              581,
              14
            ],
            [
              583,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "max_ttl": "unsigned int",
              "cache_out": "ares_qcache_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_qcache_flush(ares_qcache_t *cache)",
          "fn_dec_pos": [
            [
              584,
              14
            ],
            [
              584,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_flush",
            "parameters": {
              "cache": "ares_qcache_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_qcache_insert(ares_channel_t          *channel,\n                                 const ares_timeval_t    *now,\n                                 const ares_query_t      *query,\n                                 const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              585,
              14
            ],
            [
              588,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_insert",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "ares_timeval_t",
              "query": "ares_query_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_qcache_fetch(ares_channel_t           *channel,\n                                const ares_timeval_t     *now,\n                                const ares_dns_record_t  *dnsrec,\n                                const ares_dns_record_t **dnsrec_resp)",
          "fn_dec_pos": [
            [
              589,
              14
            ],
            [
              592,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_fetch",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "ares_timeval_t",
              "dnsrec": "ares_dns_record_t",
              "dnsrec_resp": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_metrics_record(const ares_query_t *query, ares_server_t *server,\n                           ares_status_t status, const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              594,
              7
            ],
            [
              595,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_metrics_record",
            "parameters": {
              "query": "ares_query_t",
              "server": "ares_server_t",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_metrics_server_timeout(const ares_server_t  *server,\n                                   const ares_timeval_t *now)",
          "fn_dec_pos": [
            [
              596,
              7
            ],
            [
              597,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_metrics_server_timeout",
            "parameters": {
              "server": "ares_server_t",
              "now": "ares_timeval_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_cookie_apply(ares_dns_record_t *dnsrec, ares_conn_t *conn,\n                                const ares_timeval_t *now)",
          "fn_dec_pos": [
            [
              599,
              14
            ],
            [
              600,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cookie_apply",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "conn": "ares_conn_t",
              "now": "ares_timeval_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_cookie_validate(ares_query_t            *query,\n                                   const ares_dns_record_t *dnsresp,\n                                   ares_conn_t             *conn,\n                                   const ares_timeval_t    *now,\n                                   ares_array_t           **requeue)",
          "fn_dec_pos": [
            [
              601,
              14
            ],
            [
              605,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cookie_validate",
            "parameters": {
              "query": "ares_query_t",
              "dnsresp": "ares_dns_record_t",
              "conn": "ares_conn_t",
              "now": "ares_timeval_t",
              "requeue": "ares_array_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_channel_threading_init(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              607,
              14
            ],
            [
              607,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_channel_threading_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_channel_threading_destroy(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              608,
              14
            ],
            [
              608,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_channel_threading_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_channel_lock(const ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              609,
              14
            ],
            [
              609,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_channel_lock",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_channel_unlock(const ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              610,
              14
            ],
            [
              610,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_channel_unlock",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_event_thread_destroy(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              615,
              14
            ],
            [
              615,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_event_thread_init(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              616,
              14
            ],
            [
              616,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_query {\n  /* Query ID from qbuf, for faster lookup, and current timeout */\n  unsigned short       qid; /* host byte order */\n  ares_timeval_t       ts;  /*!< Timestamp query was sent */\n  ares_timeval_t       timeout;\n  ares_channel_t      *channel;\n\n  /*\n   * Node object for each list entry the query belongs to in order to\n   * make removal operations O(1).\n   */\n  ares_slist_node_t   *node_queries_by_timeout;\n  ares_llist_node_t   *node_queries_to_conn;\n  ares_llist_node_t   *node_all_queries;\n\n  /* connection handle query is associated with */\n  ares_conn_t         *conn;\n\n  /* Query */\n  ares_dns_record_t   *query;\n\n  ares_callback_dnsrec callback;\n  void                *arg;\n\n  /* Query status */\n  size_t        try_count; /* Number of times we tried this query already. */\n  size_t        cookie_try_count; /* Attempt count for cookie resends */\n  ares_bool_t   using_tcp;\n  ares_status_t error_status;\n  size_t        timeouts;   /* number of timeouts we saw for this request */\n  ares_bool_t   no_retries; /* do not perform any additional retries, this is\n                             * set when a query is to be canceled */\n}",
          {
            "qid": "unsigned short",
            "ts": "ares_timeval_t",
            "timeout": "ares_timeval_t",
            "*channel": "ares_channel_t",
            "*node_queries_by_timeout": "ares_slist_node_t",
            "*node_queries_to_conn": "ares_llist_node_t",
            "*node_all_queries": "ares_llist_node_t",
            "*conn": "ares_conn_t",
            "*query": "ares_dns_record_t",
            "callback": "ares_callback_dnsrec",
            "*arg": "void",
            "try_count": "size_t",
            "cookie_try_count": "size_t",
            "using_tcp": "ares_bool_t",
            "error_status": "ares_status_t",
            "timeouts": "size_t",
            "no_retries": "ares_bool_t"
          },
          "ares_query",
          [
            137,
            0
          ],
          [
            169,
            1
          ]
        ],
        [
          "struct apattern {\n  struct ares_addr addr;\n  unsigned char    mask;\n}",
          {
            "addr": "struct ares_addr",
            "mask": "unsigned char"
          },
          "apattern",
          [
            171,
            0
          ],
          [
            174,
            1
          ]
        ],
        [
          "struct ares_channeldata {\n  /* Configuration data */\n  unsigned int         flags;\n  size_t               timeout; /* in milliseconds */\n  size_t               tries;\n  size_t               ndots;\n  size_t               maxtimeout;                 /* in milliseconds */\n  ares_bool_t          rotate;\n  unsigned short       udp_port;                   /* stored in network order */\n  unsigned short       tcp_port;                   /* stored in network order */\n  int                  socket_send_buffer_size;    /* setsockopt takes int */\n  int                  socket_receive_buffer_size; /* setsockopt takes int */\n  char               **domains;\n  size_t               ndomains;\n  struct apattern     *sortlist;\n  size_t               nsort;\n  char                *lookups;\n  size_t               ednspsz;\n  unsigned int         qcache_max_ttl;\n  ares_evsys_t         evsys;\n  unsigned int         optmask;\n\n  /* For binding to local devices and/or IP addresses.  Leave\n   * them null/zero for no binding.\n   */\n  char                 local_dev_name[32];\n  unsigned int         local_ip4;\n  unsigned char        local_ip6[16];\n\n  /* Thread safety lock */\n  ares_thread_mutex_t *lock;\n\n  /* Conditional to wake waiters when queue is empty */\n  ares_thread_cond_t  *cond_empty;\n\n  /* Server addresses and communications state. Sorted by least consecutive\n   * failures, followed by the configuration order if failures are equal. */\n  ares_slist_t        *servers;\n\n  /* random state to use when generating new ids and generating retry penalties\n   */\n  ares_rand_state     *rand_state;\n\n  /* All active queries in a single list */\n  ares_llist_t        *all_queries;\n  /* Queries bucketed by qid, for quickly dispatching DNS responses: */\n  ares_htable_szvp_t  *queries_by_qid;\n\n  /* Queries bucketed by timeout, for quickly handling timeouts: */\n  ares_slist_t        *queries_by_timeout;\n\n  /* Map linked list node member for connection to file descriptor.  We use\n   * the node instead of the connection object itself so we can quickly look\n   * up a connection and remove it if necessary (as otherwise we'd have to\n   * scan all connections) */\n  ares_htable_asvp_t  *connnode_by_socket;\n\n  ares_sock_state_cb   sock_state_cb;\n  void                *sock_state_cb_data;\n\n  ares_sock_create_callback           sock_create_cb;\n  void                               *sock_create_cb_data;\n\n  ares_sock_config_callback           sock_config_cb;\n  void                               *sock_config_cb_data;\n\n  struct ares_socket_functions_ex     sock_funcs;\n  void                               *sock_func_cb_data;\n  const struct ares_socket_functions *legacy_sock_funcs;\n  void                               *legacy_sock_funcs_cb_data;\n\n  ares_pending_write_cb               notify_pending_write_cb;\n  void                               *notify_pending_write_cb_data;\n  ares_bool_t                         notify_pending_write;\n\n  ares_query_enqueue_cb               query_enqueue_cb;\n  void                               *query_enqueue_cb_data;\n\n  /* Path for resolv.conf file, configurable via ares_options */\n  char                               *resolvconf_path;\n\n  /* Path for hosts file, configurable via ares_options */\n  char                               *hosts_path;\n\n  /* Maximum UDP queries per connection allowed */\n  size_t                              udp_max_queries;\n\n  /* Cache of local hosts file */\n  ares_hosts_file_t                  *hf;\n\n  /* Query Cache */\n  ares_qcache_t                      *qcache;\n\n  /* Fields controlling server failover behavior.\n   * The retry chance is the probability (1/N) by which we will retry a failed\n   * server instead of the best server when selecting a server to send queries\n   * to.\n   * The retry delay is the minimum time in milliseconds to wait between doing\n   * such retries (applied per-server).\n   */\n  unsigned short                      server_retry_chance;\n  size_t                              server_retry_delay;\n\n  /* Callback triggered when a server has a successful or failed response */\n  ares_server_state_callback          server_state_cb;\n  void                               *server_state_cb_data;\n\n  /* TRUE if a reinit is pending.  Reinit spawns a thread to read the system\n   * configuration and then apply the configuration since configuration\n   * reading may block.  The thread handle is provided for waiting on thread\n   * exit. */\n  ares_bool_t                         reinit_pending;\n  ares_thread_t                      *reinit_thread;\n\n  /* Whether the system is up or not.  This is mainly to prevent deadlocks\n   * and access violations during the cleanup process.  Some things like\n   * system config changes might get triggered and we need a flag to make\n   * sure we don't take action. */\n  ares_bool_t                         sys_up;\n}",
          {
            "flags": "unsigned int",
            "timeout": "size_t",
            "tries": "size_t",
            "ndots": "size_t",
            "maxtimeout": "size_t",
            "rotate": "ares_bool_t",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "socket_send_buffer_size": "int",
            "socket_receive_buffer_size": "int",
            "**domains": "char",
            "ndomains": "size_t",
            "*sortlist": "struct apattern",
            "nsort": "size_t",
            "*lookups": "char",
            "ednspsz": "size_t",
            "qcache_max_ttl": "unsigned int",
            "evsys": "ares_evsys_t",
            "optmask": "unsigned int",
            "local_dev_name[32]": "char",
            "local_ip4": "unsigned int",
            "local_ip6[16]": "unsigned char",
            "*lock": "ares_thread_mutex_t",
            "*cond_empty": "ares_thread_cond_t",
            "*servers": "ares_slist_t",
            "*rand_state": "ares_rand_state",
            "*all_queries": "ares_llist_t",
            "*queries_by_qid": "ares_htable_szvp_t",
            "*queries_by_timeout": "ares_slist_t",
            "*connnode_by_socket": "ares_htable_asvp_t",
            "sock_state_cb": "ares_sock_state_cb",
            "*sock_state_cb_data": "void",
            "sock_create_cb": "ares_sock_create_callback",
            "*sock_create_cb_data": "void",
            "sock_config_cb": "ares_sock_config_callback",
            "*sock_config_cb_data": "void",
            "sock_funcs": "struct ares_socket_functions_ex",
            "*sock_func_cb_data": "void",
            "struct ares_socket_functions": "const",
            "*legacy_sock_funcs_cb_data": "void",
            "notify_pending_write_cb": "ares_pending_write_cb",
            "*notify_pending_write_cb_data": "void",
            "notify_pending_write": "ares_bool_t",
            "query_enqueue_cb": "ares_query_enqueue_cb",
            "*query_enqueue_cb_data": "void",
            "*resolvconf_path": "char",
            "*hosts_path": "char",
            "udp_max_queries": "size_t",
            "*hf": "ares_hosts_file_t",
            "*qcache": "ares_qcache_t",
            "server_retry_chance": "unsigned short",
            "server_retry_delay": "size_t",
            "server_state_cb": "ares_server_state_callback",
            "*server_state_cb_data": "void",
            "reinit_pending": "ares_bool_t",
            "*reinit_thread": "ares_thread_t",
            "sys_up": "ares_bool_t"
          },
          "ares_channeldata",
          [
            182,
            0
          ],
          [
            301,
            1
          ]
        ],
        [
          "typedef struct {\n  ares_llist_t    *sconfig;\n  struct apattern *sortlist;\n  size_t           nsortlist;\n  char           **domains;\n  size_t           ndomains;\n  char            *lookups;\n  size_t           ndots;\n  size_t           tries;\n  ares_bool_t      rotate;\n  size_t           timeout_ms;\n  ares_bool_t      usevc;\n} ares_sysconfig_t;",
          {
            "*sconfig": "ares_llist_t",
            "*sortlist": "struct apattern",
            "nsortlist": "size_t",
            "**domains": "char",
            "ndomains": "size_t",
            "*lookups": "char",
            "ndots": "size_t",
            "tries": "size_t",
            "rotate": "ares_bool_t",
            "timeout_ms": "size_t",
            "usevc": "ares_bool_t"
          },
          "ares_sysconfig_t",
          [
            361,
            0
          ],
          [
            373,
            19
          ]
        ],
        [
          "struct ares_query",
          {},
          "",
          [
            133,
            0
          ],
          [
            133,
            17
          ]
        ],
        [
          "typedef struct ares_query ares_query_t;",
          {},
          "ares_query_t",
          [
            134,
            0
          ],
          [
            134,
            39
          ]
        ],
        [
          "struct ares_query {\n  /* Query ID from qbuf, for faster lookup, and current timeout */\n  unsigned short       qid; /* host byte order */\n  ares_timeval_t       ts;  /*!< Timestamp query was sent */\n  ares_timeval_t       timeout;\n  ares_channel_t      *channel;\n\n  /*\n   * Node object for each list entry the query belongs to in order to\n   * make removal operations O(1).\n   */\n  ares_slist_node_t   *node_queries_by_timeout;\n  ares_llist_node_t   *node_queries_to_conn;\n  ares_llist_node_t   *node_all_queries;\n\n  /* connection handle query is associated with */\n  ares_conn_t         *conn;\n\n  /* Query */\n  ares_dns_record_t   *query;\n\n  ares_callback_dnsrec callback;\n  void                *arg;\n\n  /* Query status */\n  size_t        try_count; /* Number of times we tried this query already. */\n  size_t        cookie_try_count; /* Attempt count for cookie resends */\n  ares_bool_t   using_tcp;\n  ares_status_t error_status;\n  size_t        timeouts;   /* number of timeouts we saw for this request */\n  ares_bool_t   no_retries; /* do not perform any additional retries, this is\n                             * set when a query is to be canceled */\n}",
          {
            "qid": "unsigned short",
            "ts": "ares_timeval_t",
            "timeout": "ares_timeval_t",
            "*channel": "ares_channel_t",
            "*node_queries_by_timeout": "ares_slist_node_t",
            "*node_queries_to_conn": "ares_llist_node_t",
            "*node_all_queries": "ares_llist_node_t",
            "*conn": "ares_conn_t",
            "*query": "ares_dns_record_t",
            "callback": "ares_callback_dnsrec",
            "*arg": "void",
            "try_count": "size_t",
            "cookie_try_count": "size_t",
            "using_tcp": "ares_bool_t",
            "error_status": "ares_status_t",
            "timeouts": "size_t",
            "no_retries": "ares_bool_t"
          },
          "ares_query",
          [
            137,
            0
          ],
          [
            169,
            1
          ]
        ],
        [
          "struct apattern {\n  struct ares_addr addr;\n  unsigned char    mask;\n}",
          {
            "addr": "struct ares_addr",
            "mask": "unsigned char"
          },
          "apattern",
          [
            171,
            0
          ],
          [
            174,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            172,
            2
          ],
          [
            172,
            18
          ]
        ],
        [
          "struct ares_qcache",
          {},
          "",
          [
            176,
            0
          ],
          [
            176,
            18
          ]
        ],
        [
          "typedef struct ares_qcache ares_qcache_t;",
          {},
          "ares_qcache_t",
          [
            177,
            0
          ],
          [
            177,
            41
          ]
        ],
        [
          "struct ares_hosts_file",
          {},
          "",
          [
            179,
            0
          ],
          [
            179,
            22
          ]
        ],
        [
          "typedef struct ares_hosts_file ares_hosts_file_t;",
          {},
          "ares_hosts_file_t",
          [
            180,
            0
          ],
          [
            180,
            49
          ]
        ],
        [
          "struct ares_channeldata {\n  /* Configuration data */\n  unsigned int         flags;\n  size_t               timeout; /* in milliseconds */\n  size_t               tries;\n  size_t               ndots;\n  size_t               maxtimeout;                 /* in milliseconds */\n  ares_bool_t          rotate;\n  unsigned short       udp_port;                   /* stored in network order */\n  unsigned short       tcp_port;                   /* stored in network order */\n  int                  socket_send_buffer_size;    /* setsockopt takes int */\n  int                  socket_receive_buffer_size; /* setsockopt takes int */\n  char               **domains;\n  size_t               ndomains;\n  struct apattern     *sortlist;\n  size_t               nsort;\n  char                *lookups;\n  size_t               ednspsz;\n  unsigned int         qcache_max_ttl;\n  ares_evsys_t         evsys;\n  unsigned int         optmask;\n\n  /* For binding to local devices and/or IP addresses.  Leave\n   * them null/zero for no binding.\n   */\n  char                 local_dev_name[32];\n  unsigned int         local_ip4;\n  unsigned char        local_ip6[16];\n\n  /* Thread safety lock */\n  ares_thread_mutex_t *lock;\n\n  /* Conditional to wake waiters when queue is empty */\n  ares_thread_cond_t  *cond_empty;\n\n  /* Server addresses and communications state. Sorted by least consecutive\n   * failures, followed by the configuration order if failures are equal. */\n  ares_slist_t        *servers;\n\n  /* random state to use when generating new ids and generating retry penalties\n   */\n  ares_rand_state     *rand_state;\n\n  /* All active queries in a single list */\n  ares_llist_t        *all_queries;\n  /* Queries bucketed by qid, for quickly dispatching DNS responses: */\n  ares_htable_szvp_t  *queries_by_qid;\n\n  /* Queries bucketed by timeout, for quickly handling timeouts: */\n  ares_slist_t        *queries_by_timeout;\n\n  /* Map linked list node member for connection to file descriptor.  We use\n   * the node instead of the connection object itself so we can quickly look\n   * up a connection and remove it if necessary (as otherwise we'd have to\n   * scan all connections) */\n  ares_htable_asvp_t  *connnode_by_socket;\n\n  ares_sock_state_cb   sock_state_cb;\n  void                *sock_state_cb_data;\n\n  ares_sock_create_callback           sock_create_cb;\n  void                               *sock_create_cb_data;\n\n  ares_sock_config_callback           sock_config_cb;\n  void                               *sock_config_cb_data;\n\n  struct ares_socket_functions_ex     sock_funcs;\n  void                               *sock_func_cb_data;\n  const struct ares_socket_functions *legacy_sock_funcs;\n  void                               *legacy_sock_funcs_cb_data;\n\n  ares_pending_write_cb               notify_pending_write_cb;\n  void                               *notify_pending_write_cb_data;\n  ares_bool_t                         notify_pending_write;\n\n  ares_query_enqueue_cb               query_enqueue_cb;\n  void                               *query_enqueue_cb_data;\n\n  /* Path for resolv.conf file, configurable via ares_options */\n  char                               *resolvconf_path;\n\n  /* Path for hosts file, configurable via ares_options */\n  char                               *hosts_path;\n\n  /* Maximum UDP queries per connection allowed */\n  size_t                              udp_max_queries;\n\n  /* Cache of local hosts file */\n  ares_hosts_file_t                  *hf;\n\n  /* Query Cache */\n  ares_qcache_t                      *qcache;\n\n  /* Fields controlling server failover behavior.\n   * The retry chance is the probability (1/N) by which we will retry a failed\n   * server instead of the best server when selecting a server to send queries\n   * to.\n   * The retry delay is the minimum time in milliseconds to wait between doing\n   * such retries (applied per-server).\n   */\n  unsigned short                      server_retry_chance;\n  size_t                              server_retry_delay;\n\n  /* Callback triggered when a server has a successful or failed response */\n  ares_server_state_callback          server_state_cb;\n  void                               *server_state_cb_data;\n\n  /* TRUE if a reinit is pending.  Reinit spawns a thread to read the system\n   * configuration and then apply the configuration since configuration\n   * reading may block.  The thread handle is provided for waiting on thread\n   * exit. */\n  ares_bool_t                         reinit_pending;\n  ares_thread_t                      *reinit_thread;\n\n  /* Whether the system is up or not.  This is mainly to prevent deadlocks\n   * and access violations during the cleanup process.  Some things like\n   * system config changes might get triggered and we need a flag to make\n   * sure we don't take action. */\n  ares_bool_t                         sys_up;\n}",
          {
            "flags": "unsigned int",
            "timeout": "size_t",
            "tries": "size_t",
            "ndots": "size_t",
            "maxtimeout": "size_t",
            "rotate": "ares_bool_t",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "socket_send_buffer_size": "int",
            "socket_receive_buffer_size": "int",
            "**domains": "char",
            "ndomains": "size_t",
            "*sortlist": "struct apattern",
            "nsort": "size_t",
            "*lookups": "char",
            "ednspsz": "size_t",
            "qcache_max_ttl": "unsigned int",
            "evsys": "ares_evsys_t",
            "optmask": "unsigned int",
            "local_dev_name[32]": "char",
            "local_ip4": "unsigned int",
            "local_ip6[16]": "unsigned char",
            "*lock": "ares_thread_mutex_t",
            "*cond_empty": "ares_thread_cond_t",
            "*servers": "ares_slist_t",
            "*rand_state": "ares_rand_state",
            "*all_queries": "ares_llist_t",
            "*queries_by_qid": "ares_htable_szvp_t",
            "*queries_by_timeout": "ares_slist_t",
            "*connnode_by_socket": "ares_htable_asvp_t",
            "sock_state_cb": "ares_sock_state_cb",
            "*sock_state_cb_data": "void",
            "sock_create_cb": "ares_sock_create_callback",
            "*sock_create_cb_data": "void",
            "sock_config_cb": "ares_sock_config_callback",
            "*sock_config_cb_data": "void",
            "sock_funcs": "struct ares_socket_functions_ex",
            "*sock_func_cb_data": "void",
            "struct ares_socket_functions": "const",
            "*legacy_sock_funcs_cb_data": "void",
            "notify_pending_write_cb": "ares_pending_write_cb",
            "*notify_pending_write_cb_data": "void",
            "notify_pending_write": "ares_bool_t",
            "query_enqueue_cb": "ares_query_enqueue_cb",
            "*query_enqueue_cb_data": "void",
            "*resolvconf_path": "char",
            "*hosts_path": "char",
            "udp_max_queries": "size_t",
            "*hf": "ares_hosts_file_t",
            "*qcache": "ares_qcache_t",
            "server_retry_chance": "unsigned short",
            "server_retry_delay": "size_t",
            "server_state_cb": "ares_server_state_callback",
            "*server_state_cb_data": "void",
            "reinit_pending": "ares_bool_t",
            "*reinit_thread": "ares_thread_t",
            "sys_up": "ares_bool_t"
          },
          "ares_channeldata",
          [
            182,
            0
          ],
          [
            301,
            1
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            196,
            2
          ],
          [
            196,
            17
          ]
        ],
        [
          "struct ares_socket_functions_ex",
          {},
          "",
          [
            248,
            2
          ],
          [
            248,
            33
          ]
        ],
        [
          "struct ares_socket_functions",
          {},
          "",
          [
            250,
            8
          ],
          [
            250,
            36
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            356,
            42
          ],
          [
            356,
            61
          ]
        ],
        [
          "typedef struct {\n  ares_llist_t    *sconfig;\n  struct apattern *sortlist;\n  size_t           nsortlist;\n  char           **domains;\n  size_t           ndomains;\n  char            *lookups;\n  size_t           ndots;\n  size_t           tries;\n  ares_bool_t      rotate;\n  size_t           timeout_ms;\n  ares_bool_t      usevc;\n} ares_sysconfig_t;",
          {
            "*sconfig": "ares_llist_t",
            "*sortlist": "struct apattern",
            "nsortlist": "size_t",
            "**domains": "char",
            "ndomains": "size_t",
            "*lookups": "char",
            "ndots": "size_t",
            "tries": "size_t",
            "rotate": "ares_bool_t",
            "timeout_ms": "size_t",
            "usevc": "ares_bool_t"
          },
          "ares_sysconfig_t",
          [
            361,
            0
          ],
          [
            373,
            19
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            363,
            2
          ],
          [
            363,
            17
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            406,
            34
          ],
          [
            406,
            49
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            417,
            32
          ],
          [
            417,
            57
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            419,
            38
          ],
          [
            419,
            63
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            422,
            0
          ],
          [
            422,
            25
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            423,
            28
          ],
          [
            423,
            53
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            424,
            29
          ],
          [
            424,
            54
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            425,
            29
          ],
          [
            425,
            54
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            427,
            30
          ],
          [
            427,
            56
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            429,
            0
          ],
          [
            429,
            26
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            430,
            29
          ],
          [
            430,
            55
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            434,
            34
          ],
          [
            434,
            59
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            436,
            39
          ],
          [
            436,
            65
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            437,
            39
          ],
          [
            437,
            65
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            442,
            39
          ],
          [
            442,
            59
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            445,
            54
          ],
          [
            445,
            68
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            448,
            42
          ],
          [
            448,
            62
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            449,
            36
          ],
          [
            449,
            50
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            451,
            42
          ],
          [
            451,
            62
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            453,
            36
          ],
          [
            453,
            55
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            454,
            36
          ],
          [
            454,
            56
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            457,
            44
          ],
          [
            457,
            70
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            458,
            38
          ],
          [
            458,
            58
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            465,
            28
          ],
          [
            465,
            44
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            471,
            50
          ],
          [
            471,
            64
          ]
        ],
        [
          "struct ares_hosts_entry",
          {},
          "",
          [
            477,
            0
          ],
          [
            477,
            23
          ]
        ],
        [
          "typedef struct ares_hosts_entry ares_hosts_entry_t;",
          {},
          "ares_hosts_entry_t",
          [
            478,
            0
          ],
          [
            478,
            51
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            488,
            54
          ],
          [
            488,
            68
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            493,
            43
          ],
          [
            493,
            63
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            575,
            38
          ],
          [
            575,
            54
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            576,
            38
          ],
          [
            576,
            54
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            578,
            43
          ],
          [
            578,
            59
          ]
        ],
        [
          "struct ares_event_thread",
          {},
          "",
          [
            612,
            0
          ],
          [
            612,
            24
          ]
        ],
        [
          "typedef struct ares_event_thread ares_event_thread_t;",
          {},
          "ares_event_thread_t",
          [
            613,
            0
          ],
          [
            613,
            53
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"ares_mem.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"util/ares_math.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"util/ares_time.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"util/ares_rand.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"ares_array.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"ares_llist.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"dsa/ares_slist.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"ares_htable_strvp.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"ares_htable_szvp.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"ares_htable_asvp.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"ares_htable_dict.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include \"ares_htable_vpvp.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include \"ares_htable_vpstr.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"record/ares_dns_multistring.h\"\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include \"ares_buf.h\"\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include \"record/ares_dns_private.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"util/ares_iface_ips.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include \"util/ares_threads.h\"\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"ares_socket.h\"\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include \"ares_conn.h\"\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include \"ares_str.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"str/ares_strsplit.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"util/ares_uri.h\"\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#  include \"ares_getenv.h\"\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_SEND_FLAG_NOCACHE = 1 << 0, /*!< Do not query the cache */\n  ARES_SEND_FLAG_NORETRY = 1 << 1  /*!< Do not retry this query on error */\n} ares_send_flags_t;",
          {
            "ARES_SEND_FLAG_NOCACHE": "",
            "ARES_SEND_FLAG_NORETRY": ""
          },
          "ares_send_flags_t",
          [
            504,
            0
          ],
          [
            507,
            20
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/config-win32.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_setup.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval {\n  ares_int64_t tv_sec;\n  long         tv_usec;\n}",
          {
            "tv_sec": "ares_int64_t",
            "tv_usec": "long"
          },
          "timeval",
          [
            204,
            0
          ],
          [
            207,
            1
          ]
        ],
        [
          "struct timeval {\n  ares_int64_t tv_sec;\n  long         tv_usec;\n}",
          {
            "tv_sec": "ares_int64_t",
            "tv_usec": "long"
          },
          "timeval",
          [
            204,
            0
          ],
          [
            207,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#  include \"ares_config.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#    include \"config-win32.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"ares_build.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            80,
            0
          ],
          [
            81,
            0
          ]
        ],
        [
          "#    include <winsock2.h>\n",
          [
            82,
            0
          ],
          [
            83,
            0
          ]
        ],
        [
          "#      include <ws2tcpip.h>\n",
          [
            85,
            0
          ],
          [
            86,
            0
          ]
        ],
        [
          "#      include <winsock.h>\n",
          [
            89,
            0
          ],
          [
            90,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            96,
            0
          ],
          [
            97,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            97,
            0
          ],
          [
            98,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            98,
            0
          ],
          [
            99,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            99,
            0
          ],
          [
            100,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            100,
            0
          ],
          [
            101,
            0
          ]
        ],
        [
          "#  include <errno.h>\n",
          [
            103,
            0
          ],
          [
            104,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            107,
            0
          ],
          [
            108,
            0
          ]
        ],
        [
          "#  include <malloc.h>\n",
          [
            111,
            0
          ],
          [
            112,
            0
          ]
        ],
        [
          "#  include <sys/stat.h>\n",
          [
            115,
            0
          ],
          [
            116,
            0
          ]
        ],
        [
          "#  include <sys/time.h>\n",
          [
            119,
            0
          ],
          [
            120,
            0
          ]
        ],
        [
          "#  include <time.h>\n",
          [
            123,
            0
          ],
          [
            124,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            127,
            0
          ],
          [
            128,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            131,
            0
          ],
          [
            132,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            147,
            0
          ],
          [
            148,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            148,
            0
          ],
          [
            149,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/Makefile.inc": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_data.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_malloc_data(ares_datatype type)",
          "fn_dec_pos": [
            [
              88,
              6
            ],
            [
              88,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_data",
            "parameters": {
              "type": "ares_datatype"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_data {\n  ares_datatype type; /* Actual data type identifier. */\n  unsigned int  mark; /* Private ares_data signature. */\n\n  union {\n    struct ares_txt_reply      txt_reply;\n    struct ares_txt_ext        txt_ext;\n    struct ares_srv_reply      srv_reply;\n    struct ares_addr_node      addr_node;\n    struct ares_addr_port_node addr_port_node;\n    struct ares_mx_reply       mx_reply;\n    struct ares_naptr_reply    naptr_reply;\n    struct ares_soa_reply      soa_reply;\n    struct ares_caa_reply      caa_reply;\n    struct ares_uri_reply      uri_reply;\n  } data;\n}",
          {
            "type": "ares_datatype",
            "mark": "unsigned int",
            "data": "union {\n    struct ares_txt_reply      txt_reply;\n    struct ares_txt_ext        txt_ext;\n    struct ares_srv_reply      srv_reply;\n    struct ares_addr_node      addr_node;\n    struct ares_addr_port_node addr_port_node;\n    struct ares_mx_reply       mx_reply;\n    struct ares_naptr_reply    naptr_reply;\n    struct ares_soa_reply      soa_reply;\n    struct ares_caa_reply      caa_reply;\n    struct ares_uri_reply      uri_reply;\n  }",
            "txt_reply": "struct ares_txt_reply",
            "txt_ext": "struct ares_txt_ext",
            "srv_reply": "struct ares_srv_reply",
            "addr_node": "struct ares_addr_node",
            "addr_port_node": "struct ares_addr_port_node",
            "mx_reply": "struct ares_mx_reply",
            "naptr_reply": "struct ares_naptr_reply",
            "soa_reply": "struct ares_soa_reply",
            "caa_reply": "struct ares_caa_reply",
            "uri_reply": "struct ares_uri_reply"
          },
          "ares_data",
          [
            70,
            0
          ],
          [
            86,
            1
          ]
        ],
        [
          "struct ares_data {\n  ares_datatype type; /* Actual data type identifier. */\n  unsigned int  mark; /* Private ares_data signature. */\n\n  union {\n    struct ares_txt_reply      txt_reply;\n    struct ares_txt_ext        txt_ext;\n    struct ares_srv_reply      srv_reply;\n    struct ares_addr_node      addr_node;\n    struct ares_addr_port_node addr_port_node;\n    struct ares_mx_reply       mx_reply;\n    struct ares_naptr_reply    naptr_reply;\n    struct ares_soa_reply      soa_reply;\n    struct ares_caa_reply      caa_reply;\n    struct ares_uri_reply      uri_reply;\n  } data;\n}",
          {
            "type": "ares_datatype",
            "mark": "unsigned int",
            "data": "union {\n    struct ares_txt_reply      txt_reply;\n    struct ares_txt_ext        txt_ext;\n    struct ares_srv_reply      srv_reply;\n    struct ares_addr_node      addr_node;\n    struct ares_addr_port_node addr_port_node;\n    struct ares_mx_reply       mx_reply;\n    struct ares_naptr_reply    naptr_reply;\n    struct ares_soa_reply      soa_reply;\n    struct ares_caa_reply      caa_reply;\n    struct ares_uri_reply      uri_reply;\n  }",
            "txt_reply": "struct ares_txt_reply",
            "txt_ext": "struct ares_txt_ext",
            "srv_reply": "struct ares_srv_reply",
            "addr_node": "struct ares_addr_node",
            "addr_port_node": "struct ares_addr_port_node",
            "mx_reply": "struct ares_mx_reply",
            "naptr_reply": "struct ares_naptr_reply",
            "soa_reply": "struct ares_soa_reply",
            "caa_reply": "struct ares_caa_reply",
            "uri_reply": "struct ares_uri_reply"
          },
          "ares_data",
          [
            70,
            0
          ],
          [
            86,
            1
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            75,
            4
          ],
          [
            75,
            25
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            76,
            4
          ],
          [
            76,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            77,
            4
          ],
          [
            77,
            25
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            78,
            4
          ],
          [
            78,
            25
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            79,
            4
          ],
          [
            79,
            30
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            80,
            4
          ],
          [
            80,
            24
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            81,
            4
          ],
          [
            81,
            27
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            82,
            4
          ],
          [
            82,
            25
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            83,
            4
          ],
          [
            83,
            25
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            84,
            4
          ],
          [
            84,
            25
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_DATATYPE_UNKNOWN = 1, /* unknown data type     - introduced in 1.7.0 */\n  ARES_DATATYPE_SRV_REPLY,   /* struct ares_srv_reply - introduced in 1.7.0 */\n  ARES_DATATYPE_TXT_REPLY,   /* struct ares_txt_reply - introduced in 1.7.0 */\n  ARES_DATATYPE_TXT_EXT,     /* struct ares_txt_ext   - introduced in 1.11.0 */\n  ARES_DATATYPE_ADDR_NODE,   /* struct ares_addr_node - introduced in 1.7.1 */\n  ARES_DATATYPE_MX_REPLY,    /* struct ares_mx_reply   - introduced in 1.7.2 */\n  ARES_DATATYPE_NAPTR_REPLY, /* struct ares_naptr_reply - introduced in 1.7.6 */\n  ARES_DATATYPE_SOA_REPLY,   /* struct ares_soa_reply - introduced in 1.9.0 */\n  ARES_DATATYPE_URI_REPLY,   /* struct ares_uri_reply */\n#if 0\n  ARES_DATATYPE_ADDR6TTL,     /* struct ares_addrttl   */\n  ARES_DATATYPE_ADDRTTL,      /* struct ares_addr6ttl  */\n  ARES_DATATYPE_HOSTENT,      /* struct hostent        */\n  ARES_DATATYPE_OPTIONS,      /* struct ares_options   */\n#endif\n  ARES_DATATYPE_ADDR_PORT_NODE, /* struct ares_addr_port_node - introduced\n                                   in 1.11.0 */\n  ARES_DATATYPE_CAA_REPLY, /* struct ares_caa_reply   - introduced in 1.17 */\n  ARES_DATATYPE_LAST       /* not used              - introduced in 1.7.0 */\n} ares_datatype;",
          {
            "ARES_DATATYPE_UNKNOWN": "",
            "ARES_DATATYPE_SRV_REPLY": "",
            "ARES_DATATYPE_TXT_REPLY": "",
            "ARES_DATATYPE_TXT_EXT": "",
            "ARES_DATATYPE_ADDR_NODE": "",
            "ARES_DATATYPE_MX_REPLY": "",
            "ARES_DATATYPE_NAPTR_REPLY": "",
            "ARES_DATATYPE_SOA_REPLY": "",
            "ARES_DATATYPE_URI_REPLY": "",
            "ARES_DATATYPE_ADDR6TTL": "",
            "ARES_DATATYPE_ADDRTTL": "",
            "ARES_DATATYPE_HOSTENT": "",
            "ARES_DATATYPE_OPTIONS": "",
            "ARES_DATATYPE_ADDR_PORT_NODE": "",
            "ARES_DATATYPE_CAA_REPLY": "",
            "ARES_DATATYPE_LAST": ""
          },
          "ares_datatype",
          [
            28,
            0
          ],
          [
            48,
            16
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_ipv6.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sockaddr_in6 {\n  unsigned short       sin6_family;\n  unsigned short       sin6_port;\n  unsigned long        sin6_flowinfo;\n  struct ares_in6_addr sin6_addr;\n  unsigned int         sin6_scope_id;\n}",
          {
            "sin6_family": "unsigned short",
            "sin6_port": "unsigned short",
            "sin6_flowinfo": "unsigned long",
            "sin6_addr": "struct ares_in6_addr",
            "sin6_scope_id": "unsigned int"
          },
          "sockaddr_in6",
          [
            47,
            0
          ],
          [
            53,
            1
          ]
        ],
        [
          "struct addrinfo {\n  int              ai_flags;\n  int              ai_family;\n  int              ai_socktype;\n  int              ai_protocol;\n  ares_socklen_t   ai_addrlen; /* Follow rfc3493 struct addrinfo */\n  char            *ai_canonname;\n  struct sockaddr *ai_addr;\n  struct addrinfo *ai_next;\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "ares_socklen_t",
            "*ai_canonname": "char",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct addrinfo"
          },
          "addrinfo",
          [
            63,
            0
          ],
          [
            72,
            1
          ]
        ],
        [
          "struct sockaddr_in6 {\n  unsigned short       sin6_family;\n  unsigned short       sin6_port;\n  unsigned long        sin6_flowinfo;\n  struct ares_in6_addr sin6_addr;\n  unsigned int         sin6_scope_id;\n}",
          {
            "sin6_family": "unsigned short",
            "sin6_port": "unsigned short",
            "sin6_flowinfo": "unsigned long",
            "sin6_addr": "struct ares_in6_addr",
            "sin6_scope_id": "unsigned int"
          },
          "sockaddr_in6",
          [
            47,
            0
          ],
          [
            53,
            1
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            51,
            2
          ],
          [
            51,
            22
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            57,
            2
          ],
          [
            57,
            17
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            58,
            2
          ],
          [
            58,
            20
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            59,
            2
          ],
          [
            59,
            21
          ]
        ],
        [
          "struct addrinfo {\n  int              ai_flags;\n  int              ai_family;\n  int              ai_socktype;\n  int              ai_protocol;\n  ares_socklen_t   ai_addrlen; /* Follow rfc3493 struct addrinfo */\n  char            *ai_canonname;\n  struct sockaddr *ai_addr;\n  struct addrinfo *ai_next;\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "ares_socklen_t",
            "*ai_canonname": "char",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct addrinfo"
          },
          "addrinfo",
          [
            63,
            0
          ],
          [
            72,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            70,
            2
          ],
          [
            70,
            17
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            71,
            2
          ],
          [
            71,
            17
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            111,
            13
          ],
          [
            111,
            33
          ]
        ]
      ],
      "include_list": [
        [
          "#  include <netinet6/in6.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/config-dos.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#  include <sys/types.h> /* For 'ssize_t' */\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_getenv.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_getenv(const char *name)",
          "fn_dec_pos": [
            [
              30,
              13
            ],
            [
              30,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getenv",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_android.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_get_android_server_list(size_t max_servers, size_t *num_servers)",
          "fn_dec_pos": [
            [
              31,
              7
            ],
            [
              31,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_server_list",
            "parameters": {
              "max_servers": "size_t",
              "num_servers": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_get_android_search_domains_list(void)",
          "fn_dec_pos": [
            [
              32,
              7
            ],
            [
              32,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_search_domains_list",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_library_cleanup_android(void)",
          "fn_dec_pos": [
            [
              33,
              7
            ],
            [
              33,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_cleanup_android",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/ares_conn.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_close_connection(ares_conn_t *conn, ares_status_t requeue_status)",
          "fn_dec_pos": [
            [
              166,
              5
            ],
            [
              166,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_close_connection",
            "parameters": {
              "conn": "ares_conn_t",
              "requeue_status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_close_sockets(ares_server_t *server)",
          "fn_dec_pos": [
            [
              167,
              5
            ],
            [
              167,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_close_sockets",
            "parameters": {
              "server": "ares_server_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_check_cleanup_conns(const ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              168,
              5
            ],
            [
              168,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_check_cleanup_conns",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_destroy_servers_state(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              170,
              5
            ],
            [
              170,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_servers_state",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_open_connection(ares_conn_t   **conn_out,\n                                     ares_channel_t *channel,\n                                     ares_server_t *server, ares_bool_t is_tcp)",
          "fn_dec_pos": [
            [
              171,
              16
            ],
            [
              173,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_open_connection",
            "parameters": {
              "conn_out": "ares_conn_t",
              "channel": "ares_channel_t",
              "server": "ares_server_t",
              "is_tcp": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_conn_write(ares_conn_t *conn, const void *data, size_t len,\n                                size_t *written)",
          "fn_dec_pos": [
            [
              175,
              16
            ],
            [
              176,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_write",
            "parameters": {
              "conn": "ares_conn_t",
              "data": "void",
              "len": "size_t",
              "written": "size_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_conn_flush(ares_conn_t *conn)",
          "fn_dec_pos": [
            [
              177,
              16
            ],
            [
              177,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_flush",
            "parameters": {
              "conn": "ares_conn_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_conn_read(ares_conn_t *conn, void *data, size_t len,\n                               size_t *read_bytes)",
          "fn_dec_pos": [
            [
              178,
              16
            ],
            [
              179,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_read",
            "parameters": {
              "conn": "ares_conn_t",
              "data": "void",
              "len": "size_t",
              "read_bytes": "size_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_conn_from_fd(const ares_channel_t *channel, ares_socket_t fd)",
          "fn_dec_pos": [
            [
              180,
              13
            ],
            [
              180,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_from_fd",
            "parameters": {
              "channel": "ares_channel_t",
              "fd": "ares_socket_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_conn_sock_state_cb_update(ares_conn_t            *conn,\n                                            ares_conn_state_flags_t flags)",
          "fn_dec_pos": [
            [
              181,
              13
            ],
            [
              182,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_conn_sock_state_cb_update",
            "parameters": {
              "conn": "ares_conn_t",
              "flags": "ares_conn_state_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_socket_recv(ares_channel_t *channel, ares_socket_t s,\n                                 ares_bool_t is_tcp, void *data,\n                                 size_t data_len, size_t *read_bytes)",
          "fn_dec_pos": [
            [
              183,
              16
            ],
            [
              185,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_recv",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "is_tcp": "ares_bool_t",
              "data": "void",
              "data_len": "size_t",
              "read_bytes": "size_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_socket_recvfrom(ares_channel_t *channel, ares_socket_t s,\n                                     ares_bool_t is_tcp, void *data,\n                                     size_t data_len, int flags,\n                                     struct sockaddr *from,\n                                     ares_socklen_t  *from_len,\n                                     size_t          *read_bytes)",
          "fn_dec_pos": [
            [
              186,
              16
            ],
            [
              191,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_socket_recvfrom",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "is_tcp": "ares_bool_t",
              "data": "void",
              "data_len": "size_t",
              "flags": "int",
              "from": "struct sockaddr",
              "from_len": "ares_socklen_t",
              "read_bytes": "size_t"
            },
            "return_type": "ares_conn_err_t"
          }
        },
        {
          "fn_code": "ares_destroy_server(ares_server_t *server)",
          "fn_dec_pos": [
            [
              193,
              16
            ],
            [
              193,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_server",
            "parameters": {
              "server": "ares_server_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_conn {\n  ares_server_t          *server;\n  ares_socket_t           fd;\n  struct ares_addr        self_ip;\n  ares_conn_flags_t       flags;\n  ares_conn_state_flags_t state_flags;\n\n  /*! Outbound buffered data that is not yet sent.  Exists as one contiguous\n   *  stream in TCP format (big endian 16bit length prefix followed by DNS\n   *  wire-format message).  For TCP this can be sent as-is, UDP this must\n   *  be sent per-packet (stripping the length prefix) */\n  ares_buf_t             *out_buf;\n\n  /*! Inbound buffered data that is not yet parsed.  Exists as one contiguous\n   *  stream in TCP format (big endian 16bit length prefix followed by DNS\n   *  wire-format message).  TCP may have partial data and this needs to be\n   *  handled gracefully, but UDP will always have a full message */\n  ares_buf_t             *in_buf;\n\n  /* total number of queries run on this connection since it was established */\n  size_t                  total_queries;\n\n  /* list of outstanding queries to this connection */\n  ares_llist_t           *queries_to_conn;\n}",
          {
            "*server": "ares_server_t",
            "fd": "ares_socket_t",
            "self_ip": "struct ares_addr",
            "flags": "ares_conn_flags_t",
            "state_flags": "ares_conn_state_flags_t",
            "*out_buf": "ares_buf_t",
            "*in_buf": "ares_buf_t",
            "total_queries": "size_t",
            "*queries_to_conn": "ares_llist_t"
          },
          "ares_conn",
          [
            56,
            0
          ],
          [
            80,
            1
          ]
        ],
        [
          "typedef struct {\n  time_t        ts;             /*!< Timestamp divided by bucket divisor */\n  unsigned int  latency_min_ms; /*!< Minimum latency for queries */\n  unsigned int  latency_max_ms; /*!< Maximum latency for queries */\n  ares_uint64_t total_ms;       /*!< Cumulative query time for bucket */\n  ares_uint64_t total_count;    /*!< Number of queries for bucket */\n\n  time_t        prev_ts;        /*!< Previous period bucket timestamp */\n  ares_uint64_t\n    prev_total_ms; /*!< Previous period bucket cumulative query time */\n  ares_uint64_t prev_total_count; /*!< Previous period bucket query count */\n} ares_server_metrics_t;",
          {
            "ts": "time_t",
            "latency_min_ms": "unsigned int",
            "latency_max_ms": "unsigned int",
            "total_ms": "ares_uint64_t",
            "total_count": "ares_uint64_t",
            "prev_ts": "time_t",
            "prev_total_ms": "ares_uint64_t",
            "prev_total_count": "ares_uint64_t"
          },
          "ares_server_metrics_t",
          [
            93,
            0
          ],
          [
            104,
            24
          ]
        ],
        [
          "typedef struct {\n  /*! starts at INITIAL, transitions as needed. */\n  ares_cookie_state_t state;\n  /*! randomly-generate client cookie */\n  unsigned char       client[8];\n  /*! timestamp client cookie was generated, used for rotation purposes */\n  ares_timeval_t      client_ts;\n  /*! IP address last used for client to connect to server.  If this changes\n   *  The client cookie gets invalidated */\n  struct ares_addr    client_ip;\n  /*! Server Cookie last received, 8-32 bytes in length */\n  unsigned char       server[32];\n  /*! Length of server cookie on file. */\n  size_t              server_len;\n  /*! Timestamp of last attempt to use cookies, but it was determined that the\n   *  server didn't support them */\n  ares_timeval_t      unsupported_ts;\n} ares_cookie_t;",
          {
            "state": "ares_cookie_state_t",
            "client[8]": "unsigned char",
            "client_ts": "ares_timeval_t",
            "client_ip": "struct ares_addr",
            "server[32]": "unsigned char",
            "server_len": "size_t",
            "unsupported_ts": "ares_timeval_t"
          },
          "ares_cookie_t",
          [
            117,
            0
          ],
          [
            134,
            16
          ]
        ],
        [
          "struct ares_server {\n  /* Configuration */\n  size_t                idx;      /* index for server in system configuration */\n  struct ares_addr      addr;\n  unsigned short        udp_port; /* host byte order */\n  unsigned short        tcp_port; /* host byte order */\n  char                  ll_iface[64];    /* IPv6 Link Local Interface */\n  unsigned int          ll_scope;        /* IPv6 Link Local Scope */\n\n  size_t                consec_failures; /* Consecutive query failure count\n                                          * can be hard errors or timeouts\n                                          */\n  ares_bool_t           probe_pending;   /* Whether a probe is pending for this\n                                          * server due to prior failures */\n  ares_llist_t         *connections;\n  ares_conn_t          *tcp_conn;\n\n  /* The next time when we will retry this server if it has hit failures */\n  ares_timeval_t        next_retry_time;\n\n  /*! Buckets for collecting metrics about the server */\n  ares_server_metrics_t metrics[ARES_METRIC_COUNT];\n\n  /*! RFC 7873/9018 DNS Cookies */\n  ares_cookie_t         cookie;\n\n  /* Link back to owning channel */\n  ares_channel_t       *channel;\n}",
          {
            "idx": "size_t",
            "addr": "struct ares_addr",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "ll_iface[64]": "char",
            "ll_scope": "unsigned int",
            "consec_failures": "size_t",
            "probe_pending": "ares_bool_t",
            "*connections": "ares_llist_t",
            "*tcp_conn": "ares_conn_t",
            "next_retry_time": "ares_timeval_t",
            "metrics[ARES_METRIC_COUNT]": "ares_server_metrics_t",
            "cookie": "ares_cookie_t",
            "*channel": "ares_channel_t"
          },
          "ares_server",
          [
            136,
            0
          ],
          [
            164,
            1
          ]
        ],
        [
          "struct ares_conn",
          {},
          "",
          [
            30,
            0
          ],
          [
            30,
            16
          ]
        ],
        [
          "typedef struct ares_conn ares_conn_t;",
          {},
          "ares_conn_t",
          [
            31,
            0
          ],
          [
            31,
            37
          ]
        ],
        [
          "struct ares_server",
          {},
          "",
          [
            33,
            0
          ],
          [
            33,
            18
          ]
        ],
        [
          "typedef struct ares_server ares_server_t;",
          {},
          "ares_server_t",
          [
            34,
            0
          ],
          [
            34,
            41
          ]
        ],
        [
          "struct ares_conn {\n  ares_server_t          *server;\n  ares_socket_t           fd;\n  struct ares_addr        self_ip;\n  ares_conn_flags_t       flags;\n  ares_conn_state_flags_t state_flags;\n\n  /*! Outbound buffered data that is not yet sent.  Exists as one contiguous\n   *  stream in TCP format (big endian 16bit length prefix followed by DNS\n   *  wire-format message).  For TCP this can be sent as-is, UDP this must\n   *  be sent per-packet (stripping the length prefix) */\n  ares_buf_t             *out_buf;\n\n  /*! Inbound buffered data that is not yet parsed.  Exists as one contiguous\n   *  stream in TCP format (big endian 16bit length prefix followed by DNS\n   *  wire-format message).  TCP may have partial data and this needs to be\n   *  handled gracefully, but UDP will always have a full message */\n  ares_buf_t             *in_buf;\n\n  /* total number of queries run on this connection since it was established */\n  size_t                  total_queries;\n\n  /* list of outstanding queries to this connection */\n  ares_llist_t           *queries_to_conn;\n}",
          {
            "*server": "ares_server_t",
            "fd": "ares_socket_t",
            "self_ip": "struct ares_addr",
            "flags": "ares_conn_flags_t",
            "state_flags": "ares_conn_state_flags_t",
            "*out_buf": "ares_buf_t",
            "*in_buf": "ares_buf_t",
            "total_queries": "size_t",
            "*queries_to_conn": "ares_llist_t"
          },
          "ares_conn",
          [
            56,
            0
          ],
          [
            80,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            59,
            2
          ],
          [
            59,
            18
          ]
        ],
        [
          "typedef struct {\n  time_t        ts;             /*!< Timestamp divided by bucket divisor */\n  unsigned int  latency_min_ms; /*!< Minimum latency for queries */\n  unsigned int  latency_max_ms; /*!< Maximum latency for queries */\n  ares_uint64_t total_ms;       /*!< Cumulative query time for bucket */\n  ares_uint64_t total_count;    /*!< Number of queries for bucket */\n\n  time_t        prev_ts;        /*!< Previous period bucket timestamp */\n  ares_uint64_t\n    prev_total_ms; /*!< Previous period bucket cumulative query time */\n  ares_uint64_t prev_total_count; /*!< Previous period bucket query count */\n} ares_server_metrics_t;",
          {
            "ts": "time_t",
            "latency_min_ms": "unsigned int",
            "latency_max_ms": "unsigned int",
            "total_ms": "ares_uint64_t",
            "total_count": "ares_uint64_t",
            "prev_ts": "time_t",
            "prev_total_ms": "ares_uint64_t",
            "prev_total_count": "ares_uint64_t"
          },
          "ares_server_metrics_t",
          [
            93,
            0
          ],
          [
            104,
            24
          ]
        ],
        [
          "typedef struct {\n  /*! starts at INITIAL, transitions as needed. */\n  ares_cookie_state_t state;\n  /*! randomly-generate client cookie */\n  unsigned char       client[8];\n  /*! timestamp client cookie was generated, used for rotation purposes */\n  ares_timeval_t      client_ts;\n  /*! IP address last used for client to connect to server.  If this changes\n   *  The client cookie gets invalidated */\n  struct ares_addr    client_ip;\n  /*! Server Cookie last received, 8-32 bytes in length */\n  unsigned char       server[32];\n  /*! Length of server cookie on file. */\n  size_t              server_len;\n  /*! Timestamp of last attempt to use cookies, but it was determined that the\n   *  server didn't support them */\n  ares_timeval_t      unsupported_ts;\n} ares_cookie_t;",
          {
            "state": "ares_cookie_state_t",
            "client[8]": "unsigned char",
            "client_ts": "ares_timeval_t",
            "client_ip": "struct ares_addr",
            "server[32]": "unsigned char",
            "server_len": "size_t",
            "unsupported_ts": "ares_timeval_t"
          },
          "ares_cookie_t",
          [
            117,
            0
          ],
          [
            134,
            16
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            126,
            2
          ],
          [
            126,
            18
          ]
        ],
        [
          "struct ares_server {\n  /* Configuration */\n  size_t                idx;      /* index for server in system configuration */\n  struct ares_addr      addr;\n  unsigned short        udp_port; /* host byte order */\n  unsigned short        tcp_port; /* host byte order */\n  char                  ll_iface[64];    /* IPv6 Link Local Interface */\n  unsigned int          ll_scope;        /* IPv6 Link Local Scope */\n\n  size_t                consec_failures; /* Consecutive query failure count\n                                          * can be hard errors or timeouts\n                                          */\n  ares_bool_t           probe_pending;   /* Whether a probe is pending for this\n                                          * server due to prior failures */\n  ares_llist_t         *connections;\n  ares_conn_t          *tcp_conn;\n\n  /* The next time when we will retry this server if it has hit failures */\n  ares_timeval_t        next_retry_time;\n\n  /*! Buckets for collecting metrics about the server */\n  ares_server_metrics_t metrics[ARES_METRIC_COUNT];\n\n  /*! RFC 7873/9018 DNS Cookies */\n  ares_cookie_t         cookie;\n\n  /* Link back to owning channel */\n  ares_channel_t       *channel;\n}",
          {
            "idx": "size_t",
            "addr": "struct ares_addr",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "ll_iface[64]": "char",
            "ll_scope": "unsigned int",
            "consec_failures": "size_t",
            "probe_pending": "ares_bool_t",
            "*connections": "ares_llist_t",
            "*tcp_conn": "ares_conn_t",
            "next_retry_time": "ares_timeval_t",
            "metrics[ARES_METRIC_COUNT]": "ares_server_metrics_t",
            "cookie": "ares_cookie_t",
            "*channel": "ares_channel_t"
          },
          "ares_server",
          [
            136,
            0
          ],
          [
            164,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            139,
            2
          ],
          [
            139,
            18
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            189,
            37
          ],
          [
            189,
            52
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_socket.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  /*! No flags */\n  ARES_CONN_FLAG_NONE = 0,\n  /*! TCP connection, not UDP */\n  ARES_CONN_FLAG_TCP = 1 << 0,\n  /*! TCP Fast Open is enabled and being used if supported by the OS */\n  ARES_CONN_FLAG_TFO = 1 << 1,\n  /*! TCP Fast Open has not yet sent its first packet. Gets unset on first\n   *  write to a connection */\n  ARES_CONN_FLAG_TFO_INITIAL = 1 << 2\n} ares_conn_flags_t;",
          {
            "ARES_CONN_FLAG_NONE": "",
            "ARES_CONN_FLAG_TCP": "",
            "ARES_CONN_FLAG_TFO": "",
            "ARES_CONN_FLAG_TFO_INITIAL": ""
          },
          "ares_conn_flags_t",
          [
            36,
            0
          ],
          [
            46,
            20
          ]
        ],
        [
          "typedef enum {\n  ARES_CONN_STATE_NONE      = 0,\n  ARES_CONN_STATE_READ      = 1 << 0,\n  ARES_CONN_STATE_WRITE     = 1 << 1,\n  ARES_CONN_STATE_CONNECTED = 1 << 2, /* This doesn't get a callback */\n  ARES_CONN_STATE_CBFLAGS   = ARES_CONN_STATE_READ | ARES_CONN_STATE_WRITE\n} ares_conn_state_flags_t;",
          {
            "ARES_CONN_STATE_NONE": "",
            "ARES_CONN_STATE_READ": "",
            "ARES_CONN_STATE_WRITE": "",
            "ARES_CONN_STATE_CONNECTED": "",
            "ARES_CONN_STATE_CBFLAGS": ""
          },
          "ares_conn_state_flags_t",
          [
            48,
            0
          ],
          [
            54,
            26
          ]
        ],
        [
          "typedef enum {\n  ARES_METRIC_1MINUTE = 0, /*!< Bucket for tracking over the last minute */\n  ARES_METRIC_15MINUTES,   /*!< Bucket for tracking over the last 15 minutes */\n  ARES_METRIC_1HOUR,       /*!< Bucket for tracking over the last hour */\n  ARES_METRIC_1DAY,        /*!< Bucket for tracking over the last day */\n  ARES_METRIC_INCEPTION,   /*!< Bucket for tracking since inception */\n  ARES_METRIC_COUNT        /*!< Count of buckets, not a real bucket */\n} ares_server_bucket_t;",
          {
            "ARES_METRIC_1MINUTE": "",
            "ARES_METRIC_15MINUTES": "",
            "ARES_METRIC_1HOUR": "",
            "ARES_METRIC_1DAY": "",
            "ARES_METRIC_INCEPTION": "",
            "ARES_METRIC_COUNT": ""
          },
          "ares_server_bucket_t",
          [
            83,
            0
          ],
          [
            90,
            23
          ]
        ],
        [
          "typedef enum {\n  ARES_COOKIE_INITIAL     = 0,\n  ARES_COOKIE_GENERATED   = 1,\n  ARES_COOKIE_SUPPORTED   = 2,\n  ARES_COOKIE_UNSUPPORTED = 3\n} ares_cookie_state_t;",
          {
            "ARES_COOKIE_INITIAL": "",
            "ARES_COOKIE_GENERATED": "",
            "ARES_COOKIE_SUPPORTED": "",
            "ARES_COOKIE_UNSUPPORTED": ""
          },
          "ares_cookie_state_t",
          [
            106,
            0
          ],
          [
            111,
            22
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_htable_dict.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_htable_dict_destroy(ares_htable_dict_t *htable)",
          "fn_dec_pos": [
            [
              52,
              18
            ],
            [
              52,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_destroy",
            "parameters": {
              "htable": "ares_htable_dict_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_dict_create(void)",
          "fn_dec_pos": [
            [
              57,
              33
            ],
            [
              57,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_dict_insert(ares_htable_dict_t *htable,\n                                                 const char         *key,\n                                                 const char         *val)",
          "fn_dec_pos": [
            [
              66,
              13
            ],
            [
              68,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_dict_insert",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char",
              "val": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_dict_get(const ares_htable_dict_t *htable,\n                                              const char               *key,\n                                              const char              **val)",
          "fn_dec_pos": [
            [
              77,
              13
            ],
            [
              79,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_dict_get",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char",
              "val": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_dict_get_direct(const ares_htable_dict_t *htable,\n                              const char               *key)",
          "fn_dec_pos": [
            [
              90,
              2
            ],
            [
              91,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_get_direct",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_dict_remove(ares_htable_dict_t *htable,\n                                                 const char         *key)",
          "fn_dec_pos": [
            [
              99,
              13
            ],
            [
              100,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_dict_remove",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "key": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_dict_num_keys(const ares_htable_dict_t *htable)",
          "fn_dec_pos": [
            [
              107,
              20
            ],
            [
              107,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_num_keys",
            "parameters": {
              "htable": "ares_htable_dict_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_dict_keys(const ares_htable_dict_t *htable,\n                                          size_t                   *num)",
          "fn_dec_pos": [
            [
              116,
              20
            ],
            [
              117,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_dict_keys",
            "parameters": {
              "htable": "ares_htable_dict_t",
              "num": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_dict",
          {},
          "",
          [
            42,
            0
          ],
          [
            42,
            23
          ]
        ],
        [
          "typedef struct ares_htable_dict ares_htable_dict_t;",
          {},
          "ares_htable_dict_t",
          [
            46,
            0
          ],
          [
            46,
            51
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_htable_asvp.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_htable_asvp_val_free_t)(void *val)",
          "fn_dec_pos": [
            [
              53,
              13
            ],
            [
              53,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_htable_asvp_destroy(ares_htable_asvp_t *htable)",
          "fn_dec_pos": [
            [
              59,
              18
            ],
            [
              59,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_destroy",
            "parameters": {
              "htable": "ares_htable_asvp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_asvp_create(ares_htable_asvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              68,
              2
            ],
            [
              68,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val_free": "ares_htable_asvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_asvp_keys(const ares_htable_asvp_t *htable, size_t *num)",
          "fn_dec_pos": [
            [
              77,
              2
            ],
            [
              77,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_asvp_insert(ares_htable_asvp_t *htable,\n                                                 ares_socket_t key, void *val)",
          "fn_dec_pos": [
            [
              87,
              13
            ],
            [
              88,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_asvp_insert",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_asvp_get(const ares_htable_asvp_t *htable,\n                                              ares_socket_t key, void **val)",
          "fn_dec_pos": [
            [
              97,
              13
            ],
            [
              98,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_asvp_get",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_asvp_get_direct(const ares_htable_asvp_t *htable,\n                                               ares_socket_t             key)",
          "fn_dec_pos": [
            [
              108,
              19
            ],
            [
              109,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_get_direct",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_asvp_remove(ares_htable_asvp_t *htable,\n                                                 ares_socket_t       key)",
          "fn_dec_pos": [
            [
              117,
              13
            ],
            [
              118,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_asvp_remove",
            "parameters": {
              "htable": "ares_htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_asvp_num_keys(const ares_htable_asvp_t *htable)",
          "fn_dec_pos": [
            [
              125,
              20
            ],
            [
              125,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_asvp_num_keys",
            "parameters": {
              "htable": "ares_htable_asvp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_asvp",
          {},
          "",
          [
            43,
            0
          ],
          [
            43,
            23
          ]
        ],
        [
          "typedef struct ares_htable_asvp ares_htable_asvp_t;",
          {},
          "ares_htable_asvp_t",
          [
            47,
            0
          ],
          [
            47,
            51
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_htable_strvp.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_htable_strvp_val_free_t)(void *val)",
          "fn_dec_pos": [
            [
              51,
              13
            ],
            [
              51,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_htable_strvp_destroy(ares_htable_strvp_t *htable)",
          "fn_dec_pos": [
            [
              57,
              18
            ],
            [
              57,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_destroy",
            "parameters": {
              "htable": "ares_htable_strvp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_strvp_create(ares_htable_strvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              66,
              2
            ],
            [
              66,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val_free": "ares_htable_strvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_strvp_insert(ares_htable_strvp_t *htable,\n                                                  const char *key, void *val)",
          "fn_dec_pos": [
            [
              75,
              13
            ],
            [
              76,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_strvp_insert",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_strvp_get(\n  const ares_htable_strvp_t *htable, const char *key, void **val)",
          "fn_dec_pos": [
            [
              85,
              13
            ],
            [
              86,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_strvp_get",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_strvp_get_direct(const ares_htable_strvp_t *htable,\n                               const char                *key)",
          "fn_dec_pos": [
            [
              97,
              2
            ],
            [
              98,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_get_direct",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_strvp_remove(ares_htable_strvp_t *htable,\n                                                  const char          *key)",
          "fn_dec_pos": [
            [
              106,
              13
            ],
            [
              107,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_strvp_remove",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_strvp_claim(ares_htable_strvp_t *htable,\n                                                 const char          *key)",
          "fn_dec_pos": [
            [
              116,
              25
            ],
            [
              117,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_claim",
            "parameters": {
              "htable": "ares_htable_strvp_t",
              "key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_strvp_num_keys(const ares_htable_strvp_t *htable)",
          "fn_dec_pos": [
            [
              125,
              2
            ],
            [
              125,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_strvp_num_keys",
            "parameters": {
              "htable": "ares_htable_strvp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_strvp",
          {},
          "",
          [
            42,
            0
          ],
          [
            42,
            24
          ]
        ],
        [
          "typedef struct ares_htable_strvp ares_htable_strvp_t;",
          {},
          "ares_htable_strvp_t",
          [
            45,
            0
          ],
          [
            45,
            53
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_str.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_strdup(const char *s1)",
          "fn_dec_pos": [
            [
              29,
              20
            ],
            [
              29,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strdup",
            "parameters": {
              "s1": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_strnlen(const char *str, size_t maxlen)",
          "fn_dec_pos": [
            [
              43,
              20
            ],
            [
              43,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strnlen",
            "parameters": {
              "str": "char",
              "maxlen": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_strlen(const char *str)",
          "fn_dec_pos": [
            [
              45,
              20
            ],
            [
              45,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strlen",
            "parameters": {
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_strcpy(char *dest, const char *src, size_t dest_size)",
          "fn_dec_pos": [
            [
              57,
              20
            ],
            [
              57,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcpy",
            "parameters": {
              "dest": "char",
              "src": "char",
              "dest_size": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t    ares_str_isnum(const char *str)",
          "fn_dec_pos": [
            [
              59,
              13
            ],
            [
              59,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t    ares_str_isnum",
            "parameters": {
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t    ares_str_isalnum(const char *str)",
          "fn_dec_pos": [
            [
              60,
              13
            ],
            [
              60,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t    ares_str_isalnum",
            "parameters": {
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_str_ltrim(char *str)",
          "fn_dec_pos": [
            [
              62,
              28
            ],
            [
              62,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_ltrim",
            "parameters": {
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_str_rtrim(char *str)",
          "fn_dec_pos": [
            [
              63,
              28
            ],
            [
              63,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_rtrim",
            "parameters": {
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_str_trim(char *str)",
          "fn_dec_pos": [
            [
              64,
              28
            ],
            [
              64,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_trim",
            "parameters": {
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_str_lower(char *str)",
          "fn_dec_pos": [
            [
              65,
              28
            ],
            [
              65,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_lower",
            "parameters": {
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_tolower(unsigned char c)",
          "fn_dec_pos": [
            [
              67,
              28
            ],
            [
              67,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_tolower",
            "parameters": {
              "c": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_memmem(const unsigned char *big,\n                                        size_t               big_len,\n                                        const unsigned char *little,\n                                        size_t               little_len)",
          "fn_dec_pos": [
            [
              68,
              28
            ],
            [
              71,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_memmem",
            "parameters": {
              "big": "unsigned char",
              "big_len": "size_t",
              "little": "unsigned char",
              "little_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t    ares_memeq(const unsigned char *ptr,\n                                       const unsigned char *val, size_t len)",
          "fn_dec_pos": [
            [
              72,
              13
            ],
            [
              73,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t    ares_memeq",
            "parameters": {
              "ptr": "unsigned char",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t    ares_memeq_ci(const unsigned char *ptr,\n                                          const unsigned char *val, size_t len)",
          "fn_dec_pos": [
            [
              74,
              13
            ],
            [
              75,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t    ares_memeq_ci",
            "parameters": {
              "ptr": "unsigned char",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t    ares_is_hostname(const char *str)",
          "fn_dec_pos": [
            [
              76,
              13
            ],
            [
              76,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t    ares_is_hostname",
            "parameters": {
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t    ares_str_isprint(const char *str, size_t len)",
          "fn_dec_pos": [
            [
              89,
              13
            ],
            [
              89,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t    ares_str_isprint",
            "parameters": {
              "str": "char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_strcmp(const char *a, const char *b)",
          "fn_dec_pos": [
            [
              145,
              17
            ],
            [
              145,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcmp",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_strncmp(const char *a, const char *b, size_t n)",
          "fn_dec_pos": [
            [
              158,
              17
            ],
            [
              158,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strncmp",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_strcasecmp(const char *a, const char *b)",
          "fn_dec_pos": [
            [
              171,
              17
            ],
            [
              171,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcasecmp",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_strncasecmp(const char *a, const char *b, size_t n)",
          "fn_dec_pos": [
            [
              185,
              17
            ],
            [
              185,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strncasecmp",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_streq(const char *a, const char *b)",
          "fn_dec_pos": [
            [
              195,
              13
            ],
            [
              195,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_streq",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_streq_max(const char *a, const char *b, size_t n)",
          "fn_dec_pos": [
            [
              206,
              13
            ],
            [
              206,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_streq_max",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_strcaseeq(const char *a, const char *b)",
          "fn_dec_pos": [
            [
              216,
              13
            ],
            [
              216,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_strcaseeq",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_strcaseeq_max(const char *a, const char *b,\n                                            size_t n)",
          "fn_dec_pos": [
            [
              228,
              13
            ],
            [
              229,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_strcaseeq_max",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_free_array(void *arr, size_t nmembers,\n                                         void (*freefunc)(void *))",
          "fn_dec_pos": [
            [
              240,
              25
            ],
            [
              241,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_array",
            "parameters": {
              "arr": "void",
              "nmembers": "size_t",
              "freefunc": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "(*freefunc)(void *)",
          "fn_dec_pos": [
            [
              241,
              46
            ],
            [
              241,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_htable_szvp.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_htable_szvp_val_free_t)(void *val)",
          "fn_dec_pos": [
            [
              51,
              13
            ],
            [
              51,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_htable_szvp_destroy(ares_htable_szvp_t *htable)",
          "fn_dec_pos": [
            [
              57,
              18
            ],
            [
              57,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_destroy",
            "parameters": {
              "htable": "ares_htable_szvp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_szvp_create(ares_htable_szvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              66,
              2
            ],
            [
              66,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val_free": "ares_htable_szvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_szvp_insert(ares_htable_szvp_t *htable,\n                                                 size_t key, void *val)",
          "fn_dec_pos": [
            [
              75,
              13
            ],
            [
              76,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_szvp_insert",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_szvp_get(const ares_htable_szvp_t *htable,\n                                              size_t key, void **val)",
          "fn_dec_pos": [
            [
              85,
              13
            ],
            [
              86,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_szvp_get",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_szvp_get_direct(const ares_htable_szvp_t *htable,\n                                               size_t                    key)",
          "fn_dec_pos": [
            [
              96,
              19
            ],
            [
              97,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_get_direct",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_szvp_remove(ares_htable_szvp_t *htable,\n                                                 size_t              key)",
          "fn_dec_pos": [
            [
              105,
              13
            ],
            [
              106,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_szvp_remove",
            "parameters": {
              "htable": "ares_htable_szvp_t",
              "key": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_szvp_num_keys(const ares_htable_szvp_t *htable)",
          "fn_dec_pos": [
            [
              113,
              20
            ],
            [
              113,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_szvp_num_keys",
            "parameters": {
              "htable": "ares_htable_szvp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_szvp",
          {},
          "",
          [
            42,
            0
          ],
          [
            42,
            23
          ]
        ],
        [
          "typedef struct ares_htable_szvp ares_htable_szvp_t;",
          {},
          "ares_htable_szvp_t",
          [
            45,
            0
          ],
          [
            45,
            51
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_mem.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_malloc(size_t size)",
          "fn_dec_pos": [
            [
              30,
              19
            ],
            [
              30,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_realloc(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              31,
              19
            ],
            [
              31,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_free(void *ptr)",
          "fn_dec_pos": [
            [
              32,
              19
            ],
            [
              32,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_malloc_zero(size_t size)",
          "fn_dec_pos": [
            [
              33,
              19
            ],
            [
              33,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_zero",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_realloc_zero(void *ptr, size_t orig_size,\n                                     size_t new_size)",
          "fn_dec_pos": [
            [
              34,
              19
            ],
            [
              35,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc_zero",
            "parameters": {
              "ptr": "void",
              "orig_size": "size_t",
              "new_size": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_htable_vpstr.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_htable_vpstr_destroy(ares_htable_vpstr_t *htable)",
          "fn_dec_pos": [
            [
              52,
              18
            ],
            [
              52,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_destroy",
            "parameters": {
              "htable": "ares_htable_vpstr_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_vpstr_create(void)",
          "fn_dec_pos": [
            [
              57,
              34
            ],
            [
              57,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpstr_insert(ares_htable_vpstr_t *htable,\n                                                  void *key, const char *val)",
          "fn_dec_pos": [
            [
              66,
              13
            ],
            [
              67,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_vpstr_insert",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void",
              "val": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpstr_get(\n  const ares_htable_vpstr_t *htable, const void *key, const char **val)",
          "fn_dec_pos": [
            [
              76,
              13
            ],
            [
              77,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_vpstr_get",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void",
              "val": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_vpstr_get_direct(const ares_htable_vpstr_t *htable,\n                               const void                *key)",
          "fn_dec_pos": [
            [
              88,
              2
            ],
            [
              89,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_get_direct",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpstr_remove(ares_htable_vpstr_t *htable,\n                                                  const void          *key)",
          "fn_dec_pos": [
            [
              97,
              13
            ],
            [
              98,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_vpstr_remove",
            "parameters": {
              "htable": "ares_htable_vpstr_t",
              "key": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_vpstr_num_keys(const ares_htable_vpstr_t *htable)",
          "fn_dec_pos": [
            [
              106,
              2
            ],
            [
              106,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpstr_num_keys",
            "parameters": {
              "htable": "ares_htable_vpstr_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_vpstr",
          {},
          "",
          [
            42,
            0
          ],
          [
            42,
            24
          ]
        ],
        [
          "typedef struct ares_htable_vpstr ares_htable_vpstr_t;",
          {},
          "ares_htable_vpstr_t",
          [
            46,
            0
          ],
          [
            46,
            53
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_array.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_array_destructor_t)(void *data)",
          "fn_dec_pos": [
            [
              50,
              13
            ],
            [
              50,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_array_cmp_t)(const void *data1, const void *data2)",
          "fn_dec_pos": [
            [
              58,
              12
            ],
            [
              58,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data1": "void",
              "data2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_array_create(size_t member_size,\n                                             ares_array_destructor_t destruct)",
          "fn_dec_pos": [
            [
              76,
              27
            ],
            [
              77,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "member_size": "size_t",
              "destruct": "ares_array_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_array_set_size(ares_array_t *arr, size_t size)",
          "fn_dec_pos": [
            [
              87,
              13
            ],
            [
              87,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_set_size",
            "parameters": {
              "arr": "ares_array_t",
              "size": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_sort(ares_array_t    *arr,\n                                           ares_array_cmp_t cmp)",
          "fn_dec_pos": [
            [
              96,
              13
            ],
            [
              97,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_sort",
            "parameters": {
              "arr": "ares_array_t",
              "cmp": "ares_array_cmp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_array_destroy(ares_array_t *arr)",
          "fn_dec_pos": [
            [
              104,
              27
            ],
            [
              104,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_destroy",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_array_finish(ares_array_t *arr, size_t *num_members)",
          "fn_dec_pos": [
            [
              114,
              20
            ],
            [
              114,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_finish",
            "parameters": {
              "arr": "ares_array_t",
              "num_members": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_len(const ares_array_t *arr)",
          "fn_dec_pos": [
            [
              121,
              20
            ],
            [
              121,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_len",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insert_at(void        **elem_ptr,\n                                                ares_array_t *arr, size_t idx)",
          "fn_dec_pos": [
            [
              132,
              13
            ],
            [
              133,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_insert_at",
            "parameters": {
              "elem_ptr": "void",
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insert_last(void        **elem_ptr,\n                                                  ares_array_t *arr)",
          "fn_dec_pos": [
            [
              141,
              13
            ],
            [
              142,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_insert_last",
            "parameters": {
              "elem_ptr": "void",
              "arr": "ares_array_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insert_first(void        **elem_ptr,\n                                                   ares_array_t *arr)",
          "fn_dec_pos": [
            [
              150,
              13
            ],
            [
              151,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_insert_first",
            "parameters": {
              "elem_ptr": "void",
              "arr": "ares_array_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insertdata_at(ares_array_t *arr,\n                                                    size_t        idx,\n                                                    const void   *data_ptr)",
          "fn_dec_pos": [
            [
              167,
              13
            ],
            [
              169,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_insertdata_at",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t",
              "data_ptr": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insertdata_last(ares_array_t *arr,\n                                                      const void   *data_ptr)",
          "fn_dec_pos": [
            [
              182,
              13
            ],
            [
              183,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_insertdata_last",
            "parameters": {
              "arr": "ares_array_t",
              "data_ptr": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_insertdata_first(ares_array_t *arr,\n                                                       const void   *data_ptr)",
          "fn_dec_pos": [
            [
              196,
              13
            ],
            [
              197,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_insertdata_first",
            "parameters": {
              "arr": "ares_array_t",
              "data_ptr": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_array_at(ares_array_t *arr, size_t idx)",
          "fn_dec_pos": [
            [
              203,
              27
            ],
            [
              203,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_at",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_first(ares_array_t *arr)",
          "fn_dec_pos": [
            [
              208,
              27
            ],
            [
              208,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_first",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_last(ares_array_t *arr)",
          "fn_dec_pos": [
            [
              213,
              27
            ],
            [
              213,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_last",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_at_const(const ares_array_t *arr,\n                                               size_t              idx)",
          "fn_dec_pos": [
            [
              219,
              27
            ],
            [
              220,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_at_const",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_first_const(const ares_array_t *arr)",
          "fn_dec_pos": [
            [
              225,
              27
            ],
            [
              225,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_first_const",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_array_last_const(const ares_array_t *arr)",
          "fn_dec_pos": [
            [
              230,
              27
            ],
            [
              230,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_array_last_const",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_array_claim_at(void *dest, size_t dest_size,\n                                               ares_array_t *arr, size_t idx)",
          "fn_dec_pos": [
            [
              246,
              13
            ],
            [
              247,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_claim_at",
            "parameters": {
              "dest": "void",
              "dest_size": "size_t",
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_remove_at(ares_array_t *arr, size_t idx)",
          "fn_dec_pos": [
            [
              256,
              13
            ],
            [
              256,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_remove_at",
            "parameters": {
              "arr": "ares_array_t",
              "idx": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_remove_first(ares_array_t *arr)",
          "fn_dec_pos": [
            [
              263,
              13
            ],
            [
              263,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_remove_first",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_array_remove_last(ares_array_t *arr)",
          "fn_dec_pos": [
            [
              270,
              13
            ],
            [
              270,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_array_remove_last",
            "parameters": {
              "arr": "ares_array_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_array",
          {},
          "",
          [
            40,
            0
          ],
          [
            40,
            17
          ]
        ],
        [
          "typedef struct ares_array ares_array_t;",
          {},
          "ares_array_t",
          [
            43,
            0
          ],
          [
            43,
            39
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_llist.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_llist_destructor_t)(void *data)",
          "fn_dec_pos": [
            [
              54,
              13
            ],
            [
              54,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_llist_create(ares_llist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              61,
              27
            ],
            [
              61,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "destruct": "ares_llist_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_replace_destructor(ares_llist_t           *list,\n                                ares_llist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              70,
              2
            ],
            [
              71,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_replace_destructor",
            "parameters": {
              "list": "ares_llist_t",
              "destruct": "ares_llist_destructor_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_llist_insert_first(ares_llist_t *list,\n                                                        void         *val)",
          "fn_dec_pos": [
            [
              80,
              32
            ],
            [
              81,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "list": "ares_llist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_insert_last(ares_llist_t *list,\n                                                       void         *val)",
          "fn_dec_pos": [
            [
              90,
              32
            ],
            [
              91,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "list": "ares_llist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_insert_before(ares_llist_node_t *node, void *val)",
          "fn_dec_pos": [
            [
              101,
              2
            ],
            [
              101,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "node": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_insert_after(ares_llist_node_t *node,\n                                                        void              *val)",
          "fn_dec_pos": [
            [
              110,
              32
            ],
            [
              111,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "node": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_first(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              118,
              32
            ],
            [
              118,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_last(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              125,
              32
            ],
            [
              125,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_idx(ares_llist_t *list,\n                                                    size_t        idx)",
          "fn_dec_pos": [
            [
              133,
              32
            ],
            [
              134,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "list": "ares_llist_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_next(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              141,
              32
            ],
            [
              141,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_prev(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              148,
              32
            ],
            [
              148,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_val(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              156,
              32
            ],
            [
              156,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_val",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_len(const ares_llist_t *list)",
          "fn_dec_pos": [
            [
              163,
              32
            ],
            [
              163,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_len",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_llist_clear(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              169,
              32
            ],
            [
              169,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_clear",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_llist_node_parent(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              176,
              32
            ],
            [
              176,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_first_val(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              183,
              32
            ],
            [
              183,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_first_val",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_last_val(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              190,
              32
            ],
            [
              190,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_last_val",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_claim(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              198,
              32
            ],
            [
              198,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_claim",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_llist_node_replace(ares_llist_node_t *node, void *val)",
          "fn_dec_pos": [
            [
              205,
              18
            ],
            [
              205,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_replace",
            "parameters": {
              "node": "ares_llist_node_t",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_llist_node_destroy(ares_llist_node_t *node)",
          "fn_dec_pos": [
            [
              211,
              18
            ],
            [
              211,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_destroy",
            "parameters": {
              "node": "ares_llist_node_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_llist_destroy(ares_llist_t *list)",
          "fn_dec_pos": [
            [
              217,
              18
            ],
            [
              217,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_destroy",
            "parameters": {
              "list": "ares_llist_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_llist_node_mvparent_last(ares_llist_node_t *node,\n                                                ares_llist_t      *new_parent)",
          "fn_dec_pos": [
            [
              225,
              18
            ],
            [
              226,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_mvparent_last",
            "parameters": {
              "node": "ares_llist_node_t",
              "new_parent": "ares_llist_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_llist_node_mvparent_first(ares_llist_node_t *node,\n                                                 ares_llist_t      *new_parent)",
          "fn_dec_pos": [
            [
              234,
              18
            ],
            [
              235,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_llist_node_mvparent_first",
            "parameters": {
              "node": "ares_llist_node_t",
              "new_parent": "ares_llist_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_llist",
          {},
          "",
          [
            40,
            0
          ],
          [
            40,
            17
          ]
        ],
        [
          "typedef struct ares_llist ares_llist_t;",
          {},
          "ares_llist_t",
          [
            43,
            0
          ],
          [
            43,
            39
          ]
        ],
        [
          "struct ares_llist_node",
          {},
          "",
          [
            45,
            0
          ],
          [
            45,
            22
          ]
        ],
        [
          "typedef struct ares_llist_node ares_llist_node_t;",
          {},
          "ares_llist_node_t",
          [
            48,
            0
          ],
          [
            48,
            49
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_buf.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_buf_create(void)",
          "fn_dec_pos": [
            [
              56,
              28
            ],
            [
              56,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_create_const(const unsigned char *data,\n                                                  size_t               data_len)",
          "fn_dec_pos": [
            [
              67,
              28
            ],
            [
              68,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_create_const",
            "parameters": {
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_destroy(ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              75,
              28
            ],
            [
              75,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_destroy",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_append(ares_buf_t          *buf,\n                                            const unsigned char *data,\n                                            size_t               data_len)",
          "fn_dec_pos": [
            [
              85,
              13
            ],
            [
              87,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_append",
            "parameters": {
              "buf": "ares_buf_t",
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_append_byte(ares_buf_t   *buf,\n                                                 unsigned char b)",
          "fn_dec_pos": [
            [
              95,
              13
            ],
            [
              96,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_append_byte",
            "parameters": {
              "buf": "ares_buf_t",
              "b": "unsigned char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_append_str(ares_buf_t *buf,\n                                                const char *str)",
          "fn_dec_pos": [
            [
              104,
              13
            ],
            [
              105,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_append_str",
            "parameters": {
              "buf": "ares_buf_t",
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_append_be16(ares_buf_t    *buf,\n                                                 unsigned short u16)",
          "fn_dec_pos": [
            [
              113,
              13
            ],
            [
              114,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_append_be16",
            "parameters": {
              "buf": "ares_buf_t",
              "u16": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_append_be32(ares_buf_t  *buf,\n                                                 unsigned int u32)",
          "fn_dec_pos": [
            [
              122,
              13
            ],
            [
              123,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_append_be32",
            "parameters": {
              "buf": "ares_buf_t",
              "u32": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_append_num_dec(ares_buf_t *buf, size_t num,\n                                                    size_t len)",
          "fn_dec_pos": [
            [
              132,
              13
            ],
            [
              133,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_append_num_dec",
            "parameters": {
              "buf": "ares_buf_t",
              "num": "size_t",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_append_num_hex(ares_buf_t *buf, size_t num,\n                                                    size_t len)",
          "fn_dec_pos": [
            [
              142,
              13
            ],
            [
              143,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_append_num_hex",
            "parameters": {
              "buf": "ares_buf_t",
              "num": "size_t",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_set_length(ares_buf_t *buf, size_t len)",
          "fn_dec_pos": [
            [
              158,
              13
            ],
            [
              158,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_set_length",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_append_start(ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              172,
              28
            ],
            [
              172,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_start",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_append_finish(ares_buf_t *buf, size_t len)",
          "fn_dec_pos": [
            [
              182,
              28
            ],
            [
              182,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_append_finish",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_hexdump(ares_buf_t          *buf,\n                                             const unsigned char *data,\n                                             size_t               len)",
          "fn_dec_pos": [
            [
              191,
              13
            ],
            [
              193,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_hexdump",
            "parameters": {
              "buf": "ares_buf_t",
              "data": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_finish_bin(ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              203,
              28
            ],
            [
              203,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_finish_bin",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_finish_str(ares_buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              219,
              28
            ],
            [
              219,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_finish_str",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_replace(ares_buf_t *buf,\n                                             const unsigned char *srch,\n                                             size_t srch_size,\n                                             const unsigned char *rplc,\n                                             size_t rplc_size)",
          "fn_dec_pos": [
            [
              235,
              13
            ],
            [
              239,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_replace",
            "parameters": {
              "buf": "ares_buf_t",
              "srch": "unsigned char",
              "srch_size": "size_t",
              "rplc": "unsigned char",
              "rplc_size": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_tag(ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              248,
              28
            ],
            [
              248,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_tag_rollback(ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              255,
              13
            ],
            [
              255,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_tag_rollback",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t  ares_buf_tag_clear(ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              264,
              13
            ],
            [
              264,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t  ares_buf_tag_clear",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_tag_fetch(const ares_buf_t *buf,\n                                                     size_t           *len)",
          "fn_dec_pos": [
            [
              275,
              34
            ],
            [
              276,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_fetch",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_buf_tag_length(const ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              283,
              34
            ],
            [
              283,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_tag_length",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_fetch_bytes(const ares_buf_t *buf,\n                                                    unsigned char    *bytes,\n                                                    size_t           *len)",
          "fn_dec_pos": [
            [
              294,
              13
            ],
            [
              296,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_tag_fetch_bytes",
            "parameters": {
              "buf": "ares_buf_t",
              "bytes": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_fetch_string(const ares_buf_t *buf,\n                                                     char *str, size_t len)",
          "fn_dec_pos": [
            [
              309,
              13
            ],
            [
              310,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_tag_fetch_string",
            "parameters": {
              "buf": "ares_buf_t",
              "str": "char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_fetch_strdup(const ares_buf_t *buf,\n                                                     char            **str)",
          "fn_dec_pos": [
            [
              323,
              13
            ],
            [
              324,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_tag_fetch_strdup",
            "parameters": {
              "buf": "ares_buf_t",
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_tag_fetch_constbuf(const ares_buf_t *buf,\n                                                       ares_buf_t **newbuf)",
          "fn_dec_pos": [
            [
              336,
              13
            ],
            [
              337,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_tag_fetch_constbuf",
            "parameters": {
              "buf": "ares_buf_t",
              "newbuf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_consume(ares_buf_t *buf, size_t len)",
          "fn_dec_pos": [
            [
              345,
              13
            ],
            [
              345,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_consume",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_be16(ares_buf_t     *buf,\n                                               unsigned short *u16)",
          "fn_dec_pos": [
            [
              353,
              13
            ],
            [
              354,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_fetch_be16",
            "parameters": {
              "buf": "ares_buf_t",
              "u16": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_be32(ares_buf_t   *buf,\n                                               unsigned int *u32)",
          "fn_dec_pos": [
            [
              362,
              13
            ],
            [
              363,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_fetch_be32",
            "parameters": {
              "buf": "ares_buf_t",
              "u32": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_bytes(ares_buf_t    *buf,\n                                                unsigned char *bytes,\n                                                size_t         len)",
          "fn_dec_pos": [
            [
              373,
              13
            ],
            [
              375,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_fetch_bytes",
            "parameters": {
              "buf": "ares_buf_t",
              "bytes": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_bytes_dup(ares_buf_t *buf, size_t len,\n                                                    ares_bool_t     null_term,\n                                                    unsigned char **bytes)",
          "fn_dec_pos": [
            [
              389,
              13
            ],
            [
              391,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_fetch_bytes_dup",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t",
              "null_term": "ares_bool_t",
              "bytes": "unsigned char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_bytes_into_buf(ares_buf_t *buf,\n                                                         ares_buf_t *dest,\n                                                         size_t      len)",
          "fn_dec_pos": [
            [
              401,
              13
            ],
            [
              403,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_fetch_bytes_into_buf",
            "parameters": {
              "buf": "ares_buf_t",
              "dest": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_fetch_str_dup(ares_buf_t *buf, size_t len,\n                                                  char **str)",
          "fn_dec_pos": [
            [
              414,
              13
            ],
            [
              415,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_fetch_str_dup",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t",
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_consume_whitespace(ares_buf_t *buf,\n                                                       ares_bool_t include_linefeed)",
          "fn_dec_pos": [
            [
              425,
              27
            ],
            [
              426,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_whitespace",
            "parameters": {
              "buf": "ares_buf_t",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_consume_nonwhitespace(ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              435,
              27
            ],
            [
              435,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_nonwhitespace",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_consume_until_charset(ares_buf_t          *buf,\n                                                          const unsigned char *charset,\n                                                          size_t               len,\n                                                          ares_bool_t require_charset)",
          "fn_dec_pos": [
            [
              450,
              27
            ],
            [
              453,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_until_charset",
            "parameters": {
              "buf": "ares_buf_t",
              "charset": "unsigned char",
              "len": "size_t",
              "require_charset": "ares_bool_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_consume_until_seq(ares_buf_t          *buf,\n                                                      const unsigned char *seq,\n                                                      size_t               len,\n                                                      ares_bool_t require_seq)",
          "fn_dec_pos": [
            [
              468,
              27
            ],
            [
              471,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_until_seq",
            "parameters": {
              "buf": "ares_buf_t",
              "seq": "unsigned char",
              "len": "size_t",
              "require_seq": "ares_bool_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_consume_charset(ares_buf_t          *buf,\n                                                    const unsigned char *charset,\n                                                    size_t               len)",
          "fn_dec_pos": [
            [
              480,
              27
            ],
            [
              482,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_charset",
            "parameters": {
              "buf": "ares_buf_t",
              "charset": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_consume_line(ares_buf_t *buf,\n                                                 ares_bool_t include_linefeed)",
          "fn_dec_pos": [
            [
              493,
              27
            ],
            [
              494,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_consume_line",
            "parameters": {
              "buf": "ares_buf_t",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_split(\n  ares_buf_t *buf, const unsigned char *delims, size_t delims_len,\n  ares_buf_split_t flags, size_t max_sections, ares_array_t **arr)",
          "fn_dec_pos": [
            [
              545,
              13
            ],
            [
              547,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_split",
            "parameters": {
              "buf": "ares_buf_t",
              "delims": "unsigned char",
              "delims_len": "size_t",
              "flags": "ares_buf_split_t",
              "max_sections": "size_t",
              "arr": "ares_array_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_split_str_array(\n  ares_buf_t *buf, const unsigned char *delims, size_t delims_len,\n  ares_buf_split_t flags, size_t max_sections, ares_array_t **arr)",
          "fn_dec_pos": [
            [
              565,
              13
            ],
            [
              567,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_split_str_array",
            "parameters": {
              "buf": "ares_buf_t",
              "delims": "unsigned char",
              "delims_len": "size_t",
              "flags": "ares_buf_split_t",
              "max_sections": "size_t",
              "arr": "ares_array_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_split_str(\n  ares_buf_t *buf, const unsigned char *delims, size_t delims_len,\n  ares_buf_split_t flags, size_t max_sections, char ***strs, size_t *nstrs)",
          "fn_dec_pos": [
            [
              586,
              13
            ],
            [
              588,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_split_str",
            "parameters": {
              "buf": "ares_buf_t",
              "delims": "unsigned char",
              "delims_len": "size_t",
              "flags": "ares_buf_split_t",
              "max_sections": "size_t",
              "strs": "char",
              "nstrs": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t          ares_buf_begins_with(const ares_buf_t    *buf,\n                                                       const unsigned char *data,\n                                                       size_t               data_len)",
          "fn_dec_pos": [
            [
              598,
              13
            ],
            [
              600,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t          ares_buf_begins_with",
            "parameters": {
              "buf": "ares_buf_t",
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_len(const ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              608,
              34
            ],
            [
              608,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_len",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_peek(const ares_buf_t *buf,\n                                                size_t           *len)",
          "fn_dec_pos": [
            [
              618,
              34
            ],
            [
              619,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_peek",
            "parameters": {
              "buf": "ares_buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t        ares_buf_peek_byte(const ares_buf_t *buf,\n                                                     unsigned char    *b)",
          "fn_dec_pos": [
            [
              627,
              13
            ],
            [
              628,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t        ares_buf_peek_byte",
            "parameters": {
              "buf": "ares_buf_t",
              "b": "unsigned char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_reclaim(ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              650,
              34
            ],
            [
              650,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_reclaim",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_set_position(ares_buf_t *buf, size_t idx)",
          "fn_dec_pos": [
            [
              666,
              13
            ],
            [
              666,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_set_position",
            "parameters": {
              "buf": "ares_buf_t",
              "idx": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_buf_get_position(const ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              680,
              27
            ],
            [
              680,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_buf_get_position",
            "parameters": {
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_parse_dns_str(ares_buf_t *buf,\n                                                  size_t      remaining_len,\n                                                  char      **name)",
          "fn_dec_pos": [
            [
              694,
              13
            ],
            [
              696,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_parse_dns_str",
            "parameters": {
              "buf": "ares_buf_t",
              "remaining_len": "size_t",
              "name": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_parse_dns_binstr(ares_buf_t *buf,\n                                                     size_t      remaining_len,\n                                                     unsigned char **bin,\n                                                     size_t         *bin_len)",
          "fn_dec_pos": [
            [
              712,
              13
            ],
            [
              715,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_parse_dns_binstr",
            "parameters": {
              "buf": "ares_buf_t",
              "remaining_len": "size_t",
              "bin": "unsigned char",
              "bin_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_buf_load_file(const char *filename,\n                                              ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              726,
              13
            ],
            [
              727,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_buf_load_file",
            "parameters": {
              "filename": "char",
              "buf": "ares_buf_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_buf",
          {},
          "",
          [
            47,
            0
          ],
          [
            47,
            15
          ]
        ],
        [
          "typedef struct ares_buf     ares_buf_t;",
          {},
          "ares_buf_t",
          [
            50,
            0
          ],
          [
            50,
            39
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_array.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  /*! No flags */\n  ARES_BUF_SPLIT_NONE = 0,\n  /*! The delimiter will be the first character in the buffer, except the\n   *  first buffer since the start doesn't have a delimiter.  This option is\n   *  incompatible with ARES_BUF_SPLIT_LTRIM since the delimiter is always\n   *  the first character.\n   */\n  ARES_BUF_SPLIT_KEEP_DELIMS = 1 << 0,\n  /*! Allow blank sections, by default blank sections are not emitted.  If using\n   *  ARES_BUF_SPLIT_KEEP_DELIMS, the delimiter is not counted as part\n   *  of the section */\n  ARES_BUF_SPLIT_ALLOW_BLANK = 1 << 1,\n  /*! Remove duplicate entries */\n  ARES_BUF_SPLIT_NO_DUPLICATES = 1 << 2,\n  /*! Perform case-insensitive matching when comparing values */\n  ARES_BUF_SPLIT_CASE_INSENSITIVE = 1 << 3,\n  /*! Trim leading whitespace from buffer */\n  ARES_BUF_SPLIT_LTRIM = 1 << 4,\n  /*! Trim trailing whitespace from buffer */\n  ARES_BUF_SPLIT_RTRIM = 1 << 5,\n  /*! Trim leading and trailing whitespace from buffer */\n  ARES_BUF_SPLIT_TRIM = (ARES_BUF_SPLIT_LTRIM | ARES_BUF_SPLIT_RTRIM)\n} ares_buf_split_t;",
          {
            "ARES_BUF_SPLIT_NONE": "",
            "ARES_BUF_SPLIT_KEEP_DELIMS": "",
            "ARES_BUF_SPLIT_ALLOW_BLANK": "",
            "ARES_BUF_SPLIT_NO_DUPLICATES": "",
            "ARES_BUF_SPLIT_CASE_INSENSITIVE": "",
            "ARES_BUF_SPLIT_LTRIM": "",
            "ARES_BUF_SPLIT_RTRIM": "",
            "ARES_BUF_SPLIT_TRIM": ""
          },
          "ares_buf_split_t",
          [
            496,
            0
          ],
          [
            519,
            19
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/include/ares_htable_vpvp.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_htable_vpvp_key_free_t)(void *key)",
          "fn_dec_pos": [
            [
              51,
              13
            ],
            [
              51,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "key": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_htable_vpvp_val_free_t)(void *val)",
          "fn_dec_pos": [
            [
              57,
              13
            ],
            [
              57,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_htable_vpvp_destroy(ares_htable_vpvp_t *htable)",
          "fn_dec_pos": [
            [
              63,
              18
            ],
            [
              63,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_destroy",
            "parameters": {
              "htable": "ares_htable_vpvp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_vpvp_create(ares_htable_vpvp_key_free_t key_free,\n                          ares_htable_vpvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              75,
              2
            ],
            [
              76,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "key_free": "ares_htable_vpvp_key_free_t",
              "val_free": "ares_htable_vpvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpvp_insert(ares_htable_vpvp_t *htable,\n                                                 void *key, void *val)",
          "fn_dec_pos": [
            [
              85,
              13
            ],
            [
              86,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_vpvp_insert",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpvp_get(const ares_htable_vpvp_t *htable,\n                                              const void *key, void **val)",
          "fn_dec_pos": [
            [
              95,
              13
            ],
            [
              96,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_vpvp_get",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void",
              "val": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_vpvp_get_direct(const ares_htable_vpvp_t *htable,\n                                               const void               *key)",
          "fn_dec_pos": [
            [
              106,
              19
            ],
            [
              107,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_get_direct",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_htable_vpvp_remove(ares_htable_vpvp_t *htable,\n                                                 const void         *key)",
          "fn_dec_pos": [
            [
              115,
              13
            ],
            [
              116,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_htable_vpvp_remove",
            "parameters": {
              "htable": "ares_htable_vpvp_t",
              "key": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_htable_vpvp_num_keys(const ares_htable_vpvp_t *htable)",
          "fn_dec_pos": [
            [
              123,
              20
            ],
            [
              123,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_vpvp_num_keys",
            "parameters": {
              "htable": "ares_htable_vpvp_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable_vpvp",
          {},
          "",
          [
            42,
            0
          ],
          [
            42,
            23
          ]
        ],
        [
          "typedef struct ares_htable_vpvp ares_htable_vpvp_t;",
          {},
          "ares_htable_vpvp_t",
          [
            45,
            0
          ],
          [
            45,
            51
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/record/ares_dns_multistring.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_multistring_create(void)",
          "fn_dec_pos": [
            [
              33,
              36
            ],
            [
              33,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_multistring_clear(ares_dns_multistring_t *strs)",
          "fn_dec_pos": [
            [
              34,
              14
            ],
            [
              34,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_clear",
            "parameters": {
              "strs": "ares_dns_multistring_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_dns_multistring_destroy(ares_dns_multistring_t *strs)",
          "fn_dec_pos": [
            [
              35,
              14
            ],
            [
              35,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_destroy",
            "parameters": {
              "strs": "ares_dns_multistring_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_dns_multistring_swap_own(ares_dns_multistring_t *strs,\n                                            size_t idx, unsigned char *str,\n                                            size_t len)",
          "fn_dec_pos": [
            [
              36,
              14
            ],
            [
              38,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_swap_own",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "idx": "size_t",
              "str": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_multistring_del(ares_dns_multistring_t *strs,\n                                       size_t                  idx)",
          "fn_dec_pos": [
            [
              39,
              14
            ],
            [
              40,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_del",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_multistring_add_own(ares_dns_multistring_t *strs,\n                                           unsigned char *str, size_t len)",
          "fn_dec_pos": [
            [
              41,
              14
            ],
            [
              42,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_add_own",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "str": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_multistring_cnt(const ares_dns_multistring_t *strs)",
          "fn_dec_pos": [
            [
              43,
              14
            ],
            [
              43,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_cnt",
            "parameters": {
              "strs": "ares_dns_multistring_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_dns_multistring_get(const ares_dns_multistring_t *strs, size_t idx,\n                           size_t *len)",
          "fn_dec_pos": [
            [
              45,
              2
            ],
            [
              46,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_get",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "idx": "size_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_multistring_combined(ares_dns_multistring_t *strs,\n                                                   size_t                 *len)",
          "fn_dec_pos": [
            [
              47,
              21
            ],
            [
              48,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_combined",
            "parameters": {
              "strs": "ares_dns_multistring_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_multistring_parse_buf(ares_buf_t *buf,\n                                                    size_t      remaining_len,\n                                                    ares_dns_multistring_t **strs,\n                                                    ares_bool_t validate_printable)",
          "fn_dec_pos": [
            [
              66,
              21
            ],
            [
              69,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_multistring_parse_buf",
            "parameters": {
              "buf": "ares_buf_t",
              "remaining_len": "size_t",
              "strs": "ares_dns_multistring_t",
              "validate_printable": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_dns_multistring",
          {},
          "",
          [
            30,
            0
          ],
          [
            30,
            27
          ]
        ],
        [
          "typedef struct ares_dns_multistring ares_dns_multistring_t;",
          {},
          "ares_dns_multistring_t",
          [
            31,
            0
          ],
          [
            31,
            59
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_buf.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/record/ares_dns_private.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_record_duplicate_ex(ares_dns_record_t      **dest,\n                                                  const ares_dns_record_t *src)",
          "fn_dec_pos": [
            [
              28,
              21
            ],
            [
              29,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_duplicate_ex",
            "parameters": {
              "dest": "ares_dns_record_t",
              "src": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_rec_allow_name_comp(ares_dns_rec_type_t type)",
          "fn_dec_pos": [
            [
              30,
              21
            ],
            [
              30,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_allow_name_comp",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_opcode_isvalid(ares_dns_opcode_t opcode)",
          "fn_dec_pos": [
            [
              31,
              21
            ],
            [
              31,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_isvalid",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_rcode_isvalid(ares_dns_rcode_t rcode)",
          "fn_dec_pos": [
            [
              32,
              21
            ],
            [
              32,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_isvalid",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_flags_arevalid(unsigned short flags)",
          "fn_dec_pos": [
            [
              33,
              21
            ],
            [
              33,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_flags_arevalid",
            "parameters": {
              "flags": "unsigned short"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_rec_type_isvalid(ares_dns_rec_type_t type,\n                                               ares_bool_t         is_query)",
          "fn_dec_pos": [
            [
              34,
              21
            ],
            [
              35,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_isvalid",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "is_query": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_class_isvalid(ares_dns_class_t    qclass,\n                                            ares_dns_rec_type_t type,\n                                            ares_bool_t         is_query)",
          "fn_dec_pos": [
            [
              36,
              21
            ],
            [
              38,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_isvalid",
            "parameters": {
              "qclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "is_query": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_section_isvalid(ares_dns_section_t sect)",
          "fn_dec_pos": [
            [
              39,
              21
            ],
            [
              39,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_isvalid",
            "parameters": {
              "sect": "ares_dns_section_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_set_str_own(ares_dns_rr_t    *dns_rr,\n                                             ares_dns_rr_key_t key, char *val)",
          "fn_dec_pos": [
            [
              40,
              21
            ],
            [
              41,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_str_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_set_bin_own(ares_dns_rr_t    *dns_rr,\n                                             ares_dns_rr_key_t key, unsigned char *val,\n                                             size_t len)",
          "fn_dec_pos": [
            [
              42,
              21
            ],
            [
              44,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_bin_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_set_abin_own(ares_dns_rr_t          *dns_rr,\n                                              ares_dns_rr_key_t       key,\n                                              ares_dns_multistring_t *strs)",
          "fn_dec_pos": [
            [
              45,
              21
            ],
            [
              47,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_abin_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "strs": "ares_dns_multistring_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_set_opt_own(ares_dns_rr_t    *dns_rr,\n                                             ares_dns_rr_key_t key, unsigned short opt,\n                                             unsigned char *val, size_t val_len)",
          "fn_dec_pos": [
            [
              48,
              21
            ],
            [
              50,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_opt_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_record_rr_prealloc(ares_dns_record_t *dnsrec,\n                                                 ares_dns_section_t sect, size_t cnt)",
          "fn_dec_pos": [
            [
              51,
              21
            ],
            [
              52,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_prealloc",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "cnt": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_get_opt_rr(ares_dns_record_t *rec)",
          "fn_dec_pos": [
            [
              53,
              21
            ],
            [
              53,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_get_opt_rr",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_get_opt_rr_const(const ares_dns_record_t *rec)",
          "fn_dec_pos": [
            [
              54,
              21
            ],
            [
              54,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_get_opt_rr_const",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_record_ttl_decrement(ares_dns_record_t *dnsrec,\n                                                   unsigned int       ttl_decrement)",
          "fn_dec_pos": [
            [
              55,
              21
            ],
            [
              56,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_ttl_decrement",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "ttl_decrement": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_dns_write_buf(const ares_dns_record_t *dnsrec,\n                                        ares_buf_t              *buf)",
          "fn_dec_pos": [
            [
              59,
              21
            ],
            [
              60,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_buf",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_write_buf_tcp(const ares_dns_record_t *dnsrec,\n                                            ares_buf_t              *buf)",
          "fn_dec_pos": [
            [
              63,
              21
            ],
            [
              64,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_buf_tcp",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_record_create_query(ares_dns_record_t **dnsrec, const char *name,\n                               ares_dns_class_t    dnsclass,\n                               ares_dns_rec_type_t type, unsigned short id,\n                               ares_dns_flags_t flags, size_t max_udp_size)",
          "fn_dec_pos": [
            [
              79,
              2
            ],
            [
              82,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_create_query",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "id": "unsigned short",
              "flags": "ares_dns_flags_t",
              "max_udp_size": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_query_reply_tostatus(ares_dns_rcode_t rcode,\n                                            size_t           ancount)",
          "fn_dec_pos": [
            [
              90,
              14
            ],
            [
              91,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_query_reply_tostatus",
            "parameters": {
              "rcode": "ares_dns_rcode_t",
              "ancount": "size_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_dns_qd {\n  char               *name;\n  ares_dns_rec_type_t qtype;\n  ares_dns_class_t    qclass;\n}",
          {
            "*name": "char",
            "qtype": "ares_dns_rec_type_t",
            "qclass": "ares_dns_class_t"
          },
          "ares_dns_qd",
          [
            93,
            0
          ],
          [
            97,
            1
          ]
        ],
        [
          "typedef struct {\n  struct in_addr addr;\n} ares_dns_a_t;",
          {
            "addr": "struct in_addr"
          },
          "ares_dns_a_t",
          [
            99,
            0
          ],
          [
            101,
            15
          ]
        ],
        [
          "typedef struct {\n  char *nsdname;\n} ares_dns_ns_t;",
          {
            "*nsdname": "char"
          },
          "ares_dns_ns_t",
          [
            103,
            0
          ],
          [
            105,
            16
          ]
        ],
        [
          "typedef struct {\n  char *cname;\n} ares_dns_cname_t;",
          {
            "*cname": "char"
          },
          "ares_dns_cname_t",
          [
            107,
            0
          ],
          [
            109,
            19
          ]
        ],
        [
          "typedef struct {\n  char        *mname;\n  char        *rname;\n  unsigned int serial;\n  unsigned int refresh;\n  unsigned int retry;\n  unsigned int expire;\n  unsigned int minimum;\n} ares_dns_soa_t;",
          {
            "*mname": "char",
            "*rname": "char",
            "serial": "unsigned int",
            "refresh": "unsigned int",
            "retry": "unsigned int",
            "expire": "unsigned int",
            "minimum": "unsigned int"
          },
          "ares_dns_soa_t",
          [
            111,
            0
          ],
          [
            119,
            17
          ]
        ],
        [
          "typedef struct {\n  char *dname;\n} ares_dns_ptr_t;",
          {
            "*dname": "char"
          },
          "ares_dns_ptr_t",
          [
            121,
            0
          ],
          [
            123,
            17
          ]
        ],
        [
          "typedef struct {\n  char *cpu;\n  char *os;\n} ares_dns_hinfo_t;",
          {
            "*cpu": "char",
            "*os": "char"
          },
          "ares_dns_hinfo_t",
          [
            125,
            0
          ],
          [
            128,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short preference;\n  char          *exchange;\n} ares_dns_mx_t;",
          {
            "preference": "unsigned short",
            "*exchange": "char"
          },
          "ares_dns_mx_t",
          [
            130,
            0
          ],
          [
            133,
            16
          ]
        ],
        [
          "typedef struct {\n  ares_dns_multistring_t *strs;\n} ares_dns_txt_t;",
          {
            "*strs": "ares_dns_multistring_t"
          },
          "ares_dns_txt_t",
          [
            135,
            0
          ],
          [
            137,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned short type_covered;\n  unsigned char  algorithm;\n  unsigned char  labels;\n  unsigned int   original_ttl;\n  unsigned int   expiration;\n  unsigned int   inception;\n  unsigned short key_tag;\n  char          *signers_name;\n  unsigned char *signature;\n  size_t         signature_len;\n} ares_dns_sig_t;",
          {
            "type_covered": "unsigned short",
            "algorithm": "unsigned char",
            "labels": "unsigned char",
            "original_ttl": "unsigned int",
            "expiration": "unsigned int",
            "inception": "unsigned int",
            "key_tag": "unsigned short",
            "*signers_name": "char",
            "*signature": "unsigned char",
            "signature_len": "size_t"
          },
          "ares_dns_sig_t",
          [
            139,
            0
          ],
          [
            150,
            17
          ]
        ],
        [
          "typedef struct {\n  struct ares_in6_addr addr;\n} ares_dns_aaaa_t;",
          {
            "addr": "struct ares_in6_addr"
          },
          "ares_dns_aaaa_t",
          [
            152,
            0
          ],
          [
            154,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  unsigned short weight;\n  unsigned short port;\n  char          *target;\n} ares_dns_srv_t;",
          {
            "priority": "unsigned short",
            "weight": "unsigned short",
            "port": "unsigned short",
            "*target": "char"
          },
          "ares_dns_srv_t",
          [
            156,
            0
          ],
          [
            161,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned short order;\n  unsigned short preference;\n  char          *flags;\n  char          *services;\n  char          *regexp;\n  char          *replacement;\n} ares_dns_naptr_t;",
          {
            "order": "unsigned short",
            "preference": "unsigned short",
            "*flags": "char",
            "*services": "char",
            "*regexp": "char",
            "*replacement": "char"
          },
          "ares_dns_naptr_t",
          [
            163,
            0
          ],
          [
            170,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short opt;\n  unsigned char *val;\n  size_t         val_len;\n} ares_dns_optval_t;",
          {
            "opt": "unsigned short",
            "*val": "unsigned char",
            "val_len": "size_t"
          },
          "ares_dns_optval_t",
          [
            172,
            0
          ],
          [
            176,
            20
          ]
        ],
        [
          "typedef struct {\n  unsigned short udp_size; /*!< taken from class */\n  unsigned char  version;  /*!< taken from bits 8-16 of ttl */\n  unsigned short flags;    /*!< Flags, remaining 16 bits, though only\n                            *   1 currently defined */\n  ares_array_t  *options;  /*!< Type is ares_dns_optval_t */\n} ares_dns_opt_t;",
          {
            "udp_size": "unsigned short",
            "version": "unsigned char",
            "flags": "unsigned short",
            "*options": "ares_array_t"
          },
          "ares_dns_opt_t",
          [
            178,
            0
          ],
          [
            184,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned char  cert_usage;\n  unsigned char  selector;\n  unsigned char  match;\n  unsigned char *data;\n  size_t         data_len;\n} ares_dns_tlsa_t;",
          {
            "cert_usage": "unsigned char",
            "selector": "unsigned char",
            "match": "unsigned char",
            "*data": "unsigned char",
            "data_len": "size_t"
          },
          "ares_dns_tlsa_t",
          [
            186,
            0
          ],
          [
            192,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  char          *target;\n  ares_array_t  *params; /*!< Type is ares_dns_optval_t */\n} ares_dns_svcb_t;",
          {
            "priority": "unsigned short",
            "*target": "char",
            "*params": "ares_array_t"
          },
          "ares_dns_svcb_t",
          [
            194,
            0
          ],
          [
            198,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  unsigned short weight;\n  char          *target;\n} ares_dns_uri_t;",
          {
            "priority": "unsigned short",
            "weight": "unsigned short",
            "*target": "char"
          },
          "ares_dns_uri_t",
          [
            200,
            0
          ],
          [
            204,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned char  critical;\n  char          *tag;\n  unsigned char *value;\n  size_t         value_len;\n} ares_dns_caa_t;",
          {
            "critical": "unsigned char",
            "*tag": "char",
            "*value": "unsigned char",
            "value_len": "size_t"
          },
          "ares_dns_caa_t",
          [
            206,
            0
          ],
          [
            211,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned short type;   /*!< Not ares_rec_type_t because it likely isn't one\n                          *   of those values since it wasn't parsed */\n  unsigned char *data;   /*!< Raw RR data */\n  size_t         length; /*!< Length of raw RR data */\n} ares_dns_raw_rr_t;",
          {
            "type": "unsigned short",
            "*data": "unsigned char",
            "length": "size_t"
          },
          "ares_dns_raw_rr_t",
          [
            214,
            0
          ],
          [
            219,
            20
          ]
        ],
        [
          "struct ares_dns_rr {\n  ares_dns_record_t  *parent;\n  char               *name;\n  ares_dns_rec_type_t type;\n  ares_dns_class_t    rclass;\n  unsigned int        ttl;\n\n  union {\n    ares_dns_a_t      a;\n    ares_dns_ns_t     ns;\n    ares_dns_cname_t  cname;\n    ares_dns_soa_t    soa;\n    ares_dns_ptr_t    ptr;\n    ares_dns_hinfo_t  hinfo;\n    ares_dns_mx_t     mx;\n    ares_dns_txt_t    txt;\n    ares_dns_sig_t    sig;\n    ares_dns_aaaa_t   aaaa;\n    ares_dns_srv_t    srv;\n    ares_dns_naptr_t  naptr;\n    ares_dns_opt_t    opt;\n    ares_dns_tlsa_t   tlsa;\n    ares_dns_svcb_t   svcb;\n    ares_dns_svcb_t   https; /*!< https is a type of svcb, so this is right */\n    ares_dns_uri_t    uri;\n    ares_dns_caa_t    caa;\n    ares_dns_raw_rr_t raw_rr;\n  } r;\n}",
          {
            "*parent": "ares_dns_record_t",
            "*name": "char",
            "type": "ares_dns_rec_type_t",
            "rclass": "ares_dns_class_t",
            "ttl": "unsigned int",
            "r": "union {\n    ares_dns_a_t      a;\n    ares_dns_ns_t     ns;\n    ares_dns_cname_t  cname;\n    ares_dns_soa_t    soa;\n    ares_dns_ptr_t    ptr;\n    ares_dns_hinfo_t  hinfo;\n    ares_dns_mx_t     mx;\n    ares_dns_txt_t    txt;\n    ares_dns_sig_t    sig;\n    ares_dns_aaaa_t   aaaa;\n    ares_dns_srv_t    srv;\n    ares_dns_naptr_t  naptr;\n    ares_dns_opt_t    opt;\n    ares_dns_tlsa_t   tlsa;\n    ares_dns_svcb_t   svcb;\n    ares_dns_svcb_t   https; /*!< https is a type of svcb, so this is right */\n    ares_dns_uri_t    uri;\n    ares_dns_caa_t    caa;\n    ares_dns_raw_rr_t raw_rr;\n  }",
            "a": "ares_dns_a_t",
            "ns": "ares_dns_ns_t",
            "cname": "ares_dns_cname_t",
            "soa": "ares_dns_soa_t",
            "ptr": "ares_dns_ptr_t",
            "hinfo": "ares_dns_hinfo_t",
            "mx": "ares_dns_mx_t",
            "txt": "ares_dns_txt_t",
            "sig": "ares_dns_sig_t",
            "aaaa": "ares_dns_aaaa_t",
            "srv": "ares_dns_srv_t",
            "naptr": "ares_dns_naptr_t",
            "opt": "ares_dns_opt_t",
            "tlsa": "ares_dns_tlsa_t",
            "svcb": "ares_dns_svcb_t",
            "https": "ares_dns_svcb_t",
            "uri": "ares_dns_uri_t",
            "caa": "ares_dns_caa_t",
            "raw_rr": "ares_dns_raw_rr_t"
          },
          "ares_dns_rr",
          [
            222,
            0
          ],
          [
            250,
            1
          ]
        ],
        [
          "struct ares_dns_record {\n  unsigned short    id;            /*!< DNS query id */\n  unsigned short    flags;         /*!< One or more ares_dns_flags_t */\n  ares_dns_opcode_t opcode;        /*!< DNS Opcode */\n  ares_dns_rcode_t  rcode;         /*!< DNS RCODE */\n  unsigned short    raw_rcode;     /*!< Raw rcode, used to ultimately form real\n                                    *   rcode after reading OPT record if it\n                                    *   exists */\n  unsigned int      ttl_decrement; /*!< Special case to apply to writing out\n                                    *   this record, where it will decrement\n                                    *   the ttl of any resource records by\n                                    *   this amount.  Used for cache */\n\n  ares_array_t     *qd;            /*!< Type is ares_dns_qd_t */\n  ares_array_t     *an;            /*!< Type is ares_dns_rr_t */\n  ares_array_t     *ns;            /*!< Type is ares_dns_rr_t */\n  ares_array_t     *ar;            /*!< Type is ares_dns_rr_t */\n}",
          {
            "id": "unsigned short",
            "flags": "unsigned short",
            "opcode": "ares_dns_opcode_t",
            "rcode": "ares_dns_rcode_t",
            "raw_rcode": "unsigned short",
            "ttl_decrement": "unsigned int",
            "*qd": "ares_array_t",
            "*an": "ares_array_t",
            "*ns": "ares_array_t",
            "*ar": "ares_array_t"
          },
          "ares_dns_record",
          [
            253,
            0
          ],
          [
            270,
            1
          ]
        ],
        [
          "struct ares_dns_qd {\n  char               *name;\n  ares_dns_rec_type_t qtype;\n  ares_dns_class_t    qclass;\n}",
          {
            "*name": "char",
            "qtype": "ares_dns_rec_type_t",
            "qclass": "ares_dns_class_t"
          },
          "ares_dns_qd",
          [
            93,
            0
          ],
          [
            97,
            1
          ]
        ],
        [
          "typedef struct {\n  struct in_addr addr;\n} ares_dns_a_t;",
          {
            "addr": "struct in_addr"
          },
          "ares_dns_a_t",
          [
            99,
            0
          ],
          [
            101,
            15
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            100,
            2
          ],
          [
            100,
            16
          ]
        ],
        [
          "typedef struct {\n  char *nsdname;\n} ares_dns_ns_t;",
          {
            "*nsdname": "char"
          },
          "ares_dns_ns_t",
          [
            103,
            0
          ],
          [
            105,
            16
          ]
        ],
        [
          "typedef struct {\n  char *cname;\n} ares_dns_cname_t;",
          {
            "*cname": "char"
          },
          "ares_dns_cname_t",
          [
            107,
            0
          ],
          [
            109,
            19
          ]
        ],
        [
          "typedef struct {\n  char        *mname;\n  char        *rname;\n  unsigned int serial;\n  unsigned int refresh;\n  unsigned int retry;\n  unsigned int expire;\n  unsigned int minimum;\n} ares_dns_soa_t;",
          {
            "*mname": "char",
            "*rname": "char",
            "serial": "unsigned int",
            "refresh": "unsigned int",
            "retry": "unsigned int",
            "expire": "unsigned int",
            "minimum": "unsigned int"
          },
          "ares_dns_soa_t",
          [
            111,
            0
          ],
          [
            119,
            17
          ]
        ],
        [
          "typedef struct {\n  char *dname;\n} ares_dns_ptr_t;",
          {
            "*dname": "char"
          },
          "ares_dns_ptr_t",
          [
            121,
            0
          ],
          [
            123,
            17
          ]
        ],
        [
          "typedef struct {\n  char *cpu;\n  char *os;\n} ares_dns_hinfo_t;",
          {
            "*cpu": "char",
            "*os": "char"
          },
          "ares_dns_hinfo_t",
          [
            125,
            0
          ],
          [
            128,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short preference;\n  char          *exchange;\n} ares_dns_mx_t;",
          {
            "preference": "unsigned short",
            "*exchange": "char"
          },
          "ares_dns_mx_t",
          [
            130,
            0
          ],
          [
            133,
            16
          ]
        ],
        [
          "typedef struct {\n  ares_dns_multistring_t *strs;\n} ares_dns_txt_t;",
          {
            "*strs": "ares_dns_multistring_t"
          },
          "ares_dns_txt_t",
          [
            135,
            0
          ],
          [
            137,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned short type_covered;\n  unsigned char  algorithm;\n  unsigned char  labels;\n  unsigned int   original_ttl;\n  unsigned int   expiration;\n  unsigned int   inception;\n  unsigned short key_tag;\n  char          *signers_name;\n  unsigned char *signature;\n  size_t         signature_len;\n} ares_dns_sig_t;",
          {
            "type_covered": "unsigned short",
            "algorithm": "unsigned char",
            "labels": "unsigned char",
            "original_ttl": "unsigned int",
            "expiration": "unsigned int",
            "inception": "unsigned int",
            "key_tag": "unsigned short",
            "*signers_name": "char",
            "*signature": "unsigned char",
            "signature_len": "size_t"
          },
          "ares_dns_sig_t",
          [
            139,
            0
          ],
          [
            150,
            17
          ]
        ],
        [
          "typedef struct {\n  struct ares_in6_addr addr;\n} ares_dns_aaaa_t;",
          {
            "addr": "struct ares_in6_addr"
          },
          "ares_dns_aaaa_t",
          [
            152,
            0
          ],
          [
            154,
            18
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            153,
            2
          ],
          [
            153,
            22
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  unsigned short weight;\n  unsigned short port;\n  char          *target;\n} ares_dns_srv_t;",
          {
            "priority": "unsigned short",
            "weight": "unsigned short",
            "port": "unsigned short",
            "*target": "char"
          },
          "ares_dns_srv_t",
          [
            156,
            0
          ],
          [
            161,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned short order;\n  unsigned short preference;\n  char          *flags;\n  char          *services;\n  char          *regexp;\n  char          *replacement;\n} ares_dns_naptr_t;",
          {
            "order": "unsigned short",
            "preference": "unsigned short",
            "*flags": "char",
            "*services": "char",
            "*regexp": "char",
            "*replacement": "char"
          },
          "ares_dns_naptr_t",
          [
            163,
            0
          ],
          [
            170,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short opt;\n  unsigned char *val;\n  size_t         val_len;\n} ares_dns_optval_t;",
          {
            "opt": "unsigned short",
            "*val": "unsigned char",
            "val_len": "size_t"
          },
          "ares_dns_optval_t",
          [
            172,
            0
          ],
          [
            176,
            20
          ]
        ],
        [
          "typedef struct {\n  unsigned short udp_size; /*!< taken from class */\n  unsigned char  version;  /*!< taken from bits 8-16 of ttl */\n  unsigned short flags;    /*!< Flags, remaining 16 bits, though only\n                            *   1 currently defined */\n  ares_array_t  *options;  /*!< Type is ares_dns_optval_t */\n} ares_dns_opt_t;",
          {
            "udp_size": "unsigned short",
            "version": "unsigned char",
            "flags": "unsigned short",
            "*options": "ares_array_t"
          },
          "ares_dns_opt_t",
          [
            178,
            0
          ],
          [
            184,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned char  cert_usage;\n  unsigned char  selector;\n  unsigned char  match;\n  unsigned char *data;\n  size_t         data_len;\n} ares_dns_tlsa_t;",
          {
            "cert_usage": "unsigned char",
            "selector": "unsigned char",
            "match": "unsigned char",
            "*data": "unsigned char",
            "data_len": "size_t"
          },
          "ares_dns_tlsa_t",
          [
            186,
            0
          ],
          [
            192,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  char          *target;\n  ares_array_t  *params; /*!< Type is ares_dns_optval_t */\n} ares_dns_svcb_t;",
          {
            "priority": "unsigned short",
            "*target": "char",
            "*params": "ares_array_t"
          },
          "ares_dns_svcb_t",
          [
            194,
            0
          ],
          [
            198,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  unsigned short weight;\n  char          *target;\n} ares_dns_uri_t;",
          {
            "priority": "unsigned short",
            "weight": "unsigned short",
            "*target": "char"
          },
          "ares_dns_uri_t",
          [
            200,
            0
          ],
          [
            204,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned char  critical;\n  char          *tag;\n  unsigned char *value;\n  size_t         value_len;\n} ares_dns_caa_t;",
          {
            "critical": "unsigned char",
            "*tag": "char",
            "*value": "unsigned char",
            "value_len": "size_t"
          },
          "ares_dns_caa_t",
          [
            206,
            0
          ],
          [
            211,
            17
          ]
        ],
        [
          "typedef struct {\n  unsigned short type;   /*!< Not ares_rec_type_t because it likely isn't one\n                          *   of those values since it wasn't parsed */\n  unsigned char *data;   /*!< Raw RR data */\n  size_t         length; /*!< Length of raw RR data */\n} ares_dns_raw_rr_t;",
          {
            "type": "unsigned short",
            "*data": "unsigned char",
            "length": "size_t"
          },
          "ares_dns_raw_rr_t",
          [
            214,
            0
          ],
          [
            219,
            20
          ]
        ],
        [
          "struct ares_dns_rr {\n  ares_dns_record_t  *parent;\n  char               *name;\n  ares_dns_rec_type_t type;\n  ares_dns_class_t    rclass;\n  unsigned int        ttl;\n\n  union {\n    ares_dns_a_t      a;\n    ares_dns_ns_t     ns;\n    ares_dns_cname_t  cname;\n    ares_dns_soa_t    soa;\n    ares_dns_ptr_t    ptr;\n    ares_dns_hinfo_t  hinfo;\n    ares_dns_mx_t     mx;\n    ares_dns_txt_t    txt;\n    ares_dns_sig_t    sig;\n    ares_dns_aaaa_t   aaaa;\n    ares_dns_srv_t    srv;\n    ares_dns_naptr_t  naptr;\n    ares_dns_opt_t    opt;\n    ares_dns_tlsa_t   tlsa;\n    ares_dns_svcb_t   svcb;\n    ares_dns_svcb_t   https; /*!< https is a type of svcb, so this is right */\n    ares_dns_uri_t    uri;\n    ares_dns_caa_t    caa;\n    ares_dns_raw_rr_t raw_rr;\n  } r;\n}",
          {
            "*parent": "ares_dns_record_t",
            "*name": "char",
            "type": "ares_dns_rec_type_t",
            "rclass": "ares_dns_class_t",
            "ttl": "unsigned int",
            "r": "union {\n    ares_dns_a_t      a;\n    ares_dns_ns_t     ns;\n    ares_dns_cname_t  cname;\n    ares_dns_soa_t    soa;\n    ares_dns_ptr_t    ptr;\n    ares_dns_hinfo_t  hinfo;\n    ares_dns_mx_t     mx;\n    ares_dns_txt_t    txt;\n    ares_dns_sig_t    sig;\n    ares_dns_aaaa_t   aaaa;\n    ares_dns_srv_t    srv;\n    ares_dns_naptr_t  naptr;\n    ares_dns_opt_t    opt;\n    ares_dns_tlsa_t   tlsa;\n    ares_dns_svcb_t   svcb;\n    ares_dns_svcb_t   https; /*!< https is a type of svcb, so this is right */\n    ares_dns_uri_t    uri;\n    ares_dns_caa_t    caa;\n    ares_dns_raw_rr_t raw_rr;\n  }",
            "a": "ares_dns_a_t",
            "ns": "ares_dns_ns_t",
            "cname": "ares_dns_cname_t",
            "soa": "ares_dns_soa_t",
            "ptr": "ares_dns_ptr_t",
            "hinfo": "ares_dns_hinfo_t",
            "mx": "ares_dns_mx_t",
            "txt": "ares_dns_txt_t",
            "sig": "ares_dns_sig_t",
            "aaaa": "ares_dns_aaaa_t",
            "srv": "ares_dns_srv_t",
            "naptr": "ares_dns_naptr_t",
            "opt": "ares_dns_opt_t",
            "tlsa": "ares_dns_tlsa_t",
            "svcb": "ares_dns_svcb_t",
            "https": "ares_dns_svcb_t",
            "uri": "ares_dns_uri_t",
            "caa": "ares_dns_caa_t",
            "raw_rr": "ares_dns_raw_rr_t"
          },
          "ares_dns_rr",
          [
            222,
            0
          ],
          [
            250,
            1
          ]
        ],
        [
          "struct ares_dns_record {\n  unsigned short    id;            /*!< DNS query id */\n  unsigned short    flags;         /*!< One or more ares_dns_flags_t */\n  ares_dns_opcode_t opcode;        /*!< DNS Opcode */\n  ares_dns_rcode_t  rcode;         /*!< DNS RCODE */\n  unsigned short    raw_rcode;     /*!< Raw rcode, used to ultimately form real\n                                    *   rcode after reading OPT record if it\n                                    *   exists */\n  unsigned int      ttl_decrement; /*!< Special case to apply to writing out\n                                    *   this record, where it will decrement\n                                    *   the ttl of any resource records by\n                                    *   this amount.  Used for cache */\n\n  ares_array_t     *qd;            /*!< Type is ares_dns_qd_t */\n  ares_array_t     *an;            /*!< Type is ares_dns_rr_t */\n  ares_array_t     *ns;            /*!< Type is ares_dns_rr_t */\n  ares_array_t     *ar;            /*!< Type is ares_dns_rr_t */\n}",
          {
            "id": "unsigned short",
            "flags": "unsigned short",
            "opcode": "ares_dns_opcode_t",
            "rcode": "ares_dns_rcode_t",
            "raw_rcode": "unsigned short",
            "ttl_decrement": "unsigned int",
            "*qd": "ares_array_t",
            "*an": "ares_array_t",
            "*ns": "ares_array_t",
            "*ar": "ares_array_t"
          },
          "ares_dns_record",
          [
            253,
            0
          ],
          [
            270,
            1
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/thirdparty/apple/dnsinfo.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "DNS_PTR(char *,\t\t\tdomain)",
          "fn_dec_pos": [
            [
              62,
              1
            ],
            [
              62,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_nameserver)",
          "fn_dec_pos": [
            [
              63,
              1
            ],
            [
              63,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(struct sockaddr **,\tnameserver)",
          "fn_dec_pos": [
            [
              64,
              1
            ],
            [
              64,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint16_t,\t\tport)",
          "fn_dec_pos": [
            [
              65,
              1
            ],
            [
              65,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_search)",
          "fn_dec_pos": [
            [
              66,
              1
            ],
            [
              66,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(char **,\t\tsearch)",
          "fn_dec_pos": [
            [
              67,
              1
            ],
            [
              67,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_sortaddr)",
          "fn_dec_pos": [
            [
              68,
              1
            ],
            [
              68,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(dns_sortaddr_t **,\tsortaddr)",
          "fn_dec_pos": [
            [
              69,
              1
            ],
            [
              69,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(char *,\t\t\toptions)",
          "fn_dec_pos": [
            [
              70,
              1
            ],
            [
              70,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\ttimeout)",
          "fn_dec_pos": [
            [
              71,
              1
            ],
            [
              71,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\tsearch_order)",
          "fn_dec_pos": [
            [
              72,
              1
            ],
            [
              72,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\tif_index)",
          "fn_dec_pos": [
            [
              73,
              1
            ],
            [
              73,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\tflags)",
          "fn_dec_pos": [
            [
              74,
              1
            ],
            [
              74,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\treserved[6])",
          "fn_dec_pos": [
            [
              76,
              1
            ],
            [
              76,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\treach_flags)",
          "fn_dec_pos": [
            [
              78,
              1
            ],
            [
              78,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\treserved[5])",
          "fn_dec_pos": [
            [
              79,
              1
            ],
            [
              79,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_resolver)",
          "fn_dec_pos": [
            [
              90,
              1
            ],
            [
              90,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(dns_resolver_t **,\tresolver)",
          "fn_dec_pos": [
            [
              91,
              1
            ],
            [
              91,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_scoped_resolver)",
          "fn_dec_pos": [
            [
              92,
              1
            ],
            [
              92,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(dns_resolver_t **,\tscoped_resolver)",
          "fn_dec_pos": [
            [
              93,
              1
            ],
            [
              93,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\treserved[5])",
          "fn_dec_pos": [
            [
              94,
              1
            ],
            [
              94,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dns_configuration_notify_key    (void)",
          "fn_dec_pos": [
            [
              105,
              0
            ],
            [
              105,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dns_configuration_notify_key",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dns_configuration_copy\t\t(void)",
          "fn_dec_pos": [
            [
              108,
              0
            ],
            [
              108,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dns_configuration_copy",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dns_configuration_free\t\t(dns_config_t\t*config)",
          "fn_dec_pos": [
            [
              111,
              0
            ],
            [
              111,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dns_configuration_free",
            "parameters": {
              "config": "dns_config_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_dns_configuration_ack\t\t(dns_config_t\t*config,\n\t\t\t\t const char\t*bundle_id)",
          "fn_dec_pos": [
            [
              115,
              0
            ],
            [
              116,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_dns_configuration_ack",
            "parameters": {
              "config": "dns_config_t",
              "bundle_id": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tstruct in_addr\taddress;\n\tstruct in_addr\tmask;\n} dns_sortaddr_t;",
          {
            "address": "struct in_addr",
            "mask": "struct in_addr"
          },
          "dns_sortaddr_t",
          [
            53,
            0
          ],
          [
            56,
            17
          ]
        ],
        [
          "typedef struct {\n\tDNS_PTR(char *,\t\t\tdomain);\t/* domain */\n\tDNS_VAR(int32_t,\t\tn_nameserver);\t/* # nameserver */\n\tDNS_PTR(struct sockaddr **,\tnameserver);\n\tDNS_VAR(uint16_t,\t\tport);\t\t/* port (in host byte order) */\n\tDNS_VAR(int32_t,\t\tn_search);\t/* # search */\n\tDNS_PTR(char **,\t\tsearch);\n\tDNS_VAR(int32_t,\t\tn_sortaddr);\t/* # sortaddr */\n\tDNS_PTR(dns_sortaddr_t **,\tsortaddr);\n\tDNS_PTR(char *,\t\t\toptions);\t/* options */\n\tDNS_VAR(uint32_t,\t\ttimeout);\t/* timeout */\n\tDNS_VAR(uint32_t,\t\tsearch_order);\t/* search_order */\n\tDNS_VAR(uint32_t,\t\tif_index);\n\tDNS_VAR(uint32_t,\t\tflags);\n#if MAC_OS_X_VERSION_MIN_REQUIRED < 1080 /* MacOS 10.8 */\n\tDNS_VAR(uint32_t,\t\treserved[6]);\n#else\n\tDNS_VAR(uint32_t,\t\treach_flags);\t/* SCNetworkReachabilityFlags */\n\tDNS_VAR(uint32_t,\t\treserved[5]);\n#endif\n} dns_resolver_t;",
          {},
          "dns_resolver_t",
          [
            61,
            0
          ],
          [
            81,
            17
          ]
        ],
        [
          "typedef struct {\n\tDNS_VAR(int32_t,\t\tn_resolver);\t\t/* resolver configurations */\n\tDNS_PTR(dns_resolver_t **,\tresolver);\n\tDNS_VAR(int32_t,\t\tn_scoped_resolver);\t/* \"scoped\" resolver configurations */\n\tDNS_PTR(dns_resolver_t **,\tscoped_resolver);\n\tDNS_VAR(uint32_t,\t\treserved[5]);\n} dns_config_t;",
          {},
          "dns_config_t",
          [
            89,
            0
          ],
          [
            95,
            15
          ]
        ],
        [
          "typedef struct {\n\tstruct in_addr\taddress;\n\tstruct in_addr\tmask;\n} dns_sortaddr_t;",
          {
            "address": "struct in_addr",
            "mask": "struct in_addr"
          },
          "dns_sortaddr_t",
          [
            53,
            0
          ],
          [
            56,
            17
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            54,
            1
          ],
          [
            54,
            15
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            55,
            1
          ],
          [
            55,
            15
          ]
        ],
        [
          "typedef struct {\n\tDNS_PTR(char *,\t\t\tdomain);\t/* domain */\n\tDNS_VAR(int32_t,\t\tn_nameserver);\t/* # nameserver */\n\tDNS_PTR(struct sockaddr **,\tnameserver);\n\tDNS_VAR(uint16_t,\t\tport);\t\t/* port (in host byte order) */\n\tDNS_VAR(int32_t,\t\tn_search);\t/* # search */\n\tDNS_PTR(char **,\t\tsearch);\n\tDNS_VAR(int32_t,\t\tn_sortaddr);\t/* # sortaddr */\n\tDNS_PTR(dns_sortaddr_t **,\tsortaddr);\n\tDNS_PTR(char *,\t\t\toptions);\t/* options */\n\tDNS_VAR(uint32_t,\t\ttimeout);\t/* timeout */\n\tDNS_VAR(uint32_t,\t\tsearch_order);\t/* search_order */\n\tDNS_VAR(uint32_t,\t\tif_index);\n\tDNS_VAR(uint32_t,\t\tflags);\n#if MAC_OS_X_VERSION_MIN_REQUIRED < 1080 /* MacOS 10.8 */\n\tDNS_VAR(uint32_t,\t\treserved[6]);\n#else\n\tDNS_VAR(uint32_t,\t\treach_flags);\t/* SCNetworkReachabilityFlags */\n\tDNS_VAR(uint32_t,\t\treserved[5]);\n#endif\n} dns_resolver_t;",
          {},
          "dns_resolver_t",
          [
            61,
            0
          ],
          [
            81,
            17
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            64,
            9
          ],
          [
            64,
            24
          ]
        ],
        [
          "typedef struct {\n\tDNS_VAR(int32_t,\t\tn_resolver);\t\t/* resolver configurations */\n\tDNS_PTR(dns_resolver_t **,\tresolver);\n\tDNS_VAR(int32_t,\t\tn_scoped_resolver);\t/* \"scoped\" resolver configurations */\n\tDNS_PTR(dns_resolver_t **,\tscoped_resolver);\n\tDNS_VAR(uint32_t,\t\treserved[5]);\n} dns_config_t;",
          {},
          "dns_config_t",
          [
            89,
            0
          ],
          [
            95,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include <Availability.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sys/cdefs.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdint.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <AvailabilityMacros.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_slist.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_slist_destructor_t)(void *data)",
          "fn_dec_pos": [
            [
              65,
              13
            ],
            [
              65,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_slist_cmp_t)(const void *data1, const void *data2)",
          "fn_dec_pos": [
            [
              73,
              12
            ],
            [
              73,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data1": "void",
              "data2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_slist_create(ares_rand_state        *rand_state,\n                                     ares_slist_cmp_t        cmp,\n                                     ares_slist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              82,
              19
            ],
            [
              84,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "cmp": "ares_slist_cmp_t",
              "destruct": "ares_slist_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_replace_destructor(ares_slist_t           *list,\n                                                 ares_slist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              91,
              19
            ],
            [
              92,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_replace_destructor",
            "parameters": {
              "list": "ares_slist_t",
              "destruct": "ares_slist_destructor_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_slist_insert(ares_slist_t *list, void *val)",
          "fn_dec_pos": [
            [
              101,
              19
            ],
            [
              101,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_insert",
            "parameters": {
              "list": "ares_slist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_first(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              108,
              19
            ],
            [
              108,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_first",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_last(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              115,
              19
            ],
            [
              115,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_last",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_next(const ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              122,
              19
            ],
            [
              122,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_next",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_prev(const ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              129,
              19
            ],
            [
              129,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_prev",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_find(const ares_slist_t *list,\n                                        const void         *val)",
          "fn_dec_pos": [
            [
              137,
              19
            ],
            [
              138,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_find",
            "parameters": {
              "list": "ares_slist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_val(ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              146,
              19
            ],
            [
              146,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_val",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_len(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              153,
              19
            ],
            [
              153,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_len",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_slist_node_parent(ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              160,
              19
            ],
            [
              160,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_parent",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_first_val(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              167,
              19
            ],
            [
              167,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_first_val",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_last_val(const ares_slist_t *list)",
          "fn_dec_pos": [
            [
              174,
              19
            ],
            [
              174,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_last_val",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_claim(ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              181,
              19
            ],
            [
              181,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_claim",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_slist_node_reinsert(ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              190,
              19
            ],
            [
              190,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_reinsert",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_slist_node_destroy(ares_slist_node_t *node)",
          "fn_dec_pos": [
            [
              196,
              19
            ],
            [
              196,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_node_destroy",
            "parameters": {
              "node": "ares_slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_slist_destroy(ares_slist_t *list)",
          "fn_dec_pos": [
            [
              202,
              19
            ],
            [
              202,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_slist_destroy",
            "parameters": {
              "list": "ares_slist_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_slist",
          {},
          "",
          [
            51,
            0
          ],
          [
            51,
            17
          ]
        ],
        [
          "typedef struct ares_slist ares_slist_t;",
          {},
          "ares_slist_t",
          [
            54,
            0
          ],
          [
            54,
            39
          ]
        ],
        [
          "struct ares_slist_node",
          {},
          "",
          [
            56,
            0
          ],
          [
            56,
            22
          ]
        ],
        [
          "typedef struct ares_slist_node ares_slist_node_t;",
          {},
          "ares_slist_node_t",
          [
            59,
            0
          ],
          [
            59,
            49
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/dsa/ares_htable.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_htable_hashfunc_t)(const void  *key,\n                                               unsigned int seed)",
          "fn_dec_pos": [
            [
              60,
              21
            ],
            [
              61,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares_htable_bucket_free_t)(void *bucket)",
          "fn_dec_pos": [
            [
              67,
              13
            ],
            [
              67,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_htable_bucket_key_t)(const void *bucket)",
          "fn_dec_pos": [
            [
              74,
              20
            ],
            [
              74,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares_htable_key_eq_t)(const void *key1, const void *key2)",
          "fn_dec_pos": [
            [
              82,
              20
            ],
            [
              82,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_destroy(ares_htable_t *htable)",
          "fn_dec_pos": [
            [
              89,
              15
            ],
            [
              89,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_destroy",
            "parameters": {
              "htable": "ares_htable_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_htable_create(ares_htable_hashfunc_t    hash_func,\n                                  ares_htable_bucket_key_t  bucket_key,\n                                  ares_htable_bucket_free_t bucket_free,\n                                  ares_htable_key_eq_t      key_eq)",
          "fn_dec_pos": [
            [
              99,
              15
            ],
            [
              102,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_create",
            "parameters": {
              "hash_func": "ares_htable_hashfunc_t",
              "bucket_key": "ares_htable_bucket_key_t",
              "bucket_free": "ares_htable_bucket_free_t",
              "key_eq": "ares_htable_key_eq_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_num_keys(const ares_htable_t *htable)",
          "fn_dec_pos": [
            [
              109,
              15
            ],
            [
              109,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_num_keys",
            "parameters": {
              "htable": "ares_htable_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_htable_all_buckets(const ares_htable_t *htable, size_t *num)",
          "fn_dec_pos": [
            [
              121,
              13
            ],
            [
              121,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_all_buckets",
            "parameters": {
              "htable": "ares_htable_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_insert(ares_htable_t *htable, void *bucket)",
          "fn_dec_pos": [
            [
              130,
              13
            ],
            [
              130,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_insert",
            "parameters": {
              "htable": "ares_htable_t",
              "bucket": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_get(const ares_htable_t *htable, const void *key)",
          "fn_dec_pos": [
            [
              138,
              13
            ],
            [
              138,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_get",
            "parameters": {
              "htable": "ares_htable_t",
              "key": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_remove(ares_htable_t *htable, const void *key)",
          "fn_dec_pos": [
            [
              146,
              13
            ],
            [
              146,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_remove",
            "parameters": {
              "htable": "ares_htable_t",
              "key": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_htable_hash_FNV1a(const unsigned char *key, size_t key_len,\n                                    unsigned int seed)",
          "fn_dec_pos": [
            [
              156,
              13
            ],
            [
              157,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_hash_FNV1a",
            "parameters": {
              "key": "unsigned char",
              "key_len": "size_t",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_htable_hash_FNV1a_casecmp(const unsigned char *key,\n                                            size_t key_len, unsigned int seed)",
          "fn_dec_pos": [
            [
              168,
              13
            ],
            [
              169,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_htable_hash_FNV1a_casecmp",
            "parameters": {
              "key": "unsigned char",
              "key_len": "size_t",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_htable",
          {},
          "",
          [
            47,
            0
          ],
          [
            47,
            18
          ]
        ],
        [
          "typedef struct ares_htable ares_htable_t;",
          {},
          "ares_htable_t",
          [
            50,
            0
          ],
          [
            50,
            41
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_uri.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_uri_create(void)",
          "fn_dec_pos": [
            [
              51,
              24
            ],
            [
              51,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_destroy(ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              57,
              24
            ],
            [
              57,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_destroy",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_uri_set_scheme(ares_uri_t *uri, const char *scheme)",
          "fn_dec_pos": [
            [
              67,
              15
            ],
            [
              67,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_scheme",
            "parameters": {
              "uri": "ares_uri_t",
              "scheme": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_get_scheme(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              74,
              15
            ],
            [
              74,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_scheme",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_set_username(ares_uri_t *uri, const char *username)",
          "fn_dec_pos": [
            [
              82,
              15
            ],
            [
              82,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_username",
            "parameters": {
              "uri": "ares_uri_t",
              "username": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_get_username(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              89,
              15
            ],
            [
              89,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_username",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_set_password(ares_uri_t *uri, const char *password)",
          "fn_dec_pos": [
            [
              97,
              15
            ],
            [
              97,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_password",
            "parameters": {
              "uri": "ares_uri_t",
              "password": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_get_password(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              104,
              15
            ],
            [
              104,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_password",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_set_host(ares_uri_t *uri, const char *host)",
          "fn_dec_pos": [
            [
              113,
              15
            ],
            [
              113,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_host",
            "parameters": {
              "uri": "ares_uri_t",
              "host": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_get_host(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              121,
              15
            ],
            [
              121,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_host",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_set_port(ares_uri_t *uri, unsigned short port)",
          "fn_dec_pos": [
            [
              130,
              15
            ],
            [
              130,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_port",
            "parameters": {
              "uri": "ares_uri_t",
              "port": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_get_port(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              137,
              15
            ],
            [
              137,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_port",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_set_path(ares_uri_t *uri, const char *path)",
          "fn_dec_pos": [
            [
              146,
              15
            ],
            [
              146,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_path",
            "parameters": {
              "uri": "ares_uri_t",
              "path": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_get_path(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              154,
              15
            ],
            [
              154,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_path",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_set_query_key(ares_uri_t *uri, const char *key,\n                                      const char *val)",
          "fn_dec_pos": [
            [
              166,
              15
            ],
            [
              167,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_query_key",
            "parameters": {
              "uri": "ares_uri_t",
              "key": "char",
              "val": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_del_query_key(ares_uri_t *uri, const char *key)",
          "fn_dec_pos": [
            [
              175,
              15
            ],
            [
              175,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_del_query_key",
            "parameters": {
              "uri": "ares_uri_t",
              "key": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_get_query_key(const ares_uri_t *uri, const char *key)",
          "fn_dec_pos": [
            [
              185,
              15
            ],
            [
              185,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_query_key",
            "parameters": {
              "uri": "ares_uri_t",
              "key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_get_query_keys(const ares_uri_t *uri, size_t *num)",
          "fn_dec_pos": [
            [
              194,
              15
            ],
            [
              194,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_query_keys",
            "parameters": {
              "uri": "ares_uri_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_set_fragment(ares_uri_t *uri, const char *fragment)",
          "fn_dec_pos": [
            [
              203,
              15
            ],
            [
              203,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_set_fragment",
            "parameters": {
              "uri": "ares_uri_t",
              "fragment": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_get_fragment(const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              211,
              15
            ],
            [
              211,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_get_fragment",
            "parameters": {
              "uri": "ares_uri_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_uri_parse_buf(ares_uri_t **out, ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              221,
              15
            ],
            [
              221,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse_buf",
            "parameters": {
              "out": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_parse(ares_uri_t **out, const char *uri)",
          "fn_dec_pos": [
            [
              229,
              15
            ],
            [
              229,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_parse",
            "parameters": {
              "out": "ares_uri_t",
              "uri": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_write(char **out, const ares_uri_t *uri)",
          "fn_dec_pos": [
            [
              238,
              15
            ],
            [
              238,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write",
            "parameters": {
              "out": "char",
              "uri": "ares_uri_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_uri_write_buf(const ares_uri_t *uri, ares_buf_t *buf)",
          "fn_dec_pos": [
            [
              247,
              15
            ],
            [
              247,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_uri_write_buf",
            "parameters": {
              "uri": "ares_uri_t",
              "buf": "ares_buf_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_uri",
          {},
          "",
          [
            42,
            0
          ],
          [
            42,
            15
          ]
        ],
        [
          "typedef struct ares_uri ares_uri_t;",
          {},
          "ares_uri_t",
          [
            45,
            0
          ],
          [
            45,
            35
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_threads.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_thread_mutex_create(void)",
          "fn_dec_pos": [
            [
              31,
              33
            ],
            [
              31,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_mutex_destroy(ares_thread_mutex_t *mut)",
          "fn_dec_pos": [
            [
              32,
              5
            ],
            [
              32,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_destroy",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_mutex_lock(ares_thread_mutex_t *mut)",
          "fn_dec_pos": [
            [
              33,
              5
            ],
            [
              33,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_lock",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_mutex_unlock(ares_thread_mutex_t *mut)",
          "fn_dec_pos": [
            [
              34,
              5
            ],
            [
              34,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_mutex_unlock",
            "parameters": {
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_cond_create(void)",
          "fn_dec_pos": [
            [
              40,
              32
            ],
            [
              40,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_cond_destroy(ares_thread_cond_t *cond)",
          "fn_dec_pos": [
            [
              41,
              14
            ],
            [
              41,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_destroy",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_cond_signal(ares_thread_cond_t *cond)",
          "fn_dec_pos": [
            [
              42,
              14
            ],
            [
              42,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_signal",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_cond_broadcast(ares_thread_cond_t *cond)",
          "fn_dec_pos": [
            [
              43,
              14
            ],
            [
              43,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_broadcast",
            "parameters": {
              "cond": "ares_thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_thread_cond_wait(ares_thread_cond_t  *cond,\n                                    ares_thread_mutex_t *mut)",
          "fn_dec_pos": [
            [
              44,
              14
            ],
            [
              45,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_wait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_thread_cond_timedwait(ares_thread_cond_t  *cond,\n                                         ares_thread_mutex_t *mut,\n                                         size_t               timeout_ms)",
          "fn_dec_pos": [
            [
              48,
              14
            ],
            [
              50,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_cond_timedwait",
            "parameters": {
              "cond": "ares_thread_cond_t",
              "mut": "ares_thread_mutex_t",
              "timeout_ms": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "(*ares_thread_func_t)(void *arg)",
          "fn_dec_pos": [
            [
              56,
              14
            ],
            [
              56,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_thread_create(ares_thread_t    **thread,\n                                 ares_thread_func_t func, void *arg)",
          "fn_dec_pos": [
            [
              57,
              14
            ],
            [
              58,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_create",
            "parameters": {
              "thread": "ares_thread_t",
              "func": "ares_thread_func_t",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_thread_join(ares_thread_t *thread, void **rv)",
          "fn_dec_pos": [
            [
              59,
              14
            ],
            [
              59,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_thread_join",
            "parameters": {
              "thread": "ares_thread_t",
              "rv": "void"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_thread_mutex",
          {},
          "",
          [
            28,
            0
          ],
          [
            28,
            24
          ]
        ],
        [
          "typedef struct ares_thread_mutex ares_thread_mutex_t;",
          {},
          "ares_thread_mutex_t",
          [
            29,
            0
          ],
          [
            29,
            53
          ]
        ],
        [
          "struct ares_thread_cond",
          {},
          "",
          [
            37,
            0
          ],
          [
            37,
            23
          ]
        ],
        [
          "typedef struct ares_thread_cond ares_thread_cond_t;",
          {},
          "ares_thread_cond_t",
          [
            38,
            0
          ],
          [
            38,
            51
          ]
        ],
        [
          "struct ares_thread",
          {},
          "",
          [
            53,
            0
          ],
          [
            53,
            18
          ]
        ],
        [
          "typedef struct ares_thread ares_thread_t;",
          {},
          "ares_thread_t",
          [
            54,
            0
          ],
          [
            54,
            41
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_math.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_is_64bit(void)",
          "fn_dec_pos": [
            [
              44,
              14
            ],
            [
              44,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_is_64bit",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_round_up_pow2(size_t n)",
          "fn_dec_pos": [
            [
              45,
              14
            ],
            [
              45,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_round_up_pow2",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_log2(size_t n)",
          "fn_dec_pos": [
            [
              46,
              14
            ],
            [
              46,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_log2",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_pow(size_t x, size_t y)",
          "fn_dec_pos": [
            [
              47,
              14
            ],
            [
              47,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pow",
            "parameters": {
              "x": "size_t",
              "y": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_count_digits(size_t n)",
          "fn_dec_pos": [
            [
              48,
              14
            ],
            [
              48,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_count_digits",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_count_hexdigits(size_t n)",
          "fn_dec_pos": [
            [
              49,
              14
            ],
            [
              49,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_count_hexdigits",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_count_bits_u8(unsigned char x)",
          "fn_dec_pos": [
            [
              50,
              14
            ],
            [
              50,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_count_bits_u8",
            "parameters": {
              "x": "unsigned char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_iface_ips.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_iface_ips_destroy(ares_iface_ips_t *ips)",
          "fn_dec_pos": [
            [
              55,
              30
            ],
            [
              55,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_destroy",
            "parameters": {
              "ips": "ares_iface_ips_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_iface_ips(ares_iface_ips_t    **ips,\n                                             ares_iface_ip_flags_t flags, const char *name)",
          "fn_dec_pos": [
            [
              65,
              30
            ],
            [
              66,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "flags": "ares_iface_ip_flags_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_iface_ips_cnt(const ares_iface_ips_t *ips)",
          "fn_dec_pos": [
            [
              73,
              30
            ],
            [
              73,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_cnt",
            "parameters": {
              "ips": "ares_iface_ips_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_iface_ips_get_name(const ares_iface_ips_t *ips, size_t idx)",
          "fn_dec_pos": [
            [
              81,
              12
            ],
            [
              81,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_name",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_iface_ips_get_addr(const ares_iface_ips_t *ips,\n                                                size_t                  idx)",
          "fn_dec_pos": [
            [
              89,
              24
            ],
            [
              90,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_addr",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_iface_ips_get_flags(const ares_iface_ips_t *ips,\n                                                 size_t                  idx)",
          "fn_dec_pos": [
            [
              98,
              24
            ],
            [
              99,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_flags",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": "ares_iface_ip_flags_t"
          }
        },
        {
          "fn_code": "ares_iface_ips_get_netmask(const ares_iface_ips_t *ips,\n                                                   size_t                  idx)",
          "fn_dec_pos": [
            [
              107,
              24
            ],
            [
              108,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_netmask",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_iface_ips_get_ll_scope(const ares_iface_ips_t *ips,\n                                                    size_t                  idx)",
          "fn_dec_pos": [
            [
              116,
              24
            ],
            [
              117,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iface_ips_get_ll_scope",
            "parameters": {
              "ips": "ares_iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_os_if_nametoindex(const char *name)",
          "fn_dec_pos": [
            [
              126,
              24
            ],
            [
              126,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_os_if_nametoindex",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_os_if_indextoname(unsigned int index, char *name,\n                                               size_t name_len)",
          "fn_dec_pos": [
            [
              135,
              24
            ],
            [
              136,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_os_if_indextoname",
            "parameters": {
              "index": "unsigned int",
              "name": "char",
              "name_len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_iface_ips",
          {},
          "",
          [
            46,
            0
          ],
          [
            46,
            21
          ]
        ],
        [
          "typedef struct ares_iface_ips ares_iface_ips_t;",
          {},
          "ares_iface_ips_t",
          [
            49,
            0
          ],
          [
            49,
            47
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            89,
            6
          ],
          [
            89,
            22
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_IFACE_IP_V4 = 1 << 0,        /*!< IPv4 address. During enumeration if\n                                     *   this flag is set ARES_IFACE_IP_V6\n                                     *   is not, will only enumerate v4\n                                     *   addresses. */\n  ARES_IFACE_IP_V6 = 1 << 1,        /*!< IPv6 address. During enumeration if\n                                     *   this flag is set ARES_IFACE_IP_V4\n                                     *   is not, will only enumerate v6\n                                     *   addresses. */\n  ARES_IFACE_IP_LOOPBACK  = 1 << 2, /*!< Loopback adapter */\n  ARES_IFACE_IP_OFFLINE   = 1 << 3, /*!< Adapter offline */\n  ARES_IFACE_IP_LINKLOCAL = 1 << 4, /*!< Link-local ip address */\n  /*! Default, enumerate all ips for online interfaces, including loopback */\n  ARES_IFACE_IP_DEFAULT = (ARES_IFACE_IP_V4 | ARES_IFACE_IP_V6 |\n                           ARES_IFACE_IP_LOOPBACK | ARES_IFACE_IP_LINKLOCAL)\n} ares_iface_ip_flags_t;",
          {
            "ARES_IFACE_IP_V4": "",
            "ARES_IFACE_IP_V6": "",
            "ARES_IFACE_IP_LOOPBACK": "",
            "ARES_IFACE_IP_OFFLINE": "",
            "ARES_IFACE_IP_LINKLOCAL": "",
            "ARES_IFACE_IP_DEFAULT": ""
          },
          "ares_iface_ip_flags_t",
          [
            29,
            0
          ],
          [
            44,
            24
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_time.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_timedout(const ares_timeval_t *now,\n                          const ares_timeval_t *check)",
          "fn_dec_pos": [
            [
              37,
              12
            ],
            [
              38,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timedout",
            "parameters": {
              "now": "ares_timeval_t",
              "check": "ares_timeval_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_tvnow(ares_timeval_t *now)",
          "fn_dec_pos": [
            [
              40,
              12
            ],
            [
              40,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_tvnow",
            "parameters": {
              "now": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_timeval_remaining(ares_timeval_t       *remaining,\n                                   const ares_timeval_t *now,\n                                   const ares_timeval_t *tout)",
          "fn_dec_pos": [
            [
              41,
              12
            ],
            [
              43,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeval_remaining",
            "parameters": {
              "remaining": "ares_timeval_t",
              "now": "ares_timeval_t",
              "tout": "ares_timeval_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_timeval_diff(ares_timeval_t *tvdiff, const ares_timeval_t *tvstart,\n                       const ares_timeval_t *tvstop)",
          "fn_dec_pos": [
            [
              44,
              5
            ],
            [
              45,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeval_diff",
            "parameters": {
              "tvdiff": "ares_timeval_t",
              "tvstart": "ares_timeval_t",
              "tvstop": "ares_timeval_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  ares_int64_t sec;  /*!< Seconds */\n  unsigned int usec; /*!< Microseconds. Can't be negative. */\n} ares_timeval_t;",
          {
            "sec": "ares_int64_t",
            "usec": "unsigned int"
          },
          "ares_timeval_t",
          [
            31,
            0
          ],
          [
            34,
            17
          ]
        ],
        [
          "typedef struct {\n  ares_int64_t sec;  /*!< Seconds */\n  unsigned int usec; /*!< Microseconds. Can't be negative. */\n} ares_timeval_t;",
          {
            "sec": "ares_int64_t",
            "usec": "unsigned int"
          },
          "ares_timeval_t",
          [
            31,
            0
          ],
          [
            34,
            17
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/util/ares_rand.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_init_rand_state(void)",
          "fn_dec_pos": [
            [
              31,
              31
            ],
            [
              31,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_rand_state",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_destroy_rand_state(ares_rand_state *state)",
          "fn_dec_pos": [
            [
              32,
              31
            ],
            [
              32,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_rand_state",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_rand_bytes(ares_rand_state *state, unsigned char *buf, size_t len)",
          "fn_dec_pos": [
            [
              33,
              5
            ],
            [
              33,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rand_bytes",
            "parameters": {
              "state": "ares_rand_state",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_rand_state",
          {},
          "",
          [
            28,
            0
          ],
          [
            28,
            22
          ]
        ],
        [
          "typedef struct ares_rand_state ares_rand_state;",
          {},
          "ares_rand_state",
          [
            29,
            0
          ],
          [
            29,
            47
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/str/ares_strsplit.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_strsplit(const char *in, const char *delms, size_t *num_elm)",
          "fn_dec_pos": [
            [
              42,
              7
            ],
            [
              42,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strsplit",
            "parameters": {
              "in": "char",
              "delms": "char",
              "num_elm": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_strsplit_free(char **elms, size_t num_elm)",
          "fn_dec_pos": [
            [
              45,
              7
            ],
            [
              45,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strsplit_free",
            "parameters": {
              "elms": "char",
              "num_elm": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_strsplit_duplicate(char **elms, size_t num_elm)",
          "fn_dec_pos": [
            [
              48,
              7
            ],
            [
              48,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strsplit_duplicate",
            "parameters": {
              "elms": "char",
              "num_elm": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_event_cb_t)(ares_event_thread_t *e, ares_socket_t fd,\n                                void *data, ares_event_flags_t flags)",
          "fn_dec_pos": [
            [
              38,
              13
            ],
            [
              39,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_event_free_data_t)(void *data)",
          "fn_dec_pos": [
            [
              41,
              13
            ],
            [
              41,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_event_signal_cb_t)(const ares_event_t *event)",
          "fn_dec_pos": [
            [
              43,
              13
            ],
            [
              43,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*init)(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              71,
              14
            ],
            [
              71,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "(*destroy)(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              72,
              7
            ],
            [
              72,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*event_add)(ares_event_t *event)",
          "fn_dec_pos": [
            [
              73,
              14
            ],
            [
              73,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "(*event_del)(ares_event_t *event)",
          "fn_dec_pos": [
            [
              74,
              7
            ],
            [
              74,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*event_mod)(ares_event_t *event, ares_event_flags_t new_flags)",
          "fn_dec_pos": [
            [
              75,
              7
            ],
            [
              75,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*wait)(ares_event_thread_t *e, unsigned long timeout_ms)",
          "fn_dec_pos": [
            [
              76,
              9
            ],
            [
              76,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_event_configchg_init(ares_event_configchg_t **configchg,\n                                        ares_event_thread_t     *e)",
          "fn_dec_pos": [
            [
              82,
              14
            ],
            [
              83,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_init",
            "parameters": {
              "configchg": "ares_event_configchg_t",
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_event_configchg_destroy(ares_event_configchg_t *configchg)",
          "fn_dec_pos": [
            [
              85,
              14
            ],
            [
              85,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_configchg_destroy",
            "parameters": {
              "configchg": "ares_event_configchg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_event_update(ares_event_t **event, ares_event_thread_t *e,\n                                ares_event_flags_t flags, ares_event_cb_t cb,\n                                ares_socket_t fd, void *data,\n                                ares_event_free_data_t free_data_cb,\n                                ares_event_signal_cb_t signal_cb)",
          "fn_dec_pos": [
            [
              154,
              14
            ],
            [
              158,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_update",
            "parameters": {
              "event": "ares_event_t",
              "e": "ares_event_thread_t",
              "flags": "ares_event_flags_t",
              "cb": "ares_event_cb_t",
              "fd": "ares_socket_t",
              "data": "void",
              "free_data_cb": "ares_event_free_data_t",
              "signal_cb": "ares_event_signal_cb_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_pipeevent_create(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              163,
              14
            ],
            [
              163,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_event {\n  /*! Registered event thread this event is bound to */\n  ares_event_thread_t   *e;\n  /*! Flags to monitor. OTHER is only allowed if the socket is ARES_SOCKET_BAD.\n   */\n  ares_event_flags_t     flags;\n  /*! Callback to be called when event is triggered */\n  ares_event_cb_t        cb;\n  /*! Socket to monitor, allowed to be ARES_SOCKET_BAD if not monitoring a\n   *  socket. */\n  ares_socket_t          fd;\n  /*! Data associated with event handle that will be passed to the callback.\n   *  Typically OS/event subsystem specific data.\n   *  Optional, may be NULL. */\n  /*! Data to be passed to callback. Optional, may be NULL. */\n  void                  *data;\n  /*! When cleaning up the registered event (either when removed or during\n   *  shutdown), this function will be called to clean up the user-supplied\n   *  data. Optional, May be NULL. */\n  ares_event_free_data_t free_data_cb;\n  /*! Callback to call to trigger an event. */\n  ares_event_signal_cb_t signal_cb;\n}",
          {
            "*e": "ares_event_thread_t",
            "flags": "ares_event_flags_t",
            "cb": "ares_event_cb_t",
            "fd": "ares_socket_t",
            "*data": "void",
            "free_data_cb": "ares_event_free_data_t",
            "signal_cb": "ares_event_signal_cb_t"
          },
          "ares_event",
          [
            45,
            0
          ],
          [
            67,
            1
          ]
        ],
        [
          "typedef struct {\n  const char *name;\n  ares_bool_t (*init)(ares_event_thread_t *e);\n  void (*destroy)(ares_event_thread_t *e);\n  ares_bool_t (*event_add)(ares_event_t *event);\n  void (*event_del)(ares_event_t *event);\n  void (*event_mod)(ares_event_t *event, ares_event_flags_t new_flags);\n  size_t (*wait)(ares_event_thread_t *e, unsigned long timeout_ms);\n} ares_event_sys_t;",
          {
            "char": "const",
            "(*init)(ares_event_thread_t *e)": "ares_bool_t",
            "(*destroy)(ares_event_thread_t *e)": "void",
            "(*event_add)(ares_event_t *event)": "ares_bool_t",
            "(*event_del)(ares_event_t *event)": "void",
            "(*event_mod)(ares_event_t *event, ares_event_flags_t new_flags)": "void",
            "(*wait)(ares_event_thread_t *e, unsigned long timeout_ms)": "size_t"
          },
          "ares_event_sys_t",
          [
            69,
            0
          ],
          [
            77,
            19
          ]
        ],
        [
          "struct ares_event_thread {\n  /*! Whether the event thread should be online or not.  Checked on every wake\n   *  event before sleeping. */\n  ares_bool_t             isup;\n  /*! Handle to the thread for joining during shutdown */\n  ares_thread_t          *thread;\n  /*! Lock to protect the data contained within the event thread itself */\n  ares_thread_mutex_t    *mutex;\n  /*! Reference to the ares channel, for being able to call things like\n   *  ares_timeout() and ares_process_fd(). */\n  ares_channel_t         *channel;\n  /*! Whether or not on the next loop we should process a pending write */\n  ares_bool_t             process_pending_write;\n  /*! Not-yet-processed event handle updates.  These will get enqueued by a\n   *  thread other than the event thread itself. The event thread will then\n   *  be woken then process these updates itself */\n  ares_llist_t           *ev_updates;\n  /*! Registered socket event handles */\n  ares_htable_asvp_t     *ev_sock_handles;\n  /*! Registered custom event handles. Typically used for external triggering.\n   */\n  ares_htable_vpvp_t     *ev_cust_handles;\n  /*! Pointer to the event handle which is used to signal and wake the event\n   *  thread itself.  This is needed to be able to do things like update the\n   *  file descriptors being waited on and to wake the event subsystem during\n   *  shutdown */\n  ares_event_t           *ev_signal;\n  /*! Handle for configuration change monitoring */\n  ares_event_configchg_t *configchg;\n  /* Event subsystem callbacks */\n  const ares_event_sys_t *ev_sys;\n  /* Event subsystem private data */\n  void                   *ev_sys_data;\n}",
          {
            "isup": "ares_bool_t",
            "*thread": "ares_thread_t",
            "*mutex": "ares_thread_mutex_t",
            "*channel": "ares_channel_t",
            "process_pending_write": "ares_bool_t",
            "*ev_updates": "ares_llist_t",
            "*ev_sock_handles": "ares_htable_asvp_t",
            "*ev_cust_handles": "ares_htable_vpvp_t",
            "*ev_signal": "ares_event_t",
            "*configchg": "ares_event_configchg_t",
            "ares_event_sys_t": "const",
            "*ev_sys_data": "void"
          },
          "ares_event_thread",
          [
            87,
            0
          ],
          [
            120,
            1
          ]
        ],
        [
          "struct ares_event",
          {},
          "",
          [
            28,
            0
          ],
          [
            28,
            17
          ]
        ],
        [
          "typedef struct ares_event ares_event_t;",
          {},
          "ares_event_t",
          [
            29,
            0
          ],
          [
            29,
            39
          ]
        ],
        [
          "struct ares_event {\n  /*! Registered event thread this event is bound to */\n  ares_event_thread_t   *e;\n  /*! Flags to monitor. OTHER is only allowed if the socket is ARES_SOCKET_BAD.\n   */\n  ares_event_flags_t     flags;\n  /*! Callback to be called when event is triggered */\n  ares_event_cb_t        cb;\n  /*! Socket to monitor, allowed to be ARES_SOCKET_BAD if not monitoring a\n   *  socket. */\n  ares_socket_t          fd;\n  /*! Data associated with event handle that will be passed to the callback.\n   *  Typically OS/event subsystem specific data.\n   *  Optional, may be NULL. */\n  /*! Data to be passed to callback. Optional, may be NULL. */\n  void                  *data;\n  /*! When cleaning up the registered event (either when removed or during\n   *  shutdown), this function will be called to clean up the user-supplied\n   *  data. Optional, May be NULL. */\n  ares_event_free_data_t free_data_cb;\n  /*! Callback to call to trigger an event. */\n  ares_event_signal_cb_t signal_cb;\n}",
          {
            "*e": "ares_event_thread_t",
            "flags": "ares_event_flags_t",
            "cb": "ares_event_cb_t",
            "fd": "ares_socket_t",
            "*data": "void",
            "free_data_cb": "ares_event_free_data_t",
            "signal_cb": "ares_event_signal_cb_t"
          },
          "ares_event",
          [
            45,
            0
          ],
          [
            67,
            1
          ]
        ],
        [
          "typedef struct {\n  const char *name;\n  ares_bool_t (*init)(ares_event_thread_t *e);\n  void (*destroy)(ares_event_thread_t *e);\n  ares_bool_t (*event_add)(ares_event_t *event);\n  void (*event_del)(ares_event_t *event);\n  void (*event_mod)(ares_event_t *event, ares_event_flags_t new_flags);\n  size_t (*wait)(ares_event_thread_t *e, unsigned long timeout_ms);\n} ares_event_sys_t;",
          {
            "char": "const",
            "(*init)(ares_event_thread_t *e)": "ares_bool_t",
            "(*destroy)(ares_event_thread_t *e)": "void",
            "(*event_add)(ares_event_t *event)": "ares_bool_t",
            "(*event_del)(ares_event_t *event)": "void",
            "(*event_mod)(ares_event_t *event, ares_event_flags_t new_flags)": "void",
            "(*wait)(ares_event_thread_t *e, unsigned long timeout_ms)": "size_t"
          },
          "ares_event_sys_t",
          [
            69,
            0
          ],
          [
            77,
            19
          ]
        ],
        [
          "struct ares_event_configchg",
          {},
          "",
          [
            79,
            0
          ],
          [
            79,
            27
          ]
        ],
        [
          "typedef struct ares_event_configchg ares_event_configchg_t;",
          {},
          "ares_event_configchg_t",
          [
            80,
            0
          ],
          [
            80,
            59
          ]
        ],
        [
          "struct ares_event_thread {\n  /*! Whether the event thread should be online or not.  Checked on every wake\n   *  event before sleeping. */\n  ares_bool_t             isup;\n  /*! Handle to the thread for joining during shutdown */\n  ares_thread_t          *thread;\n  /*! Lock to protect the data contained within the event thread itself */\n  ares_thread_mutex_t    *mutex;\n  /*! Reference to the ares channel, for being able to call things like\n   *  ares_timeout() and ares_process_fd(). */\n  ares_channel_t         *channel;\n  /*! Whether or not on the next loop we should process a pending write */\n  ares_bool_t             process_pending_write;\n  /*! Not-yet-processed event handle updates.  These will get enqueued by a\n   *  thread other than the event thread itself. The event thread will then\n   *  be woken then process these updates itself */\n  ares_llist_t           *ev_updates;\n  /*! Registered socket event handles */\n  ares_htable_asvp_t     *ev_sock_handles;\n  /*! Registered custom event handles. Typically used for external triggering.\n   */\n  ares_htable_vpvp_t     *ev_cust_handles;\n  /*! Pointer to the event handle which is used to signal and wake the event\n   *  thread itself.  This is needed to be able to do things like update the\n   *  file descriptors being waited on and to wake the event subsystem during\n   *  shutdown */\n  ares_event_t           *ev_signal;\n  /*! Handle for configuration change monitoring */\n  ares_event_configchg_t *configchg;\n  /* Event subsystem callbacks */\n  const ares_event_sys_t *ev_sys;\n  /* Event subsystem private data */\n  void                   *ev_sys_data;\n}",
          {
            "isup": "ares_bool_t",
            "*thread": "ares_thread_t",
            "*mutex": "ares_thread_mutex_t",
            "*channel": "ares_channel_t",
            "process_pending_write": "ares_bool_t",
            "*ev_updates": "ares_llist_t",
            "*ev_sock_handles": "ares_htable_asvp_t",
            "*ev_cust_handles": "ares_htable_vpvp_t",
            "*ev_signal": "ares_event_t",
            "*configchg": "ares_event_configchg_t",
            "ares_event_sys_t": "const",
            "*ev_sys_data": "void"
          },
          "ares_event_thread",
          [
            87,
            0
          ],
          [
            120,
            1
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_EVENT_FLAG_NONE  = 0,\n  ARES_EVENT_FLAG_READ  = 1 << 0,\n  ARES_EVENT_FLAG_WRITE = 1 << 1,\n  ARES_EVENT_FLAG_OTHER = 1 << 2\n} ares_event_flags_t;",
          {
            "ARES_EVENT_FLAG_NONE": "",
            "ARES_EVENT_FLAG_READ": "",
            "ARES_EVENT_FLAG_WRITE": "",
            "ARES_EVENT_FLAG_OTHER": ""
          },
          "ares_event_flags_t",
          [
            31,
            0
          ],
          [
            36,
            21
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/lib/event/ares_event_win32.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(NTAPI *PIO_APC_ROUTINE)(PVOID            ApcContext,\n                                     PIO_STATUS_BLOCK IoStatusBlock,\n                                     ULONG            Reserved)",
          "fn_dec_pos": [
            [
              57,
              12
            ],
            [
              59,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ApcContext": "PVOID",
              "IoStatusBlock": "PIO_STATUS_BLOCK",
              "Reserved": "ULONG"
            },
            "return_type": "VOID"
          }
        },
        {
          "fn_code": "(NTAPI *NtCancelIoFileEx_t)(HANDLE           FileHandle,\n                                            PIO_STATUS_BLOCK IoRequestToCancel,\n                                            PIO_STATUS_BLOCK IoStatusBlock)",
          "fn_dec_pos": [
            [
              131,
              16
            ],
            [
              133,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "FileHandle": "HANDLE",
              "IoRequestToCancel": "PIO_STATUS_BLOCK",
              "IoStatusBlock": "PIO_STATUS_BLOCK"
            },
            "return_type": "NTSTATUS"
          }
        },
        {
          "fn_code": "(NTAPI *NtDeviceIoControlFile_t)(\n  HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext,\n  PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer,\n  ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength)",
          "fn_dec_pos": [
            [
              134,
              16
            ],
            [
              137,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "FileHandle": "HANDLE",
              "Event": "HANDLE",
              "ApcRoutine": "PIO_APC_ROUTINE",
              "ApcContext": "PVOID",
              "IoStatusBlock": "PIO_STATUS_BLOCK",
              "IoControlCode": "ULONG",
              "InputBuffer": "PVOID",
              "InputBufferLength": "ULONG",
              "OutputBuffer": "PVOID",
              "OutputBufferLength": "ULONG"
            },
            "return_type": "NTSTATUS"
          }
        },
        {
          "fn_code": "(NTAPI *NtCreateFile_t)(\n  PHANDLE FileHandle, ACCESS_MASK DesiredAccess,\n  POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,\n  PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess,\n  ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength)",
          "fn_dec_pos": [
            [
              139,
              16
            ],
            [
              143,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "FileHandle": "PHANDLE",
              "DesiredAccess": "ACCESS_MASK",
              "ObjectAttributes": "POBJECT_ATTRIBUTES",
              "IoStatusBlock": "PIO_STATUS_BLOCK",
              "AllocationSize": "PLARGE_INTEGER",
              "FileAttributes": "ULONG",
              "ShareAccess": "ULONG",
              "CreateDisposition": "ULONG",
              "CreateOptions": "ULONG",
              "EaBuffer": "PVOID",
              "EaLength": "ULONG"
            },
            "return_type": "NTSTATUS"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _IO_STATUS_BLOCK {\n  union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  };\n\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;",
          {
            ";": "union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  }",
            "Status": "NTSTATUS",
            "Pointer": "PVOID",
            "Information": "ULONG_PTR"
          },
          "IO_STATUS_BLOCK",
          [
            48,
            0
          ],
          [
            55,
            37
          ]
        ],
        [
          "typedef struct _IO_STATUS_BLOCK {\n  union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  };\n\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;",
          {
            ";": "union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  }",
            "Status": "NTSTATUS",
            "Pointer": "PVOID",
            "Information": "ULONG_PTR"
          },
          "PIO_STATUS_BLOCK",
          [
            48,
            0
          ],
          [
            55,
            37
          ]
        ],
        [
          "typedef struct _UNICODE_STRING {\n  USHORT  Length;\n  USHORT  MaximumLength;\n  LPCWSTR Buffer;\n} UNICODE_STRING, *PUNICODE_STRING;",
          {
            "Length": "USHORT",
            "MaximumLength": "USHORT",
            "Buffer": "LPCWSTR"
          },
          "UNICODE_STRING",
          [
            69,
            0
          ],
          [
            73,
            35
          ]
        ],
        [
          "typedef struct _UNICODE_STRING {\n  USHORT  Length;\n  USHORT  MaximumLength;\n  LPCWSTR Buffer;\n} UNICODE_STRING, *PUNICODE_STRING;",
          {
            "Length": "USHORT",
            "MaximumLength": "USHORT",
            "Buffer": "LPCWSTR"
          },
          "PUNICODE_STRING",
          [
            69,
            0
          ],
          [
            73,
            35
          ]
        ],
        [
          "typedef struct _OBJECT_ATTRIBUTES {\n  ULONG           Length;\n  HANDLE          RootDirectory;\n  PUNICODE_STRING ObjectName;\n  ULONG           Attributes;\n  PVOID           SecurityDescriptor;\n  PVOID           SecurityQualityOfService;\n} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;",
          {
            "Length": "ULONG",
            "RootDirectory": "HANDLE",
            "ObjectName": "PUNICODE_STRING",
            "Attributes": "ULONG",
            "SecurityDescriptor": "PVOID",
            "SecurityQualityOfService": "PVOID"
          },
          "OBJECT_ATTRIBUTES",
          [
            75,
            0
          ],
          [
            82,
            41
          ]
        ],
        [
          "typedef struct _OBJECT_ATTRIBUTES {\n  ULONG           Length;\n  HANDLE          RootDirectory;\n  PUNICODE_STRING ObjectName;\n  ULONG           Attributes;\n  PVOID           SecurityDescriptor;\n  PVOID           SecurityQualityOfService;\n} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;",
          {
            "Length": "ULONG",
            "RootDirectory": "HANDLE",
            "ObjectName": "PUNICODE_STRING",
            "Attributes": "ULONG",
            "SecurityDescriptor": "PVOID",
            "SecurityQualityOfService": "PVOID"
          },
          "POBJECT_ATTRIBUTES",
          [
            75,
            0
          ],
          [
            82,
            41
          ]
        ],
        [
          "typedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE   Handle;\n  ULONG    Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;",
          {
            "Handle": "HANDLE",
            "Events": "ULONG",
            "Status": "NTSTATUS"
          },
          "AFD_POLL_HANDLE_INFO",
          [
            117,
            0
          ],
          [
            121,
            47
          ]
        ],
        [
          "typedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE   Handle;\n  ULONG    Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;",
          {
            "Handle": "HANDLE",
            "Events": "ULONG",
            "Status": "NTSTATUS"
          },
          "PAFD_POLL_HANDLE_INFO",
          [
            117,
            0
          ],
          [
            121,
            47
          ]
        ],
        [
          "typedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER        Timeout;\n  ULONG                NumberOfHandles;\n  ULONG                Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;",
          {
            "Timeout": "LARGE_INTEGER",
            "NumberOfHandles": "ULONG",
            "Exclusive": "ULONG",
            "Handles[1]": "AFD_POLL_HANDLE_INFO"
          },
          "AFD_POLL_INFO",
          [
            123,
            0
          ],
          [
            128,
            33
          ]
        ],
        [
          "typedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER        Timeout;\n  ULONG                NumberOfHandles;\n  ULONG                Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;",
          {
            "Timeout": "LARGE_INTEGER",
            "NumberOfHandles": "ULONG",
            "Exclusive": "ULONG",
            "Handles[1]": "AFD_POLL_HANDLE_INFO"
          },
          "PAFD_POLL_INFO",
          [
            123,
            0
          ],
          [
            128,
            33
          ]
        ],
        [
          "typedef struct _OVERLAPPED_ENTRY {\n  ULONG_PTR    lpCompletionKey;\n  LPOVERLAPPED lpOverlapped;\n  ULONG_PTR    Internal;\n  DWORD        dwNumberOfBytesTransferred;\n} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;",
          {
            "lpCompletionKey": "ULONG_PTR",
            "lpOverlapped": "LPOVERLAPPED",
            "Internal": "ULONG_PTR",
            "dwNumberOfBytesTransferred": "DWORD"
          },
          "OVERLAPPED_ENTRY",
          [
            160,
            0
          ],
          [
            165,
            40
          ]
        ],
        [
          "typedef struct _OVERLAPPED_ENTRY {\n  ULONG_PTR    lpCompletionKey;\n  LPOVERLAPPED lpOverlapped;\n  ULONG_PTR    Internal;\n  DWORD        dwNumberOfBytesTransferred;\n} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;",
          {
            "lpCompletionKey": "ULONG_PTR",
            "lpOverlapped": "LPOVERLAPPED",
            "Internal": "ULONG_PTR",
            "dwNumberOfBytesTransferred": "DWORD"
          },
          "LPOVERLAPPED_ENTRY",
          [
            160,
            0
          ],
          [
            165,
            40
          ]
        ],
        [
          "typedef struct _IO_STATUS_BLOCK {\n  union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  };\n\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;",
          {
            ";": "union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  }",
            "Status": "NTSTATUS",
            "Pointer": "PVOID",
            "Information": "ULONG_PTR"
          },
          "IO_STATUS_BLOCK",
          [
            48,
            0
          ],
          [
            55,
            37
          ]
        ],
        [
          "typedef struct _IO_STATUS_BLOCK {\n  union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  };\n\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;",
          {
            ";": "union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  }",
            "Status": "NTSTATUS",
            "Pointer": "PVOID",
            "Information": "ULONG_PTR"
          },
          "PIO_STATUS_BLOCK",
          [
            48,
            0
          ],
          [
            55,
            37
          ]
        ],
        [
          "typedef struct _UNICODE_STRING {\n  USHORT  Length;\n  USHORT  MaximumLength;\n  LPCWSTR Buffer;\n} UNICODE_STRING, *PUNICODE_STRING;",
          {
            "Length": "USHORT",
            "MaximumLength": "USHORT",
            "Buffer": "LPCWSTR"
          },
          "UNICODE_STRING",
          [
            69,
            0
          ],
          [
            73,
            35
          ]
        ],
        [
          "typedef struct _UNICODE_STRING {\n  USHORT  Length;\n  USHORT  MaximumLength;\n  LPCWSTR Buffer;\n} UNICODE_STRING, *PUNICODE_STRING;",
          {
            "Length": "USHORT",
            "MaximumLength": "USHORT",
            "Buffer": "LPCWSTR"
          },
          "PUNICODE_STRING",
          [
            69,
            0
          ],
          [
            73,
            35
          ]
        ],
        [
          "typedef struct _OBJECT_ATTRIBUTES {\n  ULONG           Length;\n  HANDLE          RootDirectory;\n  PUNICODE_STRING ObjectName;\n  ULONG           Attributes;\n  PVOID           SecurityDescriptor;\n  PVOID           SecurityQualityOfService;\n} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;",
          {
            "Length": "ULONG",
            "RootDirectory": "HANDLE",
            "ObjectName": "PUNICODE_STRING",
            "Attributes": "ULONG",
            "SecurityDescriptor": "PVOID",
            "SecurityQualityOfService": "PVOID"
          },
          "OBJECT_ATTRIBUTES",
          [
            75,
            0
          ],
          [
            82,
            41
          ]
        ],
        [
          "typedef struct _OBJECT_ATTRIBUTES {\n  ULONG           Length;\n  HANDLE          RootDirectory;\n  PUNICODE_STRING ObjectName;\n  ULONG           Attributes;\n  PVOID           SecurityDescriptor;\n  PVOID           SecurityQualityOfService;\n} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;",
          {
            "Length": "ULONG",
            "RootDirectory": "HANDLE",
            "ObjectName": "PUNICODE_STRING",
            "Attributes": "ULONG",
            "SecurityDescriptor": "PVOID",
            "SecurityQualityOfService": "PVOID"
          },
          "POBJECT_ATTRIBUTES",
          [
            75,
            0
          ],
          [
            82,
            41
          ]
        ],
        [
          "typedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE   Handle;\n  ULONG    Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;",
          {
            "Handle": "HANDLE",
            "Events": "ULONG",
            "Status": "NTSTATUS"
          },
          "AFD_POLL_HANDLE_INFO",
          [
            117,
            0
          ],
          [
            121,
            47
          ]
        ],
        [
          "typedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE   Handle;\n  ULONG    Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;",
          {
            "Handle": "HANDLE",
            "Events": "ULONG",
            "Status": "NTSTATUS"
          },
          "PAFD_POLL_HANDLE_INFO",
          [
            117,
            0
          ],
          [
            121,
            47
          ]
        ],
        [
          "typedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER        Timeout;\n  ULONG                NumberOfHandles;\n  ULONG                Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;",
          {
            "Timeout": "LARGE_INTEGER",
            "NumberOfHandles": "ULONG",
            "Exclusive": "ULONG",
            "Handles[1]": "AFD_POLL_HANDLE_INFO"
          },
          "AFD_POLL_INFO",
          [
            123,
            0
          ],
          [
            128,
            33
          ]
        ],
        [
          "typedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER        Timeout;\n  ULONG                NumberOfHandles;\n  ULONG                Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;",
          {
            "Timeout": "LARGE_INTEGER",
            "NumberOfHandles": "ULONG",
            "Exclusive": "ULONG",
            "Handles[1]": "AFD_POLL_HANDLE_INFO"
          },
          "PAFD_POLL_INFO",
          [
            123,
            0
          ],
          [
            128,
            33
          ]
        ],
        [
          "typedef struct _OVERLAPPED_ENTRY {\n  ULONG_PTR    lpCompletionKey;\n  LPOVERLAPPED lpOverlapped;\n  ULONG_PTR    Internal;\n  DWORD        dwNumberOfBytesTransferred;\n} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;",
          {
            "lpCompletionKey": "ULONG_PTR",
            "lpOverlapped": "LPOVERLAPPED",
            "Internal": "ULONG_PTR",
            "dwNumberOfBytesTransferred": "DWORD"
          },
          "OVERLAPPED_ENTRY",
          [
            160,
            0
          ],
          [
            165,
            40
          ]
        ],
        [
          "typedef struct _OVERLAPPED_ENTRY {\n  ULONG_PTR    lpCompletionKey;\n  LPOVERLAPPED lpOverlapped;\n  ULONG_PTR    Internal;\n  DWORD        dwNumberOfBytesTransferred;\n} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;",
          {
            "lpCompletionKey": "ULONG_PTR",
            "lpOverlapped": "LPOVERLAPPED",
            "Internal": "ULONG_PTR",
            "dwNumberOfBytesTransferred": "DWORD"
          },
          "LPOVERLAPPED_ENTRY",
          [
            160,
            0
          ],
          [
            165,
            40
          ]
        ]
      ],
      "include_list": [
        [
          "#    include <winsock2.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#    include <ws2tcpip.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#    include <mswsock.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#    include <windows.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/tools/ares_getopt.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_getopt_init(ares_getopt_state_t *state, int argc,\n                      const char * const *argv)",
          "fn_dec_pos": [
            [
              45,
              5
            ],
            [
              46,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getopt_init",
            "parameters": {
              "state": "ares_getopt_state_t",
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_getopt(ares_getopt_state_t *state, const char *ostr)",
          "fn_dec_pos": [
            [
              47,
              5
            ],
            [
              47,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getopt",
            "parameters": {
              "state": "ares_getopt_state_t",
              "ostr": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  const char         *optarg; /* argument associated with option */\n  int                 optind; /* index into parent argv vector */\n  int                 opterr; /* if error message should be printed */\n  int                 optopt; /* character checked for validity */\n  const char         *place;\n  int                 argc;\n  const char * const *argv;\n} ares_getopt_state_t;",
          {
            "char": "const",
            "optind": "int",
            "opterr": "int",
            "optopt": "int",
            "argc": "int"
          },
          "ares_getopt_state_t",
          [
            35,
            0
          ],
          [
            43,
            22
          ]
        ],
        [
          "typedef struct {\n  const char         *optarg; /* argument associated with option */\n  int                 optind; /* index into parent argv vector */\n  int                 opterr; /* if error message should be printed */\n  int                 optopt; /* character checked for validity */\n  const char         *place;\n  int                 argc;\n  const char * const *argv;\n} ares_getopt_state_t;",
          {
            "char": "const",
            "optind": "int",
            "opterr": "int",
            "optopt": "int",
            "argc": "int"
          },
          "ares_getopt_state_t",
          [
            35,
            0
          ],
          [
            43,
            22
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/src/tools/Makefile.inc": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/include/ares_nameser.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_build.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <arpa/nameser.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/nameser_compat.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum __ns_class {\n  ns_c_invalid = 0, /* Cookie. */\n  ns_c_in      = 1, /* Internet. */\n  ns_c_2       = 2, /* unallocated/unsupported. */\n  ns_c_chaos   = 3, /* MIT Chaos-net. */\n  ns_c_hs      = 4, /* MIT Hesiod. */\n  /* Query class values which do not appear in resource records */\n  ns_c_none = 254, /* for prereq. sections in update requests */\n  ns_c_any  = 255, /* Wildcard match. */\n  ns_c_max  = 65536\n} ns_class;",
          {
            "ns_c_invalid": "",
            "ns_c_in": "",
            "ns_c_2": "",
            "ns_c_chaos": "",
            "ns_c_hs": "",
            "ns_c_none": "",
            "ns_c_any": "",
            "ns_c_max": ""
          },
          "ns_class",
          [
            100,
            0
          ],
          [
            110,
            11
          ]
        ],
        [
          "typedef enum __ns_type {\n  ns_t_invalid  = 0,   /* Cookie. */\n  ns_t_a        = 1,   /* Host address. */\n  ns_t_ns       = 2,   /* Authoritative server. */\n  ns_t_md       = 3,   /* Mail destination. */\n  ns_t_mf       = 4,   /* Mail forwarder. */\n  ns_t_cname    = 5,   /* Canonical name. */\n  ns_t_soa      = 6,   /* Start of authority zone. */\n  ns_t_mb       = 7,   /* Mailbox domain name. */\n  ns_t_mg       = 8,   /* Mail group member. */\n  ns_t_mr       = 9,   /* Mail rename name. */\n  ns_t_null     = 10,  /* Null resource record. */\n  ns_t_wks      = 11,  /* Well known service. */\n  ns_t_ptr      = 12,  /* Domain name pointer. */\n  ns_t_hinfo    = 13,  /* Host information. */\n  ns_t_minfo    = 14,  /* Mailbox information. */\n  ns_t_mx       = 15,  /* Mail routing information. */\n  ns_t_txt      = 16,  /* Text strings. */\n  ns_t_rp       = 17,  /* Responsible person. */\n  ns_t_afsdb    = 18,  /* AFS cell database. */\n  ns_t_x25      = 19,  /* X_25 calling address. */\n  ns_t_isdn     = 20,  /* ISDN calling address. */\n  ns_t_rt       = 21,  /* Router. */\n  ns_t_nsap     = 22,  /* NSAP address. */\n  ns_t_nsap_ptr = 23,  /* Reverse NSAP lookup (deprecated). */\n  ns_t_sig      = 24,  /* Security signature. */\n  ns_t_key      = 25,  /* Security key. */\n  ns_t_px       = 26,  /* X.400 mail mapping. */\n  ns_t_gpos     = 27,  /* Geographical position (withdrawn). */\n  ns_t_aaaa     = 28,  /* Ip6 Address. */\n  ns_t_loc      = 29,  /* Location Information. */\n  ns_t_nxt      = 30,  /* Next domain (security). */\n  ns_t_eid      = 31,  /* Endpoint identifier. */\n  ns_t_nimloc   = 32,  /* Nimrod Locator. */\n  ns_t_srv      = 33,  /* Server Selection. */\n  ns_t_atma     = 34,  /* ATM Address */\n  ns_t_naptr    = 35,  /* Naming Authority PoinTeR */\n  ns_t_kx       = 36,  /* Key Exchange */\n  ns_t_cert     = 37,  /* Certification record */\n  ns_t_a6       = 38,  /* IPv6 address (deprecates AAAA) */\n  ns_t_dname    = 39,  /* Non-terminal DNAME (for IPv6) */\n  ns_t_sink     = 40,  /* Kitchen sink (experimental) */\n  ns_t_opt      = 41,  /* EDNS0 option (meta-RR) */\n  ns_t_apl      = 42,  /* Address prefix list (RFC3123) */\n  ns_t_ds       = 43,  /* Delegation Signer (RFC4034) */\n  ns_t_sshfp    = 44,  /* SSH Key Fingerprint (RFC4255) */\n  ns_t_rrsig    = 46,  /* Resource Record Signature (RFC4034) */\n  ns_t_nsec     = 47,  /* Next Secure (RFC4034) */\n  ns_t_dnskey   = 48,  /* DNS Public Key (RFC4034) */\n  ns_t_tkey     = 249, /* Transaction key */\n  ns_t_tsig     = 250, /* Transaction signature. */\n  ns_t_ixfr     = 251, /* Incremental zone transfer. */\n  ns_t_axfr     = 252, /* Transfer zone of authority. */\n  ns_t_mailb    = 253, /* Transfer mailbox records. */\n  ns_t_maila    = 254, /* Transfer mail agent records. */\n  ns_t_any      = 255, /* Wildcard match. */\n  ns_t_uri      = 256, /* Uniform Resource Identifier (RFC7553) */\n  ns_t_caa      = 257, /* Certification Authority Authorization. */\n  ns_t_max      = 65536\n} ns_type;",
          {
            "ns_t_invalid": "",
            "ns_t_a": "",
            "ns_t_ns": "",
            "ns_t_md": "",
            "ns_t_mf": "",
            "ns_t_cname": "",
            "ns_t_soa": "",
            "ns_t_mb": "",
            "ns_t_mg": "",
            "ns_t_mr": "",
            "ns_t_null": "",
            "ns_t_wks": "",
            "ns_t_ptr": "",
            "ns_t_hinfo": "",
            "ns_t_minfo": "",
            "ns_t_mx": "",
            "ns_t_txt": "",
            "ns_t_rp": "",
            "ns_t_afsdb": "",
            "ns_t_x25": "",
            "ns_t_isdn": "",
            "ns_t_rt": "",
            "ns_t_nsap": "",
            "ns_t_nsap_ptr": "",
            "ns_t_sig": "",
            "ns_t_key": "",
            "ns_t_px": "",
            "ns_t_gpos": "",
            "ns_t_aaaa": "",
            "ns_t_loc": "",
            "ns_t_nxt": "",
            "ns_t_eid": "",
            "ns_t_nimloc": "",
            "ns_t_srv": "",
            "ns_t_atma": "",
            "ns_t_naptr": "",
            "ns_t_kx": "",
            "ns_t_cert": "",
            "ns_t_a6": "",
            "ns_t_dname": "",
            "ns_t_sink": "",
            "ns_t_opt": "",
            "ns_t_apl": "",
            "ns_t_ds": "",
            "ns_t_sshfp": "",
            "ns_t_rrsig": "",
            "ns_t_nsec": "",
            "ns_t_dnskey": "",
            "ns_t_tkey": "",
            "ns_t_tsig": "",
            "ns_t_ixfr": "",
            "ns_t_axfr": "",
            "ns_t_mailb": "",
            "ns_t_maila": "",
            "ns_t_any": "",
            "ns_t_uri": "",
            "ns_t_caa": "",
            "ns_t_max": ""
          },
          "ns_type",
          [
            112,
            0
          ],
          [
            171,
            10
          ]
        ],
        [
          "typedef enum __ns_opcode {\n  ns_o_query  = 0, /* Standard query. */\n  ns_o_iquery = 1, /* Inverse query (deprecated/unsupported). */\n  ns_o_status = 2, /* Name server status query (unsupported). */\n                   /* Opcode 3 is undefined/reserved. */\n  ns_o_notify = 4, /* Zone change notification. */\n  ns_o_update = 5, /* Zone update message. */\n  ns_o_max    = 6\n} ns_opcode;",
          {
            "ns_o_query": "",
            "ns_o_iquery": "",
            "ns_o_status": "",
            "ns_o_notify": "",
            "ns_o_update": "",
            "ns_o_max": ""
          },
          "ns_opcode",
          [
            173,
            0
          ],
          [
            181,
            12
          ]
        ],
        [
          "typedef enum __ns_rcode {\n  ns_r_noerror  = 0, /* No error occurred. */\n  ns_r_formerr  = 1, /* Format error. */\n  ns_r_servfail = 2, /* Server failure. */\n  ns_r_nxdomain = 3, /* Name error. */\n  ns_r_notimpl  = 4, /* Unimplemented. */\n  ns_r_refused  = 5, /* Operation refused. */\n  /* these are for BIND_UPDATE */\n  ns_r_yxdomain = 6,  /* Name exists */\n  ns_r_yxrrset  = 7,  /* RRset exists */\n  ns_r_nxrrset  = 8,  /* RRset does not exist */\n  ns_r_notauth  = 9,  /* Not authoritative for zone */\n  ns_r_notzone  = 10, /* Zone of record different from zone section */\n  ns_r_max      = 11,\n  /* The following are TSIG extended errors */\n  ns_r_badsig  = 16,\n  ns_r_badkey  = 17,\n  ns_r_badtime = 18\n} ns_rcode;",
          {
            "ns_r_noerror": "",
            "ns_r_formerr": "",
            "ns_r_servfail": "",
            "ns_r_nxdomain": "",
            "ns_r_notimpl": "",
            "ns_r_refused": "",
            "ns_r_yxdomain": "",
            "ns_r_yxrrset": "",
            "ns_r_nxrrset": "",
            "ns_r_notauth": "",
            "ns_r_notzone": "",
            "ns_r_max": "",
            "ns_r_badsig": "",
            "ns_r_badkey": "",
            "ns_r_badtime": ""
          },
          "ns_rcode",
          [
            183,
            0
          ],
          [
            201,
            11
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/include/ares_dns.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/include/ares.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_sock_state_cb)(void *data, ares_socket_t socket_fd,\n                                   int readable, int writable)",
          "fn_dec_pos": [
            [
              336,
              13
            ],
            [
              337,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void",
              "socket_fd": "ares_socket_t",
              "readable": "int",
              "writable": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_callback)(void *arg, int status, int timeouts,\n                              unsigned char *abuf, int alen)",
          "fn_dec_pos": [
            [
              436,
              13
            ],
            [
              437,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "abuf": "unsigned char",
              "alen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_callback_dnsrec)(void *arg, ares_status_t status,\n                                     size_t                   timeouts,\n                                     const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              439,
              13
            ],
            [
              441,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_host_callback)(void *arg, int status, int timeouts,\n                                   struct hostent *hostent)",
          "fn_dec_pos": [
            [
              443,
              13
            ],
            [
              444,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "hostent": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_nameinfo_callback)(void *arg, int status, int timeouts,\n                                       char *node, char *service)",
          "fn_dec_pos": [
            [
              446,
              13
            ],
            [
              447,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "node": "char",
              "service": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_sock_create_callback)(ares_socket_t socket_fd, int type,\n                                         void *data)",
          "fn_dec_pos": [
            [
              449,
              12
            ],
            [
              450,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "socket_fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*ares_sock_config_callback)(ares_socket_t socket_fd, int type,\n                                         void *data)",
          "fn_dec_pos": [
            [
              452,
              12
            ],
            [
              453,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "socket_fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*ares_addrinfo_callback)(void *arg, int status, int timeouts,\n                                       struct ares_addrinfo *res)",
          "fn_dec_pos": [
            [
              455,
              13
            ],
            [
              456,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "res": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_server_state_callback)(const char *server_string,\n                                           ares_bool_t success, int flags,\n                                           void *data)",
          "fn_dec_pos": [
            [
              458,
              13
            ],
            [
              460,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "server_string": "char",
              "success": "ares_bool_t",
              "flags": "int",
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_pending_write_cb)(void *data)",
          "fn_dec_pos": [
            [
              462,
              13
            ],
            [
              462,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_query_enqueue_cb)(void *data)",
          "fn_dec_pos": [
            [
              464,
              13
            ],
            [
              464,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_library_init(int flags)",
          "fn_dec_pos": [
            [
              466,
              17
            ],
            [
              466,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init",
            "parameters": {
              "flags": "int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_init_mem(int flags, void *(*amalloc)(size_t size),\n                                       void (*afree)(void *ptr),\n                                       void *(*arealloc)(void  *ptr,\n                                                         size_t size))",
          "fn_dec_pos": [
            [
              468,
              17
            ],
            [
              471,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_mem",
            "parameters": {
              "flags": "int",
              "amalloc": "void",
              "size": "size_t",
              "afree": "void",
              "ptr": "void",
              "arealloc": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "(*amalloc)(size_t size)",
          "fn_dec_pos": [
            [
              468,
              56
            ],
            [
              468,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*afree)(void *ptr)",
          "fn_dec_pos": [
            [
              469,
              44
            ],
            [
              469,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*arealloc)(void  *ptr,\n                                                         size_t size)",
          "fn_dec_pos": [
            [
              470,
              45
            ],
            [
              471,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_library_init_jvm(JavaVM *jvm)",
          "fn_dec_pos": [
            [
              474,
              18
            ],
            [
              474,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_jvm",
            "parameters": {
              "jvm": "JavaVM"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_init_android(jobject connectivity_manager)",
          "fn_dec_pos": [
            [
              475,
              18
            ],
            [
              475,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_android",
            "parameters": {
              "connectivity_manager": "jobject"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_android_initialized(void)",
          "fn_dec_pos": [
            [
              476,
              18
            ],
            [
              476,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_android_initialized",
            "parameters": {},
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_initialized(void)",
          "fn_dec_pos": [
            [
              482,
              25
            ],
            [
              482,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_initialized",
            "parameters": {},
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_cleanup(void)",
          "fn_dec_pos": [
            [
              484,
              25
            ],
            [
              484,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_cleanup",
            "parameters": {},
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_version(int *version)",
          "fn_dec_pos": [
            [
              486,
              25
            ],
            [
              486,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_version",
            "parameters": {
              "version": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_init(\n  ares_channel_t **channelptr)",
          "fn_dec_pos": [
            [
              488,
              69
            ],
            [
              489,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init",
            "parameters": {
              "channelptr": "ares_channel_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_init_options(ares_channel_t           **channelptr,\n                                    const struct ares_options *options,\n                                    int                        optmask)",
          "fn_dec_pos": [
            [
              491,
              18
            ],
            [
              493,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_options",
            "parameters": {
              "channelptr": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_save_options(const ares_channel_t *channel,\n                                    struct ares_options *options, int *optmask)",
          "fn_dec_pos": [
            [
              495,
              18
            ],
            [
              496,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_save_options",
            "parameters": {
              "channel": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_destroy_options(struct ares_options *options)",
          "fn_dec_pos": [
            [
              498,
              18
            ],
            [
              498,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_options",
            "parameters": {
              "options": "struct ares_options"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dup(ares_channel_t **dest, const ares_channel_t *src)",
          "fn_dec_pos": [
            [
              500,
              18
            ],
            [
              500,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dup",
            "parameters": {
              "dest": "ares_channel_t",
              "src": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_reinit(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              502,
              13
            ],
            [
              502,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_reinit",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_destroy(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              504,
              27
            ],
            [
              504,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_cancel(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              506,
              27
            ],
            [
              506,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cancel",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_local_ip4(ares_channel_t *channel,\n                                              unsigned int    local_ip)",
          "fn_dec_pos": [
            [
              512,
              27
            ],
            [
              513,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_ip4",
            "parameters": {
              "channel": "ares_channel_t",
              "local_ip": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_local_ip6(ares_channel_t      *channel,\n                                              const unsigned char *local_ip6)",
          "fn_dec_pos": [
            [
              516,
              27
            ],
            [
              517,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_ip6",
            "parameters": {
              "channel": "ares_channel_t",
              "local_ip6": "unsigned char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_local_dev(ares_channel_t *channel,\n                                              const char     *local_dev_name)",
          "fn_dec_pos": [
            [
              520,
              27
            ],
            [
              521,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_dev",
            "parameters": {
              "channel": "ares_channel_t",
              "local_dev_name": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_socket_callback(ares_channel_t           *channel,\n                                                    ares_sock_create_callback callback,\n                                                    void                     *user_data)",
          "fn_dec_pos": [
            [
              523,
              27
            ],
            [
              525,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_sock_create_callback",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_socket_configure_callback(\n           ares_channel_t *channel, ares_sock_config_callback callback, void *user_data)",
          "fn_dec_pos": [
            [
              527,
              27
            ],
            [
              528,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_configure_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_sock_config_callback",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_server_state_callback(ares_channel_t            *channel,\n                                                 ares_server_state_callback callback,\n                                                 void                      *user_data)",
          "fn_dec_pos": [
            [
              531,
              18
            ],
            [
              533,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_server_state_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_server_state_callback",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_pending_write_cb(ares_channel_t       *channel,\n                                            ares_pending_write_cb callback,\n                                            void                 *user_data)",
          "fn_dec_pos": [
            [
              535,
              18
            ],
            [
              537,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_pending_write_cb",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_pending_write_cb",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_query_enqueue_cb(ares_channel_t       *channel,\n                                            ares_query_enqueue_cb callback,\n                                            void                 *user_data)",
          "fn_dec_pos": [
            [
              539,
              18
            ],
            [
              541,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_query_enqueue_cb",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_query_enqueue_cb",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_process_pending_write(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              543,
              18
            ],
            [
              543,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process_pending_write",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_sortlist(ares_channel_t *channel,\n                                    const char     *sortstr)",
          "fn_dec_pos": [
            [
              545,
              18
            ],
            [
              546,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_sortlist",
            "parameters": {
              "channel": "ares_channel_t",
              "sortstr": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_getaddrinfo(ares_channel_t *channel, const char *node,\n                                   const char                       *service,\n                                   const struct ares_addrinfo_hints *hints,\n                                   ares_addrinfo_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              548,
              18
            ],
            [
              551,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getaddrinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "node": "char",
              "service": "char",
              "hints": "struct ares_addrinfo_hints",
              "callback": "ares_addrinfo_callback",
              "arg": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_freeaddrinfo(struct ares_addrinfo *ai)",
          "fn_dec_pos": [
            [
              553,
              18
            ],
            [
              553,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_freeaddrinfo",
            "parameters": {
              "ai": "struct ares_addrinfo"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "(*asocket)(int, int, int, void *)",
          "fn_dec_pos": [
            [
              566,
              16
            ],
            [
              566,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "(*aclose)(ares_socket_t, void *)",
          "fn_dec_pos": [
            [
              567,
              6
            ],
            [
              567,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *)",
          "fn_dec_pos": [
            [
              568,
              6
            ],
            [
              569,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *)",
          "fn_dec_pos": [
            [
              570,
              15
            ],
            [
              571,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "(*asendv)(ares_socket_t, const struct iovec *, int, void *)",
          "fn_dec_pos": [
            [
              572,
              15
            ],
            [
              572,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "ares_set_socket_functions(ares_channel_t\n                                                                 *channel,\n                                                               const struct\n                                                               ares_socket_functions\n                                                                    *funcs,\n                                                               void *user_data)",
          "fn_dec_pos": [
            [
              576,
              37
            ],
            [
              581,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_functions",
            "parameters": {
              "channel": "ares_channel_t",
              "funcs": "struct\n                                                               ares_socket_functions",
              "user_data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*asocket)(int domain, int type, int protocol, void *user_data)",
          "fn_dec_pos": [
            [
              648,
              16
            ],
            [
              648,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "domain": "int",
              "type": "int",
              "protocol": "int",
              "user_data": "void"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "(*aclose)(ares_socket_t sock, void *user_data)",
          "fn_dec_pos": [
            [
              655,
              6
            ],
            [
              655,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sock": "ares_socket_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*asetsockopt)(ares_socket_t sock, ares_socket_opt_t opt, const void *val,\n                     ares_socklen_t val_size, void *user_data)",
          "fn_dec_pos": [
            [
              674,
              6
            ],
            [
              675,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sock": "ares_socket_t",
              "opt": "ares_socket_opt_t",
              "val": "void",
              "val_size": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*aconnect)(ares_socket_t sock, const struct sockaddr *address,\n                  ares_socklen_t address_len, unsigned int flags,\n                  void *user_data)",
          "fn_dec_pos": [
            [
              696,
              6
            ],
            [
              698,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sock": "ares_socket_t",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "flags": "unsigned int",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*arecvfrom)(ares_socket_t sock, void *buffer, size_t length,\n                            int flags, struct sockaddr *address,\n                            ares_socklen_t *address_len, void *user_data)",
          "fn_dec_pos": [
            [
              717,
              15
            ],
            [
              719,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sock": "ares_socket_t",
              "buffer": "void",
              "length": "size_t",
              "flags": "int",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "(*asendto)(ares_socket_t sock, const void *buffer, size_t length,\n                          int flags, const struct sockaddr *address,\n                          ares_socklen_t address_len, void *user_data)",
          "fn_dec_pos": [
            [
              740,
              15
            ],
            [
              742,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sock": "ares_socket_t",
              "buffer": "void",
              "length": "size_t",
              "flags": "int",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "(*agetsockname)(ares_socket_t sock, struct sockaddr *address,\n                      ares_socklen_t *address_len, void *user_data)",
          "fn_dec_pos": [
            [
              755,
              6
            ],
            [
              756,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sock": "ares_socket_t",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*abind)(ares_socket_t sock, unsigned int flags,\n               const struct sockaddr *address, socklen_t address_len,\n               void *user_data)",
          "fn_dec_pos": [
            [
              772,
              6
            ],
            [
              774,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sock": "ares_socket_t",
              "flags": "unsigned int",
              "address": "struct sockaddr",
              "address_len": "socklen_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*aif_nametoindex)(const char *ifname, void *user_data)",
          "fn_dec_pos": [
            [
              784,
              15
            ],
            [
              784,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ifname": "char",
              "user_data": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*aif_indextoname)(unsigned int ifindex, char *ifname_buf,\n                                 size_t ifname_buf_len, void *user_data)",
          "fn_dec_pos": [
            [
              798,
              14
            ],
            [
              799,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ifindex": "unsigned int",
              "ifname_buf": "char",
              "ifname_buf_len": "size_t",
              "user_data": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_set_socket_functions_ex(\n  ares_channel_t *channel, const struct ares_socket_functions_ex *funcs,\n  void *user_data)",
          "fn_dec_pos": [
            [
              816,
              13
            ],
            [
              818,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_set_socket_functions_ex",
            "parameters": {
              "channel": "ares_channel_t",
              "funcs": "struct ares_socket_functions_ex",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_send(\n  ares_channel_t *channel, const unsigned char *qbuf, int qlen,\n  ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              821,
              57
            ],
            [
              823,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send",
            "parameters": {
              "channel": "ares_channel_t",
              "qbuf": "unsigned char",
              "qlen": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_send_dnsrec(ares_channel_t          *channel,\n                                            const ares_dns_record_t *dnsrec,\n                                            ares_callback_dnsrec     callback,\n                                            void *arg, unsigned short *qid)",
          "fn_dec_pos": [
            [
              836,
              13
            ],
            [
              839,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_send_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_query(\n  ares_channel_t *channel, const char *name, int dnsclass, int type,\n  ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              841,
              58
            ],
            [
              843,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_query_dnsrec(ares_channel_t      *channel,\n                                             const char          *name,\n                                             ares_dns_class_t     dnsclass,\n                                             ares_dns_rec_type_t  type,\n                                             ares_callback_dnsrec callback,\n                                             void *arg, unsigned short *qid)",
          "fn_dec_pos": [
            [
              857,
              13
            ],
            [
              862,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_query_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_search(\n  ares_channel_t *channel, const char *name, int dnsclass, int type,\n  ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              864,
              59
            ],
            [
              866,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_search_dnsrec(ares_channel_t          *channel,\n                                              const ares_dns_record_t *dnsrec,\n                                              ares_callback_dnsrec     callback,\n                                              void                    *arg)",
          "fn_dec_pos": [
            [
              879,
              13
            ],
            [
              882,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_search_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_gethostbyname(\n  ares_channel_t *channel, const char *name, int family,\n  ares_host_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              884,
              57
            ],
            [
              886,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_gethostbyname_file(ares_channel_t *channel,\n                                          const char *name, int family,\n                                          struct hostent **host)",
          "fn_dec_pos": [
            [
              888,
              18
            ],
            [
              890,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname_file",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_gethostbyaddr(ares_channel_t *channel, const void *addr,\n                                     int addrlen, int family,\n                                     ares_host_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              892,
              18
            ],
            [
              894,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyaddr",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_getnameinfo(ares_channel_t        *channel,\n                                   const struct sockaddr *sa,\n                                   ares_socklen_t salen, int flags,\n                                   ares_nameinfo_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              896,
              18
            ],
            [
              899,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getnameinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t",
              "flags": "int",
              "callback": "ares_nameinfo_callback",
              "arg": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_fds(const ares_channel_t *channel,\n                                            fd_set *read_fds, fd_set *write_fds)",
          "fn_dec_pos": [
            [
              903,
              30
            ],
            [
              904,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_fds",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "write_fds": "fd_set"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_getsock(const ares_channel_t *channel,\n                                           ares_socket_t *socks, int numsocks)",
          "fn_dec_pos": [
            [
              908,
              30
            ],
            [
              909,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getsock",
            "parameters": {
              "channel": "ares_channel_t",
              "socks": "ares_socket_t",
              "numsocks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_timeout(const ares_channel_t *channel,\n                                          struct timeval       *maxtv,\n                                          struct timeval       *tv)",
          "fn_dec_pos": [
            [
              911,
              29
            ],
            [
              913,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeout",
            "parameters": {
              "channel": "ares_channel_t",
              "maxtv": "struct timeval",
              "tv": "struct timeval"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_process(\n  ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)",
          "fn_dec_pos": [
            [
              915,
              57
            ],
            [
              916,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "write_fds": "fd_set"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_process_fds(ares_channel_t         *channel,\n                                            const ares_fd_events_t *events,\n                                            size_t nevents, unsigned int flags)",
          "fn_dec_pos": [
            [
              954,
              13
            ],
            [
              956,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_process_fds",
            "parameters": {
              "channel": "ares_channel_t",
              "events": "ares_fd_events_t",
              "nevents": "size_t",
              "flags": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_process_fd(ares_channel_t *channel,\n                                           ares_socket_t   read_fd,\n                                           ares_socket_t   write_fd)",
          "fn_dec_pos": [
            [
              958,
              27
            ],
            [
              960,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process_fd",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fd": "ares_socket_t",
              "write_fd": "ares_socket_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_create_query(\n  const char *name, int dnsclass, int type, unsigned short id, int rd,\n  unsigned char **buf, int *buflen, int max_udp_size)",
          "fn_dec_pos": [
            [
              962,
              62
            ],
            [
              964,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_create_query",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "buf": "unsigned char",
              "buflen": "int",
              "max_udp_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_mkquery(\n  const char *name, int dnsclass, int type, unsigned short id, int rd,\n  unsigned char **buf, int *buflen)",
          "fn_dec_pos": [
            [
              966,
              62
            ],
            [
              968,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_mkquery",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "buf": "unsigned char",
              "buflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_expand_name(const unsigned char *encoded,\n                                  const unsigned char *abuf, int alen, char **s,\n                                  long *enclen)",
          "fn_dec_pos": [
            [
              970,
              17
            ],
            [
              972,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_name",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "int",
              "s": "char",
              "enclen": "long"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_expand_string(const unsigned char *encoded,\n                                    const unsigned char *abuf, int alen,\n                                    unsigned char **s, long *enclen)",
          "fn_dec_pos": [
            [
              974,
              17
            ],
            [
              976,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_string",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "int",
              "s": "unsigned char",
              "enclen": "long"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_parse_a_reply(\n  const unsigned char *abuf, int alen, struct hostent **host,\n  struct ares_addrttl *addrttls, int *naddrttls)",
          "fn_dec_pos": [
            [
              1103,
              54
            ],
            [
              1105,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_a_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent",
              "addrttls": "struct ares_addrttl",
              "naddrttls": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_aaaa_reply(\n  const unsigned char *abuf, int alen, struct hostent **host,\n  struct ares_addr6ttl *addrttls, int *naddrttls)",
          "fn_dec_pos": [
            [
              1107,
              54
            ],
            [
              1109,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_aaaa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent",
              "addrttls": "struct ares_addr6ttl",
              "naddrttls": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_caa_reply(\n  const unsigned char *abuf, int alen, struct ares_caa_reply **caa_out)",
          "fn_dec_pos": [
            [
              1111,
              54
            ],
            [
              1112,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_caa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "caa_out": "struct ares_caa_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_ptr_reply(\n  const unsigned char *abuf, int alen, const void *addr, int addrlen,\n  int family, struct hostent **host)",
          "fn_dec_pos": [
            [
              1114,
              54
            ],
            [
              1116,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ptr_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_ns_reply(\n  const unsigned char *abuf, int alen, struct hostent **host)",
          "fn_dec_pos": [
            [
              1118,
              54
            ],
            [
              1119,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ns_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_srv_reply(\n  const unsigned char *abuf, int alen, struct ares_srv_reply **srv_out)",
          "fn_dec_pos": [
            [
              1121,
              54
            ],
            [
              1122,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_srv_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "srv_out": "struct ares_srv_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_mx_reply(\n  const unsigned char *abuf, int alen, struct ares_mx_reply **mx_out)",
          "fn_dec_pos": [
            [
              1124,
              54
            ],
            [
              1125,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_mx_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "mx_out": "struct ares_mx_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_txt_reply(\n  const unsigned char *abuf, int alen, struct ares_txt_reply **txt_out)",
          "fn_dec_pos": [
            [
              1127,
              54
            ],
            [
              1128,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "txt_out": "struct ares_txt_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_txt_reply_ext(\n  const unsigned char *abuf, int alen, struct ares_txt_ext **txt_out)",
          "fn_dec_pos": [
            [
              1130,
              54
            ],
            [
              1131,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply_ext",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "txt_out": "struct ares_txt_ext"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_naptr_reply(\n  const unsigned char *abuf, int alen, struct ares_naptr_reply **naptr_out)",
          "fn_dec_pos": [
            [
              1133,
              54
            ],
            [
              1134,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_naptr_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "naptr_out": "struct ares_naptr_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_soa_reply(\n  const unsigned char *abuf, int alen, struct ares_soa_reply **soa_out)",
          "fn_dec_pos": [
            [
              1136,
              54
            ],
            [
              1137,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_soa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "soa_out": "struct ares_soa_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_uri_reply(\n  const unsigned char *abuf, int alen, struct ares_uri_reply **uri_out)",
          "fn_dec_pos": [
            [
              1139,
              54
            ],
            [
              1140,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_uri_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "uri_out": "struct ares_uri_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_free_string(void *str)",
          "fn_dec_pos": [
            [
              1142,
              25
            ],
            [
              1142,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_string",
            "parameters": {
              "str": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_free_hostent(struct hostent *host)",
          "fn_dec_pos": [
            [
              1144,
              25
            ],
            [
              1144,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_hostent",
            "parameters": {
              "host": "struct hostent"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_free_data(void *dataptr)",
          "fn_dec_pos": [
            [
              1146,
              25
            ],
            [
              1146,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_data",
            "parameters": {
              "dataptr": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_strerror(int code)",
          "fn_dec_pos": [
            [
              1148,
              25
            ],
            [
              1148,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strerror",
            "parameters": {
              "code": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_set_servers(\n  ares_channel_t *channel, const struct ares_addr_node *servers)",
          "fn_dec_pos": [
            [
              1173,
              60
            ],
            [
              1174,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_set_servers_ports(ares_channel_t                   *channel,\n                                          const struct ares_addr_port_node *servers)",
          "fn_dec_pos": [
            [
              1178,
              19
            ],
            [
              1179,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_ports",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_port_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_set_servers_csv(ares_channel_t *channel,\n                                        const char     *servers)",
          "fn_dec_pos": [
            [
              1182,
              19
            ],
            [
              1183,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_servers_ports_csv(ares_channel_t *channel,\n                                              const char     *servers)",
          "fn_dec_pos": [
            [
              1184,
              19
            ],
            [
              1185,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_ports_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_get_servers_csv(const ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              1186,
              19
            ],
            [
              1186,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_csv",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_get_servers(\n  const ares_channel_t *channel, struct ares_addr_node **servers)",
          "fn_dec_pos": [
            [
              1188,
              60
            ],
            [
              1189,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_get_servers_ports(const ares_channel_t        *channel,\n                                                  struct ares_addr_port_node **servers)",
          "fn_dec_pos": [
            [
              1193,
              27
            ],
            [
              1194,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_ports",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_port_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_inet_ntop(int af, const void *src, char *dst,\n                                          ares_socklen_t size)",
          "fn_dec_pos": [
            [
              1196,
              27
            ],
            [
              1197,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_ntop",
            "parameters": {
              "af": "int",
              "src": "void",
              "dst": "char",
              "size": "ares_socklen_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_inet_pton(int af, const char *src, void *dst)",
          "fn_dec_pos": [
            [
              1199,
              27
            ],
            [
              1199,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_pton",
            "parameters": {
              "af": "int",
              "src": "char",
              "dst": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t   ares_threadsafety(void)",
          "fn_dec_pos": [
            [
              1205,
              13
            ],
            [
              1205,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t   ares_threadsafety",
            "parameters": {},
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_queue_wait_empty(ares_channel_t *channel,\n                                                 int             timeout_ms)",
          "fn_dec_pos": [
            [
              1217,
              13
            ],
            [
              1218,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_queue_wait_empty",
            "parameters": {
              "channel": "ares_channel_t",
              "timeout_ms": "int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_queue_active_queries(const ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              1228,
              20
            ],
            [
              1228,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_active_queries",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_server_failover_options {\n  unsigned short retry_chance;\n  size_t         retry_delay;\n}",
          {
            "retry_chance": "unsigned short",
            "retry_delay": "size_t"
          },
          "ares_server_failover_options",
          [
            348,
            0
          ],
          [
            351,
            1
          ]
        ],
        [
          "struct ares_options {\n  int            flags;\n  int            timeout; /* in seconds or milliseconds, depending on options */\n  int            tries;\n  int            ndots;\n  unsigned short udp_port; /* host byte order */\n  unsigned short tcp_port; /* host byte order */\n  int            socket_send_buffer_size;\n  int            socket_receive_buffer_size;\n  struct in_addr    *servers;\n  int                nservers;\n  char             **domains;\n  int                ndomains;\n  char              *lookups;\n  ares_sock_state_cb sock_state_cb;\n  void              *sock_state_cb_data;\n  struct apattern   *sortlist;\n  int                nsort;\n  int                ednspsz;\n  char              *resolvconf_path;\n  char              *hosts_path;\n  int                udp_max_queries;\n  int                maxtimeout; /* in milliseconds */\n  unsigned int qcache_max_ttl;   /* Maximum TTL for query cache, 0=disabled */\n  ares_evsys_t evsys;\n  struct ares_server_failover_options server_failover_opts;\n}",
          {
            "flags": "int",
            "timeout": "int",
            "tries": "int",
            "ndots": "int",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "socket_send_buffer_size": "int",
            "socket_receive_buffer_size": "int",
            "*servers": "struct in_addr",
            "nservers": "int",
            "**domains": "char",
            "ndomains": "int",
            "*lookups": "char",
            "sock_state_cb": "ares_sock_state_cb",
            "*sock_state_cb_data": "void",
            "*sortlist": "struct apattern",
            "nsort": "int",
            "ednspsz": "int",
            "*resolvconf_path": "char",
            "*hosts_path": "char",
            "udp_max_queries": "int",
            "maxtimeout": "int",
            "qcache_max_ttl": "unsigned int",
            "evsys": "ares_evsys_t",
            "server_failover_opts": "struct ares_server_failover_options"
          },
          "ares_options",
          [
            370,
            0
          ],
          [
            396,
            1
          ]
        ],
        [
          "struct ares_in6_addr {\n  union {\n    unsigned char _S6_u8[16];\n  } _S6_un;\n}",
          {
            "_S6_un": "union {\n    unsigned char _S6_u8[16];\n  }",
            "_S6_u8[16]": "unsigned char"
          },
          "ares_in6_addr",
          [
            418,
            0
          ],
          [
            422,
            1
          ]
        ],
        [
          "struct ares_addr {\n  int family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n}",
          {
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr"
          },
          "ares_addr",
          [
            424,
            0
          ],
          [
            431,
            1
          ]
        ],
        [
          "struct ares_socket_functions {\n  ares_socket_t (*asocket)(int, int, int, void *);\n  int (*aclose)(ares_socket_t, void *);\n  int (*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *);\n  ares_ssize_t (*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *);\n  ares_ssize_t (*asendv)(ares_socket_t, const struct iovec *, int, void *);\n}",
          {
            "(*asocket)(int, int, int, void *)": "ares_socket_t",
            "(*aclose)(ares_socket_t, void *)": "int",
            "(*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *)": "int",
            "(*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *)": "ares_ssize_t",
            "(*asendv)(ares_socket_t, const struct iovec *, int, void *)": "ares_ssize_t"
          },
          "ares_socket_functions",
          [
            565,
            0
          ],
          [
            573,
            1
          ]
        ],
        [
          "struct ares_socket_functions_ex {\n  /*! ABI Version: must be \"1\" */\n  unsigned int version;\n\n  /*! Flags indicating behavior of the subsystem. One or more\n   * ares_sockfunc_flags_t  */\n  unsigned int flags;\n\n  /*! REQUIRED. Create a new socket file descriptor.  The file descriptor must\n   * be opened in non-blocking mode (so that reads and writes never block).\n   * Recommended other options would be to disable signals on write errors\n   * (SO_NOSIGPIPE), Disable the Nagle algorithm on SOCK_STREAM (TCP_NODELAY),\n   * and to automatically close file descriptors on exec (FD_CLOEXEC).\n   *\n   *  \\param[in] domain      Socket domain. Valid values are AF_INET, AF_INET6.\n   *  \\param[in] type       Socket type. Valid values are SOCK_STREAM (tcp) and\n   *                        SOCK_DGRAM (udp).\n   *  \\param[in] protocol   In general this should be ignored, may be passed as\n   *                        0 (use as default for type), or may be IPPROTO_UDP\n   *                        or IPPROTO_TCP.\n   *  \\param[in] user_data  Pointer provided to ares_set_socket_functions_ex().\n   *  \\return ARES_SOCKET_BAD on error, or socket file descriptor on success.\n   *          On error, it is expected to set errno (or WSASetLastError()) to an\n   *          appropriate reason code such as EAFNOSUPPORT / WSAAFNOSUPPORT. */\n  ares_socket_t (*asocket)(int domain, int type, int protocol, void *user_data);\n\n  /*! REQUIRED. Close a socket file descriptor.\n   *  \\param[in] sock      Socket file descriptor returned from asocket.\n   *  \\param[in] user_data Pointer provided to ares_set_socket_functions_ex().\n   *  \\return 0 on success.  On failure, should set errno (or WSASetLastError)\n   *          to an appropriate code such as EBADF / WSAEBADF */\n  int (*aclose)(ares_socket_t sock, void *user_data);\n\n\n  /*! REQUIRED. Set socket option.  This shares a similar syntax to the BSD\n   *  setsockopt() call, however we use our own options.  The value is typically\n   *  a pointer to the desired value and each option has its own data type it\n   *  will express in the documentation.\n   *\n   * \\param[in] sock         Socket file descriptor returned from asocket.\n   * \\param[in] opt          Option to set.\n   * \\param[in] val          Pointer to value for option.\n   * \\param[in] val_size     Size of value.\n   * \\param[in] user_data    Pointer provided to\n   * ares_set_socket_functions_ex().\n   * \\return Return 0 on success, otherwise -1 should be returned with an\n   *         appropriate errno (or WSASetLastError()) set.  If error is ENOSYS /\n   *         WSAEOPNOTSUPP an error will not be propagated as it will take it\n   *         to mean it is an intentional decision to not support the feature.\n   */\n  int (*asetsockopt)(ares_socket_t sock, ares_socket_opt_t opt, const void *val,\n                     ares_socklen_t val_size, void *user_data);\n\n  /*! REQUIRED. Connect to the remote using the supplied address.  For UDP\n   * sockets this will bind the file descriptor to only send and receive packets\n   * from the remote address provided.\n   *\n   *  \\param[in] sock         Socket file descriptor returned from asocket.\n   *  \\param[in] address      Address to connect to\n   *  \\param[in] address_len  Size of address structure passed\n   *  \\param[in] flags        One or more ares_socket_connect_flags_t\n   *  \\param[in] user_data    Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return Return 0 upon successful establishement, otherwise -1 should be\n   *          returned with an appropriate errno (or WSASetLastError()) set.  It\n   * is generally expected that most TCP connections (not using TCP Fast Open)\n   * will return -1 with an error of EINPROGRESS / WSAEINPROGRESS due to the\n   * non-blocking nature of the connection.  It is then the responsibility of\n   * the implementation to notify of writability on the socket to indicate the\n   * connection has succeeded (or readability on failure to retrieve the\n   * appropriate error).\n   */\n  int (*aconnect)(ares_socket_t sock, const struct sockaddr *address,\n                  ares_socklen_t address_len, unsigned int flags,\n                  void *user_data);\n\n  /*! REQUIRED. Attempt to read data from the remote.\n   *\n   *  \\param[in]     sock        Socket file descriptor returned from asocket.\n   *  \\param[in,out] buffer      Allocated buffer to place data read from\n   * socket.\n   *  \\param[in]     length      Size of buffer\n   *  \\param[in]     flags       Unused, always 0.\n   *  \\param[in,out] address     Buffer to hold address data was received from.\n   *                             May be NULL if address not desired.\n   *  \\param[in,out] address_len Input size of address buffer, output actual\n   *                             written size. Must be NULL if address is NULL.\n   *  \\param[in]     user_data   Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return -1 on error with appropriate errno (or WSASetLastError()) set,\n   * such as EWOULDBLOCK / EAGAIN / WSAEWOULDBLOCK, or ECONNRESET /\n   * WSAECONNRESET.\n   */\n  ares_ssize_t (*arecvfrom)(ares_socket_t sock, void *buffer, size_t length,\n                            int flags, struct sockaddr *address,\n                            ares_socklen_t *address_len, void *user_data);\n\n  /*! REQUIRED. Attempt to send data to the remote.  Optional address may be\n   * specified which may be useful on unbound UDP sockets (though currently not\n   * used), and TCP FastOpen where the connection is delayed until first write.\n   *\n   *  \\param[in]     sock        Socket file descriptor returned from asocket.\n   *  \\param[in]     buffer      Containing data to place onto wire.\n   *  \\param[in]     length      Size of buffer\n   *  \\param[in]     flags       Flags for writing.  Currently only used flag is\n   *                             MSG_NOSIGNAL if the host OS has such a flag. In\n   *                             general flags can be ignored.\n   *  \\param[in]     address     Buffer containing address to send data to.  May\n   *                             be NULL.\n   *  \\param[in,out] address_len Size of address buffer.  Must be 0 if address\n   *                             is NULL.\n   *  \\param[in]     user_data   Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return Number of bytes written. -1 on error with appropriate errno (or\n   * WSASetLastError()) set.\n   */\n  ares_ssize_t (*asendto)(ares_socket_t sock, const void *buffer, size_t length,\n                          int flags, const struct sockaddr *address,\n                          ares_socklen_t address_len, void *user_data);\n\n  /*! Optional. Retrieve the local address of the socket.\n   *\n   *  \\param[in]     sock        Socket file descriptor returned from asocket\n   *  \\param[in,out] address     Buffer to hold address\n   *  \\param[in,out] address_len Size of address buffer on input, written size\n   * on output.\n   *  \\param[in]     user_data   Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return 0 on success. -1 on error with an appropriate errno (or\n   * WSASetLastError()) set.\n   */\n  int (*agetsockname)(ares_socket_t sock, struct sockaddr *address,\n                      ares_socklen_t *address_len, void *user_data);\n\n  /*! Optional. Bind the socket to an address.  This can be used for client\n   *  connections to bind the source address for packets before connect, or\n   *  for server connections to bind to an address and port before listening.\n   *  Currently c-ares only supports client connections.\n   *\n   *  \\param[in] sock        Socket file descriptor returned from asocket\n   *  \\param[in] flags       ares_socket_bind_flags_t flags.\n   *  \\param[in] address     Buffer containing address.\n   *  \\param[in] address_len Size of address buffer.\n   *  \\param[in] user_data   Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return 0 on success. -1 on error with an appropriate errno (or\n   * WSASetLastError()) set.\n   */\n  int (*abind)(ares_socket_t sock, unsigned int flags,\n               const struct sockaddr *address, socklen_t address_len,\n               void *user_data);\n\n  /* Optional. Convert an interface name into the interface index.  If this\n   * callback is not specified, then IPv6 Link-Local DNS servers cannot be used.\n   *\n   * \\param[in] ifname  Interface Name as NULL-terminated string.\n   * \\param[in] user_data Pointer provided to\n   * ares_set_socket_functions_ex().\n   * \\return 0 on failure, otherwise interface index.\n   */\n  unsigned int (*aif_nametoindex)(const char *ifname, void *user_data);\n\n  /* Optional. Convert an interface index into the interface name.  If this\n   * callback is not specified, then IPv6 Link-Local DNS servers cannot be used.\n   *\n   * \\param[in] ifindex        Interface index, must be > 0\n   * \\param[in] ifname_buf     Buffer to hold interface name. Must be at least\n   *                           IFNAMSIZ in length or 32 bytes if IFNAMSIZ isn't\n   *                           defined.\n   * \\param[in] ifname_buf_len Size of ifname_buf for verification.\n   * \\param[in] user_data      Pointer provided to\n   * ares_set_socket_functions_ex().\n   * \\return NULL on failure, otherwise pointer to provided ifname_buf\n   */\n  const char *(*aif_indextoname)(unsigned int ifindex, char *ifname_buf,\n                                 size_t ifname_buf_len, void *user_data);\n}",
          {
            "version": "unsigned int",
            "flags": "unsigned int",
            "(*asocket)(int domain, int type, int protocol, void *user_data)": "ares_socket_t",
            "(*aclose)(ares_socket_t sock, void *user_data)": "int",
            "(*asetsockopt)(ares_socket_t sock, ares_socket_opt_t opt, const void *val,\n                     ares_socklen_t val_size, void *user_data)": "int",
            "(*aconnect)(ares_socket_t sock, const struct sockaddr *address,\n                  ares_socklen_t address_len, unsigned int flags,\n                  void *user_data)": "int",
            "(*arecvfrom)(ares_socket_t sock, void *buffer, size_t length,\n                            int flags, struct sockaddr *address,\n                            ares_socklen_t *address_len, void *user_data)": "ares_ssize_t",
            "(*asendto)(ares_socket_t sock, const void *buffer, size_t length,\n                          int flags, const struct sockaddr *address,\n                          ares_socklen_t address_len, void *user_data)": "ares_ssize_t",
            "(*agetsockname)(ares_socket_t sock, struct sockaddr *address,\n                      ares_socklen_t *address_len, void *user_data)": "int",
            "(*abind)(ares_socket_t sock, unsigned int flags,\n               const struct sockaddr *address, socklen_t address_len,\n               void *user_data)": "int",
            "(*aif_nametoindex)(const char *ifname, void *user_data)": "unsigned int",
            "char": "const"
          },
          "ares_socket_functions_ex",
          [
            624,
            0
          ],
          [
            800,
            1
          ]
        ],
        [
          "typedef struct {\n  ares_socket_t fd;     /*!< File descriptor */\n  unsigned int  events; /*!< Mask of ares_fd_eventflag_t */\n} ares_fd_events_t;",
          {
            "fd": "ares_socket_t",
            "events": "unsigned int"
          },
          "ares_fd_events_t",
          [
            927,
            0
          ],
          [
            930,
            19
          ]
        ],
        [
          "struct ares_addrttl {\n  struct in_addr ipaddr;\n  int            ttl;\n}",
          {
            "ipaddr": "struct in_addr",
            "ttl": "int"
          },
          "ares_addrttl",
          [
            978,
            0
          ],
          [
            981,
            1
          ]
        ],
        [
          "struct ares_addr6ttl {\n  struct ares_in6_addr ip6addr;\n  int                  ttl;\n}",
          {
            "ip6addr": "struct ares_in6_addr",
            "ttl": "int"
          },
          "ares_addr6ttl",
          [
            983,
            0
          ],
          [
            986,
            1
          ]
        ],
        [
          "struct ares_caa_reply {\n  struct ares_caa_reply *next;\n  int                    critical;\n  unsigned char         *property;\n  size_t                 plength; /* plength excludes null termination */\n  unsigned char         *value;\n  size_t                 length;  /* length excludes null termination */\n}",
          {
            "*next": "struct ares_caa_reply",
            "critical": "int",
            "*property": "unsigned char",
            "plength": "size_t",
            "*value": "unsigned char",
            "length": "size_t"
          },
          "ares_caa_reply",
          [
            988,
            0
          ],
          [
            995,
            1
          ]
        ],
        [
          "struct ares_srv_reply {\n  struct ares_srv_reply *next;\n  char                  *host;\n  unsigned short         priority;\n  unsigned short         weight;\n  unsigned short         port;\n}",
          {
            "*next": "struct ares_srv_reply",
            "*host": "char",
            "priority": "unsigned short",
            "weight": "unsigned short",
            "port": "unsigned short"
          },
          "ares_srv_reply",
          [
            997,
            0
          ],
          [
            1003,
            1
          ]
        ],
        [
          "struct ares_mx_reply {\n  struct ares_mx_reply *next;\n  char                 *host;\n  unsigned short        priority;\n}",
          {
            "*next": "struct ares_mx_reply",
            "*host": "char",
            "priority": "unsigned short"
          },
          "ares_mx_reply",
          [
            1005,
            0
          ],
          [
            1009,
            1
          ]
        ],
        [
          "struct ares_txt_reply {\n  struct ares_txt_reply *next;\n  unsigned char         *txt;\n  size_t                 length; /* length excludes null termination */\n}",
          {
            "*next": "struct ares_txt_reply",
            "*txt": "unsigned char",
            "length": "size_t"
          },
          "ares_txt_reply",
          [
            1011,
            0
          ],
          [
            1015,
            1
          ]
        ],
        [
          "struct ares_txt_ext {\n  struct ares_txt_ext *next;\n  unsigned char       *txt;\n  size_t               length;\n  /* 1 - if start of new record\n   * 0 - if a chunk in the same record */\n  unsigned char        record_start;\n}",
          {
            "*next": "struct ares_txt_ext",
            "*txt": "unsigned char",
            "length": "size_t",
            "record_start": "unsigned char"
          },
          "ares_txt_ext",
          [
            1019,
            0
          ],
          [
            1026,
            1
          ]
        ],
        [
          "struct ares_naptr_reply {\n  struct ares_naptr_reply *next;\n  unsigned char           *flags;\n  unsigned char           *service;\n  unsigned char           *regexp;\n  char                    *replacement;\n  unsigned short           order;\n  unsigned short           preference;\n}",
          {
            "*next": "struct ares_naptr_reply",
            "*flags": "unsigned char",
            "*service": "unsigned char",
            "*regexp": "unsigned char",
            "*replacement": "char",
            "order": "unsigned short",
            "preference": "unsigned short"
          },
          "ares_naptr_reply",
          [
            1028,
            0
          ],
          [
            1036,
            1
          ]
        ],
        [
          "struct ares_soa_reply {\n  char        *nsname;\n  char        *hostmaster;\n  unsigned int serial;\n  unsigned int refresh;\n  unsigned int retry;\n  unsigned int expire;\n  unsigned int minttl;\n}",
          {
            "*nsname": "char",
            "*hostmaster": "char",
            "serial": "unsigned int",
            "refresh": "unsigned int",
            "retry": "unsigned int",
            "expire": "unsigned int",
            "minttl": "unsigned int"
          },
          "ares_soa_reply",
          [
            1038,
            0
          ],
          [
            1046,
            1
          ]
        ],
        [
          "struct ares_uri_reply {\n  struct ares_uri_reply *next;\n  unsigned short         priority;\n  unsigned short         weight;\n  char                  *uri;\n  int                    ttl;\n}",
          {
            "*next": "struct ares_uri_reply",
            "priority": "unsigned short",
            "weight": "unsigned short",
            "*uri": "char",
            "ttl": "int"
          },
          "ares_uri_reply",
          [
            1048,
            0
          ],
          [
            1054,
            1
          ]
        ],
        [
          "struct ares_addrinfo_node {\n  int                        ai_ttl;\n  int                        ai_flags;\n  int                        ai_family;\n  int                        ai_socktype;\n  int                        ai_protocol;\n  ares_socklen_t             ai_addrlen;\n  struct sockaddr           *ai_addr;\n  struct ares_addrinfo_node *ai_next;\n}",
          {
            "ai_ttl": "int",
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "ares_socklen_t",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct ares_addrinfo_node"
          },
          "ares_addrinfo_node",
          [
            1059,
            0
          ],
          [
            1068,
            1
          ]
        ],
        [
          "struct ares_addrinfo_cname {\n  int                         ttl;\n  char                       *alias;\n  char                       *name;\n  struct ares_addrinfo_cname *next;\n}",
          {
            "ttl": "int",
            "*alias": "char",
            "*name": "char",
            "*next": "struct ares_addrinfo_cname"
          },
          "ares_addrinfo_cname",
          [
            1075,
            0
          ],
          [
            1080,
            1
          ]
        ],
        [
          "struct ares_addrinfo {\n  struct ares_addrinfo_cname *cnames;\n  struct ares_addrinfo_node  *nodes;\n  char                       *name;\n}",
          {
            "*cnames": "struct ares_addrinfo_cname",
            "*nodes": "struct ares_addrinfo_node",
            "*name": "char"
          },
          "ares_addrinfo",
          [
            1082,
            0
          ],
          [
            1086,
            1
          ]
        ],
        [
          "struct ares_addrinfo_hints {\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int"
          },
          "ares_addrinfo_hints",
          [
            1088,
            0
          ],
          [
            1093,
            1
          ]
        ],
        [
          "struct ares_addr_node {\n  struct ares_addr_node *next;\n  int                    family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n}",
          {
            "*next": "struct ares_addr_node",
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr"
          },
          "ares_addr_node",
          [
            1150,
            0
          ],
          [
            1158,
            1
          ]
        ],
        [
          "struct ares_addr_port_node {\n  struct ares_addr_port_node *next;\n  int                         family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n\n  int udp_port;\n  int tcp_port;\n}",
          {
            "*next": "struct ares_addr_port_node",
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr",
            "udp_port": "int",
            "tcp_port": "int"
          },
          "ares_addr_port_node",
          [
            1160,
            0
          ],
          [
            1171,
            1
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            339,
            0
          ],
          [
            339,
            15
          ]
        ],
        [
          "struct ares_server_failover_options {\n  unsigned short retry_chance;\n  size_t         retry_delay;\n}",
          {
            "retry_chance": "unsigned short",
            "retry_delay": "size_t"
          },
          "ares_server_failover_options",
          [
            348,
            0
          ],
          [
            351,
            1
          ]
        ],
        [
          "struct ares_options {\n  int            flags;\n  int            timeout; /* in seconds or milliseconds, depending on options */\n  int            tries;\n  int            ndots;\n  unsigned short udp_port; /* host byte order */\n  unsigned short tcp_port; /* host byte order */\n  int            socket_send_buffer_size;\n  int            socket_receive_buffer_size;\n  struct in_addr    *servers;\n  int                nservers;\n  char             **domains;\n  int                ndomains;\n  char              *lookups;\n  ares_sock_state_cb sock_state_cb;\n  void              *sock_state_cb_data;\n  struct apattern   *sortlist;\n  int                nsort;\n  int                ednspsz;\n  char              *resolvconf_path;\n  char              *hosts_path;\n  int                udp_max_queries;\n  int                maxtimeout; /* in milliseconds */\n  unsigned int qcache_max_ttl;   /* Maximum TTL for query cache, 0=disabled */\n  ares_evsys_t evsys;\n  struct ares_server_failover_options server_failover_opts;\n}",
          {
            "flags": "int",
            "timeout": "int",
            "tries": "int",
            "ndots": "int",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "socket_send_buffer_size": "int",
            "socket_receive_buffer_size": "int",
            "*servers": "struct in_addr",
            "nservers": "int",
            "**domains": "char",
            "ndomains": "int",
            "*lookups": "char",
            "sock_state_cb": "ares_sock_state_cb",
            "*sock_state_cb_data": "void",
            "*sortlist": "struct apattern",
            "nsort": "int",
            "ednspsz": "int",
            "*resolvconf_path": "char",
            "*hosts_path": "char",
            "udp_max_queries": "int",
            "maxtimeout": "int",
            "qcache_max_ttl": "unsigned int",
            "evsys": "ares_evsys_t",
            "server_failover_opts": "struct ares_server_failover_options"
          },
          "ares_options",
          [
            370,
            0
          ],
          [
            396,
            1
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            379,
            2
          ],
          [
            379,
            16
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            386,
            2
          ],
          [
            386,
            17
          ]
        ],
        [
          "struct ares_server_failover_options",
          {},
          "",
          [
            395,
            2
          ],
          [
            395,
            37
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            398,
            0
          ],
          [
            398,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            399,
            0
          ],
          [
            399,
            14
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            400,
            0
          ],
          [
            400,
            15
          ]
        ],
        [
          "struct ares_channeldata",
          {},
          "",
          [
            401,
            0
          ],
          [
            401,
            23
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            402,
            0
          ],
          [
            402,
            20
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            403,
            0
          ],
          [
            403,
            26
          ]
        ],
        [
          "typedef struct ares_channeldata *ares_channel;",
          {},
          "ares_channel",
          [
            406,
            0
          ],
          [
            406,
            46
          ]
        ],
        [
          "typedef struct ares_channeldata  ares_channel_t;",
          {},
          "ares_channel_t",
          [
            409,
            0
          ],
          [
            409,
            48
          ]
        ],
        [
          "struct ares_in6_addr {\n  union {\n    unsigned char _S6_u8[16];\n  } _S6_un;\n}",
          {
            "_S6_un": "union {\n    unsigned char _S6_u8[16];\n  }",
            "_S6_u8[16]": "unsigned char"
          },
          "ares_in6_addr",
          [
            418,
            0
          ],
          [
            422,
            1
          ]
        ],
        [
          "struct ares_addr {\n  int family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n}",
          {
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr"
          },
          "ares_addr",
          [
            424,
            0
          ],
          [
            431,
            1
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            428,
            4
          ],
          [
            428,
            18
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            429,
            4
          ],
          [
            429,
            24
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            444,
            35
          ],
          [
            444,
            49
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            456,
            39
          ],
          [
            456,
            59
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            492,
            42
          ],
          [
            492,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            496,
            36
          ],
          [
            496,
            55
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            498,
            39
          ],
          [
            498,
            58
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            550,
            41
          ],
          [
            550,
            67
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            553,
            36
          ],
          [
            553,
            56
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            563,
            0
          ],
          [
            563,
            12
          ]
        ],
        [
          "struct ares_socket_functions {\n  ares_socket_t (*asocket)(int, int, int, void *);\n  int (*aclose)(ares_socket_t, void *);\n  int (*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *);\n  ares_ssize_t (*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *);\n  ares_ssize_t (*asendv)(ares_socket_t, const struct iovec *, int, void *);\n}",
          {
            "(*asocket)(int, int, int, void *)": "ares_socket_t",
            "(*aclose)(ares_socket_t, void *)": "int",
            "(*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *)": "int",
            "(*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *)": "ares_ssize_t",
            "(*asendv)(ares_socket_t, const struct iovec *, int, void *)": "ares_ssize_t"
          },
          "ares_socket_functions",
          [
            565,
            0
          ],
          [
            573,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            568,
            39
          ],
          [
            568,
            54
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            571,
            28
          ],
          [
            571,
            43
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            572,
            46
          ],
          [
            572,
            58
          ]
        ],
        [
          "struct\n                                                               ares_socket_functions",
          {},
          "",
          [
            578,
            69
          ],
          [
            579,
            84
          ]
        ],
        [
          "struct ares_socket_functions_ex {\n  /*! ABI Version: must be \"1\" */\n  unsigned int version;\n\n  /*! Flags indicating behavior of the subsystem. One or more\n   * ares_sockfunc_flags_t  */\n  unsigned int flags;\n\n  /*! REQUIRED. Create a new socket file descriptor.  The file descriptor must\n   * be opened in non-blocking mode (so that reads and writes never block).\n   * Recommended other options would be to disable signals on write errors\n   * (SO_NOSIGPIPE), Disable the Nagle algorithm on SOCK_STREAM (TCP_NODELAY),\n   * and to automatically close file descriptors on exec (FD_CLOEXEC).\n   *\n   *  \\param[in] domain      Socket domain. Valid values are AF_INET, AF_INET6.\n   *  \\param[in] type       Socket type. Valid values are SOCK_STREAM (tcp) and\n   *                        SOCK_DGRAM (udp).\n   *  \\param[in] protocol   In general this should be ignored, may be passed as\n   *                        0 (use as default for type), or may be IPPROTO_UDP\n   *                        or IPPROTO_TCP.\n   *  \\param[in] user_data  Pointer provided to ares_set_socket_functions_ex().\n   *  \\return ARES_SOCKET_BAD on error, or socket file descriptor on success.\n   *          On error, it is expected to set errno (or WSASetLastError()) to an\n   *          appropriate reason code such as EAFNOSUPPORT / WSAAFNOSUPPORT. */\n  ares_socket_t (*asocket)(int domain, int type, int protocol, void *user_data);\n\n  /*! REQUIRED. Close a socket file descriptor.\n   *  \\param[in] sock      Socket file descriptor returned from asocket.\n   *  \\param[in] user_data Pointer provided to ares_set_socket_functions_ex().\n   *  \\return 0 on success.  On failure, should set errno (or WSASetLastError)\n   *          to an appropriate code such as EBADF / WSAEBADF */\n  int (*aclose)(ares_socket_t sock, void *user_data);\n\n\n  /*! REQUIRED. Set socket option.  This shares a similar syntax to the BSD\n   *  setsockopt() call, however we use our own options.  The value is typically\n   *  a pointer to the desired value and each option has its own data type it\n   *  will express in the documentation.\n   *\n   * \\param[in] sock         Socket file descriptor returned from asocket.\n   * \\param[in] opt          Option to set.\n   * \\param[in] val          Pointer to value for option.\n   * \\param[in] val_size     Size of value.\n   * \\param[in] user_data    Pointer provided to\n   * ares_set_socket_functions_ex().\n   * \\return Return 0 on success, otherwise -1 should be returned with an\n   *         appropriate errno (or WSASetLastError()) set.  If error is ENOSYS /\n   *         WSAEOPNOTSUPP an error will not be propagated as it will take it\n   *         to mean it is an intentional decision to not support the feature.\n   */\n  int (*asetsockopt)(ares_socket_t sock, ares_socket_opt_t opt, const void *val,\n                     ares_socklen_t val_size, void *user_data);\n\n  /*! REQUIRED. Connect to the remote using the supplied address.  For UDP\n   * sockets this will bind the file descriptor to only send and receive packets\n   * from the remote address provided.\n   *\n   *  \\param[in] sock         Socket file descriptor returned from asocket.\n   *  \\param[in] address      Address to connect to\n   *  \\param[in] address_len  Size of address structure passed\n   *  \\param[in] flags        One or more ares_socket_connect_flags_t\n   *  \\param[in] user_data    Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return Return 0 upon successful establishement, otherwise -1 should be\n   *          returned with an appropriate errno (or WSASetLastError()) set.  It\n   * is generally expected that most TCP connections (not using TCP Fast Open)\n   * will return -1 with an error of EINPROGRESS / WSAEINPROGRESS due to the\n   * non-blocking nature of the connection.  It is then the responsibility of\n   * the implementation to notify of writability on the socket to indicate the\n   * connection has succeeded (or readability on failure to retrieve the\n   * appropriate error).\n   */\n  int (*aconnect)(ares_socket_t sock, const struct sockaddr *address,\n                  ares_socklen_t address_len, unsigned int flags,\n                  void *user_data);\n\n  /*! REQUIRED. Attempt to read data from the remote.\n   *\n   *  \\param[in]     sock        Socket file descriptor returned from asocket.\n   *  \\param[in,out] buffer      Allocated buffer to place data read from\n   * socket.\n   *  \\param[in]     length      Size of buffer\n   *  \\param[in]     flags       Unused, always 0.\n   *  \\param[in,out] address     Buffer to hold address data was received from.\n   *                             May be NULL if address not desired.\n   *  \\param[in,out] address_len Input size of address buffer, output actual\n   *                             written size. Must be NULL if address is NULL.\n   *  \\param[in]     user_data   Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return -1 on error with appropriate errno (or WSASetLastError()) set,\n   * such as EWOULDBLOCK / EAGAIN / WSAEWOULDBLOCK, or ECONNRESET /\n   * WSAECONNRESET.\n   */\n  ares_ssize_t (*arecvfrom)(ares_socket_t sock, void *buffer, size_t length,\n                            int flags, struct sockaddr *address,\n                            ares_socklen_t *address_len, void *user_data);\n\n  /*! REQUIRED. Attempt to send data to the remote.  Optional address may be\n   * specified which may be useful on unbound UDP sockets (though currently not\n   * used), and TCP FastOpen where the connection is delayed until first write.\n   *\n   *  \\param[in]     sock        Socket file descriptor returned from asocket.\n   *  \\param[in]     buffer      Containing data to place onto wire.\n   *  \\param[in]     length      Size of buffer\n   *  \\param[in]     flags       Flags for writing.  Currently only used flag is\n   *                             MSG_NOSIGNAL if the host OS has such a flag. In\n   *                             general flags can be ignored.\n   *  \\param[in]     address     Buffer containing address to send data to.  May\n   *                             be NULL.\n   *  \\param[in,out] address_len Size of address buffer.  Must be 0 if address\n   *                             is NULL.\n   *  \\param[in]     user_data   Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return Number of bytes written. -1 on error with appropriate errno (or\n   * WSASetLastError()) set.\n   */\n  ares_ssize_t (*asendto)(ares_socket_t sock, const void *buffer, size_t length,\n                          int flags, const struct sockaddr *address,\n                          ares_socklen_t address_len, void *user_data);\n\n  /*! Optional. Retrieve the local address of the socket.\n   *\n   *  \\param[in]     sock        Socket file descriptor returned from asocket\n   *  \\param[in,out] address     Buffer to hold address\n   *  \\param[in,out] address_len Size of address buffer on input, written size\n   * on output.\n   *  \\param[in]     user_data   Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return 0 on success. -1 on error with an appropriate errno (or\n   * WSASetLastError()) set.\n   */\n  int (*agetsockname)(ares_socket_t sock, struct sockaddr *address,\n                      ares_socklen_t *address_len, void *user_data);\n\n  /*! Optional. Bind the socket to an address.  This can be used for client\n   *  connections to bind the source address for packets before connect, or\n   *  for server connections to bind to an address and port before listening.\n   *  Currently c-ares only supports client connections.\n   *\n   *  \\param[in] sock        Socket file descriptor returned from asocket\n   *  \\param[in] flags       ares_socket_bind_flags_t flags.\n   *  \\param[in] address     Buffer containing address.\n   *  \\param[in] address_len Size of address buffer.\n   *  \\param[in] user_data   Pointer provided to\n   * ares_set_socket_functions_ex().\n   *  \\return 0 on success. -1 on error with an appropriate errno (or\n   * WSASetLastError()) set.\n   */\n  int (*abind)(ares_socket_t sock, unsigned int flags,\n               const struct sockaddr *address, socklen_t address_len,\n               void *user_data);\n\n  /* Optional. Convert an interface name into the interface index.  If this\n   * callback is not specified, then IPv6 Link-Local DNS servers cannot be used.\n   *\n   * \\param[in] ifname  Interface Name as NULL-terminated string.\n   * \\param[in] user_data Pointer provided to\n   * ares_set_socket_functions_ex().\n   * \\return 0 on failure, otherwise interface index.\n   */\n  unsigned int (*aif_nametoindex)(const char *ifname, void *user_data);\n\n  /* Optional. Convert an interface index into the interface name.  If this\n   * callback is not specified, then IPv6 Link-Local DNS servers cannot be used.\n   *\n   * \\param[in] ifindex        Interface index, must be > 0\n   * \\param[in] ifname_buf     Buffer to hold interface name. Must be at least\n   *                           IFNAMSIZ in length or 32 bytes if IFNAMSIZ isn't\n   *                           defined.\n   * \\param[in] ifname_buf_len Size of ifname_buf for verification.\n   * \\param[in] user_data      Pointer provided to\n   * ares_set_socket_functions_ex().\n   * \\return NULL on failure, otherwise pointer to provided ifname_buf\n   */\n  const char *(*aif_indextoname)(unsigned int ifindex, char *ifname_buf,\n                                 size_t ifname_buf_len, void *user_data);\n}",
          {
            "version": "unsigned int",
            "flags": "unsigned int",
            "(*asocket)(int domain, int type, int protocol, void *user_data)": "ares_socket_t",
            "(*aclose)(ares_socket_t sock, void *user_data)": "int",
            "(*asetsockopt)(ares_socket_t sock, ares_socket_opt_t opt, const void *val,\n                     ares_socklen_t val_size, void *user_data)": "int",
            "(*aconnect)(ares_socket_t sock, const struct sockaddr *address,\n                  ares_socklen_t address_len, unsigned int flags,\n                  void *user_data)": "int",
            "(*arecvfrom)(ares_socket_t sock, void *buffer, size_t length,\n                            int flags, struct sockaddr *address,\n                            ares_socklen_t *address_len, void *user_data)": "ares_ssize_t",
            "(*asendto)(ares_socket_t sock, const void *buffer, size_t length,\n                          int flags, const struct sockaddr *address,\n                          ares_socklen_t address_len, void *user_data)": "ares_ssize_t",
            "(*agetsockname)(ares_socket_t sock, struct sockaddr *address,\n                      ares_socklen_t *address_len, void *user_data)": "int",
            "(*abind)(ares_socket_t sock, unsigned int flags,\n               const struct sockaddr *address, socklen_t address_len,\n               void *user_data)": "int",
            "(*aif_nametoindex)(const char *ifname, void *user_data)": "unsigned int",
            "char": "const"
          },
          "ares_socket_functions_ex",
          [
            624,
            0
          ],
          [
            800,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            696,
            44
          ],
          [
            696,
            59
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            718,
            39
          ],
          [
            718,
            54
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            741,
            43
          ],
          [
            741,
            58
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            755,
            42
          ],
          [
            755,
            57
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            773,
            21
          ],
          [
            773,
            36
          ]
        ],
        [
          "struct ares_socket_functions_ex",
          {},
          "",
          [
            817,
            33
          ],
          [
            817,
            64
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            890,
            42
          ],
          [
            890,
            56
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            897,
            41
          ],
          [
            897,
            56
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            912,
            42
          ],
          [
            912,
            56
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            913,
            42
          ],
          [
            913,
            56
          ]
        ],
        [
          "typedef struct {\n  ares_socket_t fd;     /*!< File descriptor */\n  unsigned int  events; /*!< Mask of ares_fd_eventflag_t */\n} ares_fd_events_t;",
          {
            "fd": "ares_socket_t",
            "events": "unsigned int"
          },
          "ares_fd_events_t",
          [
            927,
            0
          ],
          [
            930,
            19
          ]
        ],
        [
          "struct ares_addrttl {\n  struct in_addr ipaddr;\n  int            ttl;\n}",
          {
            "ipaddr": "struct in_addr",
            "ttl": "int"
          },
          "ares_addrttl",
          [
            978,
            0
          ],
          [
            981,
            1
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            979,
            2
          ],
          [
            979,
            16
          ]
        ],
        [
          "struct ares_addr6ttl {\n  struct ares_in6_addr ip6addr;\n  int                  ttl;\n}",
          {
            "ip6addr": "struct ares_in6_addr",
            "ttl": "int"
          },
          "ares_addr6ttl",
          [
            983,
            0
          ],
          [
            986,
            1
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            984,
            2
          ],
          [
            984,
            22
          ]
        ],
        [
          "struct ares_caa_reply {\n  struct ares_caa_reply *next;\n  int                    critical;\n  unsigned char         *property;\n  size_t                 plength; /* plength excludes null termination */\n  unsigned char         *value;\n  size_t                 length;  /* length excludes null termination */\n}",
          {
            "*next": "struct ares_caa_reply",
            "critical": "int",
            "*property": "unsigned char",
            "plength": "size_t",
            "*value": "unsigned char",
            "length": "size_t"
          },
          "ares_caa_reply",
          [
            988,
            0
          ],
          [
            995,
            1
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            989,
            2
          ],
          [
            989,
            23
          ]
        ],
        [
          "struct ares_srv_reply {\n  struct ares_srv_reply *next;\n  char                  *host;\n  unsigned short         priority;\n  unsigned short         weight;\n  unsigned short         port;\n}",
          {
            "*next": "struct ares_srv_reply",
            "*host": "char",
            "priority": "unsigned short",
            "weight": "unsigned short",
            "port": "unsigned short"
          },
          "ares_srv_reply",
          [
            997,
            0
          ],
          [
            1003,
            1
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            998,
            2
          ],
          [
            998,
            23
          ]
        ],
        [
          "struct ares_mx_reply {\n  struct ares_mx_reply *next;\n  char                 *host;\n  unsigned short        priority;\n}",
          {
            "*next": "struct ares_mx_reply",
            "*host": "char",
            "priority": "unsigned short"
          },
          "ares_mx_reply",
          [
            1005,
            0
          ],
          [
            1009,
            1
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            1006,
            2
          ],
          [
            1006,
            22
          ]
        ],
        [
          "struct ares_txt_reply {\n  struct ares_txt_reply *next;\n  unsigned char         *txt;\n  size_t                 length; /* length excludes null termination */\n}",
          {
            "*next": "struct ares_txt_reply",
            "*txt": "unsigned char",
            "length": "size_t"
          },
          "ares_txt_reply",
          [
            1011,
            0
          ],
          [
            1015,
            1
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            1012,
            2
          ],
          [
            1012,
            23
          ]
        ],
        [
          "struct ares_txt_ext {\n  struct ares_txt_ext *next;\n  unsigned char       *txt;\n  size_t               length;\n  /* 1 - if start of new record\n   * 0 - if a chunk in the same record */\n  unsigned char        record_start;\n}",
          {
            "*next": "struct ares_txt_ext",
            "*txt": "unsigned char",
            "length": "size_t",
            "record_start": "unsigned char"
          },
          "ares_txt_ext",
          [
            1019,
            0
          ],
          [
            1026,
            1
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            1020,
            2
          ],
          [
            1020,
            21
          ]
        ],
        [
          "struct ares_naptr_reply {\n  struct ares_naptr_reply *next;\n  unsigned char           *flags;\n  unsigned char           *service;\n  unsigned char           *regexp;\n  char                    *replacement;\n  unsigned short           order;\n  unsigned short           preference;\n}",
          {
            "*next": "struct ares_naptr_reply",
            "*flags": "unsigned char",
            "*service": "unsigned char",
            "*regexp": "unsigned char",
            "*replacement": "char",
            "order": "unsigned short",
            "preference": "unsigned short"
          },
          "ares_naptr_reply",
          [
            1028,
            0
          ],
          [
            1036,
            1
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            1029,
            2
          ],
          [
            1029,
            25
          ]
        ],
        [
          "struct ares_soa_reply {\n  char        *nsname;\n  char        *hostmaster;\n  unsigned int serial;\n  unsigned int refresh;\n  unsigned int retry;\n  unsigned int expire;\n  unsigned int minttl;\n}",
          {
            "*nsname": "char",
            "*hostmaster": "char",
            "serial": "unsigned int",
            "refresh": "unsigned int",
            "retry": "unsigned int",
            "expire": "unsigned int",
            "minttl": "unsigned int"
          },
          "ares_soa_reply",
          [
            1038,
            0
          ],
          [
            1046,
            1
          ]
        ],
        [
          "struct ares_uri_reply {\n  struct ares_uri_reply *next;\n  unsigned short         priority;\n  unsigned short         weight;\n  char                  *uri;\n  int                    ttl;\n}",
          {
            "*next": "struct ares_uri_reply",
            "priority": "unsigned short",
            "weight": "unsigned short",
            "*uri": "char",
            "ttl": "int"
          },
          "ares_uri_reply",
          [
            1048,
            0
          ],
          [
            1054,
            1
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            1049,
            2
          ],
          [
            1049,
            23
          ]
        ],
        [
          "struct ares_addrinfo_node {\n  int                        ai_ttl;\n  int                        ai_flags;\n  int                        ai_family;\n  int                        ai_socktype;\n  int                        ai_protocol;\n  ares_socklen_t             ai_addrlen;\n  struct sockaddr           *ai_addr;\n  struct ares_addrinfo_node *ai_next;\n}",
          {
            "ai_ttl": "int",
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "ares_socklen_t",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct ares_addrinfo_node"
          },
          "ares_addrinfo_node",
          [
            1059,
            0
          ],
          [
            1068,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1066,
            2
          ],
          [
            1066,
            17
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            1067,
            2
          ],
          [
            1067,
            27
          ]
        ],
        [
          "struct ares_addrinfo_cname {\n  int                         ttl;\n  char                       *alias;\n  char                       *name;\n  struct ares_addrinfo_cname *next;\n}",
          {
            "ttl": "int",
            "*alias": "char",
            "*name": "char",
            "*next": "struct ares_addrinfo_cname"
          },
          "ares_addrinfo_cname",
          [
            1075,
            0
          ],
          [
            1080,
            1
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            1079,
            2
          ],
          [
            1079,
            28
          ]
        ],
        [
          "struct ares_addrinfo {\n  struct ares_addrinfo_cname *cnames;\n  struct ares_addrinfo_node  *nodes;\n  char                       *name;\n}",
          {
            "*cnames": "struct ares_addrinfo_cname",
            "*nodes": "struct ares_addrinfo_node",
            "*name": "char"
          },
          "ares_addrinfo",
          [
            1082,
            0
          ],
          [
            1086,
            1
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            1083,
            2
          ],
          [
            1083,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            1084,
            2
          ],
          [
            1084,
            27
          ]
        ],
        [
          "struct ares_addrinfo_hints {\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int"
          },
          "ares_addrinfo_hints",
          [
            1088,
            0
          ],
          [
            1093,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            1104,
            39
          ],
          [
            1104,
            53
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            1105,
            2
          ],
          [
            1105,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            1108,
            39
          ],
          [
            1108,
            53
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            1109,
            2
          ],
          [
            1109,
            22
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            1112,
            39
          ],
          [
            1112,
            60
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            1116,
            14
          ],
          [
            1116,
            28
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            1119,
            39
          ],
          [
            1119,
            53
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            1122,
            39
          ],
          [
            1122,
            60
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            1125,
            39
          ],
          [
            1125,
            59
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            1128,
            39
          ],
          [
            1128,
            60
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            1131,
            39
          ],
          [
            1131,
            58
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            1134,
            39
          ],
          [
            1134,
            62
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            1137,
            39
          ],
          [
            1137,
            60
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            1140,
            39
          ],
          [
            1140,
            60
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            1144,
            43
          ],
          [
            1144,
            57
          ]
        ],
        [
          "struct ares_addr_node {\n  struct ares_addr_node *next;\n  int                    family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n}",
          {
            "*next": "struct ares_addr_node",
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr"
          },
          "ares_addr_node",
          [
            1150,
            0
          ],
          [
            1158,
            1
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1151,
            2
          ],
          [
            1151,
            23
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1155,
            4
          ],
          [
            1155,
            18
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            1156,
            4
          ],
          [
            1156,
            24
          ]
        ],
        [
          "struct ares_addr_port_node {\n  struct ares_addr_port_node *next;\n  int                         family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n\n  int udp_port;\n  int tcp_port;\n}",
          {
            "*next": "struct ares_addr_port_node",
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr",
            "udp_port": "int",
            "tcp_port": "int"
          },
          "ares_addr_port_node",
          [
            1160,
            0
          ],
          [
            1171,
            1
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1161,
            2
          ],
          [
            1161,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1165,
            4
          ],
          [
            1165,
            18
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            1166,
            4
          ],
          [
            1166,
            24
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1174,
            33
          ],
          [
            1174,
            54
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1179,
            48
          ],
          [
            1179,
            74
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1189,
            33
          ],
          [
            1189,
            54
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1194,
            50
          ],
          [
            1194,
            76
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_version.h\" /* c-ares version defines   */\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_build.h\"   /* c-ares build definitions */\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <sys/select.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include <winsock2.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#  include <ws2tcpip.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ],
        [
          "#  include <sys/select.h>\n",
          [
            77,
            0
          ],
          [
            78,
            0
          ]
        ],
        [
          "#  include <sys/bsdskt.h>\n",
          [
            81,
            0
          ],
          [
            82,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            85,
            0
          ],
          [
            86,
            0
          ]
        ],
        [
          "#  include <tcp.h>\n",
          [
            89,
            0
          ],
          [
            90,
            0
          ]
        ],
        [
          "#  include <jni.h>\n",
          [
            93,
            0
          ],
          [
            94,
            0
          ]
        ],
        [
          "#include \"ares_dns_record.h\"\n",
          [
            434,
            0
          ],
          [
            435,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_SUCCESS = 0,\n\n  /* Server error codes (ARES_ENODATA indicates no relevant answer) */\n  ARES_ENODATA   = 1,\n  ARES_EFORMERR  = 2,\n  ARES_ESERVFAIL = 3,\n  ARES_ENOTFOUND = 4,\n  ARES_ENOTIMP   = 5,\n  ARES_EREFUSED  = 6,\n\n  /* Locally generated error codes */\n  ARES_EBADQUERY    = 7,\n  ARES_EBADNAME     = 8,\n  ARES_EBADFAMILY   = 9,\n  ARES_EBADRESP     = 10,\n  ARES_ECONNREFUSED = 11,\n  ARES_ETIMEOUT     = 12,\n  ARES_EOF          = 13,\n  ARES_EFILE        = 14,\n  ARES_ENOMEM       = 15,\n  ARES_EDESTRUCTION = 16,\n  ARES_EBADSTR      = 17,\n\n  /* ares_getnameinfo error codes */\n  ARES_EBADFLAGS = 18,\n\n  /* ares_getaddrinfo error codes */\n  ARES_ENONAME   = 19,\n  ARES_EBADHINTS = 20,\n\n  /* Uninitialized library error code */\n  ARES_ENOTINITIALIZED = 21, /* introduced in 1.7.0 */\n\n  /* ares_library_init error codes */\n  ARES_ELOADIPHLPAPI         = 22, /* introduced in 1.7.0 */\n  ARES_EADDRGETNETWORKPARAMS = 23, /* introduced in 1.7.0 */\n\n  /* More error codes */\n  ARES_ECANCELLED = 24, /* introduced in 1.7.0 */\n\n  /* More ares_getaddrinfo error codes */\n  ARES_ESERVICE = 25, /* ares_getaddrinfo() was passed a text service name that\n                       * is not recognized. introduced in 1.16.0 */\n\n  ARES_ENOSERVER = 26 /* No DNS servers were configured */\n} ares_status_t;",
          {
            "ARES_SUCCESS": "",
            "ARES_ENODATA": "",
            "ARES_EFORMERR": "",
            "ARES_ESERVFAIL": "",
            "ARES_ENOTFOUND": "",
            "ARES_ENOTIMP": "",
            "ARES_EREFUSED": "",
            "ARES_EBADQUERY": "",
            "ARES_EBADNAME": "",
            "ARES_EBADFAMILY": "",
            "ARES_EBADRESP": "",
            "ARES_ECONNREFUSED": "",
            "ARES_ETIMEOUT": "",
            "ARES_EOF": "",
            "ARES_EFILE": "",
            "ARES_ENOMEM": "",
            "ARES_EDESTRUCTION": "",
            "ARES_EBADSTR": "",
            "ARES_EBADFLAGS": "",
            "ARES_ENONAME": "",
            "ARES_EBADHINTS": "",
            "ARES_ENOTINITIALIZED": "",
            "ARES_ELOADIPHLPAPI": "",
            "ARES_EADDRGETNETWORKPARAMS": "",
            "ARES_ECANCELLED": "",
            "ARES_ESERVICE": "",
            "ARES_ENOSERVER": ""
          },
          "ares_status_t",
          [
            160,
            0
          ],
          [
            206,
            16
          ]
        ],
        [
          "typedef enum {\n  ARES_FALSE = 0,\n  ARES_TRUE  = 1\n} ares_bool_t;",
          {
            "ARES_FALSE": "",
            "ARES_TRUE": ""
          },
          "ares_bool_t",
          [
            208,
            0
          ],
          [
            211,
            14
          ]
        ],
        [
          "typedef enum {\n  /*! Default (best choice) event system */\n  ARES_EVSYS_DEFAULT = 0,\n  /*! Win32 IOCP/AFD_POLL event system */\n  ARES_EVSYS_WIN32 = 1,\n  /*! Linux epoll */\n  ARES_EVSYS_EPOLL = 2,\n  /*! BSD/MacOS kqueue */\n  ARES_EVSYS_KQUEUE = 3,\n  /*! POSIX poll() */\n  ARES_EVSYS_POLL = 4,\n  /*! last fallback on Unix-like systems, select() */\n  ARES_EVSYS_SELECT = 5\n} ares_evsys_t;",
          {
            "ARES_EVSYS_DEFAULT": "",
            "ARES_EVSYS_WIN32": "",
            "ARES_EVSYS_EPOLL": "",
            "ARES_EVSYS_KQUEUE": "",
            "ARES_EVSYS_POLL": "",
            "ARES_EVSYS_SELECT": ""
          },
          "ares_evsys_t",
          [
            214,
            0
          ],
          [
            227,
            15
          ]
        ],
        [
          "typedef enum {\n  /*! Strongly recommended to create sockets as non-blocking and set this\n   *  flag */\n  ARES_SOCKFUNC_FLAG_NONBLOCKING = 1 << 0\n} ares_sockfunc_flags_t;",
          {
            "ARES_SOCKFUNC_FLAG_NONBLOCKING": ""
          },
          "ares_sockfunc_flags_t",
          [
            584,
            0
          ],
          [
            588,
            24
          ]
        ],
        [
          "typedef enum {\n  /*! Set the send buffer size. Value is a pointer to an int. (SO_SNDBUF) */\n  ARES_SOCKET_OPT_SENDBUF_SIZE,\n  /*! Set the recv buffer size. Value is a pointer to an int. (SO_RCVBUF) */\n  ARES_SOCKET_OPT_RECVBUF_SIZE,\n  /*! Set the network interface to use as the source for communication.\n   *  Value is a C string. (SO_BINDTODEVICE) */\n  ARES_SOCKET_OPT_BIND_DEVICE,\n  /*! Enable TCP Fast Open.  Value is a pointer to an ares_bool_t.  On some\n   *  systems this could be a no-op if it is known it is on by default and\n   *  return success.  Other systems may be a no-op if known the system does\n   *  not support the feature and returns failure with errno set to ENOSYS or\n   *  WSASetLastError(WSAEOPNOTSUPP).\n   */\n  ARES_SOCKET_OPT_TCP_FASTOPEN\n} ares_socket_opt_t;",
          {
            "ARES_SOCKET_OPT_SENDBUF_SIZE": "",
            "ARES_SOCKET_OPT_RECVBUF_SIZE": "",
            "ARES_SOCKET_OPT_BIND_DEVICE": "",
            "ARES_SOCKET_OPT_TCP_FASTOPEN": ""
          },
          "ares_socket_opt_t",
          [
            592,
            0
          ],
          [
            607,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! Connect using TCP Fast Open */\n  ARES_SOCKET_CONN_TCP_FASTOPEN = 1 << 0\n} ares_socket_connect_flags_t;",
          {
            "ARES_SOCKET_CONN_TCP_FASTOPEN": ""
          },
          "ares_socket_connect_flags_t",
          [
            610,
            0
          ],
          [
            613,
            30
          ]
        ],
        [
          "typedef enum {\n  /*! Bind is for a TCP connection */\n  ARES_SOCKET_BIND_TCP = 1 << 0,\n  /*! Bind is for a client connection, not server */\n  ARES_SOCKET_BIND_CLIENT = 1 << 1\n} ares_socket_bind_flags_t;",
          {
            "ARES_SOCKET_BIND_TCP": "",
            "ARES_SOCKET_BIND_CLIENT": ""
          },
          "ares_socket_bind_flags_t",
          [
            616,
            0
          ],
          [
            621,
            27
          ]
        ],
        [
          "typedef enum {\n  ARES_FD_EVENT_NONE  = 0,      /*!< No events */\n  ARES_FD_EVENT_READ  = 1 << 0, /*!< Read event (including disconnect/error) */\n  ARES_FD_EVENT_WRITE = 1 << 1  /*!< Write event */\n} ares_fd_eventflag_t;",
          {
            "ARES_FD_EVENT_NONE": "",
            "ARES_FD_EVENT_READ": "",
            "ARES_FD_EVENT_WRITE": ""
          },
          "ares_fd_eventflag_t",
          [
            919,
            0
          ],
          [
            923,
            22
          ]
        ],
        [
          "typedef enum {\n  ARES_PROCESS_FLAG_NONE        = 0,     /*!< No flag value */\n  ARES_PROCESS_FLAG_SKIP_NON_FD = 1 << 0 /*!< skip any processing unrelated to\n                                          *   the file descriptor events passed\n                                          *    in */\n} ares_process_flag_t;",
          {
            "ARES_PROCESS_FLAG_NONE": "",
            "ARES_PROCESS_FLAG_SKIP_NON_FD": ""
          },
          "ares_process_flag_t",
          [
            933,
            0
          ],
          [
            938,
            22
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/include/ares_dns_record.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_rec_type_tostr(ares_dns_rec_type_t type)",
          "fn_dec_pos": [
            [
              429,
              25
            ],
            [
              429,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_tostr",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_class_tostr(ares_dns_class_t qclass)",
          "fn_dec_pos": [
            [
              436,
              25
            ],
            [
              436,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_tostr",
            "parameters": {
              "qclass": "ares_dns_class_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opcode_tostr(ares_dns_opcode_t opcode)",
          "fn_dec_pos": [
            [
              443,
              25
            ],
            [
              443,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_tostr",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_key_tostr(ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              450,
              25
            ],
            [
              450,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_tostr",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_section_tostr(ares_dns_section_t section)",
          "fn_dec_pos": [
            [
              457,
              25
            ],
            [
              457,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_tostr",
            "parameters": {
              "section": "ares_dns_section_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_class_fromstr(ares_dns_class_t *qclass,\n                                                const char       *str)",
          "fn_dec_pos": [
            [
              465,
              13
            ],
            [
              466,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_dns_class_fromstr",
            "parameters": {
              "qclass": "ares_dns_class_t",
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rec_type_fromstr(ares_dns_rec_type_t *qtype,\n                                                   const char          *str)",
          "fn_dec_pos": [
            [
              474,
              13
            ],
            [
              475,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_dns_rec_type_fromstr",
            "parameters": {
              "qtype": "ares_dns_rec_type_t",
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rcode_tostr(ares_dns_rcode_t rcode)",
          "fn_dec_pos": [
            [
              483,
              25
            ],
            [
              483,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_tostr",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_pton(const char       *ipaddr,\n                                       struct ares_addr *addr, size_t *out_len)",
          "fn_dec_pos": [
            [
              495,
              25
            ],
            [
              496,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_pton",
            "parameters": {
              "ipaddr": "char",
              "addr": "struct ares_addr",
              "out_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_addr_to_ptr(const struct ares_addr *addr)",
          "fn_dec_pos": [
            [
              503,
              25
            ],
            [
              503,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_addr_to_ptr",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opt_datatype_t\n  ares_dns_opt_get_datatype(ares_dns_rr_key_t key, unsigned short opt)",
          "fn_dec_pos": [
            [
              514,
              13
            ],
            [
              515,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_datatype_t\n  ares_dns_opt_get_datatype",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_opt_get_name(ares_dns_rr_key_t key,\n                                               unsigned short    opt)",
          "fn_dec_pos": [
            [
              524,
              25
            ],
            [
              525,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_keys(ares_dns_rec_type_t type, size_t *cnt)",
          "fn_dec_pos": [
            [
              536,
              2
            ],
            [
              536,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "cnt": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_datatype_t\n  ares_dns_rr_key_datatype(ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              543,
              13
            ],
            [
              544,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_datatype_t\n  ares_dns_rr_key_datatype",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rec_type_t\n  ares_dns_rr_key_to_rec_type(ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              551,
              13
            ],
            [
              552,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_t\n  ares_dns_rr_key_to_rec_type",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_create(ares_dns_record_t **dnsrec,\n                                                  unsigned short      id,\n                                                  unsigned short      flags,\n                                                  ares_dns_opcode_t   opcode,\n                                                  ares_dns_rcode_t    rcode)",
          "fn_dec_pos": [
            [
              585,
              13
            ],
            [
              589,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_create",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "id": "unsigned short",
              "flags": "unsigned short",
              "opcode": "ares_dns_opcode_t",
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_destroy(ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              595,
              27
            ],
            [
              595,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_destroy",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_get_id(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              603,
              2
            ],
            [
              603,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_id",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_record_set_id(ares_dns_record_t *dnsrec,\n                                                unsigned short     id)",
          "fn_dec_pos": [
            [
              611,
              13
            ],
            [
              612,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_dns_record_set_id",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "id": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_get_flags(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              620,
              2
            ],
            [
              620,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_flags",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opcode_t\n  ares_dns_record_get_opcode(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              627,
              13
            ],
            [
              628,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_t\n  ares_dns_record_get_opcode",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rcode_t\n  ares_dns_record_get_rcode(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              635,
              13
            ],
            [
              636,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_t\n  ares_dns_record_get_rcode",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_add(ares_dns_record_t  *dnsrec,\n                                                     const char         *name,\n                                                     ares_dns_rec_type_t qtype,\n                                                     ares_dns_class_t qclass)",
          "fn_dec_pos": [
            [
              647,
              13
            ],
            [
              650,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_query_add",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "name": "char",
              "qtype": "ares_dns_rec_type_t",
              "qclass": "ares_dns_class_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_set_name(\n  ares_dns_record_t *dnsrec, size_t idx, const char *name)",
          "fn_dec_pos": [
            [
              663,
              13
            ],
            [
              664,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_query_set_name",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "name": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_set_type(\n  ares_dns_record_t *dnsrec, size_t idx, ares_dns_rec_type_t qtype)",
          "fn_dec_pos": [
            [
              675,
              13
            ],
            [
              676,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_query_set_type",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "qtype": "ares_dns_rec_type_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_query_cnt(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              683,
              20
            ],
            [
              683,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_cnt",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_get(\n  const ares_dns_record_t *dnsrec, size_t idx, const char **name,\n  ares_dns_rec_type_t *qtype, ares_dns_class_t *qclass)",
          "fn_dec_pos": [
            [
              696,
              13
            ],
            [
              698,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_query_get",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "name": "char",
              "qtype": "ares_dns_rec_type_t",
              "qclass": "ares_dns_class_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_rr_cnt(const ares_dns_record_t *dnsrec,\n                                           ares_dns_section_t       sect)",
          "fn_dec_pos": [
            [
              706,
              20
            ],
            [
              707,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_cnt",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_add(\n  ares_dns_rr_t **rr_out, ares_dns_record_t *dnsrec, ares_dns_section_t sect,\n  const char *name, ares_dns_rec_type_t type, ares_dns_class_t rclass,\n  unsigned int ttl)",
          "fn_dec_pos": [
            [
              723,
              13
            ],
            [
              726,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_rr_add",
            "parameters": {
              "rr_out": "ares_dns_rr_t",
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "name": "char",
              "type": "ares_dns_rec_type_t",
              "rclass": "ares_dns_class_t",
              "ttl": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_rr_get(ares_dns_record_t *dnsrec,\n                                                   ares_dns_section_t sect,\n                                                   size_t             idx)",
          "fn_dec_pos": [
            [
              735,
              28
            ],
            [
              737,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_record_rr_get_const(const ares_dns_record_t *dnsrec,\n                               ares_dns_section_t sect, size_t idx)",
          "fn_dec_pos": [
            [
              747,
              2
            ],
            [
              748,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_del(ares_dns_record_t *dnsrec,\n                                                  ares_dns_section_t sect,\n                                                  size_t             idx)",
          "fn_dec_pos": [
            [
              758,
              13
            ],
            [
              760,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_rr_del",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_name(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              768,
              27
            ],
            [
              768,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_name",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rec_type_t ares_dns_rr_get_type(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              775,
              13
            ],
            [
              775,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_t ares_dns_rr_get_type",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_class_t    ares_dns_rr_get_class(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              782,
              13
            ],
            [
              782,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_t    ares_dns_rr_get_class",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_ttl(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              789,
              33
            ],
            [
              789,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_ttl",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t       ares_dns_rr_set_addr(ares_dns_rr_t        *dns_rr,\n                                                      ares_dns_rr_key_t     key,\n                                                      const struct in_addr *addr)",
          "fn_dec_pos": [
            [
              799,
              13
            ],
            [
              801,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t       ares_dns_rr_set_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "addr": "struct in_addr"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t\n  ares_dns_rr_set_addr6(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                        const struct ares_in6_addr *addr)",
          "fn_dec_pos": [
            [
              811,
              13
            ],
            [
              813,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t\n  ares_dns_rr_set_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "addr": "struct ares_in6_addr"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_str(ares_dns_rr_t    *dns_rr,\n                                               ares_dns_rr_key_t key,\n                                               const char       *val)",
          "fn_dec_pos": [
            [
              823,
              13
            ],
            [
              825,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u8(ares_dns_rr_t    *dns_rr,\n                                              ares_dns_rr_key_t key,\n                                              unsigned char     val)",
          "fn_dec_pos": [
            [
              835,
              13
            ],
            [
              837,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_u8",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u16(ares_dns_rr_t    *dns_rr,\n                                               ares_dns_rr_key_t key,\n                                               unsigned short    val)",
          "fn_dec_pos": [
            [
              847,
              13
            ],
            [
              849,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_u16",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u32(ares_dns_rr_t    *dns_rr,\n                                               ares_dns_rr_key_t key,\n                                               unsigned int      val)",
          "fn_dec_pos": [
            [
              859,
              13
            ],
            [
              861,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_u32",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_bin(ares_dns_rr_t       *dns_rr,\n                                               ares_dns_rr_key_t    key,\n                                               const unsigned char *val,\n                                               size_t               len)",
          "fn_dec_pos": [
            [
              872,
              13
            ],
            [
              875,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_add_abin(ares_dns_rr_t       *dns_rr,\n                                                ares_dns_rr_key_t    key,\n                                                const unsigned char *val,\n                                                size_t               len)",
          "fn_dec_pos": [
            [
              887,
              13
            ],
            [
              890,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_add_abin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_del_abin(ares_dns_rr_t    *dns_rr,\n                                                ares_dns_rr_key_t key,\n                                                size_t            idx)",
          "fn_dec_pos": [
            [
              901,
              13
            ],
            [
              903,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_del_abin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_opt(ares_dns_rr_t       *dns_rr,\n                                               ares_dns_rr_key_t    key,\n                                               unsigned short       opt,\n                                               const unsigned char *val,\n                                               size_t               val_len)",
          "fn_dec_pos": [
            [
              914,
              13
            ],
            [
              918,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_opt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_del_opt_byid(ares_dns_rr_t    *dns_rr,\n                                                    ares_dns_rr_key_t key,\n                                                    unsigned short    opt)",
          "fn_dec_pos": [
            [
              927,
              13
            ],
            [
              929,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_del_opt_byid",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_addr(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              939,
              2
            ],
            [
              939,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_addr6(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              949,
              2
            ],
            [
              949,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_str(const ares_dns_rr_t *dns_rr,\n                                                ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              958,
              28
            ],
            [
              959,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_u8(const ares_dns_rr_t *dns_rr,\n                                               ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              968,
              28
            ],
            [
              969,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u8",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_u16(const ares_dns_rr_t *dns_rr,\n                                                ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              978,
              28
            ],
            [
              979,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u16",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_u32(const ares_dns_rr_t *dns_rr,\n                                                ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              988,
              28
            ],
            [
              989,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u32",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_bin(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                      size_t *len)",
          "fn_dec_pos": [
            [
              1002,
              2
            ],
            [
              1003,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_abin_cnt(const ares_dns_rr_t *dns_rr,\n                                             ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              1012,
              20
            ],
            [
              1013,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_abin_cnt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_abin(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                       size_t idx, size_t *len)",
          "fn_dec_pos": [
            [
              1028,
              2
            ],
            [
              1029,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_abin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_opt_cnt(const ares_dns_rr_t *dns_rr,\n                                            ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              1038,
              20
            ],
            [
              1039,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt_cnt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_opt(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                      size_t idx, const unsigned char **val, size_t *val_len)",
          "fn_dec_pos": [
            [
              1055,
              2
            ],
            [
              1056,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t   ares_dns_rr_get_opt_byid(const ares_dns_rr_t  *dns_rr,\n                                                    ares_dns_rr_key_t     key,\n                                                    unsigned short        opt,\n                                                    const unsigned char **val,\n                                                    size_t *val_len)",
          "fn_dec_pos": [
            [
              1071,
              13
            ],
            [
              1075,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t   ares_dns_rr_get_opt_byid",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_parse(const unsigned char *buf,\n                                          size_t buf_len, unsigned int flags,\n                                          ares_dns_record_t **dnsrec)",
          "fn_dec_pos": [
            [
              1086,
              13
            ],
            [
              1088,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_parse",
            "parameters": {
              "buf": "unsigned char",
              "buf_len": "size_t",
              "flags": "unsigned int",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_write(const ares_dns_record_t *dnsrec,\n                                          unsigned char **buf, size_t *buf_len)",
          "fn_dec_pos": [
            [
              1098,
              13
            ],
            [
              1099,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_write",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "unsigned char",
              "buf_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_duplicate(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              1111,
              2
            ],
            [
              1111,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addr",
          {},
          "",
          [
            496,
            39
          ],
          [
            496,
            55
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            503,
            52
          ],
          [
            503,
            68
          ]
        ],
        [
          "struct ares_dns_rr",
          {},
          "",
          [
            555,
            0
          ],
          [
            555,
            18
          ]
        ],
        [
          "typedef struct ares_dns_rr ares_dns_rr_t;",
          {},
          "ares_dns_rr_t",
          [
            558,
            0
          ],
          [
            558,
            41
          ]
        ],
        [
          "struct ares_dns_qd",
          {},
          "",
          [
            561,
            0
          ],
          [
            561,
            18
          ]
        ],
        [
          "typedef struct ares_dns_qd ares_dns_qd_t;",
          {},
          "ares_dns_qd_t",
          [
            564,
            0
          ],
          [
            564,
            41
          ]
        ],
        [
          "struct ares_dns_record",
          {},
          "",
          [
            567,
            0
          ],
          [
            567,
            22
          ]
        ],
        [
          "typedef struct ares_dns_record ares_dns_record_t;",
          {},
          "ares_dns_record_t",
          [
            570,
            0
          ],
          [
            570,
            49
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            801,
            60
          ],
          [
            801,
            74
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            813,
            30
          ],
          [
            813,
            50
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_REC_TYPE_A     = 1,     /*!< Host address. */\n  ARES_REC_TYPE_NS    = 2,     /*!< Authoritative server. */\n  ARES_REC_TYPE_CNAME = 5,     /*!< Canonical name. */\n  ARES_REC_TYPE_SOA   = 6,     /*!< Start of authority zone. */\n  ARES_REC_TYPE_PTR   = 12,    /*!< Domain name pointer. */\n  ARES_REC_TYPE_HINFO = 13,    /*!< Host information. */\n  ARES_REC_TYPE_MX    = 15,    /*!< Mail routing information. */\n  ARES_REC_TYPE_TXT   = 16,    /*!< Text strings. */\n  ARES_REC_TYPE_SIG   = 24,    /*!< RFC 2535 / RFC 2931. SIG Record */\n  ARES_REC_TYPE_AAAA  = 28,    /*!< RFC 3596. Ip6 Address. */\n  ARES_REC_TYPE_SRV   = 33,    /*!< RFC 2782. Server Selection. */\n  ARES_REC_TYPE_NAPTR = 35,    /*!< RFC 3403. Naming Authority Pointer */\n  ARES_REC_TYPE_OPT   = 41,    /*!< RFC 6891. EDNS0 option (meta-RR) */\n\n  ARES_REC_TYPE_TLSA = 52,     /*!< RFC 6698. DNS-Based Authentication of Named\n                                *   Entities (DANE) Transport Layer Security\n                                *   (TLS) Protocol: TLSA */\n  ARES_REC_TYPE_SVCB  = 64,    /*!< RFC 9460. General Purpose Service Binding */\n  ARES_REC_TYPE_HTTPS = 65,    /*!< RFC 9460. Service Binding type for use with\n                                *   HTTPS */\n  ARES_REC_TYPE_ANY = 255,     /*!< Wildcard match.  Not response RR. */\n  ARES_REC_TYPE_URI = 256,     /*!< RFC 7553. Uniform Resource Identifier */\n  ARES_REC_TYPE_CAA = 257,     /*!< RFC 6844. Certification Authority\n                                *   Authorization. */\n  ARES_REC_TYPE_RAW_RR = 65536 /*!< Used as an indicator that the RR record\n                                *   is not parsed, but provided in wire\n                                *   format */\n} ares_dns_rec_type_t;",
          {
            "ARES_REC_TYPE_A": "",
            "ARES_REC_TYPE_NS": "",
            "ARES_REC_TYPE_CNAME": "",
            "ARES_REC_TYPE_SOA": "",
            "ARES_REC_TYPE_PTR": "",
            "ARES_REC_TYPE_HINFO": "",
            "ARES_REC_TYPE_MX": "",
            "ARES_REC_TYPE_TXT": "",
            "ARES_REC_TYPE_SIG": "",
            "ARES_REC_TYPE_AAAA": "",
            "ARES_REC_TYPE_SRV": "",
            "ARES_REC_TYPE_NAPTR": "",
            "ARES_REC_TYPE_OPT": "",
            "ARES_REC_TYPE_TLSA": "",
            "ARES_REC_TYPE_SVCB": "",
            "ARES_REC_TYPE_HTTPS": "",
            "ARES_REC_TYPE_ANY": "",
            "ARES_REC_TYPE_URI": "",
            "ARES_REC_TYPE_CAA": "",
            "ARES_REC_TYPE_RAW_RR": ""
          },
          "ares_dns_rec_type_t",
          [
            44,
            0
          ],
          [
            72,
            22
          ]
        ],
        [
          "typedef enum {\n  ARES_CLASS_IN     = 1,   /*!< Internet */\n  ARES_CLASS_CHAOS  = 3,   /*!< CHAOS */\n  ARES_CLASS_HESOID = 4,   /*!< Hesoid [Dyer 87] */\n  ARES_CLASS_NONE   = 254, /*!< RFC 2136 */\n  ARES_CLASS_ANY    = 255  /*!< Any class (requests only) */\n} ares_dns_class_t;",
          {
            "ARES_CLASS_IN": "",
            "ARES_CLASS_CHAOS": "",
            "ARES_CLASS_HESOID": "",
            "ARES_CLASS_NONE": "",
            "ARES_CLASS_ANY": ""
          },
          "ares_dns_class_t",
          [
            75,
            0
          ],
          [
            81,
            19
          ]
        ],
        [
          "typedef enum {\n  ARES_SECTION_ANSWER     = 1, /*!< Answer section */\n  ARES_SECTION_AUTHORITY  = 2, /*!< Authority section */\n  ARES_SECTION_ADDITIONAL = 3  /*!< Additional information section */\n} ares_dns_section_t;",
          {
            "ARES_SECTION_ANSWER": "",
            "ARES_SECTION_AUTHORITY": "",
            "ARES_SECTION_ADDITIONAL": ""
          },
          "ares_dns_section_t",
          [
            84,
            0
          ],
          [
            88,
            21
          ]
        ],
        [
          "typedef enum {\n  ARES_OPCODE_QUERY  = 0, /*!< Standard query */\n  ARES_OPCODE_IQUERY = 1, /*!< Inverse query. Obsolete. */\n  ARES_OPCODE_STATUS = 2, /*!< Name server status query */\n  ARES_OPCODE_NOTIFY = 4, /*!< Zone change notification (RFC 1996) */\n  ARES_OPCODE_UPDATE = 5  /*!< Zone update message (RFC2136) */\n} ares_dns_opcode_t;",
          {
            "ARES_OPCODE_QUERY": "",
            "ARES_OPCODE_IQUERY": "",
            "ARES_OPCODE_STATUS": "",
            "ARES_OPCODE_NOTIFY": "",
            "ARES_OPCODE_UPDATE": ""
          },
          "ares_dns_opcode_t",
          [
            91,
            0
          ],
          [
            97,
            20
          ]
        ],
        [
          "typedef enum {\n  ARES_FLAG_QR = 1 << 0, /*!< QR. If set, is a response */\n  ARES_FLAG_AA = 1 << 1, /*!< Authoritative Answer. If set, is authoritative */\n  ARES_FLAG_TC = 1 << 2, /*!< Truncation. If set, is truncated response */\n  ARES_FLAG_RD = 1 << 3, /*!< Recursion Desired. If set, recursion is desired */\n  ARES_FLAG_RA = 1 << 4, /*!< Recursion Available. If set, server supports\n                          *   recursion */\n  ARES_FLAG_AD = 1 << 5, /*!< RFC 2065. Authentic Data bit indicates in a\n                          * response that the data included has been verified by\n                          * the server providing it */\n  ARES_FLAG_CD = 1 << 6  /*!< RFC 2065. Checking Disabled bit indicates in a\n                          * query that non-verified data is acceptable to the\n                          * resolver sending the query. */\n} ares_dns_flags_t;",
          {
            "ARES_FLAG_QR": "",
            "ARES_FLAG_AA": "",
            "ARES_FLAG_TC": "",
            "ARES_FLAG_RD": "",
            "ARES_FLAG_RA": "",
            "ARES_FLAG_AD": "",
            "ARES_FLAG_CD": ""
          },
          "ares_dns_flags_t",
          [
            100,
            0
          ],
          [
            113,
            19
          ]
        ],
        [
          "typedef enum {\n  ARES_RCODE_NOERROR = 0,    /*!< Success */\n  ARES_RCODE_FORMERR = 1,    /*!< Format error. The name server was unable\n                              *   to interpret the query. */\n  ARES_RCODE_SERVFAIL = 2,   /*!< Server Failure. The name server was\n                              *   unable to process this query due to a\n                              *   problem with the nameserver */\n  ARES_RCODE_NXDOMAIN = 3,   /*!< Name Error.  Meaningful only for\n                              *   responses from an authoritative name\n                              *   server, this code signifies that the\n                              *   domain name referenced in the query does\n                              *   not exist. */\n  ARES_RCODE_NOTIMP = 4,     /*!< Not implemented.  The name server does\n                              *   not support the requested kind of\n                              *   query */\n  ARES_RCODE_REFUSED = 5,    /*!< Refused. The name server refuses to\n                              *   perform the specified operation for\n                              *   policy reasons. */\n  ARES_RCODE_YXDOMAIN = 6,   /*!< RFC 2136. Some name that ought not to\n                              *   exist, does exist. */\n  ARES_RCODE_YXRRSET = 7,    /*!< RFC 2136. Some RRset that ought to not\n                              *   exist, does exist. */\n  ARES_RCODE_NXRRSET = 8,    /*!< RFC 2136. Some RRset that ought to exist,\n                              *   does not exist. */\n  ARES_RCODE_NOTAUTH = 9,    /*!< RFC 2136. The server is not authoritative\n                              *   for the zone named in the Zone section.\n                              */\n  ARES_RCODE_NOTZONE = 10,   /*!< RFC 2136. A name used in the Prerequisite\n                              *   or Update Section is not within the zone\n                              *   denoted by the Zone Section. */\n  ARES_RCODE_DSOTYPEI  = 11, /*!< RFC 8409. DSO-TYPE Not implemented */\n  ARES_RCODE_BADSIG    = 16, /*!< RFC 8945. TSIG Signature Failure */\n  ARES_RCODE_BADKEY    = 17, /*!< RFC 8945. Key not recognized. */\n  ARES_RCODE_BADTIME   = 18, /*!< RFC 8945. Signature out of time window. */\n  ARES_RCODE_BADMODE   = 19, /*!< RFC 2930. Bad TKEY Mode */\n  ARES_RCODE_BADNAME   = 20, /*!< RFC 2930. Duplicate Key Name */\n  ARES_RCODE_BADALG    = 21, /*!< RFC 2930. Algorithm not supported */\n  ARES_RCODE_BADTRUNC  = 22, /*!< RFC 8945. Bad Truncation */\n  ARES_RCODE_BADCOOKIE = 23  /*!< RFC 7873. Bad/missing Server Cookie */\n} ares_dns_rcode_t;",
          {
            "ARES_RCODE_NOERROR": "",
            "ARES_RCODE_FORMERR": "",
            "ARES_RCODE_SERVFAIL": "",
            "ARES_RCODE_NXDOMAIN": "",
            "ARES_RCODE_NOTIMP": "",
            "ARES_RCODE_REFUSED": "",
            "ARES_RCODE_YXDOMAIN": "",
            "ARES_RCODE_YXRRSET": "",
            "ARES_RCODE_NXRRSET": "",
            "ARES_RCODE_NOTAUTH": "",
            "ARES_RCODE_NOTZONE": "",
            "ARES_RCODE_DSOTYPEI": "",
            "ARES_RCODE_BADSIG": "",
            "ARES_RCODE_BADKEY": "",
            "ARES_RCODE_BADTIME": "",
            "ARES_RCODE_BADMODE": "",
            "ARES_RCODE_BADNAME": "",
            "ARES_RCODE_BADALG": "",
            "ARES_RCODE_BADTRUNC": "",
            "ARES_RCODE_BADCOOKIE": ""
          },
          "ares_dns_rcode_t",
          [
            116,
            0
          ],
          [
            155,
            19
          ]
        ],
        [
          "typedef enum {\n  ARES_DATATYPE_INADDR  = 1, /*!< struct in_addr * type */\n  ARES_DATATYPE_INADDR6 = 2, /*!< struct ares_in6_addr * type */\n  ARES_DATATYPE_U8      = 3, /*!< 8bit unsigned integer */\n  ARES_DATATYPE_U16     = 4, /*!< 16bit unsigned integer */\n  ARES_DATATYPE_U32     = 5, /*!< 32bit unsigned integer */\n  ARES_DATATYPE_NAME    = 6, /*!< Null-terminated string of a domain name */\n  ARES_DATATYPE_STR     = 7, /*!< Null-terminated string */\n  ARES_DATATYPE_BIN     = 8, /*!< Binary data */\n  ARES_DATATYPE_BINP    = 9, /*!< Officially defined as binary data, but likely\n                              *   printable. Guaranteed to have a NULL\n                              *   terminator for convenience (not included in\n                              *   length) */\n  ARES_DATATYPE_OPT = 10,    /*!< Array of options.  16bit identifier, BIN\n                              *   data. */\n  ARES_DATATYPE_ABINP = 11   /*!< Array of binary data, likely printable.\n                              *   Guaranteed to have a NULL terminator for\n                              *   convenience (not included in length) */\n} ares_dns_datatype_t;",
          {
            "ARES_DATATYPE_INADDR": "",
            "ARES_DATATYPE_INADDR6": "",
            "ARES_DATATYPE_U8": "",
            "ARES_DATATYPE_U16": "",
            "ARES_DATATYPE_U32": "",
            "ARES_DATATYPE_NAME": "",
            "ARES_DATATYPE_STR": "",
            "ARES_DATATYPE_BIN": "",
            "ARES_DATATYPE_BINP": "",
            "ARES_DATATYPE_OPT": "",
            "ARES_DATATYPE_ABINP": ""
          },
          "ares_dns_datatype_t",
          [
            158,
            0
          ],
          [
            176,
            22
          ]
        ],
        [
          "typedef enum {\n  /*! A Record. Address. Datatype: INADDR */\n  ARES_RR_A_ADDR = (ARES_REC_TYPE_A * 100) + 1,\n  /*! NS Record. Name. Datatype: NAME */\n  ARES_RR_NS_NSDNAME = (ARES_REC_TYPE_NS * 100) + 1,\n  /*! CNAME Record. CName. Datatype: NAME */\n  ARES_RR_CNAME_CNAME = (ARES_REC_TYPE_CNAME * 100) + 1,\n  /*! SOA Record. MNAME, Primary Source of Data. Datatype: NAME */\n  ARES_RR_SOA_MNAME = (ARES_REC_TYPE_SOA * 100) + 1,\n  /*! SOA Record. RNAME, Mailbox of person responsible. Datatype: NAME */\n  ARES_RR_SOA_RNAME = (ARES_REC_TYPE_SOA * 100) + 2,\n  /*! SOA Record. Serial, version. Datatype: U32 */\n  ARES_RR_SOA_SERIAL = (ARES_REC_TYPE_SOA * 100) + 3,\n  /*! SOA Record. Refresh, zone refersh interval. Datatype: U32 */\n  ARES_RR_SOA_REFRESH = (ARES_REC_TYPE_SOA * 100) + 4,\n  /*! SOA Record. Retry, failed refresh retry interval. Datatype: U32 */\n  ARES_RR_SOA_RETRY = (ARES_REC_TYPE_SOA * 100) + 5,\n  /*! SOA Record. Expire, upper limit on authority. Datatype: U32 */\n  ARES_RR_SOA_EXPIRE = (ARES_REC_TYPE_SOA * 100) + 6,\n  /*! SOA Record. Minimum, RR TTL. Datatype: U32 */\n  ARES_RR_SOA_MINIMUM = (ARES_REC_TYPE_SOA * 100) + 7,\n  /*! PTR Record. DNAME, pointer domain. Datatype: NAME */\n  ARES_RR_PTR_DNAME = (ARES_REC_TYPE_PTR * 100) + 1,\n  /*! HINFO Record. CPU. Datatype: STR */\n  ARES_RR_HINFO_CPU = (ARES_REC_TYPE_HINFO * 100) + 1,\n  /*! HINFO Record. OS. Datatype: STR */\n  ARES_RR_HINFO_OS = (ARES_REC_TYPE_HINFO * 100) + 2,\n  /*! MX Record. Preference. Datatype: U16 */\n  ARES_RR_MX_PREFERENCE = (ARES_REC_TYPE_MX * 100) + 1,\n  /*! MX Record. Exchange, domain. Datatype: NAME */\n  ARES_RR_MX_EXCHANGE = (ARES_REC_TYPE_MX * 100) + 2,\n  /*! TXT Record. Data. Datatype: ABINP */\n  ARES_RR_TXT_DATA = (ARES_REC_TYPE_TXT * 100) + 1,\n  /*! SIG Record. Type Covered. Datatype: U16 */\n  ARES_RR_SIG_TYPE_COVERED = (ARES_REC_TYPE_SIG * 100) + 1,\n  /*! SIG Record. Algorithm. Datatype: U8 */\n  ARES_RR_SIG_ALGORITHM = (ARES_REC_TYPE_SIG * 100) + 2,\n  /*! SIG Record. Labels. Datatype: U8 */\n  ARES_RR_SIG_LABELS = (ARES_REC_TYPE_SIG * 100) + 3,\n  /*! SIG Record. Original TTL. Datatype: U32 */\n  ARES_RR_SIG_ORIGINAL_TTL = (ARES_REC_TYPE_SIG * 100) + 4,\n  /*! SIG Record. Signature Expiration. Datatype: U32 */\n  ARES_RR_SIG_EXPIRATION = (ARES_REC_TYPE_SIG * 100) + 5,\n  /*! SIG Record. Signature Inception. Datatype: U32 */\n  ARES_RR_SIG_INCEPTION = (ARES_REC_TYPE_SIG * 100) + 6,\n  /*! SIG Record. Key Tag. Datatype: U16 */\n  ARES_RR_SIG_KEY_TAG = (ARES_REC_TYPE_SIG * 100) + 7,\n  /*! SIG Record. Signers Name. Datatype: NAME */\n  ARES_RR_SIG_SIGNERS_NAME = (ARES_REC_TYPE_SIG * 100) + 8,\n  /*! SIG Record. Signature. Datatype: BIN */\n  ARES_RR_SIG_SIGNATURE = (ARES_REC_TYPE_SIG * 100) + 9,\n  /*! AAAA Record. Address. Datatype: INADDR6 */\n  ARES_RR_AAAA_ADDR = (ARES_REC_TYPE_AAAA * 100) + 1,\n  /*! SRV Record. Priority. Datatype: U16 */\n  ARES_RR_SRV_PRIORITY = (ARES_REC_TYPE_SRV * 100) + 2,\n  /*! SRV Record. Weight. Datatype: U16 */\n  ARES_RR_SRV_WEIGHT = (ARES_REC_TYPE_SRV * 100) + 3,\n  /*! SRV Record. Port. Datatype: U16 */\n  ARES_RR_SRV_PORT = (ARES_REC_TYPE_SRV * 100) + 4,\n  /*! SRV Record. Target domain. Datatype: NAME */\n  ARES_RR_SRV_TARGET = (ARES_REC_TYPE_SRV * 100) + 5,\n  /*! NAPTR Record. Order. Datatype: U16 */\n  ARES_RR_NAPTR_ORDER = (ARES_REC_TYPE_NAPTR * 100) + 1,\n  /*! NAPTR Record. Preference. Datatype: U16 */\n  ARES_RR_NAPTR_PREFERENCE = (ARES_REC_TYPE_NAPTR * 100) + 2,\n  /*! NAPTR Record. Flags. Datatype: STR */\n  ARES_RR_NAPTR_FLAGS = (ARES_REC_TYPE_NAPTR * 100) + 3,\n  /*! NAPTR Record. Services. Datatype: STR */\n  ARES_RR_NAPTR_SERVICES = (ARES_REC_TYPE_NAPTR * 100) + 4,\n  /*! NAPTR Record. Regexp. Datatype: STR */\n  ARES_RR_NAPTR_REGEXP = (ARES_REC_TYPE_NAPTR * 100) + 5,\n  /*! NAPTR Record. Replacement. Datatype: NAME */\n  ARES_RR_NAPTR_REPLACEMENT = (ARES_REC_TYPE_NAPTR * 100) + 6,\n  /*! OPT Record. UDP Size. Datatype: U16 */\n  ARES_RR_OPT_UDP_SIZE = (ARES_REC_TYPE_OPT * 100) + 1,\n  /*! OPT Record. Version. Datatype: U8 */\n  ARES_RR_OPT_VERSION = (ARES_REC_TYPE_OPT * 100) + 3,\n  /*! OPT Record. Flags. Datatype: U16 */\n  ARES_RR_OPT_FLAGS = (ARES_REC_TYPE_OPT * 100) + 4,\n  /*! OPT Record. Options. Datatype: OPT */\n  ARES_RR_OPT_OPTIONS = (ARES_REC_TYPE_OPT * 100) + 5,\n  /*! TLSA Record. Certificate Usage. Datatype: U8 */\n  ARES_RR_TLSA_CERT_USAGE = (ARES_REC_TYPE_TLSA * 100) + 1,\n  /*! TLSA Record. Selector. Datatype: U8 */\n  ARES_RR_TLSA_SELECTOR = (ARES_REC_TYPE_TLSA * 100) + 2,\n  /*! TLSA Record. Matching Type. Datatype: U8 */\n  ARES_RR_TLSA_MATCH = (ARES_REC_TYPE_TLSA * 100) + 3,\n  /*! TLSA Record. Certificate Association Data. Datatype: BIN */\n  ARES_RR_TLSA_DATA = (ARES_REC_TYPE_TLSA * 100) + 4,\n  /*! SVCB Record. SvcPriority. Datatype: U16 */\n  ARES_RR_SVCB_PRIORITY = (ARES_REC_TYPE_SVCB * 100) + 1,\n  /*! SVCB Record. TargetName. Datatype: NAME */\n  ARES_RR_SVCB_TARGET = (ARES_REC_TYPE_SVCB * 100) + 2,\n  /*! SVCB Record. SvcParams. Datatype: OPT */\n  ARES_RR_SVCB_PARAMS = (ARES_REC_TYPE_SVCB * 100) + 3,\n  /*! HTTPS Record. SvcPriority. Datatype: U16 */\n  ARES_RR_HTTPS_PRIORITY = (ARES_REC_TYPE_HTTPS * 100) + 1,\n  /*! HTTPS Record. TargetName. Datatype: NAME */\n  ARES_RR_HTTPS_TARGET = (ARES_REC_TYPE_HTTPS * 100) + 2,\n  /*! HTTPS Record. SvcParams. Datatype: OPT */\n  ARES_RR_HTTPS_PARAMS = (ARES_REC_TYPE_HTTPS * 100) + 3,\n  /*! URI Record. Priority. Datatype: U16 */\n  ARES_RR_URI_PRIORITY = (ARES_REC_TYPE_URI * 100) + 1,\n  /*! URI Record. Weight. Datatype: U16 */\n  ARES_RR_URI_WEIGHT = (ARES_REC_TYPE_URI * 100) + 2,\n  /*! URI Record. Target domain. Datatype: NAME */\n  ARES_RR_URI_TARGET = (ARES_REC_TYPE_URI * 100) + 3,\n  /*! CAA Record. Critical flag. Datatype: U8 */\n  ARES_RR_CAA_CRITICAL = (ARES_REC_TYPE_CAA * 100) + 1,\n  /*! CAA Record. Tag/Property. Datatype: STR */\n  ARES_RR_CAA_TAG = (ARES_REC_TYPE_CAA * 100) + 2,\n  /*! CAA Record. Value. Datatype: BINP */\n  ARES_RR_CAA_VALUE = (ARES_REC_TYPE_CAA * 100) + 3,\n  /*! RAW Record. RR Type. Datatype: U16 */\n  ARES_RR_RAW_RR_TYPE = (ARES_REC_TYPE_RAW_RR * 100) + 1,\n  /*! RAW Record. RR Data. Datatype: BIN */\n  ARES_RR_RAW_RR_DATA = (ARES_REC_TYPE_RAW_RR * 100) + 2\n} ares_dns_rr_key_t;",
          {
            "ARES_RR_A_ADDR": "",
            "ARES_RR_NS_NSDNAME": "",
            "ARES_RR_CNAME_CNAME": "",
            "ARES_RR_SOA_MNAME": "",
            "ARES_RR_SOA_RNAME": "",
            "ARES_RR_SOA_SERIAL": "",
            "ARES_RR_SOA_REFRESH": "",
            "ARES_RR_SOA_RETRY": "",
            "ARES_RR_SOA_EXPIRE": "",
            "ARES_RR_SOA_MINIMUM": "",
            "ARES_RR_PTR_DNAME": "",
            "ARES_RR_HINFO_CPU": "",
            "ARES_RR_HINFO_OS": "",
            "ARES_RR_MX_PREFERENCE": "",
            "ARES_RR_MX_EXCHANGE": "",
            "ARES_RR_TXT_DATA": "",
            "ARES_RR_SIG_TYPE_COVERED": "",
            "ARES_RR_SIG_ALGORITHM": "",
            "ARES_RR_SIG_LABELS": "",
            "ARES_RR_SIG_ORIGINAL_TTL": "",
            "ARES_RR_SIG_EXPIRATION": "",
            "ARES_RR_SIG_INCEPTION": "",
            "ARES_RR_SIG_KEY_TAG": "",
            "ARES_RR_SIG_SIGNERS_NAME": "",
            "ARES_RR_SIG_SIGNATURE": "",
            "ARES_RR_AAAA_ADDR": "",
            "ARES_RR_SRV_PRIORITY": "",
            "ARES_RR_SRV_WEIGHT": "",
            "ARES_RR_SRV_PORT": "",
            "ARES_RR_SRV_TARGET": "",
            "ARES_RR_NAPTR_ORDER": "",
            "ARES_RR_NAPTR_PREFERENCE": "",
            "ARES_RR_NAPTR_FLAGS": "",
            "ARES_RR_NAPTR_SERVICES": "",
            "ARES_RR_NAPTR_REGEXP": "",
            "ARES_RR_NAPTR_REPLACEMENT": "",
            "ARES_RR_OPT_UDP_SIZE": "",
            "ARES_RR_OPT_VERSION": "",
            "ARES_RR_OPT_FLAGS": "",
            "ARES_RR_OPT_OPTIONS": "",
            "ARES_RR_TLSA_CERT_USAGE": "",
            "ARES_RR_TLSA_SELECTOR": "",
            "ARES_RR_TLSA_MATCH": "",
            "ARES_RR_TLSA_DATA": "",
            "ARES_RR_SVCB_PRIORITY": "",
            "ARES_RR_SVCB_TARGET": "",
            "ARES_RR_SVCB_PARAMS": "",
            "ARES_RR_HTTPS_PRIORITY": "",
            "ARES_RR_HTTPS_TARGET": "",
            "ARES_RR_HTTPS_PARAMS": "",
            "ARES_RR_URI_PRIORITY": "",
            "ARES_RR_URI_WEIGHT": "",
            "ARES_RR_URI_TARGET": "",
            "ARES_RR_CAA_CRITICAL": "",
            "ARES_RR_CAA_TAG": "",
            "ARES_RR_CAA_VALUE": "",
            "ARES_RR_RAW_RR_TYPE": "",
            "ARES_RR_RAW_RR_DATA": ""
          },
          "ares_dns_rr_key_t",
          [
            181,
            0
          ],
          [
            298,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! Certificate Usage 0. CA Constraint. */\n  ARES_TLSA_USAGE_CA = 0,\n  /*! Certificate Usage 1. Service Certificate Constraint. */\n  ARES_TLSA_USAGE_SERVICE = 1,\n  /*! Certificate Usage 2. Trust Anchor Assertion. */\n  ARES_TLSA_USAGE_TRUSTANCHOR = 2,\n  /*! Certificate Usage 3. Domain-issued certificate. */\n  ARES_TLSA_USAGE_DOMAIN = 3\n} ares_tlsa_usage_t;",
          {
            "ARES_TLSA_USAGE_CA": "",
            "ARES_TLSA_USAGE_SERVICE": "",
            "ARES_TLSA_USAGE_TRUSTANCHOR": "",
            "ARES_TLSA_USAGE_DOMAIN": ""
          },
          "ares_tlsa_usage_t",
          [
            301,
            0
          ],
          [
            310,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! Full Certificate */\n  ARES_TLSA_SELECTOR_FULL = 0,\n  /*! DER-encoded SubjectPublicKeyInfo */\n  ARES_TLSA_SELECTOR_SUBJPUBKEYINFO = 1\n} ares_tlsa_selector_t;",
          {
            "ARES_TLSA_SELECTOR_FULL": "",
            "ARES_TLSA_SELECTOR_SUBJPUBKEYINFO": ""
          },
          "ares_tlsa_selector_t",
          [
            313,
            0
          ],
          [
            318,
            23
          ]
        ],
        [
          "typedef enum {\n  /*! Exact match */\n  ARES_TLSA_MATCH_EXACT = 0,\n  /*! Sha256 match */\n  ARES_TLSA_MATCH_SHA256 = 1,\n  /*! Sha512 match */\n  ARES_TLSA_MATCH_SHA512 = 2\n} ares_tlsa_match_t;",
          {
            "ARES_TLSA_MATCH_EXACT": "",
            "ARES_TLSA_MATCH_SHA256": "",
            "ARES_TLSA_MATCH_SHA512": ""
          },
          "ares_tlsa_match_t",
          [
            321,
            0
          ],
          [
            328,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! Mandatory keys in this RR (RFC 9460 Section 8) */\n  ARES_SVCB_PARAM_MANDATORY = 0,\n  /*! Additional supported protocols (RFC 9460 Section 7.1) */\n  ARES_SVCB_PARAM_ALPN = 1,\n  /*! No support for default protocol (RFC 9460 Section 7.1) */\n  ARES_SVCB_PARAM_NO_DEFAULT_ALPN = 2,\n  /*! Port for alternative endpoint (RFC 9460 Section 7.2) */\n  ARES_SVCB_PARAM_PORT = 3,\n  /*! IPv4 address hints (RFC 9460 Section 7.3) */\n  ARES_SVCB_PARAM_IPV4HINT = 4,\n  /*! RESERVED (held for Encrypted ClientHello) */\n  ARES_SVCB_PARAM_ECH = 5,\n  /*! IPv6 address hints (RFC 9460 Section 7.3) */\n  ARES_SVCB_PARAM_IPV6HINT = 6\n} ares_svcb_param_t;",
          {
            "ARES_SVCB_PARAM_MANDATORY": "",
            "ARES_SVCB_PARAM_ALPN": "",
            "ARES_SVCB_PARAM_NO_DEFAULT_ALPN": "",
            "ARES_SVCB_PARAM_PORT": "",
            "ARES_SVCB_PARAM_IPV4HINT": "",
            "ARES_SVCB_PARAM_ECH": "",
            "ARES_SVCB_PARAM_IPV6HINT": ""
          },
          "ares_svcb_param_t",
          [
            331,
            0
          ],
          [
            346,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! RFC 8764. Apple's DNS Long-Lived Queries Protocol */\n  ARES_OPT_PARAM_LLQ = 1,\n  /*! http://files.dns-sd.org/draft-sekar-dns-ul.txt: Update Lease */\n  ARES_OPT_PARAM_UL = 2,\n  /*! RFC 5001. Name Server Identification */\n  ARES_OPT_PARAM_NSID = 3,\n  /*! RFC 6975. DNSSEC Algorithm Understood */\n  ARES_OPT_PARAM_DAU = 5,\n  /*! RFC 6975. DS Hash Understood */\n  ARES_OPT_PARAM_DHU = 6,\n  /*! RFC 6975. NSEC3 Hash Understood */\n  ARES_OPT_PARAM_N3U = 7,\n  /*! RFC 7871. Client Subnet */\n  ARES_OPT_PARAM_EDNS_CLIENT_SUBNET = 8,\n  /*! RFC 7314. Expire Timer */\n  ARES_OPT_PARAM_EDNS_EXPIRE = 9,\n  /*! RFC 7873. Client and Server Cookies */\n  ARES_OPT_PARAM_COOKIE = 10,\n  /*! RFC 7828. TCP Keepalive timeout */\n  ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE = 11,\n  /*! RFC 7830. Padding */\n  ARES_OPT_PARAM_PADDING = 12,\n  /*! RFC 7901. Chain query requests */\n  ARES_OPT_PARAM_CHAIN = 13,\n  /*! RFC 8145. Signaling Trust Anchor Knowledge in DNSSEC */\n  ARES_OPT_PARAM_EDNS_KEY_TAG = 14,\n  /*! RFC 8914. Extended ERROR code and message */\n  ARES_OPT_PARAM_EXTENDED_DNS_ERROR = 15\n} ares_opt_param_t;",
          {
            "ARES_OPT_PARAM_LLQ": "",
            "ARES_OPT_PARAM_UL": "",
            "ARES_OPT_PARAM_NSID": "",
            "ARES_OPT_PARAM_DAU": "",
            "ARES_OPT_PARAM_DHU": "",
            "ARES_OPT_PARAM_N3U": "",
            "ARES_OPT_PARAM_EDNS_CLIENT_SUBNET": "",
            "ARES_OPT_PARAM_EDNS_EXPIRE": "",
            "ARES_OPT_PARAM_COOKIE": "",
            "ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE": "",
            "ARES_OPT_PARAM_PADDING": "",
            "ARES_OPT_PARAM_CHAIN": "",
            "ARES_OPT_PARAM_EDNS_KEY_TAG": "",
            "ARES_OPT_PARAM_EXTENDED_DNS_ERROR": ""
          },
          "ares_opt_param_t",
          [
            349,
            0
          ],
          [
            378,
            19
          ]
        ],
        [
          "typedef enum {\n  /*! No value allowed for this option */\n  ARES_OPT_DATATYPE_NONE = 1,\n  /*! List of strings, each prefixed with a single octet representing the length\n   */\n  ARES_OPT_DATATYPE_STR_LIST = 2,\n  /*! List of 8bit integers, concatenated */\n  ARES_OPT_DATATYPE_U8_LIST = 3,\n  /*! 16bit integer in network byte order */\n  ARES_OPT_DATATYPE_U16 = 4,\n  /*! list of 16bit integer in network byte order, concatenated. */\n  ARES_OPT_DATATYPE_U16_LIST = 5,\n  /*! 32bit integer in network byte order */\n  ARES_OPT_DATATYPE_U32 = 6,\n  /*! list 32bit integer in network byte order, concatenated */\n  ARES_OPT_DATATYPE_U32_LIST = 7,\n  /*! List of ipv4 addresses in network byte order, concatenated */\n  ARES_OPT_DATATYPE_INADDR4_LIST = 8,\n  /*! List of ipv6 addresses in network byte order, concatenated */\n  ARES_OPT_DATATYPE_INADDR6_LIST = 9,\n  /*! Binary Data */\n  ARES_OPT_DATATYPE_BIN = 10,\n  /*! DNS Domain Name Format */\n  ARES_OPT_DATATYPE_NAME = 11\n} ares_dns_opt_datatype_t;",
          {
            "ARES_OPT_DATATYPE_NONE": "",
            "ARES_OPT_DATATYPE_STR_LIST": "",
            "ARES_OPT_DATATYPE_U8_LIST": "",
            "ARES_OPT_DATATYPE_U16": "",
            "ARES_OPT_DATATYPE_U16_LIST": "",
            "ARES_OPT_DATATYPE_U32": "",
            "ARES_OPT_DATATYPE_U32_LIST": "",
            "ARES_OPT_DATATYPE_INADDR4_LIST": "",
            "ARES_OPT_DATATYPE_INADDR6_LIST": "",
            "ARES_OPT_DATATYPE_BIN": "",
            "ARES_OPT_DATATYPE_NAME": ""
          },
          "ares_dns_opt_datatype_t",
          [
            382,
            0
          ],
          [
            406,
            26
          ]
        ],
        [
          "typedef enum {\n  /*! Parse Answers from RFC 1035 that allow name compression as RAW */\n  ARES_DNS_PARSE_AN_BASE_RAW = 1 << 0,\n  /*! Parse Authority from RFC 1035 that allow name compression as RAW */\n  ARES_DNS_PARSE_NS_BASE_RAW = 1 << 1,\n  /*! Parse Additional from RFC 1035 that allow name compression as RAW */\n  ARES_DNS_PARSE_AR_BASE_RAW = 1 << 2,\n  /*! Parse Answers from later RFCs (no name compression) RAW */\n  ARES_DNS_PARSE_AN_EXT_RAW = 1 << 3,\n  /*! Parse Authority from later RFCs (no name compression) as RAW */\n  ARES_DNS_PARSE_NS_EXT_RAW = 1 << 4,\n  /*! Parse Additional from later RFCs (no name compression) as RAW */\n  ARES_DNS_PARSE_AR_EXT_RAW = 1 << 5\n} ares_dns_parse_flags_t;",
          {
            "ARES_DNS_PARSE_AN_BASE_RAW": "",
            "ARES_DNS_PARSE_NS_BASE_RAW": "",
            "ARES_DNS_PARSE_AR_BASE_RAW": "",
            "ARES_DNS_PARSE_AN_EXT_RAW": "",
            "ARES_DNS_PARSE_NS_EXT_RAW": "",
            "ARES_DNS_PARSE_AR_EXT_RAW": ""
          },
          "ares_dns_parse_flags_t",
          [
            409,
            0
          ],
          [
            422,
            25
          ]
        ]
      ]
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/include/ares_version.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/ROSFuzzer/docker_shared/source_code/c-ares/docs/Makefile.inc": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}