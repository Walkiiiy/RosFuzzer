{
  "src": {
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-fuzz.c": {
      "fn_def_list": [
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)\n{\n  /* Feed the data into each of the ares_parse_*_reply functions. */\n  struct hostent          *host = NULL;\n  struct ares_addrttl      info[5];\n  struct ares_addr6ttl     info6[5];\n  unsigned char            addrv4[4] = { 0x10, 0x20, 0x30, 0x40 };\n  struct ares_srv_reply   *srv       = NULL;\n  struct ares_mx_reply    *mx        = NULL;\n  struct ares_txt_reply   *txt       = NULL;\n  struct ares_soa_reply   *soa       = NULL;\n  struct ares_naptr_reply *naptr     = NULL;\n  struct ares_caa_reply   *caa       = NULL;\n  struct ares_uri_reply   *uri       = NULL;\n  int                      count     = 5;\n  ares_parse_a_reply(data, (int)size, &host, info, &count);\n  if (host) {\n    ares_free_hostent(host);\n  }\n\n  host  = NULL;\n  count = 5;\n  ares_parse_aaaa_reply(data, (int)size, &host, info6, &count);\n  if (host) {\n    ares_free_hostent(host);\n  }\n\n  host = NULL;\n  ares_parse_ptr_reply(data, (int)size, addrv4, sizeof(addrv4), AF_INET, &host);\n  if (host) {\n    ares_free_hostent(host);\n  }\n\n  host = NULL;\n  ares_parse_ns_reply(data, (int)size, &host);\n  if (host) {\n    ares_free_hostent(host);\n  }\n\n  ares_parse_srv_reply(data, (int)size, &srv);\n  if (srv) {\n    ares_free_data(srv);\n  }\n\n  ares_parse_mx_reply(data, (int)size, &mx);\n  if (mx) {\n    ares_free_data(mx);\n  }\n\n  ares_parse_txt_reply(data, (int)size, &txt);\n  if (txt) {\n    ares_free_data(txt);\n  }\n\n  ares_parse_soa_reply(data, (int)size, &soa);\n  if (soa) {\n    ares_free_data(soa);\n  }\n\n  ares_parse_naptr_reply(data, (int)size, &naptr);\n  if (naptr) {\n    ares_free_data(naptr);\n  }\n\n  ares_parse_caa_reply(data, (int)size, &caa);\n  if (caa) {\n    ares_free_data(caa);\n  }\n\n  ares_parse_uri_reply(data, (int)size, &uri);\n  if (uri) {\n    ares_free_data(uri);\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)\n{\n  ares_dns_record_t *dnsrec    = NULL;\n  char              *printdata = NULL;\n  ares_buf_t        *printmsg  = NULL;\n  size_t             i;\n  unsigned char     *datadup     = NULL;\n  size_t             datadup_len = 0;\n\n  /* There is never a reason to have a size > 65535, it is immediately\n   * rejected by the parser */\n  if (size > 65535) {\n    return -1;\n  }\n\n  if (ares_dns_parse(data, size, 0, &dnsrec) != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Lets test the message fetchers */\n  printmsg = ares_buf_create();\n  if (printmsg == NULL) {\n    goto done;\n  }\n\n  ares_buf_append_str(printmsg, \";; ->>HEADER<<- opcode: \");\n  ares_buf_append_str(\n    printmsg, ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)));\n  ares_buf_append_str(printmsg, \", status: \");\n  ares_buf_append_str(printmsg,\n                      ares_dns_rcode_tostr(ares_dns_record_get_rcode(dnsrec)));\n  ares_buf_append_str(printmsg, \", id: \");\n  ares_buf_append_num_dec(printmsg, (size_t)ares_dns_record_get_id(dnsrec), 0);\n  ares_buf_append_str(printmsg, \"\\n;; flags: \");\n  ares_buf_append_num_hex(printmsg, (size_t)ares_dns_record_get_flags(dnsrec),\n                          0);\n  ares_buf_append_str(printmsg, \"; QUERY: \");\n  ares_buf_append_num_dec(printmsg, ares_dns_record_query_cnt(dnsrec), 0);\n  ares_buf_append_str(printmsg, \", ANSWER: \");\n  ares_buf_append_num_dec(\n    printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER), 0);\n  ares_buf_append_str(printmsg, \", AUTHORITY: \");\n  ares_buf_append_num_dec(\n    printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY), 0);\n  ares_buf_append_str(printmsg, \", ADDITIONAL: \");\n  ares_buf_append_num_dec(\n    printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL), 0);\n  ares_buf_append_str(printmsg, \"\\n\\n\");\n  ares_buf_append_str(printmsg, \";; QUESTION SECTION:\\n\");\n  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    const char         *name;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n\n    if (ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass) !=\n        ARES_SUCCESS) {\n      goto done;\n    }\n\n    ares_buf_append_str(printmsg, \";\");\n    ares_buf_append_str(printmsg, name);\n    ares_buf_append_str(printmsg, \".\\t\\t\\t\");\n    ares_buf_append_str(printmsg, ares_dns_class_tostr(qclass));\n    ares_buf_append_str(printmsg, \"\\t\");\n    ares_buf_append_str(printmsg, ares_dns_rec_type_tostr(qtype));\n    ares_buf_append_str(printmsg, \"\\n\");\n  }\n  ares_buf_append_str(printmsg, \"\\n\");\n  for (i = ARES_SECTION_ANSWER; i < ARES_SECTION_ADDITIONAL + 1; i++) {\n    size_t j;\n\n    ares_buf_append_str(printmsg, \";; \");\n    ares_buf_append_str(printmsg,\n                        ares_dns_section_tostr((ares_dns_section_t)i));\n    ares_buf_append_str(printmsg, \" SECTION:\\n\");\n    for (j = 0; j < ares_dns_record_rr_cnt(dnsrec, (ares_dns_section_t)i);\n         j++) {\n      size_t                   keys_cnt = 0;\n      const ares_dns_rr_key_t *keys     = NULL;\n      ares_dns_rr_t           *rr       = NULL;\n      size_t                   k;\n\n      rr = ares_dns_record_rr_get(dnsrec, (ares_dns_section_t)i, j);\n      ares_buf_append_str(printmsg, ares_dns_rr_get_name(rr));\n      ares_buf_append_str(printmsg, \".\\t\\t\\t\");\n      ares_buf_append_str(printmsg,\n                          ares_dns_class_tostr(ares_dns_rr_get_class(rr)));\n      ares_buf_append_str(printmsg, \"\\t\");\n      ares_buf_append_str(printmsg,\n                          ares_dns_rec_type_tostr(ares_dns_rr_get_type(rr)));\n      ares_buf_append_str(printmsg, \"\\t\");\n      ares_buf_append_num_dec(printmsg, ares_dns_rr_get_ttl(rr), 0);\n      ares_buf_append_str(printmsg, \"\\t\");\n\n      keys = ares_dns_rr_get_keys(ares_dns_rr_get_type(rr), &keys_cnt);\n      for (k = 0; k < keys_cnt; k++) {\n        char buf[256] = \"\";\n\n        ares_buf_append_str(printmsg, ares_dns_rr_key_tostr(keys[k]));\n        ares_buf_append_str(printmsg, \"=\");\n        switch (ares_dns_rr_key_datatype(keys[k])) {\n          case ARES_DATATYPE_INADDR:\n            ares_inet_ntop(AF_INET, ares_dns_rr_get_addr(rr, keys[k]), buf,\n                           sizeof(buf));\n            ares_buf_append_str(printmsg, buf);\n            break;\n          case ARES_DATATYPE_INADDR6:\n            ares_inet_ntop(AF_INET6, ares_dns_rr_get_addr6(rr, keys[k]), buf,\n                           sizeof(buf));\n            ares_buf_append_str(printmsg, buf);\n            break;\n          case ARES_DATATYPE_U8:\n            ares_buf_append_num_dec(printmsg, ares_dns_rr_get_u8(rr, keys[k]),\n                                    0);\n            break;\n          case ARES_DATATYPE_U16:\n            ares_buf_append_num_dec(printmsg, ares_dns_rr_get_u16(rr, keys[k]),\n                                    0);\n            break;\n          case ARES_DATATYPE_U32:\n            ares_buf_append_num_dec(printmsg, ares_dns_rr_get_u32(rr, keys[k]),\n                                    0);\n            break;\n          case ARES_DATATYPE_NAME:\n          case ARES_DATATYPE_STR:\n            ares_buf_append_byte(printmsg, '\"');\n            ares_buf_append_str(printmsg, ares_dns_rr_get_str(rr, keys[k]));\n            ares_buf_append_byte(printmsg, '\"');\n            break;\n          case ARES_DATATYPE_BIN:\n            /* TODO */\n            break;\n          case ARES_DATATYPE_BINP:\n            {\n              size_t templen;\n              ares_buf_append_byte(printmsg, '\"');\n              ares_buf_append_str(printmsg, (const char *)ares_dns_rr_get_bin(\n                                              rr, keys[k], &templen));\n              ares_buf_append_byte(printmsg, '\"');\n            }\n            break;\n          case ARES_DATATYPE_ABINP:\n            {\n              size_t a;\n              for (a = 0; a < ares_dns_rr_get_abin_cnt(rr, keys[k]); a++) {\n                size_t templen;\n\n                if (a != 0) {\n                  ares_buf_append_byte(printmsg, ' ');\n                }\n                ares_buf_append_byte(printmsg, '\"');\n                ares_buf_append_str(\n                  printmsg,\n                  (const char *)ares_dns_rr_get_abin(rr, keys[k], a, &templen));\n                ares_buf_append_byte(printmsg, '\"');\n              }\n            }\n            break;\n          case ARES_DATATYPE_OPT:\n            /* TODO */\n            break;\n        }\n        ares_buf_append_str(printmsg, \" \");\n      }\n      ares_buf_append_str(printmsg, \"\\n\");\n    }\n  }\n  ares_buf_append_str(printmsg, \";; SIZE: \");\n  ares_buf_append_num_dec(printmsg, size, 0);\n  ares_buf_append_str(printmsg, \"\\n\\n\");\n\n  printdata = ares_buf_finish_str(printmsg, NULL);\n  printmsg  = NULL;\n\n  /* Write it back out as a dns message to test writer */\n  if (ares_dns_write(dnsrec, &datadup, &datadup_len) != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_dns_record_destroy(dnsrec);\n  ares_buf_destroy(printmsg);\n  ares_free(printdata);\n  ares_free(datadup);\n  return 0;\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)",
          "fn_dec_pos": [
            [
              31,
              4
            ],
            [
              31,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            52,
            2
          ],
          [
            52,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            53,
            2
          ],
          [
            53,
            21
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            54,
            2
          ],
          [
            54,
            22
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            56,
            2
          ],
          [
            56,
            23
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            57,
            2
          ],
          [
            57,
            22
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            58,
            2
          ],
          [
            58,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            59,
            2
          ],
          [
            59,
            23
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            60,
            2
          ],
          [
            60,
            25
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            61,
            2
          ],
          [
            61,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            62,
            2
          ],
          [
            62,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stddef.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"include/ares_buf.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"include/ares_mem.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-fuzz-name.c": {
      "fn_def_list": [
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)\n{\n  /* Null terminate the data. */\n  char          *name   = malloc(size + 1);\n  unsigned char *buf    = NULL;\n  int            buflen = 0;\n  name[size]            = '\\0';\n  memcpy(name, data, size);\n\n  ares_create_query(name, C_IN, T_AAAA, 1234, 0, &buf, &buflen, 1024);\n  free(buf);\n  free(name);\n  return 0;\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)\n{\n  ares_channel_t *channel = NULL;\n  char           *csv;\n\n  ares_library_init(ARES_LIB_INIT_ALL);\n  ares_init(&channel);\n\n  /* Need to null-term data */\n  csv = malloc(size + 1);\n  memcpy(csv, data, size);\n  csv[size] = '\\0';\n  ares_set_servers_csv(channel, csv);\n  free(csv);\n\n  ares_destroy(channel);\n  ares_library_cleanup();\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)",
          "fn_dec_pos": [
            [
              33,
              4
            ],
            [
              33,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stddef.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-main.cc": {
      "fn_def_list": [
        {
          "fn_code": "static void thread_set_realtime(pthread_t pthread)\n{\n  mach_timebase_info_data_t            timebase_info;\n  const uint64_t                       NANOS_PER_MSEC = 1000000ULL;\n  double                               clock2abs;\n  int                                  rv;\n  thread_time_constraint_policy_data_t policy;\n\n  mach_timebase_info(&timebase_info);\n  clock2abs = ((double)timebase_info.denom / (double)timebase_info.numer)\n              * NANOS_PER_MSEC;\n\n  policy.period      = 0;\n  policy.computation = (uint32_t)(5 * clock2abs); // 5 ms of work\n  policy.constraint  = (uint32_t)(10 * clock2abs);\n  policy.preemptible = FALSE;\n\n  rv = thread_policy_set(pthread_mach_thread_np(pthread),\n                         THREAD_TIME_CONSTRAINT_POLICY,\n                         (thread_policy_t)&policy,\n                         THREAD_TIME_CONSTRAINT_POLICY_COUNT);\n  if (rv != KERN_SUCCESS) {\n    mach_error(\"thread_policy_set:\", rv);\n    exit(1);\n  }\n}",
          "fn_code_pos": [
            [
              35,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "thread_set_realtime",
            "parameters": {
              "pthread": "pthread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char* argv[]) {\n  std::vector<char*> gtest_argv = {argv[0]};\n  for (int ii = 1; ii < argc; ii++) {\n    if (strcmp(argv[ii], \"-v\") == 0) {\n      ares::test::verbose = true;\n    } else if ((strcmp(argv[ii], \"-p\") == 0) && (ii + 1 < argc)) {\n      ii++;\n      ares::test::mock_port = (unsigned short)atoi(argv[ii]);\n    } else if (strcmp(argv[ii], \"-4\") == 0) {\n      ares::test::families = ares::test::ipv4_family;\n      ares::test::families_modes = ares::test::ipv4_family_both_modes;\n      ares::test::evsys_families = ares::test::all_evsys_ipv4_family;\n      ares::test::evsys_families_modes = ares::test::all_evsys_ipv4_family_both_modes;\n    } else if (strcmp(argv[ii], \"-6\") == 0) {\n      ares::test::families = ares::test::ipv6_family;\n      ares::test::families_modes = ares::test::ipv6_family_both_modes;\n      ares::test::evsys_families = ares::test::all_evsys_ipv6_family;\n      ares::test::evsys_families_modes = ares::test::all_evsys_ipv6_family_both_modes;\n    } else {\n      gtest_argv.push_back(argv[ii]);\n    }\n  }\n  int gtest_argc = (int)gtest_argv.size();\n  gtest_argv.push_back(nullptr);\n  ::testing::InitGoogleTest(&gtest_argc, gtest_argv.data());\n\n#ifdef WIN32\n  WORD wVersionRequested = MAKEWORD(2, 2);\n  WSADATA wsaData;\n  WSAStartup(wVersionRequested, &wsaData);\n#else\n  signal(SIGPIPE, SIG_IGN);\n#endif\n\n#ifdef __APPLE__\n  /* We need to increase the priority in order for some timing-sensitive tests\n   * to succeed reliably.  On CI systems, the host can be overloaded and things\n   * like sleep timers can wait many multiples of the time specified otherwise.\n   * This is sort of a necessary hack for test reliability. Not something that\n   * would generally be used */\n  thread_set_realtime(pthread_self());\n#endif\n\n  int rc = RUN_ALL_TESTS();\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  return rc;\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <signal.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares-test.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <mach/mach.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <mach/mach_time.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <pthread.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-misc.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(DefaultChannelTest, GetServers) {\n  std::string servers = GetNameServers(channel_);\n  if (verbose) {\n    std::cerr << \"Nameserver: \" << servers << std::endl;\n  }\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              39,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, GetServersFailures) {\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel_, \"1.2.3.4,2.3.4.5\"));\n  struct ares_addr_node* servers = nullptr;\n  SetAllocFail(1);\n  EXPECT_EQ(ARES_ENOMEM, ares_get_servers(channel_, &servers));\n  SetAllocFail(2);\n  EXPECT_EQ(ARES_ENOMEM, ares_get_servers(channel_, &servers));\n  EXPECT_EQ(ARES_ENODATA, ares_get_servers(nullptr, &servers));\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetServers) {\n  /* NOTE: This test is because we have actual external users doing test case\n   *       simulation and removing all servers to generate various error\n   *       conditions in their own code.  It would make more sense to return\n   *       ARES_ENODATA, but due to historical users, we can't break them.\n   *       See: https://github.com/nodejs/node/pull/50800\n   */\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers(channel_, nullptr));\n  std::string expected_empty = \"\";\n  EXPECT_EQ(expected_empty, GetNameServers(channel_));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOSERVER, result.status_);\n\n\n  struct ares_addr_node server1;\n  struct ares_addr_node server2;\n  server1.next = &server2;\n  server1.family = AF_INET;\n  server1.addr.addr4.s_addr = htonl(0x01020304);\n  server2.next = nullptr;\n  server2.family = AF_INET;\n  server2.addr.addr4.s_addr = htonl(0x02030405);\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers(nullptr, &server1));\n\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers(channel_, &server1));\n  std::string expected = \"1.2.3.4:53,2.3.4.5:53\";\n  EXPECT_EQ(expected, GetNameServers(channel_));\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetServersPorts) {\n  /* NOTE: This test is because we have actual external users doing test case\n   *       simulation and removing all servers to generate various error\n   *       conditions in their own code.  It would make more sense to return\n   *       ARES_ENODATA, but due to historical users, we can't break them.\n   *       See: https://github.com/nodejs/node/pull/50800\n   */\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports(channel_, nullptr));\n  std::string expected_empty = \"\";\n  EXPECT_EQ(expected_empty, GetNameServers(channel_));\n\n  struct ares_addr_port_node server1;\n  struct ares_addr_port_node server2;\n  server1.next = &server2;\n  server1.family = AF_INET;\n  server1.addr.addr4.s_addr = htonl(0x01020304);\n  server1.udp_port = 111;\n  server1.tcp_port = 111;\n  server2.next = nullptr;\n  server2.family = AF_INET;\n  server2.addr.addr4.s_addr = htonl(0x02030405);\n  server2.udp_port = 0;\n  server2.tcp_port = 0;\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_ports(nullptr, &server1));\n\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports(channel_, &server1));\n  std::string expected = \"1.2.3.4:111,2.3.4.5:53\";\n  EXPECT_EQ(expected, GetNameServers(channel_));\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetServersCSV) {\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"1.2.3.4\"));\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"xyzzy,plugh\"));\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"256.1.2.3\"));\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"1.2.3.4.5\"));\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"1:2:3:4:5\"));\n\n  /* NOTE: This test is because we have actual external users doing test case\n   *       simulation and removing all servers to generate various error\n   *       conditions in their own code.  It would make more sense to return\n   *       ARES_ENODATA, but due to historical users, we can't break them.\n   *       See: https://github.com/nodejs/node/pull/50800\n   */\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_csv(channel_, NULL));\n  std::string expected_empty = \"\";\n  EXPECT_EQ(expected_empty, GetNameServers(channel_));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_csv(channel_, \"\"));\n  EXPECT_EQ(expected_empty, GetNameServers(channel_));\n\n\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel_, \"1.2.3.4,0102:0304:0506:0708:0910:1112:1314:1516,2.3.4.5\"));\n  std::string expected = \"1.2.3.4:53,[102:304:506:708:910:1112:1314:1516]:53,2.3.4.5:53\";\n  EXPECT_EQ(expected, GetNameServers(channel_));\n\n  // Same, with spaces\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel_, \"1.2.3.4 , [0102:0304:0506:0708:0910:1112:1314:1516]:53, 2.3.4.5\"));\n  EXPECT_EQ(expected, GetNameServers(channel_));\n\n  // Ignore invalid link-local interface, keep rest.\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel_, \"1.2.3.4 , [0102:0304:0506:0708:0910:1112:1314:1516]:53, [fe80::1]:53%iface0, 2.3.4.5\"));\n  EXPECT_EQ(expected, GetNameServers(channel_));\n\n  // Same, with ports\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_ports_csv(channel_, \"1.2.3.4:54,[0102:0304:0506:0708:0910:1112:1314:1516]:80,2.3.4.5:55\"));\n  std::string expected2 = {\"1.2.3.4:54,[102:304:506:708:910:1112:1314:1516]:80,2.3.4.5:55\"};\n  EXPECT_EQ(expected2, GetNameServers(channel_));\n\n  // Should survive duplication\n  ares_channel_t *channel2;\n  EXPECT_EQ(ARES_SUCCESS, ares_dup(&channel2, channel_));\n  EXPECT_EQ(expected2, GetNameServers(channel2));\n  ares_destroy(channel2);\n\n  // Allocation failure cases\n  for (int fail = 1; fail <= 5; fail++) {\n    SetAllocFail(fail);\n    EXPECT_EQ(ARES_ENOMEM,\n              ares_set_servers_csv(channel_, \"1.2.3.4,0102:0304:0506:0708:0910:1112:1314:1516,2.3.4.5\"));\n  }\n\n  EXPECT_EQ(ARES_EBADSTR, ares_set_servers_csv(channel_, \"2.3.4.5,1.2.3.4:,3.4.5.6\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_servers_csv(channel_, \"2.3.4.5,1.2.3.4:Z,3.4.5.6\"));\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, TimeoutValue) {\n  struct timeval tinfo;\n  tinfo.tv_sec = 0;\n  tinfo.tv_usec = 0;\n  struct timeval tmax;\n  tmax.tv_sec = 0;\n  tmax.tv_usec = 10;\n  struct timeval* pt;\n\n  // No timers => get max back.\n  pt = ares_timeout(channel_, &tmax, &tinfo);\n  EXPECT_EQ(&tmax, pt);\n  EXPECT_EQ(0, pt->tv_sec);\n  EXPECT_EQ(10, pt->tv_usec);\n\n  pt = ares_timeout(channel_, nullptr, &tinfo);\n  EXPECT_EQ(nullptr, pt);\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n\n  // Now there's a timer running.\n  pt = ares_timeout(channel_, &tmax, &tinfo);\n  EXPECT_EQ(&tmax, pt);\n  EXPECT_EQ(0, pt->tv_sec);\n  EXPECT_EQ(10, pt->tv_usec);\n\n  tmax.tv_sec = 100;\n  pt = ares_timeout(channel_, &tmax, &tinfo);\n  EXPECT_EQ(&tinfo, pt);\n\n  pt = ares_timeout(channel_, nullptr, &tinfo);\n  EXPECT_EQ(&tinfo, pt);\n\n  Process();\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, RecordDuplicateNull) {\n  EXPECT_EQ(ares_dns_record_duplicate(NULL), nullptr);\n}",
          "fn_code_pos": [
            [
              209,
              0
            ],
            [
              211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, InetNtoP) {\n  struct in_addr addr;\n  addr.s_addr = htonl(0x01020304);\n  char buffer[256];\n  EXPECT_EQ(buffer, ares_inet_ntop(AF_INET, &addr, buffer, sizeof(buffer)));\n  EXPECT_EQ(\"1.2.3.4\", std::string(buffer));\n}",
          "fn_code_pos": [
            [
              213,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, Mkquery) {\n  byte* p;\n  int len;\n  ares_mkquery(\"example.com\", C_IN, T_A, 0x1234, 0, &p, &len);\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).add_question(new DNSQuestion(\"example.com\", T_A));\n  std::string expected = PacketToString(pkt.data());\n  EXPECT_EQ(expected, actual);\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQuery) {\n  byte* p;\n  int len;\n  // This is hard to really test with escaping since DNS names don't allow\n  // bad characters.  So we'll escape good characters.\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_create_query(\"ex\\\\097m\\\\ple.com\", C_IN, T_A, 0x1234, 0,\n                              &p, &len, 0));\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).add_question(new DNSQuestion(\"example.com\", T_A));\n  std::string expected = PacketToString(pkt.data());\n  EXPECT_EQ(expected, actual);\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQueryTrailingEscapedDot) {\n  byte* p;\n  int len;\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_create_query(\"example.com\\\\.\", C_IN, T_A, 0x1234, 0,\n                              &p, &len, 0));\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  EXPECT_EQ(\"REQ QRY  Q:{'example.com\\\\.' IN A}\", actual);\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQueryNameTooLong) {\n  byte* p;\n  int len;\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_create_query(\n              \"a1234567890123456789.b1234567890123456789.c1234567890123456789.d1234567890123456789.\"\n              \"a1234567890123456789.b1234567890123456789.c1234567890123456789.d1234567890123456789.\"\n              \"a1234567890123456789.b1234567890123456789.c1234567890123456789.d1234567890123456789.\"\n              \"x1234567890123456789.y1234567890123456789.\",\n              C_IN, T_A, 0x1234, 0, &p, &len, 0));\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQueryFailures) {\n  byte* p;\n  int len;\n  // RC1035 has a 255 byte limit on names.\n  std::string longname;\n  for (int ii = 0; ii < 17; ii++) {\n    longname += \"fedcba9876543210\";\n  }\n  p = nullptr;\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_create_query(longname.c_str(), C_IN, T_A, 0x1234, 0,\n                    &p, &len, 0));\n  if (p) ares_free_string(p);\n\n  SetAllocFail(1);\n\n  p = nullptr;\n  EXPECT_EQ(ARES_ENOMEM,\n            ares_create_query(\"example.com\", C_IN, T_A, 0x1234, 0,\n                    &p, &len, 0));\n  if (p) ares_free_string(p);\n\n  // 63-char limit on a single label\n  std::string longlabel = \"a.a123456789b123456789c123456789d123456789e123456789f123456789g123456789.org\";\n  p = nullptr;\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_create_query(longlabel.c_str(), C_IN, T_A, 0x1234, 0,\n                    &p, &len, 0));\n  if (p) ares_free_string(p);\n\n  // Empty non-terminal label\n  p = nullptr;\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_create_query(\"example..com\", C_IN, T_A, 0x1234, 0,\n                    &p, &len, 0));\n  if (p) ares_free_string(p);\n\n  EXPECT_EQ(ARES_EFORMERR,\n            ares_create_query(NULL, C_IN, T_A, 0x1234, 0, NULL, NULL, 0));\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQueryOnionDomain) {\n  byte* p;\n  int len;\n  EXPECT_EQ(ARES_ENOTFOUND,\n            ares_create_query(\"dontleak.onion\", C_IN, T_A, 0x1234, 0,\n                              &p, &len, 0));\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, HostByNameOnionDomain) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"dontleak.onion\", AF_INET, HostCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, HostByNameFileOnionDomain) {\n  struct hostent *h;\n  EXPECT_EQ(ARES_ENOTFOUND,\n            ares_gethostbyname_file(channel_, \"dontleak.onion\", AF_INET, &h));\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, GetAddrinfoOnionDomain) {\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_UNSPEC;\n  ares_getaddrinfo(channel_, \"dontleak.onion\", NULL, &hints, AddrInfoCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n}",
          "fn_code_pos": [
            [
              340,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SearchOnionDomain) {\n  SearchResult result;\n  ares_search(channel_, \"dontleak.onion\", C_IN, T_A,\n              SearchCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n}",
          "fn_code_pos": [
            [
              352,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SendFailure) {\n  unsigned char buf[2] = {};\n  SearchResult result;\n  ares_send(channel_, buf, sizeof(buf), SearchCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EBADQUERY, result.status_);\n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static std::string ExpandName(const std::vector<byte>& data, int offset,\n                              long *enclen) {\n  char *name = nullptr;\n  int rc = ares_expand_name(data.data() + offset, data.data(), (int)data.size(),\n                            &name, enclen);\n  EXPECT_EQ(ARES_SUCCESS, rc);\n  std::string result;\n  if (rc == ARES_SUCCESS) {\n    result = name;\n  } else {\n    result = \"<error>\";\n  }\n  ares_free_string(name);\n  return result;\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExpandName",
            "parameters": {
              "data": "std::vector<byte>",
              "offset": "int",
              "enclen": "long"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ExpandName) {\n  long enclen;\n  std::vector<byte> data1 = {1, 'a', 2, 'b', 'c', 3, 'd', 'e', 'f', 0};\n  EXPECT_EQ(\"a.bc.def\", ExpandName(data1, 0, &enclen));\n  EXPECT_EQ(data1.size(), (size_t)enclen);\n\n  std::vector<byte> data2 = {0};\n  EXPECT_EQ(\"\", ExpandName(data2, 0, &enclen));\n  EXPECT_EQ(1, enclen);\n\n  // Complete name indirection\n  std::vector<byte> data3 = {0x12, 0x23,\n                             3, 'd', 'e', 'f', 0,\n                             0xC0, 2};\n  EXPECT_EQ(\"def\", ExpandName(data3, 2, &enclen));\n  EXPECT_EQ(5, enclen);\n  EXPECT_EQ(\"def\", ExpandName(data3, 7, &enclen));\n  EXPECT_EQ(2, enclen);\n\n  // One label then indirection\n  std::vector<byte> data4 = {0x12, 0x23,\n                             3, 'd', 'e', 'f', 0,\n                             1, 'a', 0xC0, 2};\n  EXPECT_EQ(\"def\", ExpandName(data4, 2, &enclen));\n  EXPECT_EQ(5, enclen);\n  EXPECT_EQ(\"a.def\", ExpandName(data4, 7, &enclen));\n  EXPECT_EQ(4, enclen);\n\n  // Two labels then indirection\n  std::vector<byte> data5 = {0x12, 0x23,\n                             3, 'd', 'e', 'f', 0,\n                             1, 'a', 1, 'b', 0xC0, 2};\n  EXPECT_EQ(\"def\", ExpandName(data5, 2, &enclen));\n  EXPECT_EQ(5, enclen);\n  EXPECT_EQ(\"a.b.def\", ExpandName(data5, 7, &enclen));\n  EXPECT_EQ(6, enclen);\n\n  // Empty name, indirection to empty name\n  std::vector<byte> data6 = {0x12, 0x23,\n                             0,\n                             0xC0, 2};\n  EXPECT_EQ(\"\", ExpandName(data6, 2, &enclen));\n  EXPECT_EQ(1, enclen);\n  EXPECT_EQ(\"\", ExpandName(data6, 3, &enclen));\n  EXPECT_EQ(2, enclen);\n}",
          "fn_code_pos": [
            [
              384,
              0
            ],
            [
              429,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ExpandNameFailure) {\n  std::vector<byte> data1 = {0x03, 'c', 'o', 'm', 0x00};\n  char *name = nullptr;\n  long enclen;\n  SetAllocFail(1);\n  EXPECT_EQ(ARES_ENOMEM,\n            ares_expand_name(data1.data(), data1.data(), (int)data1.size(),\n                             &name, &enclen));\n\n  // Empty packet\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data1.data(), data1.data(), 0, &name, &enclen));\n\n  // Start beyond enclosing data\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data1.data() + data1.size(), data1.data(), (int)data1.size(),\n                             &name, &enclen));\n\n  // Length beyond size of enclosing data\n  std::vector<byte> data2a = {0x13, 'c', 'o', 'm', 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data2a.data(), data2a.data(), (int)data2a.size(),\n                             &name, &enclen));\n  std::vector<byte> data2b = {0x1};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data2b.data(), data2b.data(), (int)data2b.size(),\n                             &name, &enclen));\n  std::vector<byte> data2c = {0xC0};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data2c.data(), data2c.data(), (int)data2c.size(),\n                             &name, &enclen));\n\n  // Indirection beyond enclosing data\n  std::vector<byte> data3a = {0xC0, 0x02};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data3a.data(), data3a.data(), (int)data3a.size(),\n                             &name, &enclen));\n  std::vector<byte> data3b = {0xC0, 0x0A, 'c', 'o', 'm', 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data3b.data(), data3b.data(), (int)data3b.size(),\n                             &name, &enclen));\n\n  // Invalid top bits in label length\n  std::vector<byte> data4 = {0x03, 'c', 'o', 'm', 0x00, 0x80, 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data4.data() + 5, data4.data(), (int)data4.size(),\n                             &name, &enclen));\n\n  // Label too long: 64-byte label, with invalid top 2 bits of length (01).\n  std::vector<byte> data5 = {0x40,\n                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n                             0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data5.data(), data5.data(), (int)data5.size(),\n                             &name, &enclen)) << name;\n\n  // Incomplete indirect length\n  std::vector<byte> data6 = {0x03, 'c', 'o', 'm', 0x00, 0xC0};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data6.data() + 5, data6.data(), (int)data6.size(),\n                             &name, &enclen));\n\n  // Indirection loops\n  std::vector<byte> data7 = {0xC0, 0x02, 0xC0, 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data7.data(), data7.data(), (int)data7.size(),\n                             &name, &enclen));\n  std::vector<byte> data8 = {3, 'd', 'e', 'f', 0xC0, 0x08, 0x00, 0x00,\n                             3, 'a', 'b', 'c', 0xC0, 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data8.data(), data8.data(), (int)data8.size(),\n                             &name, &enclen));\n  std::vector<byte> data9 = {0x12, 0x23,  // start 2 bytes in\n                             3, 'd', 'e', 'f', 0xC0, 0x02};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data9.data() + 2, data9.data(), (int)data9.size(),\n                             &name, &enclen));\n}",
          "fn_code_pos": [
            [
              431,
              0
            ],
            [
              511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateEDNSQuery) {\n  byte* p;\n  int len;\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_create_query(\"example.com\", C_IN, T_A, 0x1234, 0,\n                              &p, &len, 1280));\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, { } /* No server cookie */, false));\n  std::string expected = PacketToString(pkt.data());\n  EXPECT_EQ(expected, actual);\n}",
          "fn_code_pos": [
            [
              513,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateRootQuery) {\n  byte* p;\n  int len;\n  ares_create_query(\".\", C_IN, T_A, 0x1234, 0, &p, &len, 0);\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).add_question(new DNSQuestion(\"\", T_A));\n  std::string expected = PacketToString(pkt.data());\n  EXPECT_EQ(expected, actual);\n}",
          "fn_code_pos": [
            [
              530,
              0
            ],
            [
              542,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, Version) {\n  // Assume linked to same version\n  EXPECT_EQ(std::string(ARES_VERSION_STR),\n            std::string(ares_version(nullptr)));\n  int version;\n  ares_version(&version);\n  EXPECT_EQ(ARES_VERSION, version);\n}",
          "fn_code_pos": [
            [
              544,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ExpandString) {\n  std::vector<byte> s1 = { 3, 'a', 'b', 'c'};\n  char* result = nullptr;\n  long len;\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_expand_string(s1.data(), s1.data(), (int)s1.size(),\n                               (unsigned char**)&result, &len));\n  EXPECT_EQ(\"abc\", std::string(result));\n  EXPECT_EQ(1 + 3, len);  // amount of data consumed includes 1 byte len\n  ares_free_string(result);\n  result = nullptr;\n  EXPECT_EQ(ARES_EBADSTR,\n            ares_expand_string(s1.data() + 1, s1.data(), (int)s1.size(),\n                               (unsigned char**)&result, &len));\n  EXPECT_EQ(ARES_EBADSTR,\n            ares_expand_string(s1.data() + 4, s1.data(), (int)s1.size(),\n                               (unsigned char**)&result, &len));\n  SetAllocFail(1);\n  EXPECT_EQ(ARES_ENOMEM,\n            ares_expand_string(s1.data(), s1.data(), (int)s1.size(),\n                               (unsigned char**)&result, &len));\n}",
          "fn_code_pos": [
            [
              553,
              0
            ],
            [
              574,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, DNSMapping) {\n  ares_dns_rec_type_t types[] = {\n    ARES_REC_TYPE_A,\n    ARES_REC_TYPE_NS,\n    ARES_REC_TYPE_CNAME,\n    ARES_REC_TYPE_SOA,\n    ARES_REC_TYPE_PTR,\n    ARES_REC_TYPE_HINFO,\n    ARES_REC_TYPE_MX,\n    ARES_REC_TYPE_TXT,\n    ARES_REC_TYPE_SIG,\n    ARES_REC_TYPE_AAAA,\n    ARES_REC_TYPE_SRV,\n    ARES_REC_TYPE_NAPTR,\n    ARES_REC_TYPE_OPT,\n    ARES_REC_TYPE_TLSA,\n    ARES_REC_TYPE_SVCB,\n    ARES_REC_TYPE_HTTPS,\n    ARES_REC_TYPE_ANY,\n    ARES_REC_TYPE_URI,\n    ARES_REC_TYPE_CAA\n  };\n\n  for (size_t i=0; i<sizeof(types) / sizeof(*types); i++) {\n    ares_dns_rec_type_t type;\n    EXPECT_TRUE(ares_dns_rec_type_fromstr(&type, ares_dns_rec_type_tostr(types[i])));\n    EXPECT_EQ(types[i], type);\n    size_t cnt;\n    const ares_dns_rr_key_t *keys = ares_dns_rr_get_keys(type, &cnt);\n    for (size_t j=0; j<cnt; j++) {\n      const char *name = ares_dns_rr_key_tostr(keys[j]);\n      EXPECT_NE(nullptr, name);\n      EXPECT_NE(\"UNKNOWN\", std::string(name));\n      EXPECT_EQ(type, ares_dns_rr_key_to_rec_type(keys[j]));\n      EXPECT_NE(0, (int)ares_dns_rr_key_datatype(keys[j]));\n    }\n  }\n}",
          "fn_code_pos": [
            [
              576,
              0
            ],
            [
              613,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, StrError) {\n  ares_status_t status[] = {\n    ARES_SUCCESS, ARES_ENODATA, ARES_EFORMERR, ARES_ESERVFAIL, ARES_ENOTFOUND,\n    ARES_ENOTIMP, ARES_EREFUSED, ARES_EBADQUERY, ARES_EBADNAME, ARES_EBADFAMILY,\n    ARES_EBADRESP, ARES_ECONNREFUSED, ARES_ETIMEOUT, ARES_EOF, ARES_EFILE,\n    ARES_ENOMEM, ARES_EDESTRUCTION, ARES_EBADSTR, ARES_EBADFLAGS, ARES_ENONAME,\n    ARES_EBADHINTS, ARES_ENOTINITIALIZED, ARES_ELOADIPHLPAPI,\n    ARES_EADDRGETNETWORKPARAMS, ARES_ECANCELLED, ARES_ESERVICE, ARES_ENOSERVER\n  };\n  size_t i;\n  const char *str = nullptr;\n\n  for (i=0; i < sizeof(status) / sizeof(*status); i++) {\n    str = ares_strerror((int)status[i]);\n    EXPECT_NE(nullptr, str);\n    EXPECT_NE(\"unknown\", std::string(str));\n  }\n\n  /* unknown value */\n  str = ares_strerror(0x12345678);\n  EXPECT_NE(nullptr, str);\n  EXPECT_EQ(\"unknown\", std::string(str));\n}",
          "fn_code_pos": [
            [
              615,
              0
            ],
            [
              637,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, UsageErrors) {\n  ares_cancel(NULL);\n  ares_set_socket_callback(NULL, NULL, NULL);\n  ares_set_socket_configure_callback(NULL, NULL, NULL);\n  ares_set_socket_functions(NULL, NULL, NULL);\n  ares_destroy(NULL);\n  ares_expand_name(NULL, NULL, 0, NULL, NULL);\n  ares_expand_string(NULL, NULL, 0, NULL, NULL);\n  ares_fds(NULL, NULL, NULL);\n  ares_getaddrinfo(NULL, NULL, NULL, NULL, NULL, NULL);\n  ares_gethostbyaddr(NULL, NULL, 0, 0, NULL, NULL);\n  ares_getnameinfo(NULL, NULL, 0, 0, NULL, NULL);\n  ares_reinit(NULL);\n  ares_dup(NULL, NULL);\n  ares_set_local_ip4(NULL, 0);\n  ares_set_local_ip6(NULL, NULL);\n  ares_set_local_dev(NULL, NULL);\n  ares_query_dnsrec(NULL, NULL, ARES_CLASS_IN, ARES_REC_TYPE_A, NULL, NULL, NULL);\n  ares_query(NULL, NULL, ARES_CLASS_IN, ARES_REC_TYPE_A, NULL, NULL);\n}",
          "fn_code_pos": [
            [
              639,
              0
            ],
            [
              658,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addr_node",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            69,
            2
          ],
          [
            69,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            70,
            2
          ],
          [
            70,
            23
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            95,
            2
          ],
          [
            95,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            96,
            2
          ],
          [
            96,
            28
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            173,
            2
          ],
          [
            173,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            176,
            2
          ],
          [
            176,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            179,
            2
          ],
          [
            179,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            214,
            2
          ],
          [
            214,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            335,
            2
          ],
          [
            335,
            16
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            342,
            2
          ],
          [
            342,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseRootName) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\".\", T_A))\n    .add_answer(new DNSARR(\".\", 100, {0x02, 0x03, 0x04, 0x05}));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseIndirectRootName) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0xC0, 0x04,  // weird: pointer to a random zero earlier in the message\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0xC0, 0x04,\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n  };\n\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseEscapedName) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x05, 'a', '\\\\', 'b', '.', 'c',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x05, 'a', '\\\\', 'b', '.', 'c',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n  };\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  HostEnt hent(host);\n  std::stringstream ss;\n  ss << hent;\n  // The printable name is expanded with escapes.\n  EXPECT_EQ(11, hent.name_.size());\n  EXPECT_EQ('a', hent.name_[0]);\n  EXPECT_EQ('\\\\', hent.name_[1]);\n  EXPECT_EQ('\\\\', hent.name_[2]);\n  EXPECT_EQ('b', hent.name_[3]);\n  EXPECT_EQ('\\\\', hent.name_[4]);\n  EXPECT_EQ('.', hent.name_[5]);\n  EXPECT_EQ('c', hent.name_[6]);\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePartialCompressedName) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x03, 'w', 'w', 'w',\n    0xc0, 0x10,  // offset 16\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n  };\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseFullyCompressedName) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0xc0, 0x0c,  // offset 12\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n  };\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "hent(host)",
          "fn_dec_pos": [
            [
              120,
              10
            ],
            [
              120,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hent",
            "parameters": {},
            "return_type": "HostEnt"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            41,
            2
          ],
          [
            41,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            75,
            2
          ],
          [
            75,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            76,
            2
          ],
          [
            76,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            114,
            2
          ],
          [
            114,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            115,
            2
          ],
          [
            115,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            161,
            2
          ],
          [
            161,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            162,
            2
          ],
          [
            162,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            197,
            2
          ],
          [
            197,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            198,
            2
          ],
          [
            198,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-mock-ai.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_P(MockUDPChannelTestAI, GetAddrInfoParallelLookups) {\n  DNSPacket rsp1;\n  rsp1.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp1));\n  DNSPacket rsp2;\n  rsp2.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp2));\n\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  AddrInfoResult result1;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result1);\n  AddrInfoResult result2;\n  ares_getaddrinfo(channel_, \"www.example.com.\", NULL, &hints, AddrInfoCallback, &result2);\n  AddrInfoResult result3;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result3);\n  Process();\n\n  EXPECT_TRUE(result1.done_);\n  EXPECT_EQ(result1.status_, ARES_SUCCESS);\n  EXPECT_THAT(result1.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result1.ai_, IncludesV4Address(\"2.3.4.5\"));\n\n  EXPECT_TRUE(result2.done_);\n  EXPECT_EQ(result2.status_, ARES_SUCCESS);\n  EXPECT_THAT(result2.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result2.ai_, IncludesV4Address(\"1.2.3.4\"));\n\n  EXPECT_TRUE(result3.done_);\n  EXPECT_EQ(result3.status_, ARES_SUCCESS);\n  EXPECT_THAT(result3.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result3.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTestAI, TruncationRetry) {\n  DNSPacket rsptruncated;\n  rsptruncated.set_response().set_aa().set_tc()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsptruncated))\n    .WillOnce(SetReply(&server_, &rspok));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(result.status_, ARES_SUCCESS);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"1.2.3.4\"));\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, MalformedResponse) {\n  std::vector<byte> one = {0x01};\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, one));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EBADRESP, result.status_);\n}",
          "fn_code_pos": [
            [
              158,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, FormErrResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(FORMERR);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFORMERR, result.status_);\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              209,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              243,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, YXDomainResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(YXDOMAIN);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              245,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsTestAI()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}",
          "fn_code_pos": [
            [
              267,
              2
            ],
            [
              270,
              71
            ]
          ],
          "class_code": "8cd200b5abe974f89ec972b8fba08cab1bc6cef0e5c40d0a812f663f6e4d9a23",
          "class_node_pos": [
            [
              263,
              0
            ],
            [
              280,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              271,
              2
            ],
            [
              277,
              3
            ]
          ],
          "class_code": "8cd200b5abe974f89ec972b8fba08cab1bc6cef0e5c40d0a812f663f6e4d9a23",
          "class_node_pos": [
            [
              263,
              0
            ],
            [
              280,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsTestAI, SimpleQuery) {\n  ares_set_local_ip4(channel_, 0x7F000001);\n  byte addr6[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsNDotsTestAI(int ndots)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_, ndots),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF|ARES_OPT_NDOTS) {}",
          "fn_code_pos": [
            [
              312,
              2
            ],
            [
              315,
              86
            ]
          ],
          "class_code": "1486fe3b5a76578d99a65ba63e8a199b3884561849549d0a779b783b7d7226e9",
          "class_node_pos": [
            [
              308,
              0
            ],
            [
              326,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsNDotsTestAI",
            "parameters": {
              "ndots": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts, int ndots) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    opts->ndots = ndots;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              316,
              2
            ],
            [
              323,
              3
            ]
          ],
          "class_code": "1486fe3b5a76578d99a65ba63e8a199b3884561849549d0a779b783b7d7226e9",
          "class_node_pos": [
            [
              308,
              0
            ],
            [
              326,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "ndots": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsNDots5TestAI() : MockExtraOptsNDotsTestAI(5) {}",
          "fn_code_pos": [
            [
              330,
              2
            ],
            [
              330,
              62
            ]
          ],
          "class_code": "329d50ae96af8d0ff6e553e3b3b64d42479f49c102234b0a78ed8afdf85f80f4",
          "class_node_pos": [
            [
              328,
              0
            ],
            [
              331,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsNDots5TestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsNDots5TestAI, SimpleQuery) {\n  ares_set_local_ip4(channel_, 0x7F000001);\n  byte addr6[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"dynamodb.us-east-1.amazonaws.com\", T_A))\n    .add_answer(new DNSARR(\"dynamodb.us-east-1.amazonaws.com\", 100, {123, 45, 67, 8}));\n  ON_CALL(server_, OnRequest(\"dynamodb.us-east-1.amazonaws.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"dynamodb.us-east-1.amazonaws.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"123.45.67.8\"));\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsNDots0TestAI() : MockExtraOptsNDotsTestAI(0) {}",
          "fn_code_pos": [
            [
              361,
              2
            ],
            [
              361,
              62
            ]
          ],
          "class_code": "bd4b4d223639770830da614caeb7ed27ab8e79f9e49a86b1648448924144dfdd",
          "class_node_pos": [
            [
              359,
              0
            ],
            [
              362,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsNDots0TestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsNDots0TestAI, SimpleQuery) {\n  DNSPacket rsp_ndots0;\n  rsp_ndots0.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0\", T_A))\n    .add_answer(new DNSARR(\"ndots0\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"ndots0\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp_ndots0));\n\n  DNSPacket rsp_ndots0_first;\n  rsp_ndots0_first.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.first.com\", T_A))\n    .add_answer(new DNSARR(\"ndots0.first.com\", 100, {99, 99, 99, 99}));\n  ON_CALL(server_, OnRequest(\"ndots0.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp_ndots0_first));\n\n  DNSPacket rsp_ndots0_second;\n  rsp_ndots0_second.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.second.org\", T_A))\n    .add_answer(new DNSARR(\"ndots0.second.org\", 100, {98, 98, 98, 98}));\n  ON_CALL(server_, OnRequest(\"ndots0.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp_ndots0_second));\n\n  DNSPacket rsp_ndots0_third;\n  rsp_ndots0_third.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.third.gov\", T_A))\n    .add_answer(new DNSARR(\"ndots0.third.gov\", 100, {97, 97, 97, 97}));\n  ON_CALL(server_, OnRequest(\"ndots0.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp_ndots0_third));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"ndots0\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{addr=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsNDots0TestAI, SystemdServFail) {\n  DNSPacket rsp_ndots0;\n  rsp_ndots0.set_response().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"ndots0\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"ndots0\", T_A))\n    // Will call until it hits max retries\n    .WillRepeatedly(SetReply(&server_, &rsp_ndots0));\n\n  DNSPacket rsp_ndots0_first;\n  rsp_ndots0_first.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.first.com\", T_A))\n    .add_answer(new DNSARR(\"ndots0.first.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"ndots0.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp_ndots0_first));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"ndots0\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{addr=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              411,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsNDots0TestAI, SystemdServFailSearch) {\n  DNSPacket rsp_ndots0;\n  rsp_ndots0.set_response().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"ndots0\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"ndots0\", T_A))\n    // Will call until it hits max retries\n    .WillRepeatedly(SetReply(&server_, &rsp_ndots0));\n\n  DNSPacket rsp_ndots0_first;\n  rsp_ndots0_first.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.first.com\", T_A))\n    .add_answer(new DNSARR(\"ndots0.first.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"ndots0.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp_ndots0_first));\n\n  QueryResult result;\n  ares_dns_record_t *dnsrec = NULL;\n  ares_dns_record_create(&dnsrec, 0, ARES_FLAG_RD, ARES_OPCODE_QUERY, ARES_RCODE_NOERROR);\n  ares_dns_record_query_add(dnsrec, \"ndots0\", ARES_REC_TYPE_A, ARES_CLASS_IN);\n  ares_search_dnsrec(channel_, dnsrec, QueryCallback, &result);\n  ares_dns_record_destroy(dnsrec);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n\n  // QueryResult doesn't provide an easy way to retrieve the address, just ignore,\n  // success is probably good enough\n}",
          "fn_code_pos": [
            [
              438,
              0
            ],
            [
              465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsNDots0TestAI, SystemdRefused) {\n  DNSPacket rsp_ndots0;\n  rsp_ndots0.set_response().set_rcode(REFUSED)\n    .add_question(new DNSQuestion(\"ndots0\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"ndots0\", T_A))\n    // Will call until it hits max retries\n    .WillRepeatedly(SetReply(&server_, &rsp_ndots0));\n\n  DNSPacket rsp_ndots0_first;\n  rsp_ndots0_first.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.first.com\", T_A))\n    .add_answer(new DNSARR(\"ndots0.first.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"ndots0.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp_ndots0_first));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"ndots0\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{addr=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsNDots0TestAI, SystemdRefusedSearch) {\n  DNSPacket rsp_ndots0;\n  rsp_ndots0.set_response().set_rcode(REFUSED)\n    .add_question(new DNSQuestion(\"ndots0\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"ndots0\", T_A))\n    // Will call until it hits max retries\n    .WillRepeatedly(SetReply(&server_, &rsp_ndots0));\n\n  DNSPacket rsp_ndots0_first;\n  rsp_ndots0_first.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.first.com\", T_A))\n    .add_answer(new DNSARR(\"ndots0.first.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"ndots0.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp_ndots0_first));\n\n  QueryResult result;\n  ares_dns_record_t *dnsrec = NULL;\n  ares_dns_record_create(&dnsrec, 0, ARES_FLAG_RD, ARES_OPCODE_QUERY, ARES_RCODE_NOERROR);\n  ares_dns_record_query_add(dnsrec, \"ndots0\", ARES_REC_TYPE_A, ARES_CLASS_IN);\n  ares_search_dnsrec(channel_, dnsrec, QueryCallback, &result);\n  ares_dns_record_destroy(dnsrec);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n\n  // QueryResult doesn't provide an easy way to retrieve the address, just ignore,\n  // success is probably good enough\n}",
          "fn_code_pos": [
            [
              493,
              0
            ],
            [
              520,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockFlagsChannelOptsTestAI(int flags)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              527,
              2
            ],
            [
              529,
              72
            ]
          ],
          "class_code": "936035d07b60f29f5443519068069b99dc5b450e99248c68cb55ef391b2f6d8c",
          "class_node_pos": [
            [
              523,
              0
            ],
            [
              537,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockFlagsChannelOptsTestAI",
            "parameters": {
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              530,
              2
            ],
            [
              534,
              3
            ]
          ],
          "class_code": "936035d07b60f29f5443519068069b99dc5b450e99248c68cb55ef391b2f6d8c",
          "class_node_pos": [
            [
              523,
              0
            ],
            [
              537,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockNoCheckRespChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_NOCHECKRESP) {}",
          "fn_code_pos": [
            [
              541,
              2
            ],
            [
              541,
              87
            ]
          ],
          "class_code": "2a3d3b9a62c21d8309120421a56dd83b6785e6b9cedb19197b54580ef4c1264f",
          "class_node_pos": [
            [
              539,
              0
            ],
            [
              542,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockNoCheckRespChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTestAI, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              544,
              0
            ],
            [
              560,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTestAI, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              562,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTestAI, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              596,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyV6) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET6;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV6Address(\"2121:0000:0000:0000:0000:0000:0000:0303\"));\n}",
          "fn_code_pos": [
            [
              598,
              0
            ],
            [
              617,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, PartialQueryCancel) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_UNSPEC;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n\n  // After 100ms, issues ares_cancel(), this should be enough time for the A\n  // record reply, but before the timeout on the AAAA record.\n  Process(100);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n}",
          "fn_code_pos": [
            [
              620,
              0
            ],
            [
              645,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyV4) {\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n  AddrInfoResult result = {};\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              647,
              0
            ],
            [
              664,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyV4_MultipleAddresses) {\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}))\n    .add_answer(new DNSARR(\"example.com\", 100, {7, 8, 9, 0}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n  AddrInfoResult result = {};\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{addr=[2.3.4.5], addr=[7.8.9.0]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              666,
              0
            ],
            [
              685,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyUnspecified) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(2));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n  EXPECT_THAT(result.ai_, IncludesV6Address(\"2121:0000:0000:0000:0000:0000:0000:0303\"));\n}",
          "fn_code_pos": [
            [
              687,
              0
            ],
            [
              713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, TriggerResendThenConnFailSERVFAIL) {\n  // Set up the server response. The server always returns SERVFAIL.\n  DNSPacket badrsp4;\n  badrsp4.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket goodrsp4;\n  goodrsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  DNSPacket goodrsp6;\n  goodrsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"www.google.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyAndFailSend(&server_, &badrsp4))\n    .WillOnce(SetReply(&server_, &goodrsp4));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillRepeatedly(SetReply(&server_, &goodrsp6));\n\n  ares_socket_functions sock_funcs;\n  memset(&sock_funcs, 0, sizeof(sock_funcs));\n\n  sock_funcs.asendv = ares_sendv_fail;\n\n  ares_set_socket_functions(channel_, &sock_funcs, NULL);\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(2));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"1.2.3.4\"));\n  EXPECT_THAT(result.ai_, IncludesV6Address(\"2121:0000:0000:0000:0000:0000:0000:0303\"));\n}",
          "fn_code_pos": [
            [
              716,
              0
            ],
            [
              760,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTestAI, TriggerResendThenConnFailEDNS) {\n  // Set up the server response to simulate an EDNS failure\n DNSPacket badrsp4;\n  badrsp4.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket goodrsp4;\n  goodrsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  DNSPacket goodrsp6;\n  goodrsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"www.google.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyAndFailSend(&server_, &badrsp4))\n    .WillOnce(SetReply(&server_, &goodrsp4));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillRepeatedly(SetReply(&server_, &goodrsp6));\n\n  ares_socket_functions sock_funcs;\n  memset(&sock_funcs, 0, sizeof(sock_funcs));\n\n  sock_funcs.asendv = ares_sendv_fail;\n\n  ares_set_socket_functions(channel_, &sock_funcs, NULL);\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(2));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"1.2.3.4\"));\n  EXPECT_THAT(result.ai_, IncludesV6Address(\"2121:0000:0000:0000:0000:0000:0000:0303\"));\n}",
          "fn_code_pos": [
            [
              762,
              0
            ],
            [
              805,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTestAI, ConnectionRefusedOnSearchDomainRetry) {\n  DNSPacket badrsp4;\n  badrsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .set_rcode(NXDOMAIN);\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyAndFailSend(&server_, &badrsp4));\n\n  DNSPacket goodrsp4;\n  goodrsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com.first.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &goodrsp4));\n\n  ares_socket_functions sock_funcs;\n  memset(&sock_funcs, 0, sizeof(sock_funcs));\n\n  sock_funcs.asendv = ares_sendv_fail;\n\n  ares_set_socket_functions(channel_, &sock_funcs, NULL);\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com\", NULL, &hints,\n                   AddrInfoCallback, &result);\n\n  Process();\n}",
          "fn_code_pos": [
            [
              807,
              0
            ],
            [
              839,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockEDNSChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_EDNS) {}",
          "fn_code_pos": [
            [
              843,
              2
            ],
            [
              843,
              73
            ]
          ],
          "class_code": "e78234b88eebc58a8d463346d9514abf0d13557809d28985d5c1a83738b610fe",
          "class_node_pos": [
            [
              841,
              0
            ],
            [
              844,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEDNSChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEDNSChannelTestAI, RetryWithoutEDNS) {\n  DNSPacket rspfail;\n  rspfail.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rspfail))\n    .WillOnce(SetReply(&server_, &rspok));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"1.2.3.4\"));\n}",
          "fn_code_pos": [
            [
              846,
              0
            ],
            [
              867,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, SearchDomains) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              869,
              0
            ],
            [
              896,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, SearchDomainsServFailOnAAAA) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nofirst4;\n  nofirst4.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst4));\n\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yessecond4;\n  yessecond4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A))\n    .add_answer(new DNSARR(\"www.second.org\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &yessecond4));\n\n  DNSPacket failthird;\n  failthird.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.third.gov\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &failthird));\n  DNSPacket failthird4;\n  failthird4.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &failthird4));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              898,
              0
            ],
            [
              942,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockMultiServerChannelTestAI(ares_options *opts, int optmask)\n    : MockChannelOptsTest(3, GetParam().first, GetParam().second, false, opts, optmask) {}",
          "fn_code_pos": [
            [
              948,
              2
            ],
            [
              949,
              90
            ]
          ],
          "class_code": "892b72663ba384b6a85914828c25c4a69216d0c6d686a974f0a093a63dfa8314",
          "class_node_pos": [
            [
              944,
              0
            ],
            [
              962,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockMultiServerChannelTestAI",
            "parameters": {
              "opts": "ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckExample() {\n    AddrInfoResult result;\n    struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n    hints.ai_family = AF_INET;\n    hints.ai_flags = ARES_AI_NOSORT;\n    ares_getaddrinfo(channel_, \"www.example.com.\", NULL, &hints, AddrInfoCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    EXPECT_EQ(result.status_, ARES_SUCCESS);\n    EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n    EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n  }",
          "fn_code_pos": [
            [
              950,
              2
            ],
            [
              961,
              3
            ]
          ],
          "class_code": "892b72663ba384b6a85914828c25c4a69216d0c6d686a974f0a093a63dfa8314",
          "class_node_pos": [
            [
              944,
              0
            ],
            [
              962,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckExample",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "NoRotateMultiMockTestAI() : MockMultiServerChannelTestAI(nullptr, ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              966,
              2
            ],
            [
              966,
              89
            ]
          ],
          "class_code": "d5153131571f6de3812b09fdb33ed3c90f1ae53dfaa622f4c8ea423a3edc3e62",
          "class_node_pos": [
            [
              964,
              0
            ],
            [
              967,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "NoRotateMultiMockTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockTestAI, v4Worksv6Timesout) {\n  std::vector<byte> nothing;\n\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &rsp4));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_AAAA))\n    .WillOnce(SetReplyData(servers_[0].get(), nothing));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.example.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(result.status_, ARES_SUCCESS);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"1.2.3.4\"));\n}",
          "fn_code_pos": [
            [
              975,
              0
            ],
            [
              998,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockTestAI, v6Worksv4TimesoutFirst) {\n  std::vector<byte> nothing;\n\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"www.example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReplyData(servers_[0].get(), nothing));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_AAAA))\n    .WillOnce(SetReply(servers_[0].get(), &rsp6));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &rsp4));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.example.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(result.status_, ARES_SUCCESS);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(2));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"1.2.3.4\"));\n  EXPECT_THAT(result.ai_, IncludesV6Address(\"2121:0000:0000:0000:0000:0000:0000:0303\"));\n\n}",
          "fn_code_pos": [
            [
              1000,
              0
            ],
            [
              1034,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockTestAI, ThirdServer) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &opts, &optmask));\n  EXPECT_EQ(ARES_OPT_NOROTATE, (optmask & ARES_OPT_NOROTATE));\n  ares_destroy_options(&opts);\n\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket notimplrsp;\n  notimplrsp.set_response().set_aa().set_rcode(NOTIMP)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n   EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  CheckExample();\n\n  // Second time around, still starts from server [2], as [0] and [1] both\n  // recorded failures\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Third time around, server order is [1] (f0), [2] (f1), [0] (f2), which\n  // means [1] will get called twice in a row as after the first call\n  // order will be  [1] (f1), [2] (f1), [0] (f2) since sort order is\n  // (failure count, index)\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              1036,
              0
            ],
            [
              1085,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyV4ServiceName) {\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {1, 1, 1, 1}))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 2, 2, 2}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n  AddrInfoResult result = {};\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com\", \"http\", &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{addr=[1.1.1.1:80], addr=[2.2.2.2:80]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1087,
              0
            ],
            [
              1105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ContainedMockChannelAISysConfig()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, true, nullptr, 0) {}",
          "fn_code_pos": [
            [
              1113,
              2
            ],
            [
              1114,
              86
            ]
          ],
          "class_code": "b0dce613ec8b3766448faee8d5da529de804e7987803f12383c908af02c6c7a0",
          "class_node_pos": [
            [
              1109,
              0
            ],
            [
              1115,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ContainedMockChannelAISysConfig",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              271,
              30
            ],
            [
              271,
              69
            ]
          ],
          "class_code": "8cd200b5abe974f89ec972b8fba08cab1bc6cef0e5c40d0a812f663f6e4d9a23",
          "class_node_pos": [
            [
              263,
              0
            ],
            [
              280,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts, int ndots)",
          "fn_dec_pos": [
            [
              316,
              30
            ],
            [
              316,
              80
            ]
          ],
          "class_code": "1486fe3b5a76578d99a65ba63e8a199b3884561849549d0a779b783b7d7226e9",
          "class_node_pos": [
            [
              308,
              0
            ],
            [
              326,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "ndots": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts, int flags)",
          "fn_dec_pos": [
            [
              530,
              30
            ],
            [
              530,
              80
            ]
          ],
          "class_code": "936035d07b60f29f5443519068069b99dc5b450e99248c68cb55ef391b2f6d8c",
          "class_node_pos": [
            [
              523,
              0
            ],
            [
              537,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "8cd200b5abe974f89ec972b8fba08cab1bc6cef0e5c40d0a812f663f6e4d9a23": {
          "class_code": "class MockExtraOptsTestAI\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockExtraOptsTestAI()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockExtraOptsTestAI",
          "class_pos": [
            [
              263,
              0
            ],
            [
              280,
              1
            ]
          ]
        },
        "1486fe3b5a76578d99a65ba63e8a199b3884561849549d0a779b783b7d7226e9": {
          "class_code": "class MockExtraOptsNDotsTestAI\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockExtraOptsNDotsTestAI(int ndots)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_, ndots),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF|ARES_OPT_NDOTS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts, int ndots) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    opts->ndots = ndots;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockExtraOptsNDotsTestAI",
          "class_pos": [
            [
              308,
              0
            ],
            [
              326,
              1
            ]
          ]
        },
        "329d50ae96af8d0ff6e553e3b3b64d42479f49c102234b0a78ed8afdf85f80f4": {
          "class_code": "class MockExtraOptsNDots5TestAI : public MockExtraOptsNDotsTestAI {\n public:\n  MockExtraOptsNDots5TestAI() : MockExtraOptsNDotsTestAI(5) {}\n}",
          "class_name": "MockExtraOptsNDots5TestAI",
          "class_pos": [
            [
              328,
              0
            ],
            [
              331,
              1
            ]
          ]
        },
        "bd4b4d223639770830da614caeb7ed27ab8e79f9e49a86b1648448924144dfdd": {
          "class_code": "class MockExtraOptsNDots0TestAI : public MockExtraOptsNDotsTestAI {\n public:\n  MockExtraOptsNDots0TestAI() : MockExtraOptsNDotsTestAI(0) {}\n}",
          "class_name": "MockExtraOptsNDots0TestAI",
          "class_pos": [
            [
              359,
              0
            ],
            [
              362,
              1
            ]
          ]
        },
        "936035d07b60f29f5443519068069b99dc5b450e99248c68cb55ef391b2f6d8c": {
          "class_code": "class MockFlagsChannelOptsTestAI\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockFlagsChannelOptsTestAI(int flags)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockFlagsChannelOptsTestAI",
          "class_pos": [
            [
              523,
              0
            ],
            [
              537,
              1
            ]
          ]
        },
        "2a3d3b9a62c21d8309120421a56dd83b6785e6b9cedb19197b54580ef4c1264f": {
          "class_code": "class MockNoCheckRespChannelTestAI : public MockFlagsChannelOptsTestAI {\n public:\n  MockNoCheckRespChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_NOCHECKRESP) {}\n}",
          "class_name": "MockNoCheckRespChannelTestAI",
          "class_pos": [
            [
              539,
              0
            ],
            [
              542,
              1
            ]
          ]
        },
        "e78234b88eebc58a8d463346d9514abf0d13557809d28985d5c1a83738b610fe": {
          "class_code": "class MockEDNSChannelTestAI : public MockFlagsChannelOptsTestAI {\n public:\n  MockEDNSChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_EDNS) {}\n}",
          "class_name": "MockEDNSChannelTestAI",
          "class_pos": [
            [
              841,
              0
            ],
            [
              844,
              1
            ]
          ]
        },
        "892b72663ba384b6a85914828c25c4a69216d0c6d686a974f0a093a63dfa8314": {
          "class_code": "class MockMultiServerChannelTestAI\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockMultiServerChannelTestAI(ares_options *opts, int optmask)\n    : MockChannelOptsTest(3, GetParam().first, GetParam().second, false, opts, optmask) {}\n  void CheckExample() {\n    AddrInfoResult result;\n    struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n    hints.ai_family = AF_INET;\n    hints.ai_flags = ARES_AI_NOSORT;\n    ares_getaddrinfo(channel_, \"www.example.com.\", NULL, &hints, AddrInfoCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    EXPECT_EQ(result.status_, ARES_SUCCESS);\n    EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n    EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n  }\n}",
          "class_name": "MockMultiServerChannelTestAI",
          "class_pos": [
            [
              944,
              0
            ],
            [
              962,
              1
            ]
          ]
        },
        "d5153131571f6de3812b09fdb33ed3c90f1ae53dfaa622f4c8ea423a3edc3e62": {
          "class_code": "class NoRotateMultiMockTestAI : public MockMultiServerChannelTestAI {\n public:\n  NoRotateMultiMockTestAI() : MockMultiServerChannelTestAI(nullptr, ARES_OPT_NOROTATE) {}\n}",
          "class_name": "NoRotateMultiMockTestAI",
          "class_pos": [
            [
              964,
              0
            ],
            [
              967,
              1
            ]
          ]
        },
        "b0dce613ec8b3766448faee8d5da529de804e7987803f12383c908af02c6c7a0": {
          "class_code": "class ContainedMockChannelAISysConfig\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface<std::pair<int, bool>> {\n public:\n  ContainedMockChannelAISysConfig()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, true, nullptr, 0) {}\n}",
          "class_name": "ContainedMockChannelAISysConfig",
          "class_pos": [
            [
              1109,
              0
            ],
            [
              1115,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct sockaddr_in",
          {},
          "",
          [
            61,
            33
          ],
          [
            61,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            81,
            33
          ],
          [
            81,
            52
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            106,
            2
          ],
          [
            106,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            147,
            2
          ],
          [
            147,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            164,
            2
          ],
          [
            164,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            182,
            2
          ],
          [
            182,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            200,
            2
          ],
          [
            200,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            218,
            2
          ],
          [
            218,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            236,
            2
          ],
          [
            236,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            254,
            2
          ],
          [
            254,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            271,
            9
          ],
          [
            271,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            271,
            42
          ],
          [
            271,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            272,
            27
          ],
          [
            272,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            279,
            2
          ],
          [
            279,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            297,
            2
          ],
          [
            297,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            316,
            9
          ],
          [
            316,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            316,
            42
          ],
          [
            316,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            317,
            27
          ],
          [
            317,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            325,
            2
          ],
          [
            325,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            348,
            2
          ],
          [
            348,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            394,
            2
          ],
          [
            394,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            427,
            2
          ],
          [
            427,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            482,
            2
          ],
          [
            482,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            530,
            9
          ],
          [
            530,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            530,
            42
          ],
          [
            530,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            531,
            27
          ],
          [
            531,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            536,
            2
          ],
          [
            536,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            553,
            2
          ],
          [
            553,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            571,
            2
          ],
          [
            571,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            589,
            2
          ],
          [
            589,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            608,
            2
          ],
          [
            608,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            635,
            2
          ],
          [
            635,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            655,
            2
          ],
          [
            655,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            675,
            2
          ],
          [
            675,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            703,
            2
          ],
          [
            703,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            748,
            2
          ],
          [
            748,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            793,
            2
          ],
          [
            793,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            832,
            2
          ],
          [
            832,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            859,
            2
          ],
          [
            859,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            888,
            2
          ],
          [
            888,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            934,
            2
          ],
          [
            934,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            952,
            4
          ],
          [
            952,
            30
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            989,
            2
          ],
          [
            989,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1023,
            2
          ],
          [
            1023,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1037,
            2
          ],
          [
            1037,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1096,
            2
          ],
          [
            1096,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1129,
            2
          ],
          [
            1129,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1144,
            2
          ],
          [
            1144,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1159,
            2
          ],
          [
            1159,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1184,
            2
          ],
          [
            1184,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1199,
            2
          ],
          [
            1199,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1214,
            2
          ],
          [
            1214,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1237,
            2
          ],
          [
            1237,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1252,
            2
          ],
          [
            1252,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            1267,
            2
          ],
          [
            1267,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test-ai.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-ns.cc": {
      "fn_def_list": [
        {
          "fn_code": "int EnterContainer(void *data) {\n  ContainerInfo *container = (ContainerInfo*)data;\n\n  if (verbose) {\n    std::cerr << \"Running function in container {chroot='\"\n              << container->fs_->root() << \"', hostname='\" << container->hostname_\n              << \"', domainname='\" << container->domainname_ << \"'}\"\n              << std::endl;\n  }\n\n  // Ensure we are apparently root before continuing.\n  int count = 10;\n  while (getuid() != 0 && count > 0) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    count--;\n  }\n  if (getuid() != 0) {\n    std::cerr << \"Child in user namespace has uid \" << getuid() << std::endl;\n    return -1;\n  }\n  if (!container->fs_->mountpt().empty()) {\n    // We want to bind mount this inside the specified directory.\n    std::string innerdir = container->fs_->root() + container->fs_->mountpt();\n    if (verbose) std::cerr << \" mount --bind \" << container->fs_->mountpt()\n                           << \" \" << innerdir << std::endl;\n    int rc = mount(container->fs_->mountpt().c_str(), innerdir.c_str(),\n                   \"none\", MS_BIND, 0);\n    if (rc != 0) {\n      std::cerr << \"Warning: failed to bind mount \" << container->fs_->mountpt() << \" at \"\n                << innerdir << \", errno=\" << errno << std::endl;\n    }\n  }\n\n  // Move into the specified directory.\n  if (chdir(container->fs_->root().c_str()) != 0) {\n    std::cerr << \"Failed to chdir('\" << container->fs_->root()\n              << \"'), errno=\" << errno << std::endl;\n    return -1;\n  }\n  // And make it the new root directory;\n  char buffer[PATH_MAX + 1];\n  if (getcwd(buffer, PATH_MAX) == NULL) {\n    std::cerr << \"failed to retrieve cwd, errno=\" << errno << std::endl;\n    return -1;\n  }\n  buffer[PATH_MAX] = '\\0';\n  if (chroot(buffer) != 0) {\n    std::cerr << \"chroot('\" << buffer << \"') failed, errno=\" << errno << std::endl;\n    return -1;\n  }\n\n  // Set host/domainnames if specified\n  if (!container->hostname_.empty()) {\n    if (sethostname(container->hostname_.c_str(),\n                    container->hostname_.size()) != 0) {\n      std::cerr << \"Failed to sethostname('\" << container->hostname_\n                << \"'), errno=\" << errno << std::endl;\n      return -1;\n    }\n  }\n  if (!container->domainname_.empty()) {\n    if (setdomainname(container->domainname_.c_str(),\n                      container->domainname_.size()) != 0) {\n      std::cerr << \"Failed to setdomainname('\" << container->domainname_\n                << \"'), errno=\" << errno << std::endl;\n      return -1;\n    }\n  }\n\n  return container->fn_();\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EnterContainer",
            "parameters": {
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int RunInContainer(ContainerFilesystem* fs, const std::string& hostname,\n                   const std::string& domainname, VoidToIntFn fn) {\n  const int stack_size = 1024 * 1024;\n  std::vector<byte> stack(stack_size, 0);\n  ContainerInfo container = {fs, hostname, domainname, fn};\n\n  // Start a child process in a new user and UTS namespace\n  pid_t child = clone(EnterContainer, stack.data() + stack_size,\n                      CLONE_VM|CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWUTS|SIGCHLD,\n                      (void *)&container);\n  if (child < 0) {\n    std::cerr << \"Failed to clone(), errno=\" << errno << std::endl;\n    return -1;\n  }\n\n  // Build the UID map that makes us look like root inside the namespace.\n  std::stringstream mapfiless;\n  mapfiless << \"/proc/\" << child << \"/uid_map\";\n  std::string mapfile = mapfiless.str();\n  int fd = open(mapfile.c_str(), O_CREAT|O_WRONLY|O_TRUNC, 0644);\n  if (fd < 0) {\n    std::cerr << \"Failed to create '\" << mapfile << \"'\" << std::endl;\n    return -1;\n  }\n  std::stringstream contentss;\n  contentss << \"0 \" << getuid() << \" 1\" << std::endl;\n  std::string content = contentss.str();\n  ssize_t rc = write(fd, content.c_str(), content.size());\n  if (rc != (ssize_t)content.size()) {\n    std::cerr << \"Failed to write uid map to '\" << mapfile << \"'\" << std::endl;\n  }\n  close(fd);\n\n  // Wait for the child process and retrieve its status.\n  int status;\n  waitpid(child, &status, 0);\n  if (rc <= 0) {\n    std::cerr << \"Failed to waitpid(\" << child << \")\" << std::endl;\n    return -1;\n  }\n  if (!WIFEXITED(status)) {\n    std::cerr << \"Child \" << child << \" did not exit normally\" << std::endl;\n    return -1;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RunInContainer",
            "parameters": {
              "fs": "ContainerFilesystem",
              "hostname": "std::string",
              "domainname": "std::string",
              "fn": "VoidToIntFn"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ContainerFilesystem::ContainerFilesystem(NameContentList files, const std::string& mountpt) {\n  rootdir_ = TempNam(nullptr, \"ares-chroot\");\n  mkdir(rootdir_.c_str(), 0755);\n  dirs_.push_front(rootdir_);\n  for (const auto& nc : files) {\n    std::string fullpath = rootdir_ + nc.first;\n    size_t idx = fullpath.rfind('/');\n    std::string dir;\n    if (idx != SIZE_MAX) {\n      dir = fullpath.substr(0, idx);\n    } else {\n      dir = fullpath;\n    }\n    EnsureDirExists(dir);\n    files_.push_back(std::unique_ptr<TransientFile>(\n        new TransientFile(fullpath, nc.second)));\n  }\n  if (!mountpt.empty()) {\n    char buffer[PATH_MAX + 1];\n    if (realpath(mountpt.c_str(), buffer)) {\n      mountpt_ = buffer;\n      std::string fullpath = rootdir_ + mountpt_;\n      EnsureDirExists(fullpath);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ContainerFilesystem::ContainerFilesystem",
            "parameters": {
              "files": "NameContentList",
              "mountpt": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ContainerFilesystem::~ContainerFilesystem() {\n  files_.clear();\n  for (const std::string& dir : dirs_) {\n    rmdir(dir.c_str());\n  }\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ContainerFilesystem::~ContainerFilesystem",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void ContainerFilesystem::EnsureDirExists(const std::string& dir) {\n  if (std::find(dirs_.begin(), dirs_.end(), dir) != dirs_.end()) {\n    return;\n  }\n  size_t idx = dir.rfind('/');\n  if (idx != SIZE_MAX) {\n    std::string prevdir = dir.substr(0, idx);\n    EnsureDirExists(prevdir);\n  }\n  // Ensure this directory is in the list before its ancestors.\n  mkdir(dir.c_str(), 0755);\n  dirs_.push_front(dir);\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ContainerFilesystem::EnsureDirExists",
            "parameters": {
              "dir": "std::string"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ContainerInfo {\n  ContainerFilesystem* fs_;\n  std::string hostname_;\n  std::string domainname_;\n  VoidToIntFn fn_;\n}",
          {
            "* fs_": "ContainerFilesystem",
            "hostname_": "std::string",
            "domainname_": "std::string",
            "fn_": "VoidToIntFn"
          },
          "ContainerInfo",
          [
            45,
            0
          ],
          [
            50,
            1
          ]
        ],
        [
          "struct ContainerInfo {\n  ContainerFilesystem* fs_;\n  std::string hostname_;\n  std::string domainname_;\n  VoidToIntFn fn_;\n}",
          {
            "* fs_": "ContainerFilesystem",
            "hostname_": "std::string",
            "domainname_": "std::string",
            "fn_": "VoidToIntFn"
          },
          "ContainerInfo",
          [
            45,
            0
          ],
          [
            50,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <sys/mount.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <iostream>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <functional>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-ptr.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyOK) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.com' aliases=[other.com] addrs=[16.32.48.64]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyCname) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSCnameRR(\"64.48.32.16.in-addr.arpa\", 50, \"64.48.32.8.in-addr.arpa\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.8.in-addr.arpa\", 100, \"other.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.com' aliases=[other.com] addrs=[16.32.48.64]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNSMalformedCnameRR(const std::string& name, int ttl, const std::string& other)\n    : DNSCnameRR(name, ttl, other) {}",
          "fn_code_pos": [
            [
              73,
              2
            ],
            [
              74,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSMalformedCnameRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> data(const ares_dns_record_t *dnsrec) const {\n    std::vector<byte> data = DNSRR::data(dnsrec);\n    std::vector<byte> encname = EncodeString(other_);\n    encname[0] = encname[0] + 63;  // invalid label length\n    int len = (int)encname.size();\n    PushInt16(&data, len);\n    data.insert(data.end(), encname.begin(), encname.end());\n    return data;\n  }",
          "fn_code_pos": [
            [
              75,
              2
            ],
            [
              83,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyMalformedCname) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSMalformedCnameRR(\"64.48.32.16.in-addr.arpa\", 50, \"64.48.32.8.in-addr.arpa\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.8.in-addr.arpa\", 100, \"other.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                                addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_EQ(nullptr, host);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseManyPtrReply) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"main.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other1.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other2.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other3.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other4.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other5.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other6.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other7.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other8.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other9.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyAdditional) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 55, \"other.com\"))\n    .add_auth(new DNSNsRR(\"16.in-addr.arpa\", 234, \"ns1.other.com\"))\n    .add_auth(new DNSNsRR(\"16.in-addr.arpa\", 234, \"bb.ns2.other.com\"))\n    .add_auth(new DNSNsRR(\"16.in-addr.arpa\", 234, \"ns3.other.com\"))\n    .add_additional(new DNSARR(\"ns1.other.com\", 229, {10,20,30,41}))\n    .add_additional(new DNSARR(\"bb.ns2.other.com\", 229, {10,20,30,42}))\n    .add_additional(new DNSARR(\"ns3.other.com\", 229, {10,20,30,43}));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.com' aliases=[other.com] addrs=[16.32.48.64]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyErrors) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other.com\"));\n  std::vector<byte> data;\n  struct hostent *host = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                                addrv4, sizeof(addrv4), AF_INET, &host));\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Question != answer, ok after #683\n  host = nullptr;\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"99.48.32.16.in-addr.arpa\", T_PTR));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.com' aliases=[other.com] addrs=[16.32.48.64]}\", ss.str());\n  ares_free_hostent(host);\n\n  host = nullptr;\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                                addrv4, sizeof(addrv4), AF_INET, &host));\n  EXPECT_EQ(nullptr, host);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  EXPECT_EQ(nullptr, host);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)len,\n                                                  addrv4, sizeof(addrv4), AF_INET, &host));\n    EXPECT_EQ(nullptr, host);\n  }\n\n  // Truncated packets with CNAME.\n  pkt.add_answer(new DNSCnameRR(\"64.48.32.16.in-addr.arpa\", 50, \"64.48.32.8.in-addr.arpa\"));\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)len,\n                                                  addrv4, sizeof(addrv4), AF_INET, &host));\n    EXPECT_EQ(nullptr, host);\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), -1,\n                                                addrv4, sizeof(addrv4), AF_INET, &host));\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyAllocFailSome) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"main.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other1.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other2.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other3.com\"));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n\n  for (int ii = 1; ii <= 18; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                                addrv4, sizeof(addrv4), AF_INET, &host)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              249,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyAllocFailMany) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"main.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other1.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other2.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other3.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other4.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other5.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other6.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other7.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other8.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other9.com\"));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n\n  for (int ii = 1; ii <= 63; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    int rc = ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                  addrv4, sizeof(addrv4), AF_INET, &host);\n    if (rc != ARES_ENOMEM) {\n      EXPECT_EQ(ARES_SUCCESS, rc);\n      ares_free_hostent(host);\n      host = nullptr;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              251,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct DNSMalformedCnameRR : public DNSCnameRR {\n  DNSMalformedCnameRR(const std::string& name, int ttl, const std::string& other)\n    : DNSCnameRR(name, ttl, other) {}\n  std::vector<byte> data(const ares_dns_record_t *dnsrec) const {\n    std::vector<byte> data = DNSRR::data(dnsrec);\n    std::vector<byte> encname = EncodeString(other_);\n    encname[0] = encname[0] + 63;  // invalid label length\n    int len = (int)encname.size();\n    PushInt16(&data, len);\n    data.insert(data.end(), encname.begin(), encname.end());\n    return data;\n  }\n}",
          {},
          "",
          [
            72,
            0
          ],
          [
            84,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            61,
            2
          ],
          [
            61,
            16
          ]
        ],
        [
          "struct DNSMalformedCnameRR : public DNSCnameRR {\n  DNSMalformedCnameRR(const std::string& name, int ttl, const std::string& other)\n    : DNSCnameRR(name, ttl, other) {}\n  std::vector<byte> data(const ares_dns_record_t *dnsrec) const {\n    std::vector<byte> data = DNSRR::data(dnsrec);\n    std::vector<byte> encname = EncodeString(other_);\n    encname[0] = encname[0] + 63;  // invalid label length\n    int len = (int)encname.size();\n    PushInt16(&data, len);\n    data.insert(data.end(), encname.begin(), encname.end());\n    return data;\n  }\n}",
          {},
          "",
          [
            72,
            0
          ],
          [
            84,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            95,
            2
          ],
          [
            95,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            118,
            2
          ],
          [
            118,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            139,
            2
          ],
          [
            139,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            156,
            2
          ],
          [
            156,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            241,
            2
          ],
          [
            241,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            267,
            2
          ],
          [
            267,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-mx.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseMxReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 200, \"mx2.example.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_mx_reply* mx = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  ASSERT_NE(nullptr, mx);\n  EXPECT_EQ(\"mx1.example.com\", std::string(mx->host));\n  EXPECT_EQ(100, mx->priority);\n\n  struct ares_mx_reply* mx2 = mx->next;\n  ASSERT_NE(nullptr, mx2);\n  EXPECT_EQ(\"mx2.example.com\", std::string(mx2->host));\n  EXPECT_EQ(200, mx2->priority);\n  EXPECT_EQ(nullptr, mx2->next);\n\n  ares_free_data(mx);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseMxReplyMalformed) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x0F,  // type MX\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x0F,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x01,  // rdata length -- too short\n    0x02,\n  };\n\n  struct ares_mx_reply* mx = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  ASSERT_EQ(nullptr, mx);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseMxReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  std::vector<byte> data;\n  struct ares_mx_reply* mx = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  EXPECT_EQ(nullptr, mx);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_MX));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  EXPECT_EQ(nullptr, mx);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n\n  // Wrong sort of answer.\n  // TODO(drysdale): check if this should be ARES_ENODATA?\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  EXPECT_EQ(nullptr, mx);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  EXPECT_EQ(nullptr, mx);\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    int rc = ares_parse_mx_reply(data.data(), (int)len, &mx);\n    EXPECT_EQ(nullptr, mx);\n    EXPECT_TRUE(rc == ARES_EBADRESP || rc == ARES_EBADNAME);\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), -1, &mx));\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseMxReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSMxRR(\"c.example.com\", 100, 100, \"mx1.example.com\"));\n  std::vector<byte> data = pkt.data();\n  struct ares_mx_reply* mx = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_mx_reply(data.data(), (int)data.size(), &mx)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            48,
            2
          ],
          [
            48,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            83,
            2
          ],
          [
            83,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            95,
            2
          ],
          [
            95,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            158,
            2
          ],
          [
            158,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-srv.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_SRV))\n    .add_answer(new DNSSrvRR(\"example.com\", 100, 10, 20, 30, \"srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"example.com\", 100, 11, 21, 31, \"srv2.example.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  ASSERT_NE(nullptr, srv);\n\n  EXPECT_EQ(\"srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(10, srv->priority);\n  EXPECT_EQ(20, srv->weight);\n  EXPECT_EQ(30, srv->port);\n\n  struct ares_srv_reply* srv2 = srv->next;\n  ASSERT_NE(nullptr, srv2);\n  EXPECT_EQ(\"srv2.example.com\", std::string(srv2->host));\n  EXPECT_EQ(11, srv2->priority);\n  EXPECT_EQ(21, srv2->weight);\n  EXPECT_EQ(31, srv2->port);\n  EXPECT_EQ(nullptr, srv2->next);\n\n  ares_free_data(srv);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplySingle) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV))\n    .add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else1.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else2.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else3.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else4.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else5.where.com\"))\n    .add_additional(new DNSARR(\"else2.where.com\", 42, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else5.where.com\", 42, {172,19,0,2}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  ASSERT_NE(nullptr, srv);\n\n  EXPECT_EQ(\"example.abc.def.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(10, srv->weight);\n  EXPECT_EQ(8160, srv->port);\n  EXPECT_EQ(nullptr, srv->next);\n\n  ares_free_data(srv);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyMalformed) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x21,  // type SRV\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x21,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length -- too short\n    0x02, 0x03, 0x04, 0x05,\n  };\n\n  struct ares_srv_reply* srv = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  ASSERT_EQ(nullptr, srv);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_ra().set_rd()\n    .add_question(new DNSQuestion(\"srv.example.com\", T_SRV))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 6789, \"a1.srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 4567, \"a2.srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 5678, \"a3.srv.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns3.example.com\"))\n    .add_additional(new DNSARR(\"a1.srv.example.com\", 300, {172,19,1,1}))\n    .add_additional(new DNSARR(\"a2.srv.example.com\", 300, {172,19,1,2}))\n    .add_additional(new DNSARR(\"a3.srv.example.com\", 300, {172,19,1,3}))\n    .add_additional(new DNSARR(\"n1.example.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"n2.example.com\", 300, {172,19,0,2}))\n    .add_additional(new DNSARR(\"n3.example.com\", 300, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv0 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv0));\n  ASSERT_NE(nullptr, srv0);\n  struct ares_srv_reply* srv = srv0;\n\n  EXPECT_EQ(\"a1.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(6789, srv->port);\n  EXPECT_NE(nullptr, srv->next);\n  srv = srv->next;\n\n  EXPECT_EQ(\"a2.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(4567, srv->port);\n  EXPECT_NE(nullptr, srv->next);\n  srv = srv->next;\n\n  EXPECT_EQ(\"a3.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(5678, srv->port);\n  EXPECT_EQ(nullptr, srv->next);\n\n  ares_free_data(srv0);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyCname) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV))\n    .add_answer(new DNSCnameRR(\"example.abc.def.com\", 300, \"cname.abc.def.com\"))\n    .add_answer(new DNSSrvRR(\"cname.abc.def.com\", 300, 0, 10, 1234, \"srv.abc.def.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else1.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else2.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else3.where.com\"))\n    .add_additional(new DNSARR(\"example.abc.def.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else1.where.com\", 42, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else2.where.com\", 42, {172,19,0,2}))\n    .add_additional(new DNSARR(\"else3.where.com\", 42, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  ASSERT_NE(nullptr, srv);\n\n  EXPECT_EQ(\"srv.abc.def.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(10, srv->weight);\n  EXPECT_EQ(1234, srv->port);\n  EXPECT_EQ(nullptr, srv->next);\n\n  ares_free_data(srv);\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyCnameMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_ra().set_rd()\n    .add_question(new DNSQuestion(\"query.example.com\", T_SRV))\n    .add_answer(new DNSCnameRR(\"query.example.com\", 300, \"srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 6789, \"a1.srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 4567, \"a2.srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 5678, \"a3.srv.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns3.example.com\"))\n    .add_additional(new DNSARR(\"a1.srv.example.com\", 300, {172,19,1,1}))\n    .add_additional(new DNSARR(\"a2.srv.example.com\", 300, {172,19,1,2}))\n    .add_additional(new DNSARR(\"a3.srv.example.com\", 300, {172,19,1,3}))\n    .add_additional(new DNSARR(\"n1.example.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"n2.example.com\", 300, {172,19,0,2}))\n    .add_additional(new DNSARR(\"n3.example.com\", 300, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv0 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv0));\n  ASSERT_NE(nullptr, srv0);\n  struct ares_srv_reply* srv = srv0;\n\n  EXPECT_EQ(\"a1.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(6789, srv->port);\n  EXPECT_NE(nullptr, srv->next);\n  srv = srv->next;\n\n  EXPECT_EQ(\"a2.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(4567, srv->port);\n  EXPECT_NE(nullptr, srv->next);\n  srv = srv->next;\n\n  EXPECT_EQ(\"a3.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(5678, srv->port);\n  EXPECT_EQ(nullptr, srv->next);\n\n  ares_free_data(srv0);\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV))\n    .add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n  std::vector<byte> data;\n  struct ares_srv_reply* srv = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  pkt.add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_SRV));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SRV));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  EXPECT_EQ(nullptr, srv);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  pkt.add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    int rc = ares_parse_srv_reply(data.data(), (int)len, &srv);\n    EXPECT_TRUE(rc == ARES_EBADRESP || rc == ARES_EBADNAME);\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_srv_reply(data.data(), -1, &srv));\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n  std::vector<byte> data = pkt.data();\n  struct ares_srv_reply* srv = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_srv_reply(data.data(), (int)data.size(), &srv)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            51,
            2
          ],
          [
            51,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            76,
            2
          ],
          [
            76,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            115,
            2
          ],
          [
            115,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            138,
            2
          ],
          [
            138,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            141,
            2
          ],
          [
            141,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            181,
            2
          ],
          [
            181,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            213,
            2
          ],
          [
            213,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            216,
            2
          ],
          [
            216,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            247,
            2
          ],
          [
            247,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            305,
            2
          ],
          [
            305,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-mock-et.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp1;\n  rsp1.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp1));\n  DNSPacket rsp2;\n  rsp2.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp2));\n\n  HostResult result1;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result1);\n  HostResult result2;\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result2);\n  HostResult result3;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result3);\n  Process();\n  EXPECT_TRUE(result1.done_);\n  EXPECT_TRUE(result2.done_);\n  EXPECT_TRUE(result3.done_);\n  std::stringstream ss1;\n  ss1 << result1.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n  std::stringstream ss2;\n  ss2 << result2.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[1.2.3.4]}\", ss2.str());\n  std::stringstream ss3;\n  ss3 << result3.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss3.str());\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, BadLoopbackServerNoTimeouts) {\n  ares_set_servers_csv(channel_, \"127.0.0.1:12345\");\n#define BADLOOPBACK_TESTCNT 5\n  HostResult result[BADLOOPBACK_TESTCNT];\n  for (size_t i=0; i<BADLOOPBACK_TESTCNT; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result[i]);\n  }\n  Process();\n  for (size_t i=0; i<BADLOOPBACK_TESTCNT; i++) {\n    EXPECT_TRUE(result[i].done_);\n\n    /* This test relies on the ICMP unreachable packet coming back on UDP connections\n     * when there is no listener on the other end.  Most OS's handle this properly,\n     * but not all.  For instance, Solaris 11 seems to not be compliant (it\n     * does however honor it sometimes, just not always) so while we still run\n     * the test, we don't do a strict validation of the result.\n     *\n     * Windows also appears to have intermittent issues, AppVeyor fails but GitHub Actions\n     * succeeds, which seems strange.  This test goes to loopback so the network\n     * it resides on shouldn't matter.\n     *\n     * This test is really just testing an optimization, UDP is connectionless so you\n     * should expect most connections to rely on timeouts and not ICMP unreachable.\n     */\n# if defined(__sun) || defined(_WIN32) || defined(__NetBSD__)\n    EXPECT_TRUE(result[i].status_ == ARES_ECONNREFUSED || result[i].status_ == ARES_ETIMEOUT || result[i].status_ == ARES_ESERVFAIL);\n# else\n    EXPECT_EQ(ARES_ECONNREFUSED, result[i].status_);\n    EXPECT_EQ(0, result[i].timeouts_);\n#endif\n  }\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int noop_close(ares_socket_t sock, void *user_data)\n{\n  (void)user_data;\n#if defined(HAVE_CLOSESOCKET)\n  return closesocket(sock);\n#elif defined(HAVE_CLOSESOCKET_CAMEL)\n  return CloseSocket(sock);\n#elif defined(HAVE_CLOSE_S)\n  return close_s(sock);\n#else\n  return close(sock);\n#endif\n  return 0;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "noop_close",
            "parameters": {
              "sock": "ares_socket_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_socket_t noop_socket(int domain, int type, int protocol,\n                                 void *user_data)\n{\n  (void)user_data;\n  return socket(domain, type, protocol);\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "noop_socket",
            "parameters": {
              "domain": "int",
              "type": "int",
              "protocol": "int",
              "user_data": "void"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "static int noop_setsockopt(ares_socket_t sock, ares_socket_opt_t opt,\n                           const void *val, ares_socklen_t val_size,\n                           void *user_data)\n{\n  (void)sock;\n  (void)opt;\n  (void)val;\n  (void)val_size;\n  (void)user_data;\n  return 0;\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "noop_setsockopt",
            "parameters": {
              "sock": "ares_socket_t",
              "opt": "ares_socket_opt_t",
              "val": "void",
              "val_size": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int noop_connect(ares_socket_t sock, const struct sockaddr *address,\n                        ares_socklen_t address_len, unsigned int flags,\n                        void *user_data)\n{\n  (void)sock;\n  (void)address;\n  (void)address_len;\n  (void)flags;\n  (void)user_data;\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "noop_connect",
            "parameters": {
              "sock": "ares_socket_t",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "flags": "unsigned int",
              "user_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_ssize_t noop_recvfrom(ares_socket_t sock, void *buffer,\n                                  size_t length, int flags,\n                                  struct sockaddr *address,\n                                  ares_socklen_t  *address_len,\n                                  void            *user_data)\n{\n  (void)sock;\n  (void)buffer;\n  (void)length;\n  (void)flags;\n  (void)address;\n  (void)address_len;\n  (void)user_data;\n\n  errno = EAGAIN;\n  return 0;\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "noop_recvfrom",
            "parameters": {
              "sock": "ares_socket_t",
              "buffer": "void",
              "length": "size_t",
              "flags": "int",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "static ares_ssize_t noop_sendto(ares_socket_t sock, const void *buffer,\n                                size_t length, int flags,\n                                const struct sockaddr *address,\n                                ares_socklen_t address_len, void *user_data)\n{\n  (void)sock;\n  (void)buffer;\n  (void)flags;\n  (void)address;\n  (void)address_len;\n  (void)user_data;\n  /* Eat all data */\n  return (ares_ssize_t)length;\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "noop_sendto",
            "parameters": {
              "sock": "ares_socket_t",
              "buffer": "void",
              "length": "size_t",
              "flags": "int",
              "address": "struct sockaddr",
              "address_len": "ares_socklen_t",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, DownServer) {\n  struct ares_socket_functions_ex noop_sock_funcs;\n  memset(&noop_sock_funcs, 0, sizeof(noop_sock_funcs));\n  noop_sock_funcs.version     = 1;\n  noop_sock_funcs.asocket     = noop_socket;\n  noop_sock_funcs.aclose      = noop_close;\n  noop_sock_funcs.asetsockopt = noop_setsockopt;\n  noop_sock_funcs.aconnect    = noop_connect;\n  noop_sock_funcs.arecvfrom   = noop_recvfrom;\n  noop_sock_funcs.asendto     = noop_sendto;\n  ares_set_socket_functions_ex(channel_, &noop_sock_funcs, NULL);\n\n  QueryResult result;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result, NULL);\n  // no need to call Process() since we're not actually connecting\n  ares_queue_wait_empty(channel_, -1);\n  EXPECT_TRUE(result.done_);\n  EXPECT_NE(0, result.timeouts_);\n\n  // Issue states second query stalls\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result, NULL);\n  // no need to call Process() since we're not actually connecting\n  ares_queue_wait_empty(channel_, -1);\n  EXPECT_TRUE(result.done_);\n  EXPECT_NE(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, TruncationRetry) {\n  DNSPacket rsptruncated;\n  rsptruncated.set_response().set_aa().set_tc()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsptruncated))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              223,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int SocketConnectCallback(ares_socket_t fd, int type, void *data) {\n  int rc = *(int*)data;\n  (void)type;\n  sock_cb_count++;\n  if (verbose) std::cerr << \"SocketConnectCallback(fd: \" << fd << \", cnt: \" << sock_cb_count << \") invoked\" << std::endl;\n  return rc;\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SocketConnectCallback",
            "parameters": {
              "fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SockCallback) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n\n  HostResult result;\n  sock_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_EQ(1, sock_cb_count);\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SockFailCallback) {\n  // Notification of new sockets gives an error.\n  int rc = -1;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n\n  HostResult result;\n  sock_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_LT(1, sock_cb_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECONNREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              275,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, ReInit) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  EXPECT_EQ(ARES_SUCCESS, ares_reinit(channel_));\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPEventThreadMaxQueriesTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES|ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              315,
              2
            ],
            [
              318,
              69
            ]
          ],
          "class_code": "362d0a4576378f06f2e0f4f63b35aa7eb39d6dda1f57b1f77de87927285ea92b",
          "class_node_pos": [
            [
              311,
              0
            ],
            [
              327,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPEventThreadMaxQueriesTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_STAYOPEN|ARES_FLAG_EDNS;\n    opts->udp_max_queries = MAXUDPQUERIES_LIMIT;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              319,
              2
            ],
            [
              324,
              3
            ]
          ],
          "class_code": "362d0a4576378f06f2e0f4f63b35aa7eb39d6dda1f57b1f77de87927285ea92b",
          "class_node_pos": [
            [
              311,
              0
            ],
            [
              327,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadMaxQueriesTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[MAXUDPQUERIES_TOTAL];\n  for (size_t i=0; i<MAXUDPQUERIES_TOTAL; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(MAXUDPQUERIES_TOTAL / MAXUDPQUERIES_LIMIT, sock_cb_count);\n\n  for (size_t i=0; i<MAXUDPQUERIES_TOTAL; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              329,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPEventThreadSingleQueryPerConnTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES) {}",
          "fn_code_pos": [
            [
              366,
              2
            ],
            [
              369,
              54
            ]
          ],
          "class_code": "7be68f0abe7bc358f3c33e23abf3f24a1a74213b988f2c19af3e9ee03f14f310",
          "class_node_pos": [
            [
              362,
              0
            ],
            [
              377,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPEventThreadSingleQueryPerConnTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->udp_max_queries = 1;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              370,
              2
            ],
            [
              374,
              3
            ]
          ],
          "class_code": "7be68f0abe7bc358f3c33e23abf3f24a1a74213b988f2c19af3e9ee03f14f310",
          "class_node_pos": [
            [
              362,
              0
            ],
            [
              377,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadSingleQueryPerConnTest, LotsOfConnections) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[LOTSOFCONNECTIONS_CNT];\n  for (size_t i=0; i<LOTSOFCONNECTIONS_CNT; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(LOTSOFCONNECTIONS_CNT, sock_cb_count);\n\n  for (size_t i=0; i<LOTSOFCONNECTIONS_CNT; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              408,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CacheQueriesEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_QUERY_CACHE) {}",
          "fn_code_pos": [
            [
              415,
              2
            ],
            [
              418,
              50
            ]
          ],
          "class_code": "d584e1faeb2e94178ee8ee3f66da05be6b4737c49209786eb151b3f6118c45a5",
          "class_node_pos": [
            [
              411,
              0
            ],
            [
              426,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CacheQueriesEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->qcache_max_ttl = 3600;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              419,
              2
            ],
            [
              423,
              3
            ]
          ],
          "class_code": "d584e1faeb2e94178ee8ee3f66da05be6b4737c49209786eb151b3f6118c45a5",
          "class_node_pos": [
            [
              411,
              0
            ],
            [
              426,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CacheQueriesEventThreadTest, GetHostByNameCache) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result1;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result1);\n  Process();\n\n  std::stringstream ss1;\n  EXPECT_TRUE(result1.done_);\n  ss1 << result1.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n\n  /* Run again, should return cached result */\n  HostResult result2;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result2);\n  Process();\n\n  std::stringstream ss2;\n  EXPECT_TRUE(result2.done_);\n  ss2 << result2.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss2.str());\n\n  EXPECT_EQ(1, sock_cb_count);\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockTCPEventThreadStayOpenTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), true /* tcp */,\n                          FillOptions(&opts_),\n                          ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              469,
              2
            ],
            [
              472,
              44
            ]
          ],
          "class_code": "22cd971b210e000f2935784af0ae7d48c939af82adaf34d98cfc91d265636dcc",
          "class_node_pos": [
            [
              465,
              0
            ],
            [
              480,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockTCPEventThreadStayOpenTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_STAYOPEN|ARES_FLAG_EDNS;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              473,
              2
            ],
            [
              477,
              3
            ]
          ],
          "class_code": "22cd971b210e000f2935784af0ae7d48c939af82adaf34d98cfc91d265636dcc",
          "class_node_pos": [
            [
              465,
              0
            ],
            [
              480,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadStayOpenTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[TCPPARALLELLOOKUPS];\n  for (size_t i=0; i<TCPPARALLELLOOKUPS; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(1, sock_cb_count);\n\n  for (size_t i=0; i<TCPPARALLELLOOKUPS; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, MalformedResponse) {\n  std::vector<byte> one = {0x00};\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, one));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EBADRESP, result.status_);\n}",
          "fn_code_pos": [
            [
              512,
              0
            ],
            [
              522,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, FormErrResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(FORMERR);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFORMERR, result.status_);\n}",
          "fn_code_pos": [
            [
              524,
              0
            ],
            [
              536,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              538,
              0
            ],
            [
              550,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              552,
              0
            ],
            [
              564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              566,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, YXDomainResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(YXDOMAIN);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              592,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}",
          "fn_code_pos": [
            [
              598,
              2
            ],
            [
              601,
              71
            ]
          ],
          "class_code": "82d949ff484d78b54e755841fbad7438f2563b6f6da9134186b9e648458c4108",
          "class_node_pos": [
            [
              594,
              0
            ],
            [
              611,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              602,
              2
            ],
            [
              608,
              3
            ]
          ],
          "class_code": "82d949ff484d78b54e755841fbad7438f2563b6f6da9134186b9e648458c4108",
          "class_node_pos": [
            [
              594,
              0
            ],
            [
              611,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsEventThreadTest, SimpleQuery) {\n  ares_set_local_ip4(channel_, 0x7F000001);\n  byte addr6[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              613,
              0
            ],
            [
              634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockFlagsEventThreadOptsTest(int flags)\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              640,
              2
            ],
            [
              642,
              72
            ]
          ],
          "class_code": "7f5da8b759f299aa797ed06a36afdd64fccd27b74bdec19224cf0261824559b9",
          "class_node_pos": [
            [
              636,
              0
            ],
            [
              650,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockFlagsEventThreadOptsTest",
            "parameters": {
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              643,
              2
            ],
            [
              647,
              3
            ]
          ],
          "class_code": "7f5da8b759f299aa797ed06a36afdd64fccd27b74bdec19224cf0261824559b9",
          "class_node_pos": [
            [
              636,
              0
            ],
            [
              650,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockNoCheckRespEventThreadTest() : MockFlagsEventThreadOptsTest(ARES_FLAG_NOCHECKRESP) {}",
          "fn_code_pos": [
            [
              654,
              2
            ],
            [
              654,
              91
            ]
          ],
          "class_code": "f92d810b0e4d92cb51a793501dfe4f7aaa0a67cfe1a375b0e29dfbc85591872a",
          "class_node_pos": [
            [
              652,
              0
            ],
            [
              655,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockNoCheckRespEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespEventThreadTest, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              657,
              0
            ],
            [
              669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespEventThreadTest, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              671,
              0
            ],
            [
              683,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespEventThreadTest, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              685,
              0
            ],
            [
              697,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockEDNSEventThreadTest() : MockFlagsEventThreadOptsTest(ARES_FLAG_EDNS) {}",
          "fn_code_pos": [
            [
              701,
              2
            ],
            [
              701,
              77
            ]
          ],
          "class_code": "f7a0ed1052be25136d0484f67b8f9d332504504fe1f53f54b63a7d4414702ad4",
          "class_node_pos": [
            [
              699,
              0
            ],
            [
              702,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEDNSEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEDNSEventThreadTest, RetryWithoutEDNS) {\n  DNSPacket rspfail;\n  rspfail.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rspfail))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              704,
              0
            ],
            [
              722,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchDomains) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              724,
              0
            ],
            [
              749,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, SearchDomainsWithResentReply) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillOnce(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  // Before sending the real answer, resend an earlier reply\n  EXPECT_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillOnce(DoAll(SetReply(&server_, &nofirst),\n                    SetReplyQID(&server_, 123)))\n    .WillOnce(DoAll(SetReply(&server_, &yesthird),\n                    SetReplyQID(&server_, -1)));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              752,
              0
            ],
            [
              781,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchDomainsBare) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket yesbare;\n  yesbare.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www\", T_A))\n    .add_answer(new DNSARR(\"www\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &yesbare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              783,
              0
            ],
            [
              813,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchNoDataThenSuccess) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              815,
              0
            ],
            [
              841,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchNoDataThenNoDataBare) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket nobare;\n  nobare.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www\", T_A));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              843,
              0
            ],
            [
              871,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchNoDataThenFail) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket nobare;\n  nobare.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www\", T_A));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              873,
              0
            ],
            [
              901,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchHighNdots) {\n  DNSPacket nobare;\n  nobare.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"a.b.c.w.w.w\", T_A));\n  ON_CALL(server_, OnRequest(\"a.b.c.w.w.w\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"a.b.c.w.w.w.first.com\", T_A))\n    .add_answer(new DNSARR(\"a.b.c.w.w.w.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"a.b.c.w.w.w.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  SearchResult result;\n  ares_search(channel_, \"a.b.c.w.w.w\", C_IN, T_A, SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << PacketToString(result.data_);\n  EXPECT_EQ(\"RSP QRY AA NOERROR Q:{'a.b.c.w.w.w.first.com' IN A} \"\n            \"A:{'a.b.c.w.w.w.first.com' IN A TTL=512 2.3.4.5}\",\n            ss.str());\n}",
          "fn_code_pos": [
            [
              903,
              0
            ],
            [
              926,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, V4WorksV6Timeout) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              928,
              0
            ],
            [
              949,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, DestroyQuick) {\n  /* We are not looking for any particular result as its possible (but unlikely)\n   * it finished before the destroy completed. We really just want to make sure\n   * cleanup works in this case properly. */\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  ares_destroy(channel_);\n  channel_ = nullptr;\n  EXPECT_TRUE(result.done_);\n}",
          "fn_code_pos": [
            [
              951,
              0
            ],
            [
              960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, PartialQueryCancel) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result);\n  // After 100ms, issues ares_cancel(), this should be enough time for the A\n  // record reply, but before the timeout on the AAAA record.\n  Process(100);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n}",
          "fn_code_pos": [
            [
              963,
              0
            ],
            [
              983,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, BulkCancel) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n#define BULKCANCEL_LOOP 5\n#define BULKCANCEL_CNT 50\n  for (size_t l = 0; l<BULKCANCEL_LOOP; l++) {\n    HostResult result[BULKCANCEL_CNT];\n    for (size_t i = 0; i<BULKCANCEL_CNT; i++) {\n      ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n    }\n    // After 1ms, issues ares_cancel(), there should be queries outstanding that\n    // are cancelled.\n    Process(1);\n\n    size_t success_cnt = 0;\n    size_t cancel_cnt = 0;\n    for (size_t i = 0; i<BULKCANCEL_CNT; i++) {\n      EXPECT_TRUE(result[i].done_);\n      EXPECT_TRUE(result[i].status_ == ARES_ECANCELLED || result[i].status_ == ARES_SUCCESS);\n      if (result[i].done_ && result[i].status_ == ARES_SUCCESS)\n        success_cnt++;\n      if (result[i].done_ && result[i].status_ == ARES_ECANCELLED)\n        cancel_cnt++;\n    }\n    if (verbose) std::cerr << \"success: \" << success_cnt << \", cancel: \" << cancel_cnt << std::endl;\n  }\n}",
          "fn_code_pos": [
            [
              987,
              0
            ],
            [
              1020,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, UnspecifiedFamilyV6) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  // Default to IPv6 when both are available.\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2121:0000:0000:0000:0000:0000:0000:0303]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1022,
              0
            ],
            [
              1046,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, UnspecifiedFamilyV4) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1048,
              0
            ],
            [
              1068,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, UnspecifiedFamilyNoData) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 100, \"elsewhere.com\"));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'' aliases=[] addrs=[]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1070,
              0
            ],
            [
              1090,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, UnspecifiedFamilyCname6A4) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 100, \"elsewhere.com\"));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1092,
              0
            ],
            [
              1113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, ExplicitIP) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"1.2.3.4\", AF_INET, HostCallback, &result);\n  EXPECT_TRUE(result.done_);  // Immediate return\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'1.2.3.4' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1115,
              0
            ],
            [
              1123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SortListV4) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {22, 23, 24, 25}))\n    .add_answer(new DNSARR(\"example.com\", 100, {12, 13, 14, 15}))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"12.13.0.0/255.255.0.0 1234::5678\"));\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[12.13.14.15, 22.23.24.25, 2.3.4.5]}\", ss.str());\n  }\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"2.3.0.0/16 130.140.150.160/26\"));\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5, 22.23.24.25, 12.13.14.15]}\", ss.str());\n  }\n  struct ares_options options;\n  memset(&options, 0, sizeof(options));\n  int optmask = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &options, &optmask));\n  EXPECT_TRUE((optmask & ARES_OPT_SORTLIST) == ARES_OPT_SORTLIST);\n  ares_destroy_options(&options);\n}",
          "fn_code_pos": [
            [
              1125,
              0
            ],
            [
              1161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SortListV6) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02}))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  {\n    ares_set_sortlist(channel_, \"1111::/16 2.3.0.0/255.255.0.0\");\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET6, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[1111:0000:0000:0000:0000:0000:0000:0202, \"\n              \"2121:0000:0000:0000:0000:0000:0000:0303]}\", ss.str());\n  }\n  {\n    ares_set_sortlist(channel_, \"2121::/8\");\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET6, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2121:0000:0000:0000:0000:0000:0000:0303, \"\n              \"1111:0000:0000:0000:0000:0000:0000:0202]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              1163,
              0
            ],
            [
              1198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, Resend) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(2, result.timeouts_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1201,
              0
            ],
            [
              1221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, CancelImmediate) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  ares_cancel(channel_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1223,
              0
            ],
            [
              1230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, CancelImmediateGetHostByAddr) {\n  HostResult result;\n  struct in_addr addr;\n  addr.s_addr = htonl(0x08080808);\n\n  ares_gethostbyaddr(channel_, &addr, sizeof(addr), AF_INET, HostCallback, &result);\n  ares_cancel(channel_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1232,
              0
            ],
            [
              1242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, CancelLater) {\n  std::vector<byte> nothing;\n\n  // On second request, cancel the channel.\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(CancelChannel(&server_, channel_));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1245,
              0
            ],
            [
              1259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, DisconnectFirstAttempt) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  // On second request, cancel the channel.\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(Disconnect(&server_))\n    .WillOnce(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.done_) {\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              1261,
              0
            ],
            [
              1281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, GetHostByNameCNAMENoData) {\n  DNSPacket response;\n  response.set_response().set_aa()\n    .add_question(new DNSQuestion(\"cname.first.com\", T_A))\n    .add_answer(new DNSCnameRR(\"cname.first.com\", 100, \"a.first.com\"));\n  ON_CALL(server_, OnRequest(\"cname.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &response));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"cname.first.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              1283,
              0
            ],
            [
              1296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, HostAlias) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  TempFile aliases(\"\\n\\n# www commentedout\\nwww www.google.com\\n\");\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1299,
              0
            ],
            [
              1317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, HostAliasMissing) {\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  TempFile aliases(\"\\n\\n# www commentedout\\nww www.google.com\\n\");\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.first.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1319,
              0
            ],
            [
              1336,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, HostAliasMissingFile) {\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  EnvValue with_env(\"HOSTALIASES\", \"bogus.mcfile\");\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.first.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1338,
              0
            ],
            [
              1354,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, HostAliasUnreadable) {\n  TempFile aliases(\"www www.google.com\\n\");\n  EXPECT_EQ(chmod(aliases.filename(), 0), 0);\n\n  /* Perform OS sanity checks.  We are observing on Debian after the chmod(fn, 0)\n   * that we are still able to fopen() the file which is unexpected.  Skip the\n   * test if we observe this behavior */\n  struct stat st;\n  EXPECT_EQ(stat(aliases.filename(), &st), 0);\n  EXPECT_EQ(st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO), 0);\n  FILE *fp = fopen(aliases.filename(), \"r\");\n  if (fp != NULL) {\n    if (verbose) std::cerr << \"Skipping Test due to OS incompatibility (open file caching)\" << std::endl;\n    fclose(fp);\n    return;\n  }\n\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFILE, result.status_);\n  chmod(aliases.filename(), 0777);\n}",
          "fn_code_pos": [
            [
              1356,
              0
            ],
            [
              1381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockMultiServerEventThreadTest(ares_options *opts, int optmask)\n    : MockEventThreadOptsTest(3, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()), opts, optmask) {}",
          "fn_code_pos": [
            [
              1389,
              2
            ],
            [
              1390,
              125
            ]
          ],
          "class_code": "66b80291a45115fee770c294a04c21d06437af0d3fcb21fba5025e3884b30a4a",
          "class_node_pos": [
            [
              1385,
              0
            ],
            [
              1400,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockMultiServerEventThreadTest",
            "parameters": {
              "opts": "ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }",
          "fn_code_pos": [
            [
              1391,
              2
            ],
            [
              1399,
              3
            ]
          ],
          "class_code": "66b80291a45115fee770c294a04c21d06437af0d3fcb21fba5025e3884b30a4a",
          "class_node_pos": [
            [
              1385,
              0
            ],
            [
              1400,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckExample",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "NoRotateMultiMockEventThreadTest() : MockMultiServerEventThreadTest(nullptr, ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              1404,
              2
            ],
            [
              1404,
              100
            ]
          ],
          "class_code": "1b209ee70953491fadc01349b8b4f3e575c9509a4c61bc8303c8e9c0ed0c5d21",
          "class_node_pos": [
            [
              1402,
              0
            ],
            [
              1405,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "NoRotateMultiMockEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockEventThreadTest, ThirdServer) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &opts, &optmask));\n  EXPECT_EQ(ARES_OPT_NOROTATE, (optmask & ARES_OPT_NOROTATE));\n  ares_destroy_options(&opts);\n\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket notimplrsp;\n  notimplrsp.set_response().set_aa().set_rcode(NOTIMP)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  CheckExample();\n\n  // Second time around, still starts from server [2], as [0] and [1] both\n  // recorded failures\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Third time around, server order is [1] (f0), [2] (f1), [0] (f2), which\n  // means [1] will get called twice in a row as after the first call\n  // order will be  [1] (f1), [2] (f1), [0] (f2) since sort order is\n  // (failure count, index)\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              1408,
              0
            ],
            [
              1457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockEventThreadTest, ServerNoResponseFailover) {\n  std::vector<byte> nothing;\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  /* Server #1 works fine on first attempt, then acts like its offline on\n   * second, then backonline on the third. */\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp))\n    .WillOnce(SetReplyData(servers_[0].get(), nothing))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n\n  /* Server #2 always acts like its offline */\n  ON_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReplyData(servers_[1].get(), nothing));\n\n  /* Server #3 works fine on first and second request, then no reply on 3rd */\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp))\n    .WillOnce(SetReplyData(servers_[2].get(), nothing));\n\n  HostResult result;\n\n  /* 1. First server returns a response on the first request immediately, normal\n   *    operation on channel. */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n  std::stringstream ss1;\n  ss1 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n\n  /* 2. On the second request, simulate the first and second servers not\n   *    returning a response at all, but the 3rd server works, so should have\n   *    2 timeouts. */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(2, result.timeouts_);\n  std::stringstream ss2;\n  ss2 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss2.str());\n\n  /* 3. On the third request, the active server should be #3, so should respond\n   *    immediately with no timeouts */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n  std::stringstream ss3;\n  ss3 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss3.str());\n\n  /* 4. On the fourth request, the active server should be #3, but will timeout,\n   *    and the first server should then respond */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n  std::stringstream ss4;\n  ss4 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss4.str());\n}",
          "fn_code_pos": [
            [
              1459,
              0
            ],
            [
              1525,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ServerFailoverOptsMockEventThreadTest()\n    : MockEventThreadOptsTest(4, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_),\n                          ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              1538,
              2
            ],
            [
              1541,
              74
            ]
          ],
          "class_code": "7f93d6537e2ae37a4864162c4a46920e92edd0073544ef442302eae2ecff82ec",
          "class_node_pos": [
            [
              1534,
              0
            ],
            [
              1560,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ServerFailoverOptsMockEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }",
          "fn_code_pos": [
            [
              1542,
              2
            ],
            [
              1550,
              3
            ]
          ],
          "class_code": "7f93d6537e2ae37a4864162c4a46920e92edd0073544ef442302eae2ecff82ec",
          "class_node_pos": [
            [
              1534,
              0
            ],
            [
              1560,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckExample",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = SERVER_FAILOVER_RETRY_DELAY;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              1552,
              2
            ],
            [
              1557,
              3
            ]
          ],
          "class_code": "7f93d6537e2ae37a4864162c4a46920e92edd0073544ef442302eae2ecff82ec",
          "class_node_pos": [
            [
              1534,
              0
            ],
            [
              1560,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ServerFailoverOptsMockEventThreadTest, ServerFailoverOpts) {\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  auto tv_begin = std::chrono::high_resolution_clock::now();\n  auto tv_now   = std::chrono::high_resolution_clock::now();\n  unsigned int delay_ms;\n\n  // At start all servers are healthy, first server should be selected\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: First server should be selected\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // Fail server #0 but leave server #1 as healthy.  This results in server\n  // order:\n  //  #1 (failures: 0), #2 (failures: 0), #3 (failures: 0), #0 (failures: 1)\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Server0 will fail but leave Server1 as healthy\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Sleep for the retry delay (actually a little more than the retry delay to account\n  // for unreliable timing, e.g. NTP slew) and send in another query. The real\n  // query will be sent to Server #1 (which will succeed) and Server #0 will\n  // be probed and return a successful result.  This leaves the server order\n  // of:\n  //   #0 (failures: 0), #1 (failures: 0), #2 (failures: 0), #3 (failures: 0)\n  tv_now = std::chrono::high_resolution_clock::now();\n  delay_ms = SERVER_FAILOVER_RETRY_DELAY + (SERVER_FAILOVER_RETRY_DELAY / 10);\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: sleep \" << delay_ms << \"ms\" << std::endl;\n  ares_sleep_time(delay_ms);\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Server0 should be past retry delay and should be probed (successful), server 1 will respond successful for real query\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n\n  // Fail all servers for the first round of tries. On the second round, #0\n  // responds successfully. This should leave server order of:\n  //   #1 (failures: 0), #2 (failures: 1), #3 (failures: 1), #0 (failures: 2)\n  // NOTE: A single query being retried won't spawn probes to downed servers,\n  //       only an initial query attempt is eligible to spawn probes.  So\n  //       no probes are sent for this test.\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: All 4 servers will fail on the first attempt, server 0 will fail on second. Server 1 will succeed on second.\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[3], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[3].get(), &servfailrsp));\n  CheckExample();\n\n\n  // Sleep for the retry delay and send in another query. Server #1 is the\n  // highest priority server and will respond with success, however a probe\n  // will be sent for Server #2 which will succeed:\n  //  #1 (failures: 0), #2 (failures: 0), #3 (failures: 1 - expired), #0 (failures: 2 - expired)\n  tv_now = std::chrono::high_resolution_clock::now();\n  delay_ms = SERVER_FAILOVER_RETRY_DELAY + (SERVER_FAILOVER_RETRY_DELAY / 10);\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: sleep \" << delay_ms << \"ms\" << std::endl;\n  ares_sleep_time(delay_ms);\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Past retry delay, will query Server 1 and probe Server 2, both will succeed.\" << std::endl;\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  CheckExample();\n\n  // Cause another server to fail so we have at least one non-expired failed\n  // server and one expired failed server.  #1 is highest priority, which we\n  // will fail, #2 will succeed, and #3 will be probed and succeed:\n  //  #2 (failures: 0), #3 (failures: 0), #1 (failures: 1 not expired), #0 (failures: 2 expired)\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Will query Server 1 and fail, Server 2 will answer successfully. Server 3 will be probed and succeed.\" << std::endl;\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  EXPECT_CALL(*servers_[3], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[3].get(), &okrsp));\n  CheckExample();\n\n  // We need to make sure that if there is a failed server that is higher priority\n  // but not yet expired that it will probe the next failed server instead.\n  // In this case #2 is the server that the query will go to and succeed, and\n  // then a probe will be sent for #0 (since #1 is not expired) and succeed.  We\n  // will sleep for 1/4 the retry duration before spawning the queries so we can\n  // then sleep for the rest for the follow-up test.  This will leave the servers\n  // in this state:\n  //   #0 (failures: 0), #2 (failures: 0), #3 (failures: 0), #1 (failures: 1 not expired)\n  tv_now = std::chrono::high_resolution_clock::now();\n\n  // We need to track retry delay time to know what is expired when.\n  auto elapse_start = tv_now;\n\n  delay_ms = (SERVER_FAILOVER_RETRY_DELAY/4);\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: sleep \" << delay_ms << \"ms\" << std::endl;\n  ares_sleep_time(delay_ms);\n  tv_now = std::chrono::high_resolution_clock::now();\n\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Retry delay has not been hit yet. Server2 will be queried and succeed. Server 0 (not server 1 due to non-expired retry delay) will be probed and succeed.\" << std::endl;\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // Finally we sleep for the remainder of the retry delay, send another\n  // query, which should succeed on Server #0, and also probe Server #1 which\n  // will also succeed.\n  tv_now = std::chrono::high_resolution_clock::now();\n\n  unsigned int elapsed_time = (unsigned int)std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - elapse_start).count();\n  delay_ms = (SERVER_FAILOVER_RETRY_DELAY) + (SERVER_FAILOVER_RETRY_DELAY / 10);\n  if (elapsed_time > delay_ms) {\n    if (verbose) std::cerr << \"elapsed duration \" << elapsed_time << \"ms greater than desired delay of \" << delay_ms << \"ms, not sleeping\" << std::endl;\n  } else {\n    delay_ms -= elapsed_time; // subtract already elapsed time\n    if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: sleep \" << delay_ms << \"ms\" << std::endl;\n    ares_sleep_time(delay_ms);\n  }\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Retry delay has expired on Server1, Server 0 will be queried and succeed, Server 1 will be probed and succeed.\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              1564,
              0
            ],
            [
              1710,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static const char *evsys_tostr(ares_evsys_t evsys)\n{\n  switch (evsys) {\n    case ARES_EVSYS_WIN32:\n      return \"WIN32\";\n    case ARES_EVSYS_EPOLL:\n      return \"EPOLL\";\n    case ARES_EVSYS_KQUEUE:\n      return \"KQUEUE\";\n    case ARES_EVSYS_POLL:\n      return \"POLL\";\n    case ARES_EVSYS_SELECT:\n      return \"SELECT\";\n    case ARES_EVSYS_DEFAULT:\n      return \"DEFAULT\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              1712,
              0
            ],
            [
              1729,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "evsys_tostr",
            "parameters": {
              "evsys": "ares_evsys_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static std::string PrintEvsysFamilyMode(const testing::TestParamInfo<std::tuple<ares_evsys_t, int, bool>> &info)\n{\n  std::string name;\n\n  name += evsys_tostr(std::get<0>(info.param));\n  name += \"_\";\n  name += af_tostr(std::get<1>(info.param));\n  name += \"_\";\n  name += mode_tostr(std::get<2>(info.param));\n  return name;\n}",
          "fn_code_pos": [
            [
              1732,
              0
            ],
            [
              1742,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintEvsysFamilyMode",
            "parameters": {
              "info": "testing::TestParamInfo<std::tuple<ares_evsys_t, int, bool>>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static std::string PrintEvsysFamily(const testing::TestParamInfo<std::tuple<ares_evsys_t, int>> &info)\n{\n  std::string name;\n\n  name += evsys_tostr(std::get<0>(info.param));\n  name += \"_\";\n  name += af_tostr(std::get<1>(info.param));\n  return name;\n}",
          "fn_code_pos": [
            [
              1744,
              0
            ],
            [
              1752,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintEvsysFamily",
            "parameters": {
              "info": "testing::TestParamInfo<std::tuple<ares_evsys_t, int>>"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              319,
              30
            ],
            [
              319,
              69
            ]
          ],
          "class_code": "362d0a4576378f06f2e0f4f63b35aa7eb39d6dda1f57b1f77de87927285ea92b",
          "class_node_pos": [
            [
              311,
              0
            ],
            [
              327,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              370,
              30
            ],
            [
              370,
              69
            ]
          ],
          "class_code": "7be68f0abe7bc358f3c33e23abf3f24a1a74213b988f2c19af3e9ee03f14f310",
          "class_node_pos": [
            [
              362,
              0
            ],
            [
              377,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              419,
              30
            ],
            [
              419,
              69
            ]
          ],
          "class_code": "d584e1faeb2e94178ee8ee3f66da05be6b4737c49209786eb151b3f6118c45a5",
          "class_node_pos": [
            [
              411,
              0
            ],
            [
              426,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              473,
              30
            ],
            [
              473,
              69
            ]
          ],
          "class_code": "22cd971b210e000f2935784af0ae7d48c939af82adaf34d98cfc91d265636dcc",
          "class_node_pos": [
            [
              465,
              0
            ],
            [
              480,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              602,
              30
            ],
            [
              602,
              69
            ]
          ],
          "class_code": "82d949ff484d78b54e755841fbad7438f2563b6f6da9134186b9e648458c4108",
          "class_node_pos": [
            [
              594,
              0
            ],
            [
              611,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts, int flags)",
          "fn_dec_pos": [
            [
              643,
              30
            ],
            [
              643,
              80
            ]
          ],
          "class_code": "7f5da8b759f299aa797ed06a36afdd64fccd27b74bdec19224cf0261824559b9",
          "class_node_pos": [
            [
              636,
              0
            ],
            [
              650,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options *opts)",
          "fn_dec_pos": [
            [
              1552,
              30
            ],
            [
              1552,
              68
            ]
          ],
          "class_code": "7f93d6537e2ae37a4864162c4a46920e92edd0073544ef442302eae2ecff82ec",
          "class_node_pos": [
            [
              1534,
              0
            ],
            [
              1560,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "evsys_tostr(ares_evsys_t evsys)",
          "fn_dec_pos": [
            [
              1712,
              19
            ],
            [
              1712,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "evsys_tostr",
            "parameters": {
              "evsys": "ares_evsys_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "362d0a4576378f06f2e0f4f63b35aa7eb39d6dda1f57b1f77de87927285ea92b": {
          "class_code": "class MockUDPEventThreadMaxQueriesTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t,int>> {\n public:\n  MockUDPEventThreadMaxQueriesTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES|ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_STAYOPEN|ARES_FLAG_EDNS;\n    opts->udp_max_queries = MAXUDPQUERIES_LIMIT;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockUDPEventThreadMaxQueriesTest",
          "class_pos": [
            [
              311,
              0
            ],
            [
              327,
              1
            ]
          ]
        },
        "7be68f0abe7bc358f3c33e23abf3f24a1a74213b988f2c19af3e9ee03f14f310": {
          "class_code": "class MockUDPEventThreadSingleQueryPerConnTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t,int>> {\n public:\n  MockUDPEventThreadSingleQueryPerConnTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->udp_max_queries = 1;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockUDPEventThreadSingleQueryPerConnTest",
          "class_pos": [
            [
              362,
              0
            ],
            [
              377,
              1
            ]
          ]
        },
        "d584e1faeb2e94178ee8ee3f66da05be6b4737c49209786eb151b3f6118c45a5": {
          "class_code": "class CacheQueriesEventThreadTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t,int>> {\n public:\n  CacheQueriesEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_QUERY_CACHE) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->qcache_max_ttl = 3600;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "CacheQueriesEventThreadTest",
          "class_pos": [
            [
              411,
              0
            ],
            [
              426,
              1
            ]
          ]
        },
        "22cd971b210e000f2935784af0ae7d48c939af82adaf34d98cfc91d265636dcc": {
          "class_code": "class MockTCPEventThreadStayOpenTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t,int>> {\n public:\n  MockTCPEventThreadStayOpenTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), true /* tcp */,\n                          FillOptions(&opts_),\n                          ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_STAYOPEN|ARES_FLAG_EDNS;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockTCPEventThreadStayOpenTest",
          "class_pos": [
            [
              465,
              0
            ],
            [
              480,
              1
            ]
          ]
        },
        "82d949ff484d78b54e755841fbad7438f2563b6f6da9134186b9e648458c4108": {
          "class_code": "class MockExtraOptsEventThreadTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int, bool> > {\n public:\n  MockExtraOptsEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockExtraOptsEventThreadTest",
          "class_pos": [
            [
              594,
              0
            ],
            [
              611,
              1
            ]
          ]
        },
        "7f5da8b759f299aa797ed06a36afdd64fccd27b74bdec19224cf0261824559b9": {
          "class_code": "class MockFlagsEventThreadOptsTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface< std::tuple<ares_evsys_t, int, bool> > {\n public:\n  MockFlagsEventThreadOptsTest(int flags)\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockFlagsEventThreadOptsTest",
          "class_pos": [
            [
              636,
              0
            ],
            [
              650,
              1
            ]
          ]
        },
        "f92d810b0e4d92cb51a793501dfe4f7aaa0a67cfe1a375b0e29dfbc85591872a": {
          "class_code": "class MockNoCheckRespEventThreadTest : public MockFlagsEventThreadOptsTest {\n public:\n  MockNoCheckRespEventThreadTest() : MockFlagsEventThreadOptsTest(ARES_FLAG_NOCHECKRESP) {}\n}",
          "class_name": "MockNoCheckRespEventThreadTest",
          "class_pos": [
            [
              652,
              0
            ],
            [
              655,
              1
            ]
          ]
        },
        "f7a0ed1052be25136d0484f67b8f9d332504504fe1f53f54b63a7d4414702ad4": {
          "class_code": "class MockEDNSEventThreadTest : public MockFlagsEventThreadOptsTest {\n public:\n  MockEDNSEventThreadTest() : MockFlagsEventThreadOptsTest(ARES_FLAG_EDNS) {}\n}",
          "class_name": "MockEDNSEventThreadTest",
          "class_pos": [
            [
              699,
              0
            ],
            [
              702,
              1
            ]
          ]
        },
        "66b80291a45115fee770c294a04c21d06437af0d3fcb21fba5025e3884b30a4a": {
          "class_code": "class MockMultiServerEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface< std::tuple<ares_evsys_t, int, bool> > {\n public:\n  MockMultiServerEventThreadTest(ares_options *opts, int optmask)\n    : MockEventThreadOptsTest(3, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()), opts, optmask) {}\n  void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "class_name": "MockMultiServerEventThreadTest",
          "class_pos": [
            [
              1385,
              0
            ],
            [
              1400,
              1
            ]
          ]
        },
        "1b209ee70953491fadc01349b8b4f3e575c9509a4c61bc8303c8e9c0ed0c5d21": {
          "class_code": "class NoRotateMultiMockEventThreadTest : public MockMultiServerEventThreadTest {\n public:\n  NoRotateMultiMockEventThreadTest() : MockMultiServerEventThreadTest(nullptr, ARES_OPT_NOROTATE) {}\n}",
          "class_name": "NoRotateMultiMockEventThreadTest",
          "class_pos": [
            [
              1402,
              0
            ],
            [
              1405,
              1
            ]
          ]
        },
        "7f93d6537e2ae37a4864162c4a46920e92edd0073544ef442302eae2ecff82ec": {
          "class_code": "class ServerFailoverOptsMockEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int, bool> > {\n public:\n  ServerFailoverOptsMockEventThreadTest()\n    : MockEventThreadOptsTest(4, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_),\n                          ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}\n  void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n\n  static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = SERVER_FAILOVER_RETRY_DELAY;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "ServerFailoverOptsMockEventThreadTest",
          "class_pos": [
            [
              1534,
              0
            ],
            [
              1560,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct sockaddr",
          {},
          "",
          [
            148,
            50
          ],
          [
            148,
            65
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            163,
            34
          ],
          [
            163,
            49
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            181,
            38
          ],
          [
            181,
            53
          ]
        ],
        [
          "struct ares_socket_functions_ex",
          {},
          "",
          [
            196,
            2
          ],
          [
            196,
            33
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            319,
            9
          ],
          [
            319,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            319,
            42
          ],
          [
            319,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            320,
            27
          ],
          [
            320,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            326,
            2
          ],
          [
            326,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            370,
            9
          ],
          [
            370,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            370,
            42
          ],
          [
            370,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            371,
            27
          ],
          [
            371,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            376,
            2
          ],
          [
            376,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            419,
            9
          ],
          [
            419,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            419,
            42
          ],
          [
            419,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            420,
            27
          ],
          [
            420,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            425,
            2
          ],
          [
            425,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            473,
            9
          ],
          [
            473,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            473,
            42
          ],
          [
            473,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            474,
            27
          ],
          [
            474,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            479,
            2
          ],
          [
            479,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            602,
            9
          ],
          [
            602,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            602,
            42
          ],
          [
            602,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            603,
            27
          ],
          [
            603,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            610,
            2
          ],
          [
            610,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            643,
            9
          ],
          [
            643,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            643,
            42
          ],
          [
            643,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            644,
            27
          ],
          [
            644,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            649,
            2
          ],
          [
            649,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1155,
            2
          ],
          [
            1155,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1234,
            2
          ],
          [
            1234,
            16
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            1363,
            2
          ],
          [
            1363,
            13
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1409,
            2
          ],
          [
            1409,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1552,
            9
          ],
          [
            1552,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1552,
            42
          ],
          [
            1552,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1553,
            27
          ],
          [
            1553,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1559,
            2
          ],
          [
            1559,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-init.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST(LibraryInit, Basic) {\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  EXPECT_EQ(ARES_SUCCESS, ares_library_initialized());\n  ares_library_cleanup();\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(LibraryInit, UnexpectedCleanup) {\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n  ares_library_cleanup();\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(LibraryInit, Nested) {\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  EXPECT_EQ(ARES_SUCCESS, ares_library_initialized());\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  EXPECT_EQ(ARES_SUCCESS, ares_library_initialized());\n  ares_library_cleanup();\n  EXPECT_EQ(ARES_SUCCESS, ares_library_initialized());\n  ares_library_cleanup();\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(LibraryInit, BasicChannelInit) {\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  ares_channel_t *channel = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_init(&channel));\n  EXPECT_NE(nullptr, channel);\n  ares_destroy(channel);\n  ares_library_cleanup();\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, OptionsChannelInit) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  opts.flags = ARES_FLAG_USEVC | ARES_FLAG_PRIMARY;\n  optmask |= ARES_OPT_FLAGS;\n  opts.timeout = 2000;\n  optmask |= ARES_OPT_TIMEOUTMS;\n  opts.tries = 2;\n  optmask |= ARES_OPT_TRIES;\n  opts.ndots = 4;\n  optmask |= ARES_OPT_NDOTS;\n  opts.udp_port = 54;\n  optmask |= ARES_OPT_MAXTIMEOUTMS;\n  opts.maxtimeout = 10000;\n  optmask |= ARES_OPT_UDP_PORT;\n  opts.tcp_port = 54;\n  optmask |= ARES_OPT_TCP_PORT;\n  opts.socket_send_buffer_size = 514;\n  optmask |= ARES_OPT_SOCK_SNDBUF;\n  opts.socket_receive_buffer_size = 514;\n  optmask |= ARES_OPT_SOCK_RCVBUF;\n  opts.ednspsz = 1280;\n  optmask |= ARES_OPT_EDNSPSZ;\n  opts.nservers = 2;\n  opts.servers = (struct in_addr *)malloc((size_t)opts.nservers * sizeof(struct in_addr));\n  opts.servers[0].s_addr = htonl(0x01020304);\n  opts.servers[1].s_addr = htonl(0x02030405);\n  optmask |= ARES_OPT_SERVERS;\n  opts.ndomains = 2;\n  opts.domains = (char **)malloc((size_t)opts.ndomains * sizeof(char *));\n  opts.domains[0] = strdup(\"example.com\");\n  opts.domains[1] = strdup(\"example2.com\");\n  optmask |= ARES_OPT_DOMAINS;\n  opts.lookups = strdup(\"b\");\n  optmask |= ARES_OPT_LOOKUPS;\n  optmask |= ARES_OPT_ROTATE;\n  opts.resolvconf_path = strdup(\"/etc/resolv.conf\");\n  optmask |= ARES_OPT_RESOLVCONF;\n  opts.hosts_path = strdup(\"/etc/hosts\");\n  optmask |= ARES_OPT_HOSTS_FILE;\n\n  ares_channel_t *channel = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel, &opts, optmask));\n  EXPECT_NE(nullptr, channel);\n\n  ares_channel_t *channel2 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_dup(&channel2, channel));\n  EXPECT_NE(nullptr, channel2);\n\n  struct ares_options opts2;\n  int optmask2 = 0;\n  memset(&opts2, 0, sizeof(opts2));\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel2, &opts2, &optmask2));\n\n  // Note that not all opts-settable fields are saved (e.g.\n  // ednspsz, socket_{send,receive}_buffer_size).\n  EXPECT_EQ(opts.flags, opts2.flags);\n  EXPECT_EQ(opts.timeout, opts2.timeout);\n  EXPECT_EQ(opts.tries, opts2.tries);\n  EXPECT_EQ(opts.ndots, opts2.ndots);\n  EXPECT_EQ(opts.maxtimeout, opts2.maxtimeout);\n  EXPECT_EQ(opts.udp_port, opts2.udp_port);\n  EXPECT_EQ(opts.tcp_port, opts2.tcp_port);\n  EXPECT_EQ(1, opts2.nservers);  // Truncated by ARES_FLAG_PRIMARY\n  EXPECT_EQ(opts.servers[0].s_addr, opts2.servers[0].s_addr);\n  EXPECT_EQ(opts.ndomains, opts2.ndomains);\n  EXPECT_EQ(std::string(opts.domains[0]), std::string(opts2.domains[0]));\n  EXPECT_EQ(std::string(opts.domains[1]), std::string(opts2.domains[1]));\n  EXPECT_EQ(std::string(opts.lookups), std::string(opts2.lookups));\n  EXPECT_EQ(std::string(opts.resolvconf_path), std::string(opts2.resolvconf_path));\n  EXPECT_EQ(std::string(opts.hosts_path), std::string(opts2.hosts_path));\n\n  ares_destroy_options(&opts);\n  ares_destroy_options(&opts2);\n  ares_destroy(channel);\n  ares_destroy(channel2);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ChannelAllocFail) {\n  ares_channel_t *channel;\n  for (int ii = 1; ii <= 25; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    channel = nullptr;\n    int rc = ares_init(&channel);\n    // The number of allocations depends on local environment, so don't expect ENOMEM.\n    if (rc == ARES_ENOMEM) {\n      EXPECT_EQ(nullptr, channel);\n    } else {\n      ares_destroy(channel);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, OptionsChannelAllocFail) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  opts.flags = ARES_FLAG_USEVC;\n  optmask |= ARES_OPT_FLAGS;\n  opts.timeout = 2;\n  optmask |= ARES_OPT_TIMEOUT;\n  opts.tries = 2;\n  optmask |= ARES_OPT_TRIES;\n  opts.ndots = 4;\n  optmask |= ARES_OPT_NDOTS;\n  opts.udp_port = 54;\n  optmask |= ARES_OPT_UDP_PORT;\n  opts.tcp_port = 54;\n  optmask |= ARES_OPT_TCP_PORT;\n  opts.socket_send_buffer_size = 514;\n  optmask |= ARES_OPT_SOCK_SNDBUF;\n  opts.socket_receive_buffer_size = 514;\n  optmask |= ARES_OPT_SOCK_RCVBUF;\n  opts.ednspsz = 1280;\n  optmask |= ARES_OPT_EDNSPSZ;\n  opts.nservers = 2;\n  opts.servers = (struct in_addr *)malloc((size_t)opts.nservers * sizeof(struct in_addr));\n  opts.servers[0].s_addr = htonl(0x01020304);\n  opts.servers[1].s_addr = htonl(0x02030405);\n  optmask |= ARES_OPT_SERVERS;\n  opts.ndomains = 2;\n  opts.domains = (char **)malloc((size_t)opts.ndomains * sizeof(char *));\n  opts.domains[0] = strdup(\"example.com\");\n  opts.domains[1] = strdup(\"example2.com\");\n  optmask |= ARES_OPT_DOMAINS;\n  opts.lookups = strdup(\"b\");\n  optmask |= ARES_OPT_LOOKUPS;\n  optmask |= ARES_OPT_ROTATE;\n  opts.resolvconf_path = strdup(\"/etc/resolv.conf\");\n  optmask |= ARES_OPT_RESOLVCONF;\n  opts.hosts_path = strdup(\"/etc/hosts\");\n  optmask |= ARES_OPT_HOSTS_FILE;\n\n  ares_channel_t *channel = nullptr;\n  for (int ii = 1; ii <= 8; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    int rc = ares_init_options(&channel, &opts, optmask);\n    if (rc == ARES_ENOMEM) {\n      EXPECT_EQ(nullptr, channel);\n    } else {\n      EXPECT_EQ(ARES_SUCCESS, rc);\n      ares_destroy(channel);\n      channel = nullptr;\n    }\n  }\n  ClearFails();\n\n  EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel, &opts, optmask));\n  EXPECT_NE(nullptr, channel);\n\n  // Add some servers and a sortlist for flavour.\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel, \"1.2.3.4,0102:0304:0506:0708:0910:1112:1314:1516,2.3.4.5\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel, \"1.2.3.4 2.3.4.5\"));\n\n  ares_channel_t *channel2 = nullptr;\n  for (int ii = 1; ii <= 18; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_dup(&channel2, channel)) << ii;\n    EXPECT_EQ(nullptr, channel2) << ii;\n  }\n\n  struct ares_options opts2;\n  int optmask2 = 0;\n  for (int ii = 1; ii <= 6; ii++) {\n    memset(&opts2, 0, sizeof(opts2));\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_save_options(channel, &opts2, &optmask2)) << ii;\n    // May still have allocations even after ARES_ENOMEM return code.\n    ares_destroy_options(&opts2);\n  }\n  ares_destroy_options(&opts);\n  ares_destroy(channel);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, FailChannelInit) {\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_library_init_mem(ARES_LIB_INIT_ALL,\n                                  &LibraryTest::amalloc,\n                                  &LibraryTest::afree,\n                                  &LibraryTest::arealloc));\n  SetAllocFail(1);\n  ares_channel_t *channel = nullptr;\n  EXPECT_EQ(ARES_ENOMEM, ares_init(&channel));\n  EXPECT_EQ(nullptr, channel);\n  ares_library_cleanup();\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, EnvInit) {\n  ares_channel_t *channel = nullptr;\n  EnvValue v1(\"LOCALDOMAIN\", \"this.is.local\");\n  EnvValue v2(\"RES_OPTIONS\", \"options debug ndots:3 retry:3 rotate retrans:2\");\n  EXPECT_EQ(ARES_SUCCESS, ares_init(&channel));\n  ares_destroy(channel);\n}",
          "fn_code_pos": [
            [
              270,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, EnvInitModernOptions) {\n  ares_channel_t *channel = nullptr;\n  EnvValue v1(\"LOCALDOMAIN\", \"this.is.local\");\n  EnvValue v2(\"RES_OPTIONS\", \"options debug retrans:2 ndots:3 attempts:4 timeout:5 rotate\");\n  EXPECT_EQ(ARES_SUCCESS, ares_init(&channel));\n\n  channel->optmask |= ARES_OPT_TRIES;\n  channel->optmask |= ARES_OPT_TIMEOUTMS;\n\n  struct ares_options opts;\n  memset(&opts, 0, sizeof(opts));\n  int optmask = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel, &opts, &optmask));\n  EXPECT_EQ(5000, opts.timeout);\n  EXPECT_EQ(4, opts.tries);\n\n  ares_destroy(channel);\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, EnvInitAllocFail) {\n  ares_channel_t *channel;\n  EnvValue v1(\"LOCALDOMAIN\", \"this.is.local\");\n  EnvValue v2(\"RES_OPTIONS\", \"options debug ndots:3 retry:3 rotate retrans:2\");\n  for (int ii = 1; ii <= 10; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    channel = nullptr;\n    int rc = ares_init(&channel);\n    if (rc == ARES_SUCCESS) {\n      ares_destroy(channel);\n    } else {\n      EXPECT_EQ(ARES_ENOMEM, rc);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetAddresses) {\n  ares_set_local_ip4(channel_, 0x01020304);\n  byte addr6[16] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n                    0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n}",
          "fn_code_pos": [
            [
              315,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetSortlistFailures) {\n  EXPECT_EQ(ARES_ENODATA, ares_set_sortlist(nullptr, \"1.2.3.4\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"111.111.111.111*/16\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"111.111.111.111/255.255.255.240*\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"1 0123456789012345\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"1 /01234567890123456789012345678901\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"xyzzy ; lwk\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"xyzzy ; 0x123\"));\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetSortlistVariants) {\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"1.2.3.4\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"1.2.3.4 ; 2.3.4.5\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"1.2.3.4/26;1234::5678/126;4.5.6.7;5678::1234\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \" 1.2.3.4/26 1234::5678/126   4.5.6.7 5678::1234  \"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"129.1.1.1\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"192.1.1.1\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"224.1.1.1\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"225.1.1.1\"));\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetSortlistAllocFail) {\n  for (int ii = 1; ii <= 3; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_set_sortlist(channel_, \"12.13.0.0/16 1234::5678/40 1.2.3.4\")) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(Init, NoLibraryInit) {\n  ares_channel_t *channel = nullptr;\n  EXPECT_EQ(ARES_ENOTINITIALIZED, ares_init(&channel));\n}",
          "fn_code_pos": [
            [
              353,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "explicit MakeUnreadable(const std::string& filename)\n    : filename_(filename) {\n    chmod(filename_.c_str(), 0000);\n  }",
          "fn_code_pos": [
            [
              542,
              2
            ],
            [
              545,
              3
            ]
          ],
          "class_code": "f77489f9fd42798776383da3aceb4b4cb1b8fe183752b39eada5679181806099",
          "class_node_pos": [
            [
              540,
              0
            ],
            [
              549,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MakeUnreadable",
            "parameters": {
              "filename": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~MakeUnreadable() { chmod(filename_.c_str(), 0644); }",
          "fn_code_pos": [
            [
              546,
              2
            ],
            [
              546,
              55
            ]
          ],
          "class_code": "f77489f9fd42798776383da3aceb4b4cb1b8fe183752b39eada5679181806099",
          "class_node_pos": [
            [
              540,
              0
            ],
            [
              549,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "f77489f9fd42798776383da3aceb4b4cb1b8fe183752b39eada5679181806099": {
          "class_code": "class MakeUnreadable {\n public:\n  explicit MakeUnreadable(const std::string& filename)\n    : filename_(filename) {\n    chmod(filename_.c_str(), 0000);\n  }\n  ~MakeUnreadable() { chmod(filename_.c_str(), 0644); }\n private:\n  std::string filename_;\n}",
          "class_name": "MakeUnreadable",
          "class_pos": [
            [
              540,
              0
            ],
            [
              549,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ares_options",
          {},
          "",
          [
            77,
            2
          ],
          [
            77,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            101,
            18
          ],
          [
            101,
            32
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            101,
            73
          ],
          [
            101,
            87
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            126,
            2
          ],
          [
            126,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            172,
            2
          ],
          [
            172,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            194,
            18
          ],
          [
            194,
            32
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            194,
            73
          ],
          [
            194,
            87
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            242,
            2
          ],
          [
            242,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            287,
            2
          ],
          [
            287,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            419,
            2
          ],
          [
            419,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            464,
            2
          ],
          [
            464,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            491,
            2
          ],
          [
            491,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            600,
            2
          ],
          [
            600,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            693,
            2
          ],
          [
            693,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            707,
            2
          ],
          [
            707,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            2
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-soa.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_SOA))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_soa_reply* soa = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  ASSERT_NE(nullptr, soa);\n  EXPECT_EQ(\"soa1.example.com\", std::string(soa->nsname));\n  EXPECT_EQ(\"fred.example.com\", std::string(soa->hostmaster));\n  EXPECT_EQ((unsigned int)1, soa->serial);\n  EXPECT_EQ((unsigned int)2, soa->refresh);\n  EXPECT_EQ((unsigned int)3, soa->retry);\n  EXPECT_EQ((unsigned int)4, soa->expire);\n  EXPECT_EQ((unsigned int)5, soa->minttl);\n  ares_free_data(soa);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_SOA))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data;\n  struct ares_soa_reply* soa = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SOA));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_SOA));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SOA));\n#endif\n\n  // Two questions\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SOA));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SOA));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)len, &soa));\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), -1, &soa));\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_SOA))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data = pkt.data();\n  struct ares_soa_reply* soa = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_soa_reply(data.data(), (int)data.size(), &soa)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            43,
            2
          ],
          [
            43,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            64,
            2
          ],
          [
            64,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            125,
            2
          ],
          [
            125,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-soa-any.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaAnyReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_ANY))\\\n    .add_answer(new DNSARR(\"example.com\", 0x01020304, {2,3,4,5}))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 200, \"mx2.example.com\"))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_soa_reply* soa = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  ASSERT_NE(nullptr, soa);\n  EXPECT_EQ(\"soa1.example.com\", std::string(soa->nsname));\n  EXPECT_EQ(\"fred.example.com\", std::string(soa->hostmaster));\n  EXPECT_EQ((unsigned int)1, soa->serial);\n  EXPECT_EQ((unsigned int)2, soa->refresh);\n  EXPECT_EQ((unsigned int)3, soa->retry);\n  EXPECT_EQ((unsigned int)4, soa->expire);\n  EXPECT_EQ((unsigned int)5, soa->minttl);\n  ares_free_data(soa);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaAnyReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_ANY))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data;\n  struct ares_soa_reply* soa = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.add_question(new DNSQuestion(\"example.com\", T_ANY));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_ANY));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_ANY));\n#endif\n\n  // Two questions\n  pkt.add_question(new DNSQuestion(\"example.com\", T_ANY));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_ANY));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)len, &soa));\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), -1, &soa));\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaAnyReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_ANY))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data = pkt.data();\n  struct ares_soa_reply* soa = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_soa_reply(data.data(), (int)data.size(), &soa)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            46,
            2
          ],
          [
            46,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            67,
            2
          ],
          [
            67,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            128,
            2
          ],
          [
            128,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-caa.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaReplyMultipleOK) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,  0x00, 0x00, 0x00, 0x00, 0x09, 0x77, 0x69, 0x6B, // '............wik\n    0x69, 0x70, 0x65, 0x64, 0x69, 0x61, 0x03, 0x6F,  0x72, 0x67, 0x00, 0x01, 0x01, 0x00, 0x01, 0xC0, // ipedia.org......\n    0x0C, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x02,  0x23, 0x00, 0x15, 0x00, 0x05, 0x69, 0x73, 0x73, // ........#....iss\n    0x75, 0x65, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C,  0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, // ueglobalsign.com\n    0xC0, 0x0C, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00,  0x02, 0x23, 0x00, 0x13, 0x00, 0x05, 0x69, 0x73, // .........#....is\n    0x73, 0x75, 0x65, 0x64, 0x69, 0x67, 0x69, 0x63,  0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0xC0, // suedigicert.com.\n    0x0C, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x02,  0x23, 0x00, 0x16, 0x00, 0x05, 0x69, 0x73, 0x73, // ........#....iss\n    0x75, 0x65, 0x6C, 0x65, 0x74, 0x73, 0x65, 0x6E,  0x63, 0x72, 0x79, 0x70, 0x74, 0x2E, 0x6F, 0x72, // ueletsencrypt.or\n    0x67, 0xC0, 0x0C, 0x01, 0x01, 0x00, 0x01, 0x00,  0x00, 0x02, 0x23, 0x00, 0x25, 0x00, 0x05, 0x69, // g.........#.%..i\n    0x6F, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x69, 0x6C,  0x74, 0x6F, 0x3A, 0x64, 0x6E, 0x73, 0x2D, 0x61, // odefmailto:dns-a\n    0x64, 0x6D, 0x69, 0x6E, 0x40, 0x77, 0x69, 0x6B,  0x69, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x2E, 0x6F, // dmin@wikimedia.o\n    0x72, 0x67                                                                                       // rg\n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_NE(nullptr, caa);\n  ASSERT_NE(nullptr, caa->next);\n  ASSERT_NE(nullptr, caa->next->next);\n  ASSERT_NE(nullptr, caa->next->next->next);\n\n  ares_free_data(caa);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaReplySingleOK) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F, 0x6F,  //  '............goo \n    0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00,  0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C, 0x01, 0x01,  //  gle.com......... \n    0x00, 0x01, 0x00, 0x01, 0x43, 0xBE, 0x00, 0x0F,  0x00, 0x05, 0x69, 0x73, 0x73, 0x75, 0x65, 0x70,  //  ....C.....issuep \n    0x6B, 0x69, 0x2E, 0x67, 0x6F, 0x6F, 0x67                                                          //  ki.goog \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_NE(nullptr, caa);\n\n  EXPECT_EQ(caa->critical, (int)0);\n  EXPECT_EQ(caa->plength, (size_t)5);\n  EXPECT_STREQ((char *)caa->property, \"issue\");\n  EXPECT_EQ(caa->length, (size_t)8);\n  EXPECT_STREQ((char *)caa->value, \"pki.goog\");\n\n  ares_free_data(caa);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaBogusReply1) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F, 0x6F,  //  '............goo \n    0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00,  0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C, 0x01, 0x01,  //  gle.com......... \n    0x00, 0x01, 0x00, 0x01, 0x43, 0xBE, 0x00, 0x0F,  0x00, 0x00, 0x69, 0x73, 0x73, 0x75, 0x65, 0x70,  //  ....C.....issuep \n    0x6B, 0x69, 0x2E, 0x67, 0x6F, 0x6F, 0x67                                                          //  ki.goog \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_EQ(nullptr, caa);\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaBogusReply2) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F, 0x6F,  //  '............goo \n    0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00,  0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C, 0x01, 0x01,  //  gle.com......... \n    0x00, 0x01, 0x00, 0x01, 0x43, 0xBE, 0x00, 0x0F,  0x00, 0x0e, 0x69, 0x73, 0x73, 0x75, 0x65, 0x70,  //  ....C.....issuep \n    0x6B, 0x69, 0x2E, 0x67, 0x6F, 0x6F, 0x67                                                          //  ki.goog \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_EQ(nullptr, caa);\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaBogusReply3) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F, 0x6F,  //  '............goo \n    0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00,  0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C, 0x01, 0x01,  //  gle.com......... \n    0x00, 0x01, 0x00, 0x01, 0x43, 0xBE, 0x00, 0x10,  0x00, 0x05, 0x69, 0x73, 0x73, 0x75, 0x65, 0x70,  //  ....C.....issuep \n    0x6B, 0x69, 0x2E, 0x67, 0x6F, 0x6F, 0x67                                                          //  ki.goog \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_EQ(nullptr, caa);\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaEmptyReply) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x00,  0x00, 0x01, 0x00, 0x00, 0x09, 0x77, 0x69, 0x6B,  //  '............wik \n    0x69, 0x70, 0x65, 0x64, 0x69, 0x61, 0x02, 0x64,  0x65, 0x00, 0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C,  //  ipedia.de....... \n    0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x02, 0x58,  0x00, 0x3B, 0x04, 0x6E, 0x73, 0x38, 0x31, 0x0D,  //  .......X.;.ns81. \n    0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E, 0x63, 0x6F,  0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x03, 0x63, 0x6F,  //  domaincontrol.co \n    0x6D, 0x00, 0x03, 0x64, 0x6E, 0x73, 0x05, 0x6A,  0x6F, 0x6D, 0x61, 0x78, 0x03, 0x6E, 0x65, 0x74,  //  m..dns.jomax.net \n    0x00, 0x78, 0x67, 0xFE, 0x34, 0x00, 0x00, 0x70,  0x80, 0x00, 0x00, 0x1C, 0x20, 0x00, 0x09, 0x3A,  //  .xg.4..p.... ..: \n    0x80, 0x00, 0x00, 0x02, 0x58                                                                      //  ....X \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_EQ(nullptr, caa);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNegativeReply) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x00,  0x00, 0x01, 0x00, 0x00, 0x09, 0x77, 0x69, 0x6B,  //  '............wik\n    0x69, 0x70, 0x65, 0x64, 0x69, 0x61, 0x02, 0x64,  0x65, 0x00, 0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C,  //  ipedia.de.......\n    0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x02, 0x58,  0x00, 0x3B, 0x04, 0x6E, 0x73, 0x38, 0x31, 0x0D,  //  .......X.;.ns81.\n    0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E, 0x63, 0x6F,  0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x03, 0x63, 0x6F,  //  domaincontrol.co\n    0x6D, 0x00, 0x03, 0x64, 0x6E, 0x73, 0x05, 0x6A,  0x6F, 0x6D, 0x61, 0x78, 0x03, 0x6E, 0x65, 0x74,  //  m..dns.jomax.net\n    0x00, 0x78, 0x67, 0xFE, 0x34, 0x00, 0x00, 0x70,  0x80, 0x00, 0x00, 0x1C, 0x20, 0x00, 0x09, 0x3A,  //  .xg.4..p.... ..:\n    0x80, 0x00, 0x00, 0x02, 0x58                                                                      //  ....X\n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_caa_reply(data.data(), -1, &caa));\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            50,
            2
          ],
          [
            50,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            68,
            2
          ],
          [
            68,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            89,
            2
          ],
          [
            89,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            102,
            2
          ],
          [
            102,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            115,
            2
          ],
          [
            115,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            131,
            2
          ],
          [
            131,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            147,
            2
          ],
          [
            147,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/dns-proto-test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST(DNSProto, EncodeQuestions) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com.\", T_A))\n    .add_question(new DNSQuestion(\"www.example.com\", T_AAAA, C_CHAOS));\n\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x02,  // num questions\n    0x00, 0x00,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Question 2\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x1C,  // type AAAA = 28\n    0x00, 0x03,  // class CHAOS = 3\n  };\n  EXPECT_EQ(data, pkt.data());\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(DNSProto, EncodeSingleNameAnswers) {\n  DNSPacket pkt;\n  pkt.qid_ = 0x1234;\n  pkt.response_ = true;\n  pkt.aa_ = true;\n  pkt.opcode_ = O_QUERY;\n  pkt.add_answer(new DNSCnameRR(\"example.com\", 0x01020304, \"other.com.\"));\n  pkt.add_auth(new DNSPtrRR(\"www.example.com\", 0x01020304, \"www.other.com\"));\n\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x00,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x01,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x05,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x0B,  // rdata length\n    0x05, 'o', 't', 'h', 'e', 'r',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    // Authority 1\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x0c,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x0F,  // rdata length\n    0x03, 'w', 'w', 'w',\n    0x05, 'o', 't', 'h', 'e', 'r',\n    0x03, 'c', 'o', 'm',\n    0x00,\n  };\n  EXPECT_EQ(data, pkt.data());\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(DNSProto, EncodeAddressAnswers) {\n  DNSPacket pkt;\n  pkt.qid_ = 0x1234;\n  pkt.response_ = true;\n  pkt.aa_ = true;\n  pkt.opcode_ = O_QUERY;\n  std::vector<byte> addrv4 = {0x02, 0x03, 0x04, 0x05};\n  pkt.add_answer(new DNSARR(\"example.com\", 0x01020304, addrv4));\n  byte addrv6[16] = {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                     0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04};\n  pkt.add_additional(new DNSAaaaRR(\"www.example.com\", 0x01020304, addrv6, 16));\n\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x00,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x01,  // num additional RRs\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n    // Additional 1\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x1c,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x10,  // rdata length\n    0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n    0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04\n  };\n  EXPECT_EQ(data, pkt.data());\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/dns-proto.cc": {
      "fn_def_list": [
        {
          "fn_code": "void arestest_strtolower(char *dest, const char *src, size_t dest_size)\n{\n  size_t len;\n\n  if (dest == NULL)\n    return;\n\n  memset(dest, 0, dest_size);\n\n  if (src == NULL)\n    return;\n\n  len = strlen(src);\n  if (len >= dest_size)\n    return;\n\n  for (size_t i = 0; i<len; i++) {\n    dest[i] = (char)tolower(src[i]);\n  }\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "arestest_strtolower",
            "parameters": {
              "dest": "char",
              "src": "char",
              "dest_size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::string HexDump(std::vector<byte> data) {\n  std::stringstream ss;\n  for (size_t ii = 0; ii < data.size();  ii++) {\n    char buffer[2 + 1];\n    snprintf(buffer, sizeof(buffer), \"%02x\", data[ii]);\n    ss << buffer;\n  }\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string HexDump(const byte *data, int len) {\n  return HexDump(std::vector<byte>(data, data + len));\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string HexDump(const char *data, int len) {\n  return HexDump(reinterpret_cast<const byte*>(data), len);\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "char",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string StatusToString(int status) {\n  switch (status) {\n  case ARES_SUCCESS: return \"ARES_SUCCESS\";\n  case ARES_ENODATA: return \"ARES_ENODATA\";\n  case ARES_EFORMERR: return \"ARES_EFORMERR\";\n  case ARES_ESERVFAIL: return \"ARES_ESERVFAIL\";\n  case ARES_ENOTFOUND: return \"ARES_ENOTFOUND\";\n  case ARES_ENOTIMP: return \"ARES_ENOTIMP\";\n  case ARES_EREFUSED: return \"ARES_EREFUSED\";\n  case ARES_EBADQUERY: return \"ARES_EBADQUERY\";\n  case ARES_EBADNAME: return \"ARES_EBADNAME\";\n  case ARES_EBADFAMILY: return \"ARES_EBADFAMILY\";\n  case ARES_EBADRESP: return \"ARES_EBADRESP\";\n  case ARES_ECONNREFUSED: return \"ARES_ECONNREFUSED\";\n  case ARES_ETIMEOUT: return \"ARES_ETIMEOUT\";\n  case ARES_EOF: return \"ARES_EOF\";\n  case ARES_EFILE: return \"ARES_EFILE\";\n  case ARES_ENOMEM: return \"ARES_ENOMEM\";\n  case ARES_EDESTRUCTION: return \"ARES_EDESTRUCTION\";\n  case ARES_EBADSTR: return \"ARES_EBADSTR\";\n  case ARES_EBADFLAGS: return \"ARES_EBADFLAGS\";\n  case ARES_ENONAME: return \"ARES_ENONAME\";\n  case ARES_EBADHINTS: return \"ARES_EBADHINTS\";\n  case ARES_ENOTINITIALIZED: return \"ARES_ENOTINITIALIZED\";\n  case ARES_ELOADIPHLPAPI: return \"ARES_ELOADIPHLPAPI\";\n  case ARES_EADDRGETNETWORKPARAMS: return \"ARES_EADDRGETNETWORKPARAMS\";\n  case ARES_ECANCELLED: return \"ARES_ECANCELLED\";\n  default: return \"UNKNOWN\";\n  }\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StatusToString",
            "parameters": {
              "status": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string RcodeToString(int rcode) {\n  switch (rcode) {\n  case NOERROR: return \"NOERROR\";\n  case FORMERR: return \"FORMERR\";\n  case SERVFAIL: return \"SERVFAIL\";\n  case NXDOMAIN: return \"NXDOMAIN\";\n  case NOTIMP: return \"NOTIMP\";\n  case REFUSED: return \"REFUSED\";\n  case YXDOMAIN: return \"YXDOMAIN\";\n  case YXRRSET: return \"YXRRSET\";\n  case NXRRSET: return \"NXRRSET\";\n  case NOTAUTH: return \"NOTAUTH\";\n  case NOTZONE: return \"NOTZONE\";\n  case TSIG_BADSIG: return \"BADSIG\";\n  case TSIG_BADKEY: return \"BADKEY\";\n  case TSIG_BADTIME: return \"BADTIME\";\n  default: return \"UNKNOWN\";\n  }\n}",
          "fn_code_pos": [
            [
              115,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RcodeToString",
            "parameters": {
              "rcode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string RRTypeToString(int rrtype) {\n  switch (rrtype) {\n  case T_A: return \"A\";\n  case T_NS: return \"NS\";\n  case T_MD: return \"MD\";\n  case T_MF: return \"MF\";\n  case T_CNAME: return \"CNAME\";\n  case T_SOA: return \"SOA\";\n  case T_MB: return \"MB\";\n  case T_MG: return \"MG\";\n  case T_MR: return \"MR\";\n  case T_NULL: return \"NULL\";\n  case T_WKS: return \"WKS\";\n  case T_PTR: return \"PTR\";\n  case T_HINFO: return \"HINFO\";\n  case T_MINFO: return \"MINFO\";\n  case T_MX: return \"MX\";\n  case T_TXT: return \"TXT\";\n  case T_RP: return \"RP\";\n  case T_AFSDB: return \"AFSDB\";\n  case T_X25: return \"X25\";\n  case T_ISDN: return \"ISDN\";\n  case T_RT: return \"RT\";\n  case T_NSAP: return \"NSAP\";\n  case T_NSAP_PTR: return \"NSAP_PTR\";\n  case T_SIG: return \"SIG\";\n  case T_KEY: return \"KEY\";\n  case T_PX: return \"PX\";\n  case T_GPOS: return \"GPOS\";\n  case T_AAAA: return \"AAAA\";\n  case T_LOC: return \"LOC\";\n  case T_NXT: return \"NXT\";\n  case T_EID: return \"EID\";\n  case T_NIMLOC: return \"NIMLOC\";\n  case T_SRV: return \"SRV\";\n  case T_ATMA: return \"ATMA\";\n  case T_NAPTR: return \"NAPTR\";\n  case T_KX: return \"KX\";\n  case T_CERT: return \"CERT\";\n  case T_A6: return \"A6\";\n  case T_DNAME: return \"DNAME\";\n  case T_SINK: return \"SINK\";\n  case T_OPT: return \"OPT\";\n  case T_APL: return \"APL\";\n  case T_DS: return \"DS\";\n  case T_SSHFP: return \"SSHFP\";\n  case T_RRSIG: return \"RRSIG\";\n  case T_NSEC: return \"NSEC\";\n  case T_DNSKEY: return \"DNSKEY\";\n  case T_TKEY: return \"TKEY\";\n  case T_TSIG: return \"TSIG\";\n  case T_IXFR: return \"IXFR\";\n  case T_AXFR: return \"AXFR\";\n  case T_MAILB: return \"MAILB\";\n  case T_MAILA: return \"MAILA\";\n  case T_ANY: return \"ANY\";\n  case T_URI: return \"URI\";\n  case T_MAX: return \"MAX\";\n  default: return \"UNKNOWN\";\n  }\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RRTypeToString",
            "parameters": {
              "rrtype": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string ClassToString(int qclass) {\n  switch (qclass) {\n  case C_IN: return \"IN\";\n  case C_CHAOS: return \"CHAOS\";\n  case C_HS: return \"HESIOD\";\n  case C_NONE: return \"NONE\";\n  case C_ANY: return \"ANY\";\n  default: return \"UNKNOWN\";\n  }\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              206,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ClassToString",
            "parameters": {
              "qclass": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string AddressToString(const void* vaddr, int len) {\n  const byte* addr = reinterpret_cast<const byte*>(vaddr);\n  std::stringstream ss;\n  if (len == 4) {\n    char buffer[4*4 + 3 + 1];\n    snprintf(buffer, sizeof(buffer), \"%u.%u.%u.%u\",\n             (unsigned char)addr[0],\n             (unsigned char)addr[1],\n             (unsigned char)addr[2],\n             (unsigned char)addr[3]);\n    ss << buffer;\n  } else if (len == 16) {\n    for (int ii = 0; ii < 16;  ii+=2) {\n      if (ii > 0) ss << ':';\n      char buffer[4 + 1];\n      snprintf(buffer, sizeof(buffer), \"%02x%02x\", (unsigned char)addr[ii], (unsigned char)addr[ii+1]);\n      ss << buffer;\n    }\n  } else {\n    ss << \"!\" << HexDump(addr, len) << \"!\";\n  }\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              208,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddressToString",
            "parameters": {
              "vaddr": "void",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string PacketToString(const std::vector<byte>& packet) {\n  const byte* data = packet.data();\n  int len = (int)packet.size();\n  std::stringstream ss;\n  if (len < NS_HFIXEDSZ) {\n    ss << \"(too short, len \" << len << \")\";\n    return ss.str();\n  }\n  ss << ((DNS_HEADER_QR(data) == 0) ? \"REQ \" : \"RSP \");\n  switch (DNS_HEADER_OPCODE(data)) {\n  case O_QUERY: ss << \"QRY \"; break;\n  case O_IQUERY: ss << \"IQRY \"; break;\n  case O_STATUS: ss << \"STATUS \"; break;\n  case O_NOTIFY: ss << \"NOTIFY \"; break;\n  case O_UPDATE: ss << \"UPDATE \"; break;\n  default: ss << \"UNKNOWN(\" << DNS_HEADER_OPCODE(data) << \") \"; break;\n  }\n  if (DNS_HEADER_AA(data)) ss << \"AA \";\n  if (DNS_HEADER_TC(data)) ss << \"TC \";\n  if (DNS_HEADER_RD(data)) ss << \"RD \";\n  if (DNS_HEADER_RA(data)) ss << \"RA \";\n  if (DNS_HEADER_Z(data)) ss << \"Z \";\n  if (DNS_HEADER_QR(data) == 1) ss << RcodeToString(DNS_HEADER_RCODE(data));\n\n  int nquestions = DNS_HEADER_QDCOUNT(data);\n  int nanswers = DNS_HEADER_ANCOUNT(data);\n  int nauths = DNS_HEADER_NSCOUNT(data);\n  int nadds = DNS_HEADER_ARCOUNT(data);\n\n  const byte* pq = data + NS_HFIXEDSZ;\n  len -= NS_HFIXEDSZ;\n  for (int ii = 0; ii < nquestions; ii++) {\n    ss << \" Q:\" << QuestionToString(packet, &pq, &len);\n  }\n  const byte* prr = pq;\n  for (int ii = 0; ii < nanswers; ii++) {\n    ss << \" A:\" << RRToString(packet, &prr, &len);\n  }\n  for (int ii = 0; ii < nauths; ii++) {\n    ss << \" AUTH:\" << RRToString(packet, &prr, &len);\n  }\n  for (int ii = 0; ii < nadds; ii++) {\n    ss << \" ADD:\" << RRToString(packet, &prr, &len);\n  }\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PacketToString",
            "parameters": {
              "packet": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string QuestionToString(const std::vector<byte>& packet,\n                             const byte** data, int* len) {\n  std::stringstream ss;\n  ss << \"{\";\n  if (*len < NS_QFIXEDSZ) {\n    ss << \"(too short, len \" << *len << \")\";\n    return ss.str();\n  }\n\n  char *name = nullptr;\n  long enclen;\n  int rc = ares_expand_name(*data, packet.data(), (int)packet.size(), &name, &enclen);\n  if (rc != ARES_SUCCESS) {\n    ss << \"(error from ares_expand_name)\";\n    return ss.str();\n  }\n  if (enclen > *len) {\n    ss << \"(error, encoded name len \" << enclen << \"bigger than remaining data \" << *len << \" bytes)\";\n    return ss.str();\n  }\n  *len -= (int)enclen;\n  *data += enclen;\n\n  // DNS 0x20 may mix case, output as all lower for checks as the mixed case\n  // is really more of an internal thing\n  char lowername[256];\n  arestest_strtolower(lowername, name, sizeof(lowername));\n  ares_free_string(name);\n\n  ss << \"'\" << lowername << \"' \";\n  if (*len < NS_QFIXEDSZ) {\n    ss << \"(too short, len left \" << *len << \")\";\n    return ss.str();\n  }\n  ss << ClassToString(DNS_QUESTION_CLASS(*data)) << \" \";\n  ss << RRTypeToString(DNS_QUESTION_TYPE(*data));\n  *data += NS_QFIXEDSZ;\n  *len -= NS_QFIXEDSZ;\n  ss << \"}\";\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              279,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QuestionToString",
            "parameters": {
              "packet": "std::vector<byte>",
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string RRToString(const std::vector<byte>& packet,\n                       const byte** data, int* len) {\n  std::stringstream ss;\n  ss << \"{\";\n  if (*len < NS_RRFIXEDSZ) {\n    ss << \"too short, len \" << *len << \")\";\n    return ss.str();\n  }\n\n  char *name = nullptr;\n  long enclen;\n  int rc = ares_expand_name(*data, packet.data(), (int)packet.size(), &name, &enclen);\n  if (rc != ARES_SUCCESS) {\n    ss << \"(error from ares_expand_name)\";\n    return ss.str();\n  }\n  if (enclen > *len) {\n    ss << \"(error, encoded name len \" << enclen << \"bigger than remaining data \" << *len << \" bytes)\";\n    return ss.str();\n  }\n  *len -= (int)enclen;\n  *data += enclen;\n  ss << \"'\" << name << \"' \";\n  ares_free_string(name);\n  name = nullptr;\n\n  if (*len < NS_RRFIXEDSZ) {\n    ss << \"(too short, len left \" << *len << \")\";\n    return ss.str();\n  }\n  int rrtype = DNS_RR_TYPE(*data);\n  if (rrtype == T_OPT) {\n    ss << \"MAXUDP=\" << DNS_RR_CLASS(*data) << \" \";\n    ss << RRTypeToString(rrtype) << \" \";\n    ss << \"RCODE2=\" << DNS_RR_TTL(*data);\n  } else {\n    ss << ClassToString(DNS_RR_CLASS(*data)) << \" \";\n    ss << RRTypeToString(rrtype) << \" \";\n    ss << \"TTL=\" << DNS_RR_TTL(*data);\n  }\n  int rdatalen = DNS_RR_LEN(*data);\n\n  *data += NS_RRFIXEDSZ;\n  *len -= NS_RRFIXEDSZ;\n  if (*len < rdatalen) {\n    ss << \"(RR too long at \" << rdatalen << \", len left \" << *len << \")\";\n  } else {\n    switch (rrtype) {\n    case T_A:\n    case T_AAAA:\n      ss << \" \" << AddressToString(*data, rdatalen);\n      break;\n    case T_TXT: {\n      const byte* p = *data;\n      while (p < (*data + rdatalen)) {\n        int tlen = *p++;\n        if ((p + tlen) <= (*data + rdatalen)) {\n          std::string txt(p, p + tlen);\n          ss << \" \" << tlen << \":'\" << txt << \"'\";\n        } else {\n          ss << \"(string too long)\";\n        }\n        p += tlen;\n      }\n      break;\n    }\n    case T_CNAME:\n    case T_NS:\n    case T_PTR: {\n      rc = ares_expand_name(*data, packet.data(), (int)packet.size(), &name, &enclen);\n      if (rc != ARES_SUCCESS) {\n        ss << \"(error from ares_expand_name)\";\n        break;\n      }\n      ss << \" '\" << name << \"'\";\n      ares_free_string(name);\n      break;\n    }\n    case T_MX:\n      if (rdatalen > 2) {\n        rc = ares_expand_name(*data + 2, packet.data(), (int)packet.size(), &name, &enclen);\n        if (rc != ARES_SUCCESS) {\n          ss << \"(error from ares_expand_name)\";\n          break;\n        }\n        ss << \" \" << DNS__16BIT(*data) << \" '\" << name << \"'\";\n        ares_free_string(name);\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    case T_SRV: {\n      if (rdatalen > 6) {\n        const byte* p = *data;\n        unsigned long prio = DNS__16BIT(p);\n        unsigned long weight = DNS__16BIT(p + 2);\n        unsigned long port = DNS__16BIT(p + 4);\n        p += 6;\n        rc = ares_expand_name(p, packet.data(), (int)packet.size(), &name, &enclen);\n        if (rc != ARES_SUCCESS) {\n          ss << \"(error from ares_expand_name)\";\n          break;\n        }\n        ss << prio << \" \" << weight << \" \" << port << \" '\" << name << \"'\";\n        ares_free_string(name);\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    }\n    case T_URI: {\n      if (rdatalen > 4) {\n        const byte* p = *data;\n        unsigned long prio = DNS__16BIT(p);\n        unsigned long weight = DNS__16BIT(p + 2);\n        p += 4;\n        std::string uri(p, p + (rdatalen - 4));\n        ss << prio << \" \" << weight << \" '\" << uri << \"'\";\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    }\n    case T_SOA: {\n      const byte* p = *data;\n      rc = ares_expand_name(p, packet.data(), (int)packet.size(), &name, &enclen);\n      if (rc != ARES_SUCCESS) {\n        ss << \"(error from ares_expand_name)\";\n        break;\n      }\n      ss << \" '\" << name << \"'\";\n      ares_free_string(name);\n      p += enclen;\n      rc = ares_expand_name(p, packet.data(), (int)packet.size(), &name, &enclen);\n      if (rc != ARES_SUCCESS) {\n        ss << \"(error from ares_expand_name)\";\n        break;\n      }\n      ss << \" '\" << name << \"'\";\n      ares_free_string(name);\n      p += enclen;\n      if ((p + 20) <= (*data + rdatalen)) {\n        unsigned long serial = DNS__32BIT(p);\n        unsigned long refresh = DNS__32BIT(p + 4);\n        unsigned long retry = DNS__32BIT(p + 8);\n        unsigned long expire = DNS__32BIT(p + 12);\n        unsigned long minimum = DNS__32BIT(p + 16);\n        ss << \" \" << serial << \" \" << refresh << \" \" << retry << \" \" << expire << \" \" << minimum;\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    }\n    case T_NAPTR: {\n      if (rdatalen > 7) {\n        const byte* p = *data;\n        unsigned long order = DNS__16BIT(p);\n        unsigned long pref = DNS__16BIT(p + 2);\n        p += 4;\n        ss << order << \" \" << pref;\n\n        int nlen = *p++;\n        std::string flags(p, p + nlen);\n        ss << \" \" << flags;\n        p += nlen;\n\n        nlen = *p++;\n        std::string service(p, p + nlen);\n        ss << \" '\" << service << \"'\";\n        p += nlen;\n\n        nlen = *p++;\n        std::string regexp(p, p + nlen);\n        ss << \" '\" << regexp << \"'\";\n        p += nlen;\n\n        rc = ares_expand_name(p, packet.data(), (int)packet.size(), &name, &enclen);\n        if (rc != ARES_SUCCESS) {\n          ss << \"(error from ares_expand_name)\";\n          break;\n        }\n        ss << \" '\" << name << \"'\";\n        ares_free_string(name);\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    }\n    default:\n      ss << \" \" << HexDump(*data, rdatalen);\n      break;\n    }\n  }\n  *data += rdatalen;\n  *len -= rdatalen;\n\n  ss << \"}\";\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RRToString",
            "parameters": {
              "packet": "std::vector<byte>",
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void PushInt32(std::vector<byte>* data, int value) {\n  data->push_back((byte)(((unsigned int)value & 0xff000000) >> 24));\n  data->push_back((byte)(((unsigned int)value & 0x00ff0000) >> 16));\n  data->push_back((byte)(((unsigned int)value & 0x0000ff00) >> 8));\n  data->push_back((byte)(value & 0x000000ff));\n}",
          "fn_code_pos": [
            [
              521,
              0
            ],
            [
              526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PushInt32",
            "parameters": {
              "data": "std::vector<byte>",
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void PushInt16(std::vector<byte>* data, int value) {\n  data->push_back((byte)((value & 0xff00) >> 8));\n  data->push_back((byte)value & 0x00ff);\n}",
          "fn_code_pos": [
            [
              528,
              0
            ],
            [
              531,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PushInt16",
            "parameters": {
              "data": "std::vector<byte>",
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::vector<byte> EncodeString(const std::string &name) {\n  std::vector<byte> data;\n  std::stringstream ss(name);\n  std::string label;\n  // TODO: cope with escapes\n  while (std::getline(ss, label, '.')) {\n    /* Label length of 0 indicates the end, and we always push an end\n     * terminator, so don't do it twice */\n    if (label.length() == 0)\n      break;\n    data.push_back((byte)label.length());\n    data.insert(data.end(), label.begin(), label.end());\n  }\n  data.push_back(0);\n  return data;\n}",
          "fn_code_pos": [
            [
              533,
              0
            ],
            [
              548,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncodeString",
            "parameters": {
              "name": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSQuestion::data(const char *request_name, const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data;\n  std::vector<byte> encname;\n  if (request_name != nullptr && strcasecmp(request_name, name_.c_str()) == 0) {\n    encname = EncodeString(request_name);\n  } else {\n    encname = EncodeString(name_);\n  }\n  data.insert(data.end(), encname.begin(), encname.end());\n  PushInt16(&data, rrtype_);\n  PushInt16(&data, qclass_);\n  return data;\n}",
          "fn_code_pos": [
            [
              550,
              0
            ],
            [
              562,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSQuestion::data",
            "parameters": {
              "request_name": "char",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSQuestion::data(dnsrec);\n  PushInt32(&data, ttl_);\n  return data;\n}",
          "fn_code_pos": [
            [
              564,
              0
            ],
            [
              568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSSingleNameRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSRR::data(dnsrec);\n  std::vector<byte> encname = EncodeString(other_);\n  int len = (int)encname.size();\n  PushInt16(&data, len);\n  data.insert(data.end(), encname.begin(), encname.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              570,
              0
            ],
            [
              577,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSingleNameRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSTxtRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSRR::data(dnsrec);\n  int len = 0;\n  for (const std::string& txt : txt_) {\n    len += (1 + (int)txt.size());\n  }\n  PushInt16(&data, len);\n  for (const std::string& txt : txt_) {\n    data.push_back((byte)txt.size());\n    data.insert(data.end(), txt.begin(), txt.end());\n  }\n  return data;\n}",
          "fn_code_pos": [
            [
              579,
              0
            ],
            [
              591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSTxtRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSMxRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSRR::data(dnsrec);\n  std::vector<byte> encname = EncodeString(other_);\n  int len = 2 + (int)encname.size();\n  PushInt16(&data, len);\n  PushInt16(&data, pref_);\n  data.insert(data.end(), encname.begin(), encname.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              593,
              0
            ],
            [
              601,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSMxRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSSrvRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSRR::data(dnsrec);\n  std::vector<byte> encname = EncodeString(target_);\n  int len = 6 + (int)encname.size();\n  PushInt16(&data, len);\n  PushInt16(&data, prio_);\n  PushInt16(&data, weight_);\n  PushInt16(&data, port_);\n  data.insert(data.end(), encname.begin(), encname.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              603,
              0
            ],
            [
              613,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSrvRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSUriRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSRR::data(dnsrec);\n  int len = 4 + (int)target_.size();\n  PushInt16(&data, len);\n  PushInt16(&data, prio_);\n  PushInt16(&data, weight_);\n  data.insert(data.end(), target_.begin(), target_.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              615,
              0
            ],
            [
              623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSUriRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSAddressRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSRR::data(dnsrec);\n  int len = (int)addr_.size();\n  PushInt16(&data, len);\n  data.insert(data.end(), addr_.begin(), addr_.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              625,
              0
            ],
            [
              631,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAddressRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSSoaRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSRR::data(dnsrec);\n  std::vector<byte> encname1 = EncodeString(nsname_);\n  std::vector<byte> encname2 = EncodeString(rname_);\n  int len = (int)encname1.size() + (int)encname2.size() + 5*4;\n  PushInt16(&data, len);\n  data.insert(data.end(), encname1.begin(), encname1.end());\n  data.insert(data.end(), encname2.begin(), encname2.end());\n  PushInt32(&data, serial_);\n  PushInt32(&data, refresh_);\n  PushInt32(&data, retry_);\n  PushInt32(&data, expire_);\n  PushInt32(&data, minimum_);\n  return data;\n}",
          "fn_code_pos": [
            [
              633,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSoaRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const ares_dns_rr_t *fetch_rr_opt(const ares_dns_record_t *rec)\n{\n  size_t i;\n  for (i = 0; i < ares_dns_record_rr_cnt(rec, ARES_SECTION_ADDITIONAL); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get_const(rec, ARES_SECTION_ADDITIONAL, i);\n\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      return rr;\n    }\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              649,
              0
            ],
            [
              661,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fetch_rr_opt",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "std::vector<byte> DNSOptRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte>    data = DNSRR::data(dnsrec);\n  int len                   = 0;\n  std::vector<byte>    cookie;\n  const ares_dns_rr_t *rr  = fetch_rr_opt(dnsrec);\n  size_t               passed_cookie_len = 0;\n  const unsigned char *passed_cookie = NULL;\n\n  ares_dns_rr_get_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE,\n                           &passed_cookie, &passed_cookie_len);\n\n  /* Error out if we expected a server cookie but didn't get one, or if the\n   * passed in server cookie doesn't match our expected value */\n  if (expect_server_cookie_ &&\n      (passed_cookie_len <= 8 ||\n       passed_cookie_len - 8 != server_cookie_.size() ||\n       memcmp(passed_cookie + 8, server_cookie_.data(), server_cookie_.size()) != 0\n      )\n     ) {\n    data.clear();\n    return data;\n  }\n\n  /* See if we should be applying a server cookie */\n  if (server_cookie_.size() && passed_cookie_len >= 8) {\n    /* If client cookie was provided to test framework, we are overwriting\n     * the one received from the client.  This is likely to test failure\n     * scenarios */\n    if (client_cookie_.size()) {\n      cookie.insert(cookie.end(), client_cookie_.begin(), client_cookie_.end());\n    } else {\n      cookie.insert(cookie.end(), passed_cookie, passed_cookie+8);\n    }\n    cookie.insert(cookie.end(), server_cookie_.begin(), server_cookie_.end());\n  }\n\n  if (cookie.size()) {\n    len += 4 + (int)cookie.size();\n  }\n  for (const DNSOption& opt : opts_) {\n    len += (4 + (int)opt.data_.size());\n  }\n\n  PushInt16(&data, len);\n  for (const DNSOption& opt : opts_) {\n    PushInt16(&data, opt.code_);\n    PushInt16(&data, (int)opt.data_.size());\n    data.insert(data.end(), opt.data_.begin(), opt.data_.end());\n  }\n\n  if (cookie.size()) {\n    PushInt16(&data, ARES_OPT_PARAM_COOKIE);\n    PushInt16(&data, (int)cookie.size());\n    data.insert(data.end(), cookie.begin(), cookie.end());\n  }\n\n  return data;\n}",
          "fn_code_pos": [
            [
              663,
              0
            ],
            [
              720,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSOptRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSNaptrRR::data(const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data = DNSRR::data(dnsrec);\n  std::vector<byte> encname = EncodeString(replacement_);\n  int len = (4 + 1 + (int)flags_.size() + 1 + (int)service_.size() + 1 + (int)regexp_.size() + (int)encname.size());\n  PushInt16(&data, len);\n  PushInt16(&data, order_);\n  PushInt16(&data, pref_);\n  data.push_back((byte)flags_.size());\n  data.insert(data.end(), flags_.begin(), flags_.end());\n  data.push_back((byte)service_.size());\n  data.insert(data.end(), service_.begin(), service_.end());\n  data.push_back((byte)regexp_.size());\n  data.insert(data.end(), regexp_.begin(), regexp_.end());\n  data.insert(data.end(), encname.begin(), encname.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              722,
              0
            ],
            [
              737,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSNaptrRR::data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSPacket::data(const char *request_name, const ares_dns_record_t *dnsrec) const {\n  std::vector<byte> data;\n  PushInt16(&data, qid_);\n  byte b = 0x00;\n  if (response_) b |= 0x80;\n  b |= ((opcode_ & 0x0f) << 3);\n  if (aa_) b |= 0x04;\n  if (tc_) b |= 0x02;\n  if (rd_) b |= 0x01;\n  data.push_back(b);\n  b = 0x00;\n  if (ra_) b |= 0x80;\n  if (z_) b |= 0x40;\n  if (ad_) b |= 0x20;\n  if (cd_) b |= 0x10;\n  b |= (rcode_ & 0x0f);\n  data.push_back(b);\n\n  int count = (int)questions_.size();\n  PushInt16(&data, count);\n  count = (int)answers_.size();\n  PushInt16(&data, count);\n  count = (int)auths_.size();\n  PushInt16(&data, count);\n  count = (int)adds_.size();\n  PushInt16(&data, count);\n\n  for (const std::unique_ptr<DNSQuestion>& question : questions_) {\n    std::vector<byte> qdata = question->data(request_name, dnsrec);\n    if (qdata.size() == 0) {\n      data.clear();\n      return data;\n    }\n    data.insert(data.end(), qdata.begin(), qdata.end());\n  }\n  for (const std::unique_ptr<DNSRR>& rr : answers_) {\n    std::vector<byte> rrdata = rr->data(dnsrec);\n    if (rrdata.size() == 0) {\n      data.clear();\n      return data;\n    }\n    data.insert(data.end(), rrdata.begin(), rrdata.end());\n  }\n  for (const std::unique_ptr<DNSRR>& rr : auths_) {\n    std::vector<byte> rrdata = rr->data(dnsrec);\n    if (rrdata.size() == 0) {\n      data.clear();\n      return data;\n    }\n    data.insert(data.end(), rrdata.begin(), rrdata.end());\n  }\n  for (const std::unique_ptr<DNSRR>& rr : adds_) {\n    std::vector<byte> rrdata = rr->data(dnsrec);\n    if (rrdata.size() == 0) {\n      data.clear();\n      return data;\n    }\n    data.insert(data.end(), rrdata.begin(), rrdata.end());\n  }\n  return data;\n}",
          "fn_code_pos": [
            [
              739,
              0
            ],
            [
              799,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSPacket::data",
            "parameters": {
              "request_name": "char",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ss(name)",
          "fn_dec_pos": [
            [
              535,
              20
            ],
            [
              535,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ss",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "fetch_rr_opt(const ares_dns_record_t *rec)",
          "fn_dec_pos": [
            [
              649,
              21
            ],
            [
              649,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fetch_rr_opt",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <algorithm>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-a.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 0x01020304, {2,3,4,5}))\n    .add_answer(new DNSAaaaRR(\"example.com\", 0x01020304, {0,0,0,0,0,0,0,0,0,0,0,0,2,3,4,5}));\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x02,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n    // Answer 2\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x1c,  //  RR type\n    0x00, 0x01,  //  class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x10,  // rdata length\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x04, 0x05,\n  };\n  EXPECT_EQ(data, pkt.data());\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[5];\n  int count = 5;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(0x01020304, info[0].ttl);\n  unsigned long expected_addr = htonl(0x02030405);\n  EXPECT_EQ(expected_addr, info[0].ipaddr.s_addr);\n  EXPECT_EQ(\"2.3.4.5\", AddressToString(&(info[0].ipaddr), 4));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n\n  // Repeat without providing a hostent\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             nullptr, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(0x01020304, info[0].ttl);\n  EXPECT_EQ(expected_addr, info[0].ipaddr.s_addr);\n  EXPECT_EQ(\"2.3.4.5\", AddressToString(&(info[0].ipaddr), 4));\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseMalformedAReply) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // [0:2) qid\n    0x84, // [2] response + query + AA + not-TC + not-RD\n    0x00, // [3] not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // [4:6) num questions\n    0x00, 0x02,  // [6:8) num answer RRs\n    0x00, 0x00,  // [8:10) num authority RRs\n    0x00, 0x00,  // [10:12) num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e', // [12:20)\n    0x03, 'c', 'o', 'm', // [20,24)\n    0x00, // [24]\n    0x00, 0x01,  // [25:26) type A\n    0x00, 0x01,  // [27:29) class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e', // [29:37)\n    0x03, 'c', 'o', 'm', // [37:41)\n    0x00, // [41]\n    0x00, 0x01,  // [42:44) RR type\n    0x00, 0x01,  // [44:46) class IN\n    0x01, 0x02, 0x03, 0x04, // [46:50) TTL\n    0x00, 0x04,  // [50:52) rdata length\n    0x02, 0x03, 0x04, 0x05, // [52,56)\n  };\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n\n  // Invalid RR-len.\n  std::vector<byte> invalid_rrlen(data);\n  invalid_rrlen[51] = 180;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(invalid_rrlen.data(), (int)invalid_rrlen.size(),\n                                              &host, info, &count));\n\n  // Truncate mid-question.\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), 26,\n                                              &host, info, &count));\n\n  // Truncate mid-answer.\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), 42,\n                                              &host, info, &count));\n\n  // Negative length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), -1,\n                                              &host, info, &count));\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyNoData) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(0, count);\n  EXPECT_EQ(nullptr, host);\n\n  // Again but with a CNAME.\n  pkt.add_answer(new DNSCnameRR(\"example.com\", 200, \"c.example.com\"));\n  data = pkt.data();\n  // Expect success as per https://github.com/c-ares/c-ares/commit/2c63440127feed70ccefb148b8f938a2df6c15f8\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(0, count);\n  EXPECT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'c.example.com' aliases=[example.com] addrs=[]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyVariantA) {\n  DNSPacket pkt;\n  pkt.set_qid(6366).set_rd().set_ra()\n    .add_question(new DNSQuestion(\"mit.edu\", T_A))\n    .add_answer(new DNSARR(\"mit.edu\", 52, {18,7,22,69}))\n    .add_auth(new DNSNsRR(\"mit.edu\", 292, \"W20NS.mit.edu\"))\n    .add_auth(new DNSNsRR(\"mit.edu\", 292, \"BITSY.mit.edu\"))\n    .add_auth(new DNSNsRR(\"mit.edu\", 292, \"STRAWB.mit.edu\"))\n    .add_additional(new DNSARR(\"STRAWB.mit.edu\", 292, {18,71,0,151}));\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  std::vector<byte> data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(\"18.7.22.69\", AddressToString(&(info[0].ipaddr), 4));\n  EXPECT_EQ(52, info[0].ttl);\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyJustCname) {\n  DNSPacket pkt;\n  pkt.set_qid(6366).set_rd().set_ra()\n    .add_question(new DNSQuestion(\"mit.edu\", T_A))\n    .add_answer(new DNSCnameRR(\"mit.edu\", 52, \"other.mit.edu\"));\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  std::vector<byte> data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(0, count);\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.mit.edu' aliases=[mit.edu] addrs=[]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyVariantCname) {\n  DNSPacket pkt;\n  pkt.set_qid(6366).set_rd().set_ra()\n    .add_question(new DNSQuestion(\"query.example.com\", T_A))\n    .add_answer(new DNSCnameRR(\"query.example.com\", 200, \"redirect.query.example.com\"))\n    .add_answer(new DNSARR(\"redirect.query.example.com\", 300, {129,97,123,22}))\n    .add_auth(new DNSNsRR(\"example.com\", 218, \"aa.ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 218, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 218, \"ns3.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 218, \"ns4.example.com\"))\n    .add_additional(new DNSARR(\"aa.ns1.example.com\", 218, {129,97,1,1}))\n    .add_additional(new DNSARR(\"ns2.example.com\", 218, {129,97,1,2}))\n    .add_additional(new DNSARR(\"ns3.example.com\", 218, {129,97,1,3}))\n    .add_additional(new DNSARR(\"ns4.example.com\", 218, {129,97,1,4}));\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  std::vector<byte> data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(\"129.97.123.22\", AddressToString(&(info[0].ipaddr), 4));\n  // TTL is reduced to match CNAME's.\n  EXPECT_EQ(200, info[0].ttl);\n  ares_free_hostent(host);\n\n  // Repeat parsing without places to put the results.\n  count = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             nullptr, info, &count));\n}",
          "fn_code_pos": [
            [
              214,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyVariantCnameChain) {\n  DNSPacket pkt;\n  pkt.set_qid(6366).set_rd().set_ra()\n    .add_question(new DNSQuestion(\"c1.localhost\", T_A))\n    .add_answer(new DNSCnameRR(\"c1.localhost\", 604800, \"c2.localhost\"))\n    .add_answer(new DNSCnameRR(\"c2.localhost\", 604800, \"c3.localhost\"))\n    .add_answer(new DNSCnameRR(\"c3.localhost\", 604800, \"c4.localhost\"))\n    .add_answer(new DNSARR(\"c4.localhost\", 604800, {8,8,8,8}))\n    .add_auth(new DNSNsRR(\"localhost\", 604800, \"localhost\"))\n    .add_additional(new DNSARR(\"localhost\", 604800, {127,0,0,1}))\n    .add_additional(new DNSAaaaRR(\"localhost\", 604800,\n                              {0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}));\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  std::vector<byte> data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(\"8.8.8.8\", AddressToString(&(info[0].ipaddr), 4));\n  EXPECT_EQ(604800, info[0].ttl);\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              246,
              0
            ],
            [
              269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {0x02, 0x03, 0x04, 0x05}));\n  std::vector<byte> data;\n\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_A));\n\n  // Question != answer, this is ok as of Issue #683\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_A));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'axample.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n  host = nullptr;\n\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_A));\n\n#ifdef DISABLED\n  // Not a response.\n  pkt.set_response(false);\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.set_response(true);\n\n  // Bad return code.\n  pkt.set_rcode(FORMERR);\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.set_rcode(NOERROR);\n#endif\n\n  // Two questions\n  pkt.add_question(new DNSQuestion(\"example.com\", T_A));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_A));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSARR(\"example.com\", 100, {0x02, 0x03, 0x04, 0x05}));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_answer(new DNSARR(\"example.com\", 100, {0x02, 0x03, 0x04, 0x05}));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)len,\n                                                &host, info, &count));\n    EXPECT_EQ(nullptr, host);\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)len,\n                                                nullptr, info, &count));\n  }\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              360,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSARR(\"c.example.com\", 500, {0x02, 0x03, 0x04, 0x05}));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n\n  for (int ii = 1; ii <= 8; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count)) << ii;\n    EXPECT_EQ(nullptr, host);\n  }\n}",
          "fn_code_pos": [
            [
              362,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "invalid_rrlen(data)",
          "fn_dec_pos": [
            [
              129,
              20
            ],
            [
              129,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "invalid_rrlen",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            74,
            2
          ],
          [
            74,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            75,
            2
          ],
          [
            75,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            124,
            2
          ],
          [
            124,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            125,
            2
          ],
          [
            125,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            152,
            2
          ],
          [
            152,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            153,
            2
          ],
          [
            153,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            183,
            2
          ],
          [
            183,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            184,
            2
          ],
          [
            184,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            200,
            2
          ],
          [
            200,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            201,
            2
          ],
          [
            201,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            228,
            2
          ],
          [
            228,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            229,
            2
          ],
          [
            229,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            259,
            2
          ],
          [
            259,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            260,
            2
          ],
          [
            260,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            278,
            2
          ],
          [
            278,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            279,
            2
          ],
          [
            279,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            370,
            2
          ],
          [
            370,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            371,
            2
          ],
          [
            371,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-live.cc": {
      "fn_def_list": [
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByNameV4) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_LT(0, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET, result.host_.addrtype_);\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByNameV6) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_LT(0, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByAddrV4) {\n  HostResult result;\n  ares_gethostbyaddr(channel_, cflare_addr4, sizeof(cflare_addr4), AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_LT(0, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET, result.host_.addrtype_);\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByAddrV6) {\n  HostResult result;\n  ares_gethostbyaddr(channel_, cflare_addr6, sizeof(cflare_addr6), AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_LT(0, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByNameFile) {\n  struct hostent *host = nullptr;\n\n  // Still need a channel even to query /etc/hosts.\n  EXPECT_EQ(ARES_ENOTFOUND,\n            ares_gethostbyname_file(nullptr, \"localhost\", AF_INET, &host));\n\n  int rc = ares_gethostbyname_file(channel_, \"bogus.mcname\", AF_INET, &host);\n  EXPECT_EQ(nullptr, host);\n  EXPECT_EQ(ARES_ENOTFOUND, rc);\n\n  rc = ares_gethostbyname_file(channel_, \"localhost\", AF_INET, &host);\n  if (rc == ARES_SUCCESS) {\n    EXPECT_NE(nullptr, host);\n    ares_free_hostent(host);\n  }\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByNameV4) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"localhost\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ECONNREFUSED) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET, result.host_.addrtype_);\n    EXPECT_NE(SIZE_MAX, result.host_.name_.find(\"localhost\"));\n  }\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByNameV6) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"localhost\", AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ECONNREFUSED) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n    std::stringstream ss;\n    ss << HostEnt(result.host_);\n    EXPECT_NE(SIZE_MAX, result.host_.name_.find(\"localhost\"));\n  }\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetNonExistLocalhostByNameV4) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"idonotexist.localhost\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ECONNREFUSED) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET, result.host_.addrtype_);\n    EXPECT_NE(SIZE_MAX, result.host_.name_.find(\"idonotexist.localhost\"));\n  }\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetNonExistLocalhostByNameV6) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"idonotexist.localhost\", AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ECONNREFUSED) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n    std::stringstream ss;\n    ss << HostEnt(result.host_);\n    EXPECT_NE(SIZE_MAX, result.host_.name_.find(\"idonotexist.localhost\"));\n  }\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByNameIPV4) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"127.0.0.1\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(1, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET, result.host_.addrtype_);\n  std::stringstream ss;\n  ss << HostEnt(result.host_);\n  EXPECT_EQ(\"{'127.0.0.1' aliases=[] addrs=[127.0.0.1]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByNameIPV6) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"::1\", AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ENOTFOUND) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n    std::stringstream ss;\n    ss << HostEnt(result.host_);\n    EXPECT_EQ(\"{'::1' aliases=[] addrs=[0000:0000:0000:0000:0000:0000:0000:0001]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              239,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostFailFamily) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"127.0.0.1\", AF_INET+AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              254,
              0
            ],
            [
              260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByAddrV4) {\n  HostResult result;\n  struct in_addr addr;\n  addr.s_addr = htonl(INADDR_LOOPBACK);\n  ares_gethostbyaddr(channel_, &addr, sizeof(addr), AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ENOTFOUND) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_LT(0, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET, result.host_.addrtype_);\n    // oddly, travis does not resolve to localhost, but a random hostname starting with travis-job\n    if (result.host_.name_.find(\"travis-job\") == SIZE_MAX) {\n        EXPECT_NE(SIZE_MAX,\n                  result.host_.name_.find(\"localhost\"));\n    }\n  }\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByAddrV6) {\n  HostResult result;\n  struct in6_addr addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.s6_addr[15] = 1;  // in6addr_loopback\n  ares_gethostbyaddr(channel_, &addr, sizeof(addr), AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ENOTFOUND) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_LT(0, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n    const std::string& name = result.host_.name_;\n    EXPECT_TRUE(SIZE_MAX != name.find(\"localhost\") ||\n                SIZE_MAX != name.find(\"ip6-loopback\"));\n  }\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetHostByAddrFailFamily) {\n  HostResult result;\n  unsigned char addr[4] = {8, 8, 8, 8};\n  ares_gethostbyaddr(channel_, addr, sizeof(addr), AF_INET6+AF_INET,\n                     HostCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetHostByAddrFailAddrSize) {\n  HostResult result;\n  unsigned char addr[4] = {8, 8, 8, 8};\n  ares_gethostbyaddr(channel_, addr, sizeof(addr) - 1, AF_INET,\n                     HostCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetHostByAddrFailAlloc) {\n  HostResult result;\n  unsigned char addr[4] = {8, 8, 8, 8};\n  SetAllocFail(1);\n  ares_gethostbyaddr(channel_, addr, sizeof(addr), AF_INET,\n                     HostCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOMEM, result.status_);\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchA) {\n  SearchResult result;\n  ares_search(channel_, \"www.youtube.com.\", C_IN, T_A,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchEmptyA) {\n  SearchResult result;\n  ares_search(channel_, \"\", C_IN, T_A,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_NE(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchNS) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_NS,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchMX) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_MX,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchTXT) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_TXT,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchSOA) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_SOA,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchSRV) {\n  SearchResult result;\n  ares_search(channel_, \"_imap._tcp.gmail.com.\", C_IN, T_SRV,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              384,
              0
            ],
            [
              391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchANY) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_ANY,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              393,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"8.8.8.8:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              402,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4NoPort) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(0);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"8.8.8.8:0 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              418,
              0
            ],
            [
              432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4UnassignedPort) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(4);  // Unassigned at IANA\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"8.8.8.8:4 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              434,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6Both) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_TCP|ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_NOFQDN,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"[2001:4860:4860::8888]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              450,
              0
            ],
            [
              464,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6Neither) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_TCP|ARES_NI_NOFQDN,  // Neither specified => assume lookup host.\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"[2001:4860:4860::8888]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4Numeric) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_TCP|ARES_NI_NUMERICHOST,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"8.8.8.8\", result.node_);\n  if (verbose) std::cerr << \"8.8.8.8:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6Numeric) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_DCCP|ARES_NI_NUMERICHOST,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"2606:4700:4700::1111%0\", result.node_);\n  if (verbose) std::cerr << \"[2606:4700:4700::1111]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              499,
              0
            ],
            [
              514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6LinkLocal) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  unsigned char addr6[16] = {0xfe, 0x80, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00,\n                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04};\n  memcpy(sockaddr.sin6_addr.s6_addr, addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_DCCP|ARES_NI_NUMERICHOST,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"fe80:102:102::304%0\", result.node_);\n  if (verbose) std::cerr << \"[fe80:102:102::304]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              516,
              0
            ],
            [
              533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4NotFound) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(4);  // Port 4 unassigned at IANA\n  // RFC5737 says 192.0.2.0 should not be used publicly.\n  sockaddr.sin_addr.s_addr = htonl(0xC0000200);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"192.0.2.0\", result.node_);\n  if (verbose) std::cerr << \"192.0.2.0:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              535,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4NotFoundFail) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  // RFC5737 says 192.0.2.0 should not be used publicly.\n  sockaddr.sin_addr.s_addr = htonl(0xC0000200);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP|ARES_NI_NAMEREQD,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n}",
          "fn_code_pos": [
            [
              553,
              0
            ],
            [
              567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6NotFound) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  // 2001:db8::/32 is only supposed to be used in documentation.\n  unsigned char addr6[16] = {0x20, 0x01, 0x0d, 0xb8, 0x01, 0x02, 0x00, 0x00,\n                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04};\n  memcpy(sockaddr.sin6_addr.s6_addr, addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"2001:db8:102::304%0\", result.node_);\n  if (verbose) std::cerr << \"[2001:db8:102::304]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              569,
              0
            ],
            [
              587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInvalidFamily) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6 + AF_INET;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              589,
              0
            ],
            [
              602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInvalidFlags) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  // Ask for both a name-required, and a numeric host.\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP|ARES_NI_NUMERICHOST|ARES_NI_NAMEREQD,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EBADFLAGS, result.status_);\n}",
          "fn_code_pos": [
            [
              604,
              0
            ],
            [
              618,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetServiceInfo) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  // Just look up service info\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPSERVICE|ARES_NI_SCTP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"\", result.node_);\n}",
          "fn_code_pos": [
            [
              620,
              0
            ],
            [
              635,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetServiceInfoNumeric) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  // Just look up service info\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPSERVICE|ARES_NI_SCTP|ARES_NI_NUMERICSERV,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"\", result.node_);\n  EXPECT_EQ(\"53\", result.service_);\n}",
          "fn_code_pos": [
            [
              637,
              0
            ],
            [
              653,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoAllocFail) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  SetAllocFail(1);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOMEM, result.status_);\n}",
          "fn_code_pos": [
            [
              655,
              0
            ],
            [
              669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, LiveSetServers) {\n  struct ares_addr_node server1;\n  struct ares_addr_node server2;\n  server1.next = &server2;\n  server1.family = AF_INET;\n  server1.addr.addr4.s_addr = htonl(0x01020304);\n  server2.next = nullptr;\n  server2.family = AF_INET;\n  server2.addr.addr4.s_addr = htonl(0x02030405);\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers(channel_, &server1));\n  ares_cancel(channel_);\n}",
          "fn_code_pos": [
            [
              673,
              0
            ],
            [
              687,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, LiveSetServersPorts) {\n  struct ares_addr_port_node server1;\n  struct ares_addr_port_node server2;\n  server1.next = &server2;\n  server1.family = AF_INET;\n  server1.addr.addr4.s_addr = htonl(0x01020304);\n  server1.udp_port = 111;\n  server1.tcp_port = 111;\n  server2.next = nullptr;\n  server2.family = AF_INET;\n  server2.addr.addr4.s_addr = htonl(0x02030405);\n  server2.udp_port = 0;\n  server2.tcp_port = 0;\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_ports(nullptr, &server1));\n\n  // Change while pending will requeue any requests to new servers\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports(channel_, &server1));\n  ares_cancel(channel_);\n}",
          "fn_code_pos": [
            [
              689,
              0
            ],
            [
              709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, LiveSetServersCSV) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  // Change while pending will requeue any requests to new servers\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_csv(channel_, \"1.2.3.4,2.3.4.5\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports_csv(channel_, \"1.2.3.4:56,2.3.4.5:67\"));\n  ares_cancel(channel_);\n}",
          "fn_code_pos": [
            [
              711,
              0
            ],
            [
              718,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            153,
            2
          ],
          [
            153,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            264,
            2
          ],
          [
            264,
            16
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            283,
            2
          ],
          [
            283,
            17
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            404,
            2
          ],
          [
            404,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            409,
            36
          ],
          [
            409,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            420,
            2
          ],
          [
            420,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            425,
            36
          ],
          [
            425,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            436,
            2
          ],
          [
            436,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            441,
            36
          ],
          [
            441,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            452,
            2
          ],
          [
            452,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            457,
            36
          ],
          [
            457,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            468,
            2
          ],
          [
            468,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            473,
            36
          ],
          [
            473,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            484,
            2
          ],
          [
            484,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            489,
            36
          ],
          [
            489,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            501,
            2
          ],
          [
            501,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            506,
            36
          ],
          [
            506,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            518,
            2
          ],
          [
            518,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            525,
            36
          ],
          [
            525,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            537,
            2
          ],
          [
            537,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            543,
            36
          ],
          [
            543,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            555,
            2
          ],
          [
            555,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            561,
            36
          ],
          [
            561,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            571,
            2
          ],
          [
            571,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            579,
            36
          ],
          [
            579,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            591,
            2
          ],
          [
            591,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            596,
            36
          ],
          [
            596,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            606,
            2
          ],
          [
            606,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            612,
            36
          ],
          [
            612,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            622,
            2
          ],
          [
            622,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            628,
            36
          ],
          [
            628,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            639,
            2
          ],
          [
            639,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            645,
            36
          ],
          [
            645,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            657,
            2
          ],
          [
            657,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            663,
            36
          ],
          [
            663,
            51
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            674,
            2
          ],
          [
            674,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            675,
            2
          ],
          [
            675,
            23
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            690,
            2
          ],
          [
            690,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            691,
            2
          ],
          [
            691,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void ares_sleep_time(unsigned int ms)\n{\n  auto duration   = std::chrono::milliseconds(ms);\n  auto start_time = std::chrono::high_resolution_clock::now();\n  auto wake_time  = start_time + duration;\n  std::this_thread::sleep_until(wake_time);\n  auto end_time   = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << \"sleep requested \" << ms << \"ms, slept for \" << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count() << \"ms\" << std::endl;\n}",
          "fn_code_pos": [
            [
              254,
              0
            ],
            [
              262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sleep_time",
            "parameters": {
              "ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ProcessWork(ares_channel_t *channel,\n                 std::function<std::set<ares_socket_t>()> get_extrafds,\n                 std::function<void(ares_socket_t)> process_extra,\n                 unsigned int cancel_ms) {\n  int nfds, count;\n  fd_set readers, writers;\n\n  auto tv_begin = std::chrono::high_resolution_clock::now();\n  auto tv_cancel = tv_begin;\n\n  if (cancel_ms) {\n    if (verbose) std::cerr << \"ares_cancel will be called after \" << cancel_ms << \"ms\" << std::endl;\n    tv_cancel += std::chrono::milliseconds(cancel_ms);\n  }\n\n  while (true) {\n    struct timeval  tv;\n    struct timeval *tv_select;\n\n    // Retrieve the set of file descriptors that the library wants us to monitor.\n    FD_ZERO(&readers);\n    FD_ZERO(&writers);\n    nfds = ares_fds(channel, &readers, &writers);\n    if (nfds == 0)  // no work left to do in the library\n      return;\n\n    // Add in the extra FDs if present.\n    std::set<ares_socket_t> extrafds = get_extrafds();\n    for (ares_socket_t extrafd : extrafds) {\n      FD_SET(extrafd, &readers);\n      if (extrafd >= (ares_socket_t)nfds) {\n        nfds = (int)extrafd + 1;\n      }\n    }\n\n    /* If ares_timeout returns NULL, it means there are no requests in queue,\n     * so we can break out */\n    tv_select = ares_timeout(channel, NULL, &tv);\n    if (tv_select == NULL)\n      return;\n\n    if (cancel_ms) {\n      auto tv_now       = std::chrono::high_resolution_clock::now();\n      auto remaining_ms = std::chrono::duration_cast<std::chrono::milliseconds>(tv_cancel - tv_now).count();\n\n      if (remaining_ms <= 0) {\n        if (verbose) std::cerr << \"Issuing ares_cancel()\" << std::endl;\n        ares_cancel(channel);\n        cancel_ms = 0; /* Disable issuing cancel again */\n      } else {\n        struct timeval tv_remaining;\n\n        tv_remaining.tv_sec = remaining_ms / 1000;\n        tv_remaining.tv_usec = (int)(remaining_ms % 1000);\n\n        /* Recalculate proper timeout since we also have a cancel to wait on */\n        tv_select = ares_timeout(channel, &tv_remaining, &tv);\n      }\n    }\n\n    count = select(nfds, &readers, &writers, nullptr, tv_select);\n    if (count < 0) {\n      fprintf(stderr, \"select() failed, errno %d\\n\", errno);\n      return;\n    }\n\n    // Let the library process any activity.\n    ares_process(channel, &readers, &writers);\n\n    // Let the provided callback process any activity on the extra FD.\n    for (ares_socket_t extrafd : extrafds) {\n      if (FD_ISSET(extrafd, &readers)) {\n        process_extra(extrafd);\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ProcessWork",
            "parameters": {
              "channel": "ares_channel_t",
              "get_extrafds": "std::function<std::set<ares_socket_t>()>",
              "process_extra": "std::function<void(ares_socket_t)>",
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void LibraryTest::SetFailSend() {\n  failsend_ = true;\n}",
          "fn_code_pos": [
            [
              343,
              0
            ],
            [
              345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::SetFailSend",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_ssize_t LibraryTest::ares_sendv_fail(ares_socket_t socket, const struct iovec *vec, int len, void *user_data)\n{\n  (void)user_data;\n\n  if (failsend_) {\n#ifdef USE_WINSOCK\n    WSASetLastError(WSAECONNREFUSED);\n#else\n    errno = ECONNREFUSED;\n#endif\n    failsend_ = false;\n    return -1;\n  }\n\n  return send(socket, (const char *)vec[0].iov_base, vec[0].iov_len, 0);\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::ares_sendv_fail",
            "parameters": {
              "socket": "ares_socket_t",
              "vec": "struct iovec",
              "len": "int",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "void LibraryTest::SetAllocFail(int nth) {\n  lock_.lock();\n  assert(nth > 0);\n  assert(nth <= (int)(8 * sizeof(fails_)));\n  fails_ |= (1LL << (nth - 1));\n  lock_.unlock();\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::SetAllocFail",
            "parameters": {
              "nth": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void LibraryTest::SetAllocSizeFail(size_t size) {\n  lock_.lock();\n  size_fails_[size]++;\n  lock_.unlock();\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::SetAllocSizeFail",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void LibraryTest::ClearFails() {\n  lock_.lock();\n  fails_ = 0;\n  size_fails_.clear();\n  lock_.unlock();\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              387,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::ClearFails",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "bool LibraryTest::ShouldAllocFail(size_t size) {\n  lock_.lock();\n  bool fail = (fails_ & 0x01);\n  fails_ >>= 1;\n  if (size_fails_[size] > 0) {\n    size_fails_[size]--;\n    fail = true;\n  }\n  lock_.unlock();\n  return fail;\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::ShouldAllocFail",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void* LibraryTest::amalloc(size_t size) {\n  if (ShouldAllocFail(size) || size == 0) {\n    if (verbose) std::cerr << \"Failing malloc(\" << size << \") request\" << std::endl;\n    return nullptr;\n  } else {\n    return malloc(size);\n  }\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::amalloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* LibraryTest::arealloc(void *ptr, size_t size) {\n  if (ShouldAllocFail(size)) {\n    if (verbose) std::cerr << \"Failing realloc(\" << ptr << \", \" << size << \") request\" << std::endl;\n    return nullptr;\n  } else {\n    return realloc(ptr, size);\n  }\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::arealloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void LibraryTest::afree(void *ptr) {\n  free(ptr);\n}",
          "fn_code_pos": [
            [
              424,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::afree",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::set<ares_socket_t> NoExtraFDs() {\n  return std::set<ares_socket_t>();\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NoExtraFDs",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void DefaultChannelTest::Process(unsigned int cancel_ms) {\n  ProcessWork(channel_, NoExtraFDs, nullptr, cancel_ms);\n}",
          "fn_code_pos": [
            [
              432,
              0
            ],
            [
              434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultChannelTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FileChannelTest::Process(unsigned int cancel_ms) {\n  ProcessWork(channel_, NoExtraFDs, nullptr, cancel_ms);\n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              438,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FileChannelTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DefaultChannelModeTest::Process(unsigned int cancel_ms) {\n  ProcessWork(channel_, NoExtraFDs, nullptr, cancel_ms);\n}",
          "fn_code_pos": [
            [
              440,
              0
            ],
            [
              442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultChannelModeTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockServer::MockServer(int family, unsigned short port)\n  : udpport_(port), tcpport_(port), qid_(-1) {\n  reply_ = nullptr;\n  // Create a TCP socket to receive data on.\n  tcp_data_ = NULL;\n  tcp_data_len_ = 0;\n  tcpfd_ = socket(family, SOCK_STREAM, 0);\n  EXPECT_NE(ARES_SOCKET_BAD, tcpfd_);\n  int optval = 1;\n  setsockopt(tcpfd_, SOL_SOCKET, SO_REUSEADDR,\n             BYTE_CAST &optval , sizeof(int));\n  // Send TCP data right away.\n  setsockopt(tcpfd_, IPPROTO_TCP, TCP_NODELAY,\n             BYTE_CAST &optval , sizeof(int));\n#if defined(SO_NOSIGPIPE)\n  setsockopt(tcpfd_, SOL_SOCKET, SO_NOSIGPIPE, (void *)&optval, sizeof(optval));\n#endif\n\n  /* Test system enable TCP FastOpen */\n#if defined(TCP_FASTOPEN)\n#  ifdef __linux__\n  int qlen = 32;\n  setsockopt(tcpfd_, IPPROTO_TCP, TCP_FASTOPEN, &qlen, sizeof(qlen));\n#  else\n  int on = 1;\n  setsockopt(tcpfd_, IPPROTO_TCP, TCP_FASTOPEN, BYTE_CAST &on, sizeof(on));\n#  endif\n#endif\n\n  // Create a UDP socket to receive data on.\n  udpfd_ = socket(family, SOCK_DGRAM, 0);\n  EXPECT_NE(ARES_SOCKET_BAD, udpfd_);\n#if defined(SO_NOSIGPIPE)\n  setsockopt(udpfd_, SOL_SOCKET, SO_NOSIGPIPE, (void *)&optval, sizeof(optval));\n#endif\n\n  // Bind the sockets to the given port.\n  if (family == AF_INET) {\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(tcpport_);\n    int tcprc = bind(tcpfd_, (struct sockaddr*)&addr, sizeof(addr));\n    EXPECT_EQ(0, tcprc) << \"Failed to bind AF_INET to TCP port \" << tcpport_;\n    addr.sin_port = htons(udpport_);\n    int udprc = bind(udpfd_, (struct sockaddr*)&addr, sizeof(addr));\n    EXPECT_EQ(0, udprc) << \"Failed to bind AF_INET to UDP port \" << udpport_;\n    // retrieve system-assigned port\n    if (udpport_ == dynamic_port) {\n      ares_socklen_t len = sizeof(addr);\n      auto result = getsockname(udpfd_, (struct sockaddr*)&addr, &len);\n      EXPECT_EQ(0, result);\n      udpport_ = ntohs(addr.sin_port);\n      EXPECT_NE(dynamic_port, udpport_);\n    }\n    if (tcpport_ == dynamic_port) {\n      ares_socklen_t len = sizeof(addr);\n      auto result = getsockname(tcpfd_, (struct sockaddr*)&addr, &len);\n      EXPECT_EQ(0, result);\n      tcpport_ = ntohs(addr.sin_port);\n      EXPECT_NE(dynamic_port, tcpport_);\n    }\n  } else {\n    EXPECT_EQ(AF_INET6, family);\n    struct sockaddr_in6 addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin6_family = AF_INET6;\n    memset(&addr.sin6_addr, 0, sizeof(addr.sin6_addr));  // in6addr_any\n    addr.sin6_port = htons(tcpport_);\n    int tcprc = bind(tcpfd_, (struct sockaddr*)&addr, sizeof(addr));\n    EXPECT_EQ(0, tcprc) << \"Failed to bind AF_INET6 to TCP port \" << tcpport_;\n    addr.sin6_port = htons(udpport_);\n    int udprc = bind(udpfd_, (struct sockaddr*)&addr, sizeof(addr));\n    EXPECT_EQ(0, udprc) << \"Failed to bind AF_INET6 to UDP port \" << udpport_;\n    // retrieve system-assigned port\n    if (udpport_ == dynamic_port) {\n      ares_socklen_t len = sizeof(addr);\n      auto result = getsockname(udpfd_, (struct sockaddr*)&addr, &len);\n      EXPECT_EQ(0, result);\n      udpport_ = ntohs(addr.sin6_port);\n      EXPECT_NE(dynamic_port, udpport_);\n    }\n    if (tcpport_ == dynamic_port) {\n      ares_socklen_t len = sizeof(addr);\n      auto result = getsockname(tcpfd_, (struct sockaddr*)&addr, &len);\n      EXPECT_EQ(0, result);\n      tcpport_ = ntohs(addr.sin6_port);\n      EXPECT_NE(dynamic_port, tcpport_);\n    }\n  }\n  if (verbose) std::cerr << \"Configured \"\n                         << (family == AF_INET ? \"IPv4\" : \"IPv6\")\n                         << \" mock server with TCP socket \" << tcpfd_\n                         << \" on port \" << tcpport_\n                         << \" and UDP socket \" << udpfd_\n                         << \" on port \" << udpport_ << std::endl;\n\n  // For TCP, also need to listen for connections.\n  EXPECT_EQ(0, listen(tcpfd_, 5)) << \"Failed to listen for TCP connections\";\n}",
          "fn_code_pos": [
            [
              444,
              0
            ],
            [
              544,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::MockServer",
            "parameters": {
              "family": "int",
              "port": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockServer::~MockServer() {\n  for (ares_socket_t fd : connfds_) {\n    sclose(fd);\n  }\n  sclose(tcpfd_);\n  sclose(udpfd_);\n  free(tcp_data_);\n}",
          "fn_code_pos": [
            [
              546,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::~MockServer",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned short getaddrport(struct sockaddr_storage *addr)\n{\n  if (addr->ss_family == AF_INET)\n    return ntohs(((struct sockaddr_in *)(void *)addr)->sin_port);\n  if (addr->ss_family == AF_INET6)\n    return ntohs(((struct sockaddr_in6 *)(void *)addr)->sin6_port);\n\n  /* TCP should use getpeername() to get the port, getting this from recvfrom\n   * won't work */\n  return 0;\n}",
          "fn_code_pos": [
            [
              555,
              0
            ],
            [
              565,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getaddrport",
            "parameters": {
              "addr": "struct sockaddr_storage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void MockServer::ProcessPacket(ares_socket_t fd, struct sockaddr_storage *addr, ares_socklen_t addrlen,\n                               byte *data, int len) {\n\n  // Assume the packet is a well-formed DNS request and extract the request\n  // details.\n  if (len < NS_HFIXEDSZ) {\n    std::cerr << \"Packet too short (\" << len << \")\" << std::endl;\n    return;\n  }\n  int qid = DNS_HEADER_QID(data);\n  if (DNS_HEADER_QR(data) != 0) {\n    std::cerr << \"Not a request\" << std::endl;\n    return;\n  }\n  if (DNS_HEADER_OPCODE(data) != O_QUERY) {\n    std::cerr << \"Not a query (opcode \" << DNS_HEADER_OPCODE(data)\n              << \")\" << std::endl;\n    return;\n  }\n  if (DNS_HEADER_QDCOUNT(data) != 1) {\n    std::cerr << \"Unexpected question count (\" << DNS_HEADER_QDCOUNT(data)\n              << \")\" << std::endl;\n    return;\n  }\n  byte* question = data + NS_HFIXEDSZ;\n  int qlen = len - NS_HFIXEDSZ;\n\n  char *name = nullptr;\n  long enclen;\n  ares_expand_name(question, data, len, &name, &enclen);\n  if (!name) {\n    std::cerr << \"Failed to retrieve name\" << std::endl;\n    return;\n  }\n  if (enclen > qlen) {\n    std::cerr << \"(error, encoded name len \" << enclen << \"bigger than remaining data \" << qlen << \" bytes)\" << std::endl;\n    ares_free_string(name);\n    return;\n  }\n  qlen -= (int)enclen;\n  question += enclen;\n\n  if (qlen < 4) {\n    std::cerr << \"Unexpected question size (\" << qlen\n              << \" bytes after name)\" << std::endl;\n    ares_free_string(name);\n    return;\n  }\n  if (DNS_QUESTION_CLASS(question) != C_IN) {\n    std::cerr << \"Unexpected question class (\" << DNS_QUESTION_CLASS(question)\n              << \")\" << std::endl;\n    ares_free_string(name);\n    return;\n  }\n  int rrtype = DNS_QUESTION_TYPE(question);\n\n  std::vector<byte> req(data, data + len);\n  std::string reqstr = PacketToString(req);\n  if (verbose) {\n    std::cerr << \"received \" << (fd == udpfd_ ? \"UDP\" : \"TCP\") << \" request \" << reqstr\n              << \" on port \" << (fd == udpfd_ ? udpport_ : tcpport_)\n              << \":\" << getaddrport(addr) << std::endl;\n    std::cerr << \"ProcessRequest(\" << qid << \", '\" << name\n              << \"', \" << RRTypeToString(rrtype) << \")\" << std::endl;\n  }\n  ProcessRequest(fd, addr, addrlen, req, reqstr, qid, name, rrtype);\n  ares_free_string(name);\n}",
          "fn_code_pos": [
            [
              567,
              0
            ],
            [
              634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::ProcessPacket",
            "parameters": {
              "fd": "ares_socket_t",
              "addr": "struct sockaddr_storage",
              "addrlen": "ares_socklen_t",
              "data": "byte",
              "len": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void MockServer::ProcessFD(ares_socket_t fd) {\n  if (fd != tcpfd_ && fd != udpfd_ && connfds_.find(fd) == connfds_.end()) {\n    // Not one of our FDs.\n    return;\n  }\n  if (fd == tcpfd_) {\n    ares_socket_t connfd = accept(tcpfd_, NULL, NULL);\n    if (connfd == ARES_SOCKET_BAD) {\n      std::cerr << \"Error accepting connection on fd \" << fd << std::endl;\n    } else {\n      connfds_.insert(connfd);\n    }\n    return;\n  }\n\n  // Activity on a data-bearing file descriptor.\n  struct sockaddr_storage addr;\n  socklen_t addrlen = sizeof(addr);\n  memset(&addr, 0, sizeof(addr));\n  byte buffer[2048];\n  ares_ssize_t len = (ares_ssize_t)recvfrom(fd, BYTE_CAST buffer, sizeof(buffer), 0,\n                     (struct sockaddr *)&addr, &addrlen);\n\n  if (fd != udpfd_) {\n    if (len <= 0) {\n      connfds_.erase(std::find(connfds_.begin(), connfds_.end(), fd));\n      sclose(fd);\n      free(tcp_data_);\n      tcp_data_ = NULL;\n      tcp_data_len_ = 0;\n      return;\n    }\n    tcp_data_ = (unsigned char *)realloc(tcp_data_, tcp_data_len_ + (size_t)len);\n    memcpy(tcp_data_ + tcp_data_len_, buffer, (size_t)len);\n    tcp_data_len_ += (size_t)len;\n\n    /* TCP might aggregate the various requests into a single packet, so we\n     * need to split */\n    while (tcp_data_len_ > 2) {\n      size_t tcplen = ((size_t)tcp_data_[0] << 8) + (size_t)tcp_data_[1];\n      if (tcp_data_len_ - 2 < tcplen)\n        break;\n\n      ProcessPacket(fd, &addr, addrlen, tcp_data_ + 2, (int)tcplen);\n\n      /* strip off processed data if connection not terminated */\n      if (tcp_data_ != NULL) {\n        memmove(tcp_data_, tcp_data_ + tcplen + 2, tcp_data_len_ - 2 - tcplen);\n        tcp_data_len_ -= 2 + tcplen;\n      }\n    }\n  } else {\n    /* UDP is always a single packet */\n    ProcessPacket(fd, &addr, addrlen, buffer, (int)len);\n  }\n\n}",
          "fn_code_pos": [
            [
              636,
              0
            ],
            [
              692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::ProcessFD",
            "parameters": {
              "fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::set<ares_socket_t> MockServer::fds() const {\n  std::set<ares_socket_t> result = connfds_;\n  result.insert(tcpfd_);\n  result.insert(udpfd_);\n  return result;\n}",
          "fn_code_pos": [
            [
              694,
              0
            ],
            [
              699,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::fds",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void MockServer::ProcessRequest(ares_socket_t fd, struct sockaddr_storage* addr,\n                                ares_socklen_t addrlen, const std::vector<byte> &req,\n                                const std::string &reqstr,\n                                int qid, const char *name, int rrtype) {\n\n  /* DNS 0x20 will mix case, do case-insensitive matching of name in request */\n  char lower_name[256];\n  int flags = 0;\n\n  arestest_strtolower(lower_name, name, sizeof(lower_name));\n\n  // Before processing, let gMock know the request is happening.\n  OnRequest(lower_name, rrtype);\n\n  // If we are expecting a specific request then check it matches here.\n  if (expected_request_.length() > 0) {\n    ASSERT_EQ(expected_request_, reqstr);\n  }\n\n  if (reply_ != nullptr) {\n    ares_dns_record_t *dnsrec = NULL;\n    /* We will *attempt* to parse the request string.  It may be malformed that\n     * will lead to a parse failure.  If so, we just ignore it.  We want to\n     * pass this parsed data structure to the reply generator in case it needs\n     * to extract metadata (such as a DNS client cookie) from the original\n     * request.  If we can't parse it, oh well, we'll just pass NULL, most\n     * replies don't need anything from the request other than the name which\n     * is passed separately. */\n    ares_dns_parse(req.data(), req.size(), 0, &dnsrec);\n    exact_reply_ = reply_->data(name, dnsrec);\n    ares_dns_record_destroy(dnsrec);\n  }\n\n  if (exact_reply_.size() == 0) {\n    return;\n  }\n\n  // Make a local copy of the current pending reply.\n  std::vector<byte> reply = exact_reply_;\n\n  if (qid_ >= 0) {\n    // Use the explicitly specified query ID.\n    qid = qid_;\n  }\n  if (reply.size() >=  2) {\n    // Overwrite the query ID if space to do so.\n    reply[0] = (byte)((qid >> 8) & 0xff);\n    reply[1] = (byte)(qid & 0xff);\n  }\n  if (verbose) {\n    std::cerr << \"sending reply \" << PacketToString(reply)\n              << \" on port \" << ((fd == udpfd_) ? udpport_ : tcpport_)\n              << \":\" << getaddrport(addr) << std::endl;\n  }\n\n  // Prefix with 2-byte length if TCP.\n  if (fd != udpfd_) {\n    int len = (int)reply.size();\n    std::vector<byte> vlen = {(byte)((len & 0xFF00) >> 8), (byte)(len & 0xFF)};\n    reply.insert(reply.begin(), vlen.begin(), vlen.end());\n    // Also, don't bother with the destination address.\n    addr = nullptr;\n    addrlen = 0;\n  }\n\n#ifdef MSG_NOSIGNAL\n  flags |= MSG_NOSIGNAL;\n#endif\n\n  ares_ssize_t rc = (ares_ssize_t)sendto(fd, BYTE_CAST reply.data(), (SEND_TYPE_ARG3)reply.size(), flags,\n                                         (struct sockaddr *)addr, addrlen);\n  if (rc < static_cast<ares_ssize_t>(reply.size())) {\n    std::cerr << \"Failed to send full reply, rc=\" << rc << std::endl;\n  }\n\n}",
          "fn_code_pos": [
            [
              701,
              0
            ],
            [
              776,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::ProcessRequest",
            "parameters": {
              "fd": "ares_socket_t",
              "addr": "struct sockaddr_storage",
              "addrlen": "ares_socklen_t",
              "req": "std::vector<byte>",
              "reqstr": "std::string",
              "qid": "int",
              "name": "char",
              "rrtype": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockChannelOptsTest::NiceMockServers MockChannelOptsTest::BuildServers(int count, int family, unsigned short base_port) {\n  NiceMockServers servers;\n  assert(count > 0);\n  for (unsigned short ii = 0; ii < count; ii++) {\n    unsigned short port = base_port == dynamic_port ? dynamic_port : base_port + ii;\n    std::unique_ptr<NiceMockServer> server(new NiceMockServer(family, port));\n    servers.push_back(std::move(server));\n  }\n  return servers;\n}",
          "fn_code_pos": [
            [
              779,
              0
            ],
            [
              788,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::BuildServers",
            "parameters": {
              "count": "int",
              "family": "int",
              "base_port": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockChannelOptsTest::MockChannelOptsTest(int count,\n                                         int family,\n                                         bool force_tcp,\n                                         bool honor_sysconfig,\n                                         struct ares_options* givenopts,\n                                         int optmask)\n  : servers_(BuildServers(count, family, mock_port)),\n    server_(*servers_[0].get()), channel_(nullptr) {\n  // Set up channel options.\n  const char *domains[3] = {\"first.com\", \"second.org\", \"third.gov\"};\n  struct ares_options opts;\n  if (givenopts) {\n    memcpy(&opts, givenopts, sizeof(opts));\n  } else {\n    memset(&opts, 0, sizeof(opts));\n  }\n\n  /* Honor items from resolv.conf except the dns server itself */\n  if (!honor_sysconfig) {\n    if (!(optmask & (ARES_OPT_TIMEOUTMS|ARES_OPT_TIMEOUT))) {\n      // Reduce timeouts significantly to shorten test times.\n      opts.timeout = 250;\n      optmask |= ARES_OPT_TIMEOUTMS;\n    }\n    // If not already overridden, set 3 retries.\n    if (!(optmask & ARES_OPT_TRIES)) {\n      opts.tries = 3;\n      optmask |= ARES_OPT_TRIES;\n    }\n\n    // If not already overridden, set search domains.\n    if (!(optmask & ARES_OPT_DOMAINS)) {\n      opts.ndomains = 3;\n      opts.domains = (char**)domains;\n      optmask |= ARES_OPT_DOMAINS;\n    }\n\n    /* Tests expect ndots=1 in general, the system config may not default to this\n     * so we don't want to inherit that. */\n    if (!(optmask & ARES_OPT_NDOTS)) {\n      opts.ndots = 1;\n      optmask |= ARES_OPT_NDOTS;\n    }\n  }\n\n  if (force_tcp) {\n    opts.flags |= ARES_FLAG_USEVC;\n    optmask |= ARES_OPT_FLAGS;\n  }\n\n  /* Disable the query cache for tests unless explicitly enabled. As of\n   * c-ares 1.31.0, the query cache is enabled by default so we have to set\n   * the option and set the TTL to 0 to effectively disable it. */\n  if (!(optmask & ARES_OPT_QUERY_CACHE)) {\n    opts.qcache_max_ttl = 0;\n    optmask |= ARES_OPT_QUERY_CACHE;\n  }\n\n  /* Enable DNS0x20 by default. Need to also turn on default flag of EDNS */\n  if (!(optmask & ARES_OPT_FLAGS)) {\n    optmask |= ARES_OPT_FLAGS;\n    opts.flags = ARES_FLAG_DNS0x20|ARES_FLAG_EDNS;\n  }\n\n  EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n  EXPECT_NE(nullptr, channel_);\n\n  // Set up servers after construction so we can set individual ports\n  struct ares_addr_port_node* prev = nullptr;\n  struct ares_addr_port_node* first = nullptr;\n  for (const auto& server : servers_) {\n    struct ares_addr_port_node* node = (struct ares_addr_port_node*)malloc(sizeof(*node));\n    if (prev) {\n      prev->next = node;\n    } else {\n      first = node;\n    }\n    node->next = nullptr;\n    node->family = family;\n    node->udp_port = server->udpport();\n    node->tcp_port = server->tcpport();\n    if (family == AF_INET) {\n      node->addr.addr4.s_addr = htonl(0x7F000001);\n    } else {\n      memset(&node->addr.addr6, 0, sizeof(node->addr.addr6));\n      node->addr.addr6._S6_un._S6_u8[15] = 1;\n    }\n    prev = node;\n  }\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports(channel_, first));\n\n  while (first) {\n    prev = first;\n    first = first->next;\n    free(prev);\n  }\n  if (verbose) {\n    std::cerr << \"Configured library with servers:\";\n    std::cerr << GetNameServers(channel_);\n    std::cerr << std::endl;\n  }\n}",
          "fn_code_pos": [
            [
              790,
              0
            ],
            [
              891,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::MockChannelOptsTest",
            "parameters": {
              "count": "int",
              "family": "int",
              "force_tcp": "bool",
              "honor_sysconfig": "bool",
              "givenopts": "struct ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockChannelOptsTest::~MockChannelOptsTest() {\n  if (channel_) {\n    ares_destroy(channel_);\n  }\n  channel_ = nullptr;\n}",
          "fn_code_pos": [
            [
              893,
              0
            ],
            [
              898,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::~MockChannelOptsTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::set<ares_socket_t> MockChannelOptsTest::fds() const {\n  std::set<ares_socket_t> fds;\n  for (const auto& server : servers_) {\n    std::set<ares_socket_t> serverfds = server->fds();\n    fds.insert(serverfds.begin(), serverfds.end());\n  }\n  return fds;\n}",
          "fn_code_pos": [
            [
              900,
              0
            ],
            [
              907,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::fds",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void MockChannelOptsTest::ProcessFD(ares_socket_t fd) {\n  for (auto& server : servers_) {\n    server->ProcessFD(fd);\n  }\n}",
          "fn_code_pos": [
            [
              909,
              0
            ],
            [
              913,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::ProcessFD",
            "parameters": {
              "fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void MockChannelOptsTest::ProcessAltChannel(ares_channel_t *chan, unsigned int cancel_ms) {\n  using namespace std::placeholders;\n  ProcessWork(chan,\n              std::bind(&MockChannelOptsTest::fds, this),\n              std::bind(&MockChannelOptsTest::ProcessFD, this, _1),\n              cancel_ms);\n}",
          "fn_code_pos": [
            [
              915,
              0
            ],
            [
              921,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::ProcessAltChannel",
            "parameters": {
              "chan": "ares_channel_t",
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void MockChannelOptsTest::Process(unsigned int cancel_ms) {\n  ProcessAltChannel(channel_, cancel_ms);\n}",
          "fn_code_pos": [
            [
              923,
              0
            ],
            [
              925,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void MockEventThreadOptsTest::Process(unsigned int cancel_ms) {\n  std::set<ares_socket_t> fds;\n\n  auto tv_begin = std::chrono::high_resolution_clock::now();\n  auto tv_cancel = tv_begin;\n\n  if (cancel_ms) {\n    if (verbose) std::cerr << \"ares_cancel will be called after \" << cancel_ms << \"ms\" << std::endl;\n    tv_cancel += std::chrono::milliseconds(cancel_ms);\n  }\n\n  while (ares_queue_active_queries(channel_)) {\n    //if (verbose) std::cerr << \"pending queries: \" << ares_queue_active_queries(channel_) << std::endl;\n\n    int nfds = 0;\n    fd_set readers;\n\n    struct timeval  tv;\n\n    /* c-ares is using its own event thread, so we only need to monitor the\n     * extrafds passed in */\n    FD_ZERO(&readers);\n    fds = MockEventThreadOptsTest::fds();\n    for (ares_socket_t fd : fds) {\n      FD_SET(fd, &readers);\n      if (fd >= (ares_socket_t)nfds) {\n        nfds = (int)fd + 1;\n      }\n    }\n\n    /* We just always wait 20ms then recheck if we're done. Not doing any\n     * complex signaling. */\n    tv.tv_sec  = 0;\n    tv.tv_usec = 20000;\n\n    if (cancel_ms) {\n      auto tv_now       = std::chrono::high_resolution_clock::now();\n      auto remaining_ms = std::chrono::duration_cast<std::chrono::milliseconds>(tv_cancel - tv_now).count();\n\n      if (remaining_ms <= 0) {\n        if (verbose) std::cerr << \"Issuing ares_cancel()\" << std::endl;\n        ares_cancel(channel_);\n        cancel_ms = 0; /* Disable issuing cancel again */\n      } else {\n        tv.tv_sec = remaining_ms / 1000;\n        tv.tv_usec = (int)(remaining_ms % 1000);\n      }\n    }\n\n    if (select(nfds, &readers, nullptr, nullptr, &tv) < 0) {\n      fprintf(stderr, \"select() failed, errno %d\\n\", errno);\n      return;\n    }\n\n    // Let the provided callback process any activity on the extra FD.\n    for (ares_socket_t fd : fds) {\n      if (FD_ISSET(fd, &readers)) {\n        ProcessFD(fd);\n      }\n    }\n  }\n\n  //if (verbose) std::cerr << \"pending queries at process end: \" << ares_queue_active_queries(channel_) << std::endl;\n}",
          "fn_code_pos": [
            [
              927,
              0
            ],
            [
              990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockEventThreadOptsTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const HostResult& result) {\n  os << '{';\n  if (result.done_) {\n    os << StatusToString(result.status_);\n    if (result.host_.addrtype_ != -1) {\n      os << \" \" << result.host_;\n    } else {\n      os << \", (no hostent)\";\n    }\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              992,
              0
            ],
            [
              1006,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "HostEnt::HostEnt(const struct hostent *hostent) : addrtype_(-1) {\n  if (!hostent)\n    return;\n\n  if (hostent->h_name) {\n    // DNS 0x20 may mix case, output as all lower for checks as the mixed case\n    // is really more of an internal thing\n    char lowername[256];\n    arestest_strtolower(lowername, hostent->h_name, sizeof(lowername));\n    name_ = lowername;\n  }\n\n  if (hostent->h_aliases) {\n    char** palias = hostent->h_aliases;\n    while (*palias != nullptr) {\n      aliases_.push_back(*palias);\n      palias++;\n    }\n  }\n\n  addrtype_ = hostent->h_addrtype;\n\n  if (hostent->h_addr_list) {\n    char** paddr = hostent->h_addr_list;\n    while (*paddr != nullptr) {\n      std::string addr = AddressToString(*paddr, hostent->h_length);\n      addrs_.push_back(addr);\n      paddr++;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              1008,
              0
            ],
            [
              1038,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostEnt::HostEnt",
            "parameters": {
              "hostent": "struct hostent"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const HostEnt& host) {\n  os << \"{'\";\n  if (host.name_.length() > 0) {\n    os << host.name_;\n  }\n  os << \"' aliases=[\";\n  for (size_t ii = 0; ii < host.aliases_.size(); ii++) {\n    if (ii > 0) os << \", \";\n    os << host.aliases_[ii];\n  }\n  os << \"] \";\n  os << \"addrs=[\";\n  for (size_t ii = 0; ii < host.addrs_.size(); ii++) {\n    if (ii > 0) os << \", \";\n    os << host.addrs_[ii];\n  }\n  os << \"]\";\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1040,
              0
            ],
            [
              1059,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void HostCallback(void *data, int status, int timeouts,\n                  struct hostent *hostent) {\n  EXPECT_NE(nullptr, data);\n  if (data == nullptr)\n    return;\n\n  HostResult* result = reinterpret_cast<HostResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_ = timeouts;\n  if (hostent)\n    result->host_ = HostEnt(hostent);\n  if (verbose) std::cerr << \"HostCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1061,
              0
            ],
            [
              1074,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "hostent": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const AresDnsRecord& dnsrec) {\n  os << \"{'\";\n  /* XXX: Todo */\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1076,
              0
            ],
            [
              1081,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const QueryResult& result) {\n  os << '{';\n  if (result.done_) {\n    os << StatusToString(result.status_);\n      if (result.dnsrec_.dnsrec_ != nullptr) {\n        os << \" \" << result.dnsrec_;\n      } else {\n        os << \", (no dnsrec)\";\n      }\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1083,
              0
            ],
            [
              1097,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void QueryCallback(void *data, ares_status_t status, size_t timeouts,\n                   const ares_dns_record_t *dnsrec) {\n  EXPECT_NE(nullptr, data);\n  if (data == nullptr)\n    return;\n\n  QueryResult* result = reinterpret_cast<QueryResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_ = timeouts;\n  if (dnsrec)\n    result->dnsrec_.SetDnsRecord(dnsrec);\n  if (verbose) std::cerr << \"QueryCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1099,
              0
            ],
            [
              1112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QueryCallback",
            "parameters": {
              "data": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const AddrInfoResult& result) {\n  os << '{';\n  if (result.done_ && result.ai_) {\n    os << StatusToString(result.status_) << \" \" << result.ai_;\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1114,
              0
            ],
            [
              1123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const AddrInfo& ai) {\n  os << '{';\n  if (ai == nullptr) {\n    os << \"nullptr}\";\n    return os;\n  }\n\n  struct ares_addrinfo_cname *next_cname = ai->cnames;\n  while(next_cname) {\n    if(next_cname->alias) {\n      os << next_cname->alias << \"->\";\n    }\n    if(next_cname->name) {\n      os << next_cname->name;\n    }\n\n    next_cname = next_cname->next;\n\n    if (next_cname != NULL)\n      os << \", \";\n    else\n      os << \" \";\n  }\n\n  struct ares_addrinfo_node *next = ai->nodes;\n  while(next) {\n    //if(next->ai_canonname) {\n      //os << \"'\" << next->ai_canonname << \"' \";\n    //}\n    unsigned short port = 0;\n    os << \"addr=[\";\n    if(next->ai_family == AF_INET) {\n      sockaddr_in* sin = (sockaddr_in *)((void *)next->ai_addr);\n      port = ntohs(sin->sin_port);\n      os << AddressToString(&sin->sin_addr, 4);\n    }\n    else if (next->ai_family == AF_INET6) {\n      sockaddr_in6* sin = (sockaddr_in6*)((void *)next->ai_addr);\n      port = ntohs(sin->sin6_port);\n      os << \"[\" << AddressToString(&sin->sin6_addr, 16) << \"]\";\n    }\n    else\n      os << \"unknown family\";\n    if(port) {\n      os << \":\" << port;\n    }\n    os << \"]\";\n    next = next->ai_next;\n    if (next != NULL)\n      os << \", \";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1125,
              0
            ],
            [
              1178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void AddrInfoCallback(void *data, int status, int timeouts,\n                      struct ares_addrinfo *ai) {\n  EXPECT_NE(nullptr, data);\n  AddrInfoResult* result = reinterpret_cast<AddrInfoResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_= timeouts;\n  if (ai)\n    result->ai_ = AddrInfo(ai);\n  if (verbose) std::cerr << \"AddrInfoCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1180,
              0
            ],
            [
              1190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddrInfoCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const SearchResult& result) {\n  os << '{';\n  if (result.done_) {\n    os << StatusToString(result.status_) << \" \" << PacketToString(result.data_);\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1192,
              0
            ],
            [
              1201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SearchCallback(void *data, int status, int timeouts,\n                    unsigned char *abuf, int alen) {\n  EXPECT_NE(nullptr, data);\n  SearchResult* result = reinterpret_cast<SearchResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_ = timeouts;\n  result->data_.assign(abuf, abuf + alen);\n  if (verbose) std::cerr << \"SearchCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1203,
              0
            ],
            [
              1212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "abuf": "unsigned char",
              "alen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SearchCallbackDnsRec(void *data, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec) {\n  EXPECT_NE(nullptr, data);\n  SearchResult* result = reinterpret_cast<SearchResult*>(data);\n  unsigned char *abuf = NULL;\n  size_t alen = 0;\n  result->done_ = true;\n  result->status_ = (int)status;\n  result->timeouts_ = (int)timeouts;\n  if (dnsrec != NULL) {\n    ares_dns_write(dnsrec, &abuf, &alen);\n  }\n  result->data_.assign(abuf, abuf + alen);\n  ares_free_string(abuf);\n  if (verbose) std::cerr << \"SearchCallbackDnsRec(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1214,
              0
            ],
            [
              1229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchCallbackDnsRec",
            "parameters": {
              "data": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const NameInfoResult& result) {\n  os << '{';\n  if (result.done_) {\n    os << StatusToString(result.status_) << \" \" << result.node_ << \" \" << result.service_;\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1231,
              0
            ],
            [
              1240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void NameInfoCallback(void *data, int status, int timeouts,\n                      char *node, char *service) {\n  EXPECT_NE(nullptr, data);\n  NameInfoResult* result = reinterpret_cast<NameInfoResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_ = timeouts;\n  result->node_ = std::string(node ? node : \"\");\n  result->service_ = std::string(service ? service : \"\");\n  if (verbose) std::cerr << \"NameInfoCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1242,
              0
            ],
            [
              1252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NameInfoCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "node": "char",
              "service": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::string GetNameServers(ares_channel_t *channel) {\n  char *csv = ares_get_servers_csv(channel);\n  EXPECT_NE((char *)NULL, csv);\n\n  std::string servers(csv);\n\n  ares_free_string(csv);\n  return servers;\n}",
          "fn_code_pos": [
            [
              1254,
              0
            ],
            [
              1262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetNameServers",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientDir::TransientDir(const std::string& dirname) : dirname_(dirname) {\n  if (mkdir_(dirname_.c_str(), 0755) != 0) {\n    std::cerr << \"Failed to create subdirectory '\" << dirname_ << \"'\" << std::endl;\n  }\n}",
          "fn_code_pos": [
            [
              1264,
              0
            ],
            [
              1268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransientDir::TransientDir",
            "parameters": {
              "dirname": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientDir::~TransientDir() {\n  rmdir(dirname_.c_str());\n}",
          "fn_code_pos": [
            [
              1270,
              0
            ],
            [
              1272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransientDir::~TransientDir",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TransientFile::TransientFile(const std::string& filename,\n                             const std::string& contents)\n    : filename_(filename) {\n  FILE *f = fopen(filename.c_str(), \"w\");\n  if (f == nullptr) {\n    std::cerr << \"Error: failed to create '\" << filename << \"'\" << std::endl;\n    return;\n  }\n  size_t rc = (size_t)fwrite(contents.data(), 1, contents.size(), f);\n  if (rc != contents.size()) {\n    std::cerr << \"Error: failed to write contents of '\" << filename << \"'\" << std::endl;\n  }\n  fclose(f);\n}",
          "fn_code_pos": [
            [
              1274,
              0
            ],
            [
              1287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransientFile::TransientFile",
            "parameters": {
              "filename": "std::string",
              "contents": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientFile::~TransientFile() {\n  unlink(filename_.c_str());\n}",
          "fn_code_pos": [
            [
              1289,
              0
            ],
            [
              1291,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransientFile::~TransientFile",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::string TempNam(const char *dir, const char *prefix) {\n  char *p = tempnam(dir, prefix);\n  std::string result(p);\n  free(p);\n  return result;\n}",
          "fn_code_pos": [
            [
              1293,
              0
            ],
            [
              1298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TempNam",
            "parameters": {
              "dir": "char",
              "prefix": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TempFile::TempFile(const std::string& contents)\n  : TransientFile(TempNam(nullptr, \"ares\"), contents) {\n\n}",
          "fn_code_pos": [
            [
              1300,
              0
            ],
            [
              1303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TempFile::TempFile",
            "parameters": {
              "contents": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "VirtualizeIO::VirtualizeIO(ares_channel_t *c)\n  : channel_(c)\n{\n  ares_set_socket_functions(channel_, &default_functions, 0);\n}",
          "fn_code_pos": [
            [
              1305,
              0
            ],
            [
              1309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VirtualizeIO::VirtualizeIO",
            "parameters": {
              "c": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "VirtualizeIO::~VirtualizeIO() {\n  ares_set_socket_functions(channel_, 0, 0);\n}",
          "fn_code_pos": [
            [
              1311,
              0
            ],
            [
              1313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VirtualizeIO::~VirtualizeIO",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LibraryTest::amalloc(size_t size)",
          "fn_dec_pos": [
            [
              404,
              6
            ],
            [
              404,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::amalloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "LibraryTest::arealloc(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              414,
              6
            ],
            [
              414,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::arealloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const HostResult& result)",
          "fn_dec_pos": [
            [
              992,
              14
            ],
            [
              992,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "HostResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const HostEnt& host)",
          "fn_dec_pos": [
            [
              1040,
              14
            ],
            [
              1040,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "host": "HostEnt"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const AresDnsRecord& dnsrec)",
          "fn_dec_pos": [
            [
              1076,
              14
            ],
            [
              1076,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "dnsrec": "AresDnsRecord"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const QueryResult& result)",
          "fn_dec_pos": [
            [
              1083,
              14
            ],
            [
              1083,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "QueryResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const AddrInfoResult& result)",
          "fn_dec_pos": [
            [
              1114,
              14
            ],
            [
              1114,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "AddrInfoResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const AddrInfo& ai)",
          "fn_dec_pos": [
            [
              1125,
              14
            ],
            [
              1125,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "ai": "AddrInfo"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const SearchResult& result)",
          "fn_dec_pos": [
            [
              1192,
              14
            ],
            [
              1192,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "SearchResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const NameInfoResult& result)",
          "fn_dec_pos": [
            [
              1231,
              14
            ],
            [
              1231,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "NameInfoResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "servers(csv)",
          "fn_dec_pos": [
            [
              1258,
              14
            ],
            [
              1258,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "servers",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "result(p)",
          "fn_dec_pos": [
            [
              1295,
              14
            ],
            [
              1295,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "result",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            280,
            4
          ],
          [
            280,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            281,
            4
          ],
          [
            281,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            314,
            8
          ],
          [
            314,
            22
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            348,
            70
          ],
          [
            348,
            82
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            482,
            4
          ],
          [
            482,
            22
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            487,
            30
          ],
          [
            487,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            490,
            30
          ],
          [
            490,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            495,
            41
          ],
          [
            495,
            56
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            502,
            41
          ],
          [
            502,
            56
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            509,
            4
          ],
          [
            509,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            514,
            30
          ],
          [
            514,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            517,
            30
          ],
          [
            517,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            522,
            41
          ],
          [
            522,
            56
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            529,
            41
          ],
          [
            529,
            56
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            555,
            34
          ],
          [
            555,
            57
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            558,
            19
          ],
          [
            558,
            37
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            560,
            19
          ],
          [
            560,
            38
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            567,
            49
          ],
          [
            567,
            72
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            652,
            2
          ],
          [
            652,
            25
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            657,
            22
          ],
          [
            657,
            37
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            701,
            50
          ],
          [
            701,
            73
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            771,
            42
          ],
          [
            771,
            57
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            794,
            41
          ],
          [
            794,
            60
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            800,
            2
          ],
          [
            800,
            21
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            858,
            2
          ],
          [
            858,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            859,
            2
          ],
          [
            859,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            861,
            4
          ],
          [
            861,
            30
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            861,
            40
          ],
          [
            861,
            66
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            944,
            4
          ],
          [
            944,
            18
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            1008,
            23
          ],
          [
            1008,
            37
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            1062,
            18
          ],
          [
            1062,
            32
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            1132,
            2
          ],
          [
            1132,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            1149,
            2
          ],
          [
            1149,
            27
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            1181,
            22
          ],
          [
            1181,
            42
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares-test.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares-test-ai.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_setup.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"str/ares_strsplit.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <netinet/tcp.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <functional>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <algorithm>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include <chrono>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-naptr.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseNaptrReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NAPTR))\n    .add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"))\n    .add_answer(new DNSNaptrRR(\"example.com\", 0x0010,\n                               11, 21, \"SP\", \"service2\", \"regexp2\", \"replace2\"));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_naptr_reply* naptr = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  ASSERT_NE(nullptr, naptr);\n  EXPECT_EQ(\"SP\", std::string((char*)naptr->flags));\n  EXPECT_EQ(\"service\", std::string((char*)naptr->service));\n  EXPECT_EQ(\"regexp\", std::string((char*)naptr->regexp));\n  EXPECT_EQ(\"replace\", std::string((char*)naptr->replacement));\n  EXPECT_EQ(10, naptr->order);\n  EXPECT_EQ(20, naptr->preference);\n\n  struct ares_naptr_reply* naptr2 = naptr->next;\n  ASSERT_NE(nullptr, naptr2);\n  EXPECT_EQ(\"SP\", std::string((char*)naptr2->flags));\n  EXPECT_EQ(\"service2\", std::string((char*)naptr2->service));\n  EXPECT_EQ(\"regexp2\", std::string((char*)naptr2->regexp));\n  EXPECT_EQ(\"replace2\", std::string((char*)naptr2->replacement));\n  EXPECT_EQ(11, naptr2->order);\n  EXPECT_EQ(21, naptr2->preference);\n  EXPECT_EQ(nullptr, naptr2->next);\n\n  ares_free_data(naptr);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNaptrReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NAPTR))\n    .add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"));\n  std::vector<byte> data;\n  struct ares_naptr_reply* naptr = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NAPTR));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_NAPTR));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NAPTR));\n#endif\n\n  // Two questions\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NAPTR));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NAPTR));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  EXPECT_EQ(nullptr, naptr);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  pkt.add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    int rc = ares_parse_naptr_reply(data.data(), (int)len, &naptr);\n    EXPECT_TRUE(rc == ARES_EBADRESP || rc == ARES_EBADNAME);\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_naptr_reply(data.data(), -1, &naptr));\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNaptrReplyTooShort) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x23,  // type NAPTR\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x23,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x01,  // rdata length\n    0x00,  // Too short: expect 2 x int16 and 3 x name (min 1 byte each)\n  };\n  struct ares_naptr_reply* naptr = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNaptrReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NAPTR))\n    .add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"))\n    .add_answer(new DNSNaptrRR(\"example.com\", 0x0010,\n                               11, 21, \"SP\", \"service2\", \"regexp2\", \"replace2\"));\n  std::vector<byte> data = pkt.data();\n  struct ares_naptr_reply* naptr = nullptr;\n\n  for (int ii = 1; ii <= 13; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  }\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            54,
            2
          ],
          [
            54,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            74,
            2
          ],
          [
            74,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            152,
            2
          ],
          [
            152,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            165,
            2
          ],
          [
            165,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-mock.cc": {
      "fn_def_list": [
        {
          "fn_code": "NoDNS0x20MockTest()\n    : MockChannelOptsTest(1, GetParam(), false, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              49,
              44
            ]
          ],
          "class_code": "49d22d9448d8a4a3104fd768c18ff2a306c4c5f409502881a46ba928e1af33d3",
          "class_node_pos": [
            [
              42,
              0
            ],
            [
              57,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "NoDNS0x20MockTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_EDNS;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              50,
              2
            ],
            [
              54,
              3
            ]
          ],
          "class_code": "49d22d9448d8a4a3104fd768c18ff2a306c4c5f409502881a46ba928e1af33d3",
          "class_node_pos": [
            [
              42,
              0
            ],
            [
              57,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoDNS0x20MockTest, Basic) {\n  std::vector<byte> reply = {\n    0x00, 0x00,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // 1 question\n    0x00, 0x01,  // 1 answer RRs\n    0x00, 0x00,  // 0 authority RRs\n    0x00, 0x00,  // 0 additional RRs\n    // Question\n    0x03, 'w', 'w', 'w',\n    0x06, 'g', 'o', 'o', 'g', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer\n    0x03, 'w', 'w', 'w',\n    0x06, 'g', 'o', 'o', 'g', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    0x00, 0x00, 0x01, 0x00,  // TTL\n    0x00, 0x04,  // rdata length\n    0x01, 0x02, 0x03, 0x04\n  };\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, DNS0x20BadReply) {\n  std::vector<byte> reply = {\n    0x00, 0x00,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // 1 question\n    0x00, 0x01,  // 1 answer RRs\n    0x00, 0x00,  // 0 authority RRs\n    0x00, 0x00,  // 0 additional RRs\n    // Question\n    0x03, 'w', 'w', 'w',\n    0x1D, 's', 'o', 'm', 'e', 'l', 'o', 'n', 'g', 'd', 'o', 'm', 'a', 'i', 'n', 'n', 'a', 'm', 'e', 'b', 'e', 'c', 'a', 'u', 's', 'e', 'p', 'r', 'n', 'g',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer\n    0x03, 'w', 'w', 'w',\n    0x1D, 's', 'o', 'm', 'e', 'l', 'o', 'n', 'g', 'd', 'o', 'm', 'a', 'i', 'n', 'n', 'a', 'm', 'e', 'b', 'e', 'c', 'a', 'u', 's', 'e', 'p', 'r', 'n', 'g',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    0x00, 0x00, 0x01, 0x00,  // TTL\n    0x00, 0x04,  // rdata length\n    0x01, 0x02, 0x03, 0x04\n  };\n\n  ON_CALL(server_, OnRequest(\"www.somelongdomainnamebecauseprng.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, reply));\n\n  /* Reply will be thrown out due to mismatched case for DNS 0x20 in response,\n   * its technically possible this test case may not fail if somehow the\n   * PRNG returns all lowercase domain name so we need to make this domain\n   * fairly long to make sure those odds are very very very low */\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.somelongdomainnamebecauseprng.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ETIMEOUT, result.status_);\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp1;\n  rsp1.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp1));\n  DNSPacket rsp2;\n  rsp2.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp2));\n\n  HostResult result1;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result1);\n  HostResult result2;\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result2);\n  HostResult result3;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result3);\n  Process();\n  EXPECT_TRUE(result1.done_);\n  EXPECT_TRUE(result2.done_);\n  EXPECT_TRUE(result3.done_);\n  std::stringstream ss1;\n  ss1 << result1.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n  std::stringstream ss2;\n  ss2 << result2.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[1.2.3.4]}\", ss2.str());\n  std::stringstream ss3;\n  ss3 << result3.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss3.str());\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, TruncationRetry) {\n  DNSPacket rsptruncated;\n  rsptruncated.set_response().set_aa().set_tc()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsptruncated))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, UTF8BadName) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"espa\u00f1a.icom.museum\", T_A))\n    .add_answer(new DNSARR(\"espa\u00f1a.icom.museum\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"espa\u00f1a.icom.museum\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"espa\u00f1a.icom.museum\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EBADNAME, result.status_);\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int SocketConnectCallback(ares_socket_t fd, int type, void *data) {\n  int rc = *(int*)data;\n  (void)type;\n  if (verbose) std::cerr << \"SocketConnectCallback(\" << fd << \") invoked\" << std::endl;\n  sock_cb_count++;\n  return rc;\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SocketConnectCallback",
            "parameters": {
              "fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SockCallback) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n\n  HostResult result;\n  sock_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_EQ(1, sock_cb_count);\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              223,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SockFailCallback) {\n  // Notification of new sockets gives an error.\n  int rc = -1;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n\n  HostResult result;\n  sock_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_LT(1, sock_cb_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECONNREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              246,
              0
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int SocketConfigureCallback(ares_socket_t fd, int type, void *data) {\n  int rc = *(int*)data;\n  (void)type;\n  if (verbose) std::cerr << \"SocketConfigureCallback(\" << fd << \") invoked\" << std::endl;\n  sock_config_cb_count++;\n  return rc;\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SocketConfigureCallback",
            "parameters": {
              "fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SockConfigureCallback) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets\n  int rc = ARES_SUCCESS;\n  ares_set_socket_configure_callback(channel_, SocketConfigureCallback, &rc);\n\n  HostResult result;\n  sock_config_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_EQ(1, sock_config_cb_count);\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SockConfigureFailCallback) {\n  // Notification of new sockets gives an error.\n  int rc = -1;\n  ares_set_socket_configure_callback(channel_, SocketConfigureCallback, &rc);\n\n  HostResult result;\n  sock_config_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_LT(1, sock_config_cb_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECONNREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              292,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static void ServerStateCallback(const char *server_string,\n                                ares_bool_t success, int flags, void *data) {\n  // Increment overall success/failure counts appropriately.\n  if (verbose) std::cerr << \"ServerStateCallback(\"\n                         << server_string << \", \"\n                         << success       << \", \"\n                         << flags         << \") invoked\" << std::endl;\n  if (success == ARES_TRUE) server_state_cb_success_count++;\n  else server_state_cb_failure_count++;\n\n  // Check that the server string is as expected.\n  char *exp_server_string = *(char **)(data);\n  EXPECT_STREQ(exp_server_string, server_string);\n\n  // The callback should be invoked with either the UDP flag or the TCP flag,\n  // but not both.\n  ares_bool_t udp = (flags & ARES_SERV_STATE_UDP) ? ARES_TRUE: ARES_FALSE;\n  ares_bool_t tcp = (flags & ARES_SERV_STATE_TCP) ? ARES_TRUE: ARES_FALSE;\n  EXPECT_NE(udp, tcp);\n}",
          "fn_code_pos": [
            [
              310,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ServerStateCallback",
            "parameters": {
              "server_string": "char",
              "success": "ares_bool_t",
              "flags": "int",
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ServStateCallbackSuccess) {\n  // Set up the server response. The server returns successfully with an answer\n  // to the query.\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Set up the server state callback. The channel used for this test has a\n  // single server configured.\n  char *exp_server_string = ares_get_servers_csv(channel_);\n  ares_set_server_state_callback(channel_, ServerStateCallback,\n                                 &exp_server_string);\n\n  // Perform the hostname lookup. Expect 1 successful query to the server.\n  HostResult result;\n  server_state_cb_success_count = 0;\n  server_state_cb_failure_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback,\n                     &result);\n  Process();\n  EXPECT_EQ(1, server_state_cb_success_count);\n  EXPECT_EQ(0, server_state_cb_failure_count);\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n\n  ares_free_string(exp_server_string);\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ServStateCallbackFailure) {\n  // Set up the server response. The server always returns SERVFAIL.\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Set up the server state callback. The channel used for this test has a\n  // single server configured.\n  char *exp_server_string = ares_get_servers_csv(channel_);\n  ares_set_server_state_callback(channel_, ServerStateCallback,\n                                 &exp_server_string);\n\n  // Perform the hostname lookup. Expect 3 failed queries to the server (due to\n  // retries).\n  HostResult result;\n  server_state_cb_success_count = 0;\n  server_state_cb_failure_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback,\n                     &result);\n  Process();\n  EXPECT_EQ(0, server_state_cb_success_count);\n  EXPECT_EQ(3, server_state_cb_failure_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n\n  ares_free_string(exp_server_string);\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ServStateCallbackRecover) {\n  // Set up the server response. The server initially times out, but then\n  // returns successfully (with NXDOMAIN) on the first retry.\n  std::vector<byte> nothing;\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NXDOMAIN);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Set up the server state callback. The channel used for this test has a\n  // single server configured.\n  char *exp_server_string = ares_get_servers_csv(channel_);\n  ares_set_server_state_callback(channel_, ServerStateCallback,\n                                 &exp_server_string);\n\n  // Perform the hostname lookup. Expect 1 failed query and 1 successful query\n  // to the server.\n  HostResult result;\n  server_state_cb_success_count = 0;\n  server_state_cb_failure_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback,\n                     &result);\n  Process();\n  EXPECT_EQ(1, server_state_cb_success_count);\n  EXPECT_EQ(1, server_state_cb_failure_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n\n  ares_free_string(exp_server_string);\n}",
          "fn_code_pos": [
            [
              395,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ReInit) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  EXPECT_EQ(ARES_SUCCESS, ares_reinit(channel_));\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPMaxQueriesTest()\n    : MockChannelOptsTest(1, GetParam(), false, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES) {}",
          "fn_code_pos": [
            [
              454,
              2
            ],
            [
              457,
              54
            ]
          ],
          "class_code": "ea767858224c190ad7b278358faa0325a631462938236ef7fa704714a1e0c4fb",
          "class_node_pos": [
            [
              450,
              0
            ],
            [
              465,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPMaxQueriesTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->udp_max_queries = MAXUDPQUERIES_LIMIT;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              458,
              2
            ],
            [
              462,
              3
            ]
          ],
          "class_code": "ea767858224c190ad7b278358faa0325a631462938236ef7fa704714a1e0c4fb",
          "class_node_pos": [
            [
              450,
              0
            ],
            [
              465,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPMaxQueriesTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[MAXUDPQUERIES_TOTAL];\n  for (size_t i=0; i<MAXUDPQUERIES_TOTAL; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(MAXUDPQUERIES_TOTAL / MAXUDPQUERIES_LIMIT, sock_cb_count);\n\n  for (size_t i=0; i<MAXUDPQUERIES_TOTAL; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              467,
              0
            ],
            [
              495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CacheQueriesTest()\n    : MockChannelOptsTest(1, GetParam(), false, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_QUERY_CACHE) {}",
          "fn_code_pos": [
            [
              501,
              2
            ],
            [
              504,
              50
            ]
          ],
          "class_code": "3335d0964ca60c45952e017df71e6241ed132e5a6cadab397ed25543df3a2a98",
          "class_node_pos": [
            [
              497,
              0
            ],
            [
              512,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CacheQueriesTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->qcache_max_ttl = 3600;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              505,
              2
            ],
            [
              509,
              3
            ]
          ],
          "class_code": "3335d0964ca60c45952e017df71e6241ed132e5a6cadab397ed25543df3a2a98",
          "class_node_pos": [
            [
              497,
              0
            ],
            [
              512,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CacheQueriesTest, GetHostByNameCache) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result1;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result1);\n  Process();\n\n  std::stringstream ss1;\n  EXPECT_TRUE(result1.done_);\n  ss1 << result1.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n\n  /* Run again, should return cached result */\n  HostResult result2;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result2);\n  Process();\n\n  std::stringstream ss2;\n  EXPECT_TRUE(result2.done_);\n  ss2 << result2.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss2.str());\n\n  EXPECT_EQ(1, sock_cb_count);\n}",
          "fn_code_pos": [
            [
              514,
              0
            ],
            [
              547,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[TCPPARALLELLOOKUPS];\n  for (size_t i=0; i<TCPPARALLELLOOKUPS; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(1, sock_cb_count);\n\n  for (size_t i=0; i<TCPPARALLELLOOKUPS; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              550,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, MalformedResponse) {\n  std::vector<byte> one = {0x00};\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, one));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EBADRESP, result.status_);\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              590,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, FormErrResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(FORMERR);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFORMERR, result.status_);\n}",
          "fn_code_pos": [
            [
              592,
              0
            ],
            [
              604,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              606,
              0
            ],
            [
              618,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              620,
              0
            ],
            [
              632,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              634,
              0
            ],
            [
              646,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, YXDomainResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(YXDOMAIN);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              648,
              0
            ],
            [
              660,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsTest()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}",
          "fn_code_pos": [
            [
              666,
              2
            ],
            [
              669,
              71
            ]
          ],
          "class_code": "45a4604120c25c8bdfa969dcbc4c5fa08ed77ce94faedf7972410f6e40fab0e7",
          "class_node_pos": [
            [
              662,
              0
            ],
            [
              679,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              670,
              2
            ],
            [
              676,
              3
            ]
          ],
          "class_code": "45a4604120c25c8bdfa969dcbc4c5fa08ed77ce94faedf7972410f6e40fab0e7",
          "class_node_pos": [
            [
              662,
              0
            ],
            [
              679,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsTest, SimpleQuery) {\n  ares_set_local_ip4(channel_, 0x7F000001);\n  byte addr6[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              681,
              0
            ],
            [
              702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockFlagsChannelOptsTest(int flags)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              708,
              2
            ],
            [
              710,
              72
            ]
          ],
          "class_code": "8d1264bb9ce689dbe9c01453a9f88395362edf051ba45e61d544cb8f905f9767",
          "class_node_pos": [
            [
              704,
              0
            ],
            [
              718,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockFlagsChannelOptsTest",
            "parameters": {
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              711,
              2
            ],
            [
              715,
              3
            ]
          ],
          "class_code": "8d1264bb9ce689dbe9c01453a9f88395362edf051ba45e61d544cb8f905f9767",
          "class_node_pos": [
            [
              704,
              0
            ],
            [
              718,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockNoCheckRespChannelTest() : MockFlagsChannelOptsTest(ARES_FLAG_NOCHECKRESP) {}",
          "fn_code_pos": [
            [
              722,
              2
            ],
            [
              722,
              83
            ]
          ],
          "class_code": "e4acaa4e65fb26b4a2f5446e475cd09090d789045f1f025ba5402c4f3efeef4c",
          "class_node_pos": [
            [
              720,
              0
            ],
            [
              723,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockNoCheckRespChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTest, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              725,
              0
            ],
            [
              737,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTest, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              739,
              0
            ],
            [
              751,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTest, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              753,
              0
            ],
            [
              765,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockEDNSChannelTest() : MockFlagsChannelOptsTest(ARES_FLAG_EDNS) {}",
          "fn_code_pos": [
            [
              769,
              2
            ],
            [
              769,
              69
            ]
          ],
          "class_code": "578e1e23b823c1565296c9cb13adf8dabc2015436f4fc8d77a7b2a8e6f151add",
          "class_node_pos": [
            [
              767,
              0
            ],
            [
              770,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEDNSChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEDNSChannelTest, RetryWithoutEDNS) {\n  DNSPacket rspfail;\n  rspfail.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rspfail))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              772,
              0
            ],
            [
              790,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, RetryWithoutEDNSNonCompliant) {\n  DNSPacket rspfail;\n  rspfail.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, { }, false));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rspfail))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              794,
              0
            ],
            [
              813,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchDomains) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              815,
              0
            ],
            [
              840,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ContainedMockChannelSysConfig()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, true, nullptr, 0) {}",
          "fn_code_pos": [
            [
              848,
              2
            ],
            [
              849,
              86
            ]
          ],
          "class_code": "9974153922f31fa4380bfc281c6ef59b692c52dc52474286e889feabd0080257",
          "class_node_pos": [
            [
              844,
              0
            ],
            [
              850,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ContainedMockChannelSysConfig",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CacheQueriesTest, BlankName) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\".\", T_SOA))\n    .add_answer(new DNSSoaRR(\".\", 600, \"a.root-servers.net\", \"nstld.verisign-grs.com\", 123456, 3600, 3600, 3600, 3600));\n  EXPECT_CALL(server_, OnRequest(\"\", T_SOA))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  QueryResult result;\n  ares_query_dnsrec(channel_, \".\", ARES_CLASS_IN, ARES_REC_TYPE_SOA, QueryCallback, &result, NULL);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n\n  QueryResult cacheresult;\n  ares_query_dnsrec(channel_, \".\", ARES_CLASS_IN, ARES_REC_TYPE_SOA, QueryCallback, &cacheresult, NULL);\n  Process();\n  EXPECT_TRUE(cacheresult.done_);\n  EXPECT_EQ(0, cacheresult.timeouts_);\n}",
          "fn_code_pos": [
            [
              905,
              0
            ],
            [
              924,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CacheQueriesTest, SearchDomainsCache) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_auth(new DNSSoaRR(\"first.com\", 600, \"ns1.first.com\", \"admin.first.com\", 123456, 3600, 3600, 3600, 3600));\n  EXPECT_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A))\n    .add_auth(new DNSSoaRR(\"second.org\", 600, \"ns1.second.org\", \"admin.second.org\", 123456, 3600, 3600, 3600, 3600));\n  EXPECT_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillOnce(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillOnce(SetReply(&server_, &yesthird));\n\n  // First pass through should send the queries.  The EXPECT_CALL .WillOnce\n  // will make sure this only happens once (vs ON_CALL .WillByDefault)\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n\n  // This pass should be fully served by cache and yield the same result\n  HostResult cacheresult;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &cacheresult);\n  Process();\n  EXPECT_TRUE(cacheresult.done_);\n  std::stringstream sscache;\n  sscache << cacheresult.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", sscache.str());\n}",
          "fn_code_pos": [
            [
              926,
              0
            ],
            [
              964,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, SearchDomainsWithResentReply) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillOnce(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  // Before sending the real answer, resend an earlier reply\n  EXPECT_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillOnce(DoAll(SetReply(&server_, &nofirst),\n                    SetReplyQID(&server_, 123)))\n    .WillOnce(DoAll(SetReply(&server_, &yesthird),\n                    SetReplyQID(&server_, -1)));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              967,
              0
            ],
            [
              996,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchDomainsBare) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket yesbare;\n  yesbare.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www\", T_A))\n    .add_answer(new DNSARR(\"www\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &yesbare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              998,
              0
            ],
            [
              1030,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchNoDataThenSuccess) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1032,
              0
            ],
            [
              1058,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchNoDataThenNoDataBare) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket nobare;\n  nobare.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www\", T_A));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              1060,
              0
            ],
            [
              1088,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchNoDataThenFail) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket nobare;\n  nobare.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www\", T_A));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              1090,
              0
            ],
            [
              1118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchAllocFailure) {\n  SearchResult result;\n  SetAllocFail(1);\n  ares_search(channel_, \"fully.qualified.\", C_IN, T_A, SearchCallback, &result);\n  /* Already done */\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOMEM, result.status_);\n}",
          "fn_code_pos": [
            [
              1120,
              0
            ],
            [
              1127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchHighNdots) {\n  DNSPacket nobare;\n  nobare.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"a.b.c.w.w.w\", T_A));\n  ON_CALL(server_, OnRequest(\"a.b.c.w.w.w\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"a.b.c.w.w.w.first.com\", T_A))\n    .add_answer(new DNSARR(\"a.b.c.w.w.w.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"a.b.c.w.w.w.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  SearchResult result;\n  ares_search(channel_, \"a.b.c.w.w.w\", C_IN, T_A, SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << PacketToString(result.data_);\n  EXPECT_EQ(\"RSP QRY AA NOERROR Q:{'a.b.c.w.w.w.first.com' IN A} \"\n            \"A:{'a.b.c.w.w.w.first.com' IN A TTL=512 2.3.4.5}\",\n            ss.str());\n}",
          "fn_code_pos": [
            [
              1129,
              0
            ],
            [
              1152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, SearchOptVal) {\n  /* Define the OPT RR options code and value to use. */\n  unsigned short opt_opt = 3;\n  unsigned char opt_val[] = { 'c', '-', 'a', 'r', 'e', 's' };\n\n  /* Set up the expected request and reply on the mock server for the first,\n   * second and third domains. The expected requests contain the OPT RR options\n   * value defined above.\n   */\n  std::string nofirst_req = \"REQ QRY RD  Q:{'example.first.com' IN A} \"\n    \"ADD:{'' MAXUDP=1232 OPT RCODE2=0 \"\n    \"0003\"  // opt_opt\n    \"0006\"  // length of opt_val\n    \"632d61726573\"  // opt_val in hex\n    \"}\";\n  DNSPacket nofirst_rep;\n  nofirst_rep.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"example.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.first.com\", T_A))\n    .WillByDefault(SetReplyExpRequest(&server_, &nofirst_rep, nofirst_req));\n\n  std::string nosecond_req = \"REQ QRY RD  Q:{'example.second.org' IN A} \"\n    \"ADD:{'' MAXUDP=1232 OPT RCODE2=0 \"\n    \"0003\"  // opt_opt\n    \"0006\"  // length of opt_val\n    \"632d61726573\"  // opt_val in hex\n    \"}\";\n  DNSPacket nosecond_rep;\n  nosecond_rep.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"example.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"example.second.org\", T_A))\n    .WillByDefault(SetReplyExpRequest(&server_, &nosecond_rep, nosecond_req));\n\n  std::string nothird_req = \"REQ QRY RD  Q:{'example.third.gov' IN A} \"\n    \"ADD:{'' MAXUDP=1232 OPT RCODE2=0 \"\n    \"0003\"  // opt_opt\n    \"0006\"  // length of opt_val\n    \"632d61726573\"  // opt_val in hex\n    \"}\";\n  DNSPacket nothird_rep;\n  nothird_rep.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"example.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"example.third.gov\", T_A))\n    .WillByDefault(SetReplyExpRequest(&server_, &nothird_rep, nothird_req));\n\n  /* Set up the expected request and reply on the mock server for the bare\n   * domain. The expected request contains the OPT RR options value defined\n   * above.\n   */\n  std::string yesbare_req = \"REQ QRY RD  Q:{'example' IN A} \"\n    \"ADD:{'' MAXUDP=1232 OPT RCODE2=0 \"\n    \"0003\"  // opt_opt\n    \"0006\"  // length of opt_val\n    \"632d61726573\"  // opt_val in hex\n    \"}\";\n  DNSPacket yesbare_rep;\n  yesbare_rep.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example\", T_A))\n    .add_answer(new DNSARR(\"example\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example\", T_A))\n    .WillByDefault(SetReplyExpRequest(&server_, &yesbare_rep, yesbare_req));\n\n  /* Construct the DNS record to search. */\n  ares_dns_record_t *dnsrec = NULL;\n  ares_dns_rr_t *rr = NULL;\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_create(&dnsrec, 0, ARES_FLAG_RD, ARES_OPCODE_QUERY,\n      ARES_RCODE_NOERROR));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_query_add(dnsrec, \"example\", (ares_dns_rec_type_t)T_A,\n      (ares_dns_class_t)C_IN));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n      ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE, 1232));\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0));\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_OPT_OPTIONS, opt_opt, opt_val,\n      sizeof(opt_val)));\n\n  /* Perform the search. Check that it succeeds with the expected response. */\n  SearchResult result;\n  ares_search_dnsrec(channel_, dnsrec, SearchCallbackDnsRec, &result);\n  ares_dns_record_destroy(dnsrec);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << PacketToString(result.data_);\n  EXPECT_EQ(\"RSP QRY AA NOERROR Q:{'example' IN A} \"\n            \"A:{'example' IN A TTL=512 2.3.4.5}\",\n            ss.str());\n}",
          "fn_code_pos": [
            [
              1158,
              0
            ],
            [
              1252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, V4WorksV6Timeout) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1254,
              0
            ],
            [
              1275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, PartialQueryCancel) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result);\n  // After 100ms, issues ares_cancel(), this should be enough time for the A\n  // record reply, but before the timeout on the AAAA record.\n  Process(100);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n}",
          "fn_code_pos": [
            [
              1278,
              0
            ],
            [
              1298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, UnspecifiedFamilyV6) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  // Default to IPv6 when both are available.\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2121:0000:0000:0000:0000:0000:0000:0303]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1300,
              0
            ],
            [
              1324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, UnspecifiedFamilyV4) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1326,
              0
            ],
            [
              1346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, UnspecifiedFamilyNoData) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 100, \"elsewhere.com\"));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'' aliases=[] addrs=[]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1348,
              0
            ],
            [
              1368,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, UnspecifiedFamilyCname6A4) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 100, \"elsewhere.com\"));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1370,
              0
            ],
            [
              1391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ExplicitIP) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"1.2.3.4\", AF_INET, HostCallback, &result);\n  EXPECT_TRUE(result.done_);  // Immediate return\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'1.2.3.4' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1393,
              0
            ],
            [
              1401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ExplicitIPAllocFail) {\n  HostResult result;\n  SetAllocSizeFail(strlen(\"1.2.3.4\") + 1);\n  ares_gethostbyname(channel_, \"1.2.3.4\", AF_INET, HostCallback, &result);\n  EXPECT_TRUE(result.done_);  // Immediate return\n  EXPECT_EQ(ARES_ENOMEM, result.status_);\n}",
          "fn_code_pos": [
            [
              1403,
              0
            ],
            [
              1409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SortListV4) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {22, 23, 24, 25}))\n    .add_answer(new DNSARR(\"example.com\", 100, {12, 13, 14, 15}))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"12.13.0.0/255.255.0.0 1234::5678\"));\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[12.13.14.15, 22.23.24.25, 2.3.4.5]}\", ss.str());\n  }\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"2.3.0.0/16 130.140.150.160/26\"));\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5, 22.23.24.25, 12.13.14.15]}\", ss.str());\n  }\n  struct ares_options options;\n  memset(&options, 0, sizeof(options));\n  int optmask = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &options, &optmask));\n  EXPECT_TRUE((optmask & ARES_OPT_SORTLIST) == ARES_OPT_SORTLIST);\n  ares_destroy_options(&options);\n}",
          "fn_code_pos": [
            [
              1411,
              0
            ],
            [
              1447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SortListV6) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02}))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  {\n    ares_set_sortlist(channel_, \"1111::/16 2.3.0.0/255.255.0.0\");\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET6, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[1111:0000:0000:0000:0000:0000:0000:0202, \"\n              \"2121:0000:0000:0000:0000:0000:0000:0303]}\", ss.str());\n  }\n  {\n    ares_set_sortlist(channel_, \"2121::/8\");\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET6, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2121:0000:0000:0000:0000:0000:0000:0303, \"\n              \"1111:0000:0000:0000:0000:0000:0000:0202]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              1449,
              0
            ],
            [
              1484,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, SearchDomainsAllocFail) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  // Fail a variety of different memory allocations, and confirm\n  // that the operation either fails with ENOMEM or succeeds\n  // with the expected result.\n  const int kCount = 34;\n  HostResult results[kCount];\n  for (int ii = 1; ii <= kCount; ii++) {\n    HostResult* result = &(results[ii - 1]);\n    ClearFails();\n    SetAllocFail(ii);\n    ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, result);\n    Process();\n    EXPECT_TRUE(result->done_);\n    if (result->status_ == ARES_SUCCESS) {\n      std::stringstream ss;\n      ss << result->host_;\n      EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str()) << \" failed alloc #\" << ii;\n      if (verbose) std::cerr << \"Succeeded despite failure of alloc #\" << ii << std::endl;\n    }\n  }\n\n  // Explicitly destroy the channel now, so that the HostResult objects\n  // are still valid (in case any pending work refers to them).\n  ares_destroy(channel_);\n  channel_ = nullptr;\n}",
          "fn_code_pos": [
            [
              1487,
              0
            ],
            [
              1529,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, Resend) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(2, result.timeouts_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1532,
              0
            ],
            [
              1552,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, CancelImmediate) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  ares_cancel(channel_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1554,
              0
            ],
            [
              1561,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, CancelImmediateGetHostByAddr) {\n  HostResult result;\n  struct in_addr addr;\n  addr.s_addr = htonl(0x08080808);\n\n  ares_gethostbyaddr(channel_, &addr, sizeof(addr), AF_INET, HostCallback, &result);\n  ares_cancel(channel_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1563,
              0
            ],
            [
              1573,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, CancelLater) {\n  std::vector<byte> nothing;\n\n  // On second request, cancel the channel.\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(CancelChannel(&server_, channel_));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1576,
              0
            ],
            [
              1590,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, DisconnectFirstAttempt) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  // On second request, cancel the channel.\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(Disconnect(&server_))\n    .WillOnce(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1592,
              0
            ],
            [
              1610,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, GetHostByNameDestroyAbsolute) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n\n  ares_destroy(channel_);\n  channel_ = nullptr;\n\n  EXPECT_TRUE(result.done_);  // Synchronous\n  EXPECT_EQ(ARES_EDESTRUCTION, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1612,
              0
            ],
            [
              1622,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, GetHostByNameDestroyRelative) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n\n  ares_destroy(channel_);\n  channel_ = nullptr;\n\n  EXPECT_TRUE(result.done_);  // Synchronous\n  EXPECT_EQ(ARES_EDESTRUCTION, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1624,
              0
            ],
            [
              1634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, GetHostByNameCNAMENoData) {\n  DNSPacket response;\n  response.set_response().set_aa()\n    .add_question(new DNSQuestion(\"cname.first.com\", T_A))\n    .add_answer(new DNSCnameRR(\"cname.first.com\", 100, \"a.first.com\"));\n  ON_CALL(server_, OnRequest(\"cname.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &response));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"cname.first.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              1636,
              0
            ],
            [
              1649,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, GetHostByAddrDestroy) {\n  unsigned char gdns_addr4[4] = {0x08, 0x08, 0x08, 0x08};\n  HostResult result;\n  ares_gethostbyaddr(channel_, gdns_addr4, sizeof(gdns_addr4), AF_INET, HostCallback, &result);\n\n  ares_destroy(channel_);\n  channel_ = nullptr;\n\n  EXPECT_TRUE(result.done_);  // Synchronous\n  EXPECT_EQ(ARES_EDESTRUCTION, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1651,
              0
            ],
            [
              1662,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, TriggerResendThenConnFailSERVFAIL) {\n  // Set up the server response. The server always returns SERVFAIL.\n  DNSPacket badrsp;\n  badrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket goodrsp;\n  goodrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyAndFailSend(&server_, &badrsp))\n    .WillOnce(SetReply(&server_, &goodrsp));\n\n  ares_socket_functions sock_funcs;\n  memset(&sock_funcs, 0, sizeof(sock_funcs));\n\n  sock_funcs.asendv = ares_sendv_fail;\n\n  ares_set_socket_functions(channel_, &sock_funcs, NULL);\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback,\n                     &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1664,
              0
            ],
            [
              1692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, TriggerResendThenConnFailEDNS) {\n  // Set up the server response to simulate an EDNS failure\n  DNSPacket badrsp;\n  badrsp.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket goodrsp;\n  goodrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyAndFailSend(&server_, &badrsp))\n    .WillOnce(SetReply(&server_, &goodrsp));\n\n  ares_socket_functions sock_funcs;\n  memset(&sock_funcs, 0, sizeof(sock_funcs));\n\n  sock_funcs.asendv = ares_sendv_fail;\n\n  ares_set_socket_functions(channel_, &sock_funcs, NULL);\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback,\n                     &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1694,
              0
            ],
            [
              1722,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, GetSock) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ares_socket_t socks[3] = {ARES_SOCKET_BAD, ARES_SOCKET_BAD, ARES_SOCKET_BAD};\n  int bitmask;\n\n  bitmask = ares_getsock(channel_, socks, 3);\n  EXPECT_EQ(0, bitmask);\n  bitmask = ares_getsock(channel_, nullptr, 0);\n  EXPECT_EQ(0, bitmask);\n\n  // Ask again with a pending query.\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  bitmask = ares_getsock(channel_, socks, 3);\n  EXPECT_NE(0, bitmask);\n\n  size_t sock_cnt = 0;\n  for (size_t i=0; i<3; i++) {\n    if (ARES_GETSOCK_READABLE(bitmask, i) || ARES_GETSOCK_WRITABLE(bitmask, i)) {\n      EXPECT_NE(ARES_SOCKET_BAD, socks[i]);\n      if (socks[i] != ARES_SOCKET_BAD)\n        sock_cnt++;\n    }\n  }\n  EXPECT_NE((size_t)0, sock_cnt);\n\n  Process();\n\n  bitmask = ares_getsock(channel_, nullptr, 0);\n  EXPECT_EQ(0, bitmask);\n}",
          "fn_code_pos": [
            [
              1724,
              0
            ],
            [
              1760,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, GetSock) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ares_socket_t socks[3] = {ARES_SOCKET_BAD, ARES_SOCKET_BAD, ARES_SOCKET_BAD};\n  int bitmask;\n\n  bitmask = ares_getsock(channel_, socks, 3);\n  EXPECT_EQ(0, bitmask);\n  bitmask = ares_getsock(channel_, nullptr, 0);\n  EXPECT_EQ(0, bitmask);\n\n  // Ask again with a pending query.\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  bitmask = ares_getsock(channel_, socks, 3);\n  EXPECT_NE(0, bitmask);\n\n  size_t sock_cnt = 0;\n  for (size_t i=0; i<3; i++) {\n    if (ARES_GETSOCK_READABLE(bitmask, i) || ARES_GETSOCK_WRITABLE(bitmask, i)) {\n      EXPECT_NE(ARES_SOCKET_BAD, socks[i]);\n      if (socks[i] != ARES_SOCKET_BAD)\n        sock_cnt++;\n    }\n  }\n  EXPECT_NE((size_t)0, sock_cnt);\n\n  Process();\n\n  bitmask = ares_getsock(channel_, nullptr, 0);\n  EXPECT_EQ(0, bitmask);\n}",
          "fn_code_pos": [
            [
              1762,
              0
            ],
            [
              1798,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, VerifySocketFunctionCallback) {\n  ares_socket_functions sock_funcs;\n  memset(&sock_funcs, 0, sizeof(sock_funcs));\n\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  size_t count = 0;\n\n  sock_funcs.asocket = [](int af, int type, int protocol, void * p) -> ares_socket_t {\n    EXPECT_NE(nullptr, p);\n    (*reinterpret_cast<size_t *>(p))++;\n    return ::socket(af, type, protocol);\n  };\n\n  ares_set_socket_functions(channel_, &sock_funcs, &count);\n\n  {\n    count = 0;\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n    Process();\n\n    EXPECT_TRUE(result.done_);\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(0, result.timeouts_);\n    EXPECT_NE((size_t)0, count);\n  }\n\n  {\n    count = 0;\n    ares_channel_t *copy;\n    EXPECT_EQ(ARES_SUCCESS, ares_dup(&copy, channel_));\n\n    HostResult result;\n    ares_gethostbyname(copy, \"www.google.com.\", AF_INET, HostCallback, &result);\n\n    ProcessAltChannel(copy);\n\n    EXPECT_TRUE(result.done_);\n    ares_destroy(copy);\n    EXPECT_NE((size_t)0, count);\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(0, result.timeouts_);\n  }\n\n}",
          "fn_code_pos": [
            [
              1801,
              0
            ],
            [
              1851,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static const unsigned char *\n  fetch_server_cookie(const ares_dns_record_t *dnsrec, size_t *len)\n{\n  const ares_dns_rr_t *rr  = fetch_rr_opt(dnsrec);\n  const unsigned char *val = NULL;\n  *len                     = 0;\n\n  if (rr == NULL) {\n    return NULL;\n  }\n\n  if (!ares_dns_rr_get_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE,\n                                &val, len)) {\n    return NULL;\n  }\n\n  if (*len <= 8) {\n    *len = 0;\n    return NULL;\n  }\n\n  *len -= 8;\n  val  += 8;\n  return val;\n}",
          "fn_code_pos": [
            [
              1853,
              0
            ],
            [
              1877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fetch_server_cookie",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const unsigned char *\n  fetch_client_cookie(const ares_dns_record_t *dnsrec, size_t *len)\n{\n  const ares_dns_rr_t *rr  = fetch_rr_opt(dnsrec);\n  const unsigned char *val = NULL;\n  *len                     = 0;\n\n  if (rr == NULL) {\n    return NULL;\n  }\n\n  if (!ares_dns_rr_get_opt_byid(rr, ARES_RR_OPT_OPTIONS, ARES_OPT_PARAM_COOKIE,\n                                &val, len)) {\n    return NULL;\n  }\n\n  if (*len < 8) {\n    *len = 0;\n    return NULL;\n  }\n\n  *len = 8;\n  return val;\n}",
          "fn_code_pos": [
            [
              1879,
              0
            ],
            [
              1902,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fetch_client_cookie",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, DNSCookieSingle) {\n  DNSPacket reply;\n  std::vector<byte> server_cookie = { 1, 2, 3, 4, 5, 6, 7, 8 };\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, server_cookie, false));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &reply));\n\n  QueryResult result;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result, NULL);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n\n  size_t len;\n  const unsigned char *returned_cookie = fetch_server_cookie(result.dnsrec_.dnsrec_, &len);\n  EXPECT_EQ(len, server_cookie.size());\n  EXPECT_TRUE(memcmp(server_cookie.data(), returned_cookie, len) == 0);\n}",
          "fn_code_pos": [
            [
              1904,
              0
            ],
            [
              1924,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, DNSCookieMissingAfterGood) {\n  std::vector<byte> server_cookie = { 1, 2, 3, 4, 5, 6, 7, 8 };\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, server_cookie, false));\n  DNSPacket reply_nocookie;\n  reply_nocookie.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, { }, false));\n  DNSPacket reply_ensurecookie;\n  reply_ensurecookie.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, server_cookie, true));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &reply))\n    .WillOnce(SetReply(&server_, &reply_nocookie))\n    .WillOnce(SetReply(&server_, &reply_ensurecookie));\n\n  /* This test will establish the server supports cookies, then the next reply\n   * will be missing the server cookie and therefore be rejected and timeout, then\n   * an internal retry will occur and the cookie will be present again and it\n   * will be verified a server cookie was actually present that matches the\n   * server cookie. */\n  QueryResult result1;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result1, NULL);\n  Process();\n  EXPECT_TRUE(result1.done_);\n  EXPECT_EQ(0, result1.timeouts_);\n\n  QueryResult result2;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result2, NULL);\n  Process();\n  EXPECT_TRUE(result2.done_);\n  EXPECT_EQ(1, result2.timeouts_);\n\n  /* Client cookie should NOT have rotated */\n  size_t len1;\n  const unsigned char *client_cookie_1 = fetch_client_cookie(result1.dnsrec_.dnsrec_, &len1);\n  size_t len2;\n  const unsigned char *client_cookie_2 = fetch_client_cookie(result2.dnsrec_.dnsrec_, &len2);\n  EXPECT_EQ(len1, 8);\n  EXPECT_EQ(len1, len2);\n  EXPECT_TRUE(memcmp(client_cookie_1, client_cookie_2, len1) == 0);\n}",
          "fn_code_pos": [
            [
              1926,
              0
            ],
            [
              1974,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, DNSCookieBadLen) {\n  std::vector<byte> server_cookie = { 1, 2, 3, 4, 5, 6, 7, 8 };\n  std::vector<byte> server_cookie_bad = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0 };\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, server_cookie, false));\n  DNSPacket reply_badcookielen;\n  reply_badcookielen.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, server_cookie_bad, false));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &reply_badcookielen))\n    .WillOnce(SetReply(&server_, &reply));\n\n  /* This test will send back a malformed cookie len, then when it times out and retry occurs will send back a valid cookie. */\n  QueryResult result1;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result1, NULL);\n  Process();\n  EXPECT_TRUE(result1.done_);\n  EXPECT_EQ(1, result1.timeouts_);\n}",
          "fn_code_pos": [
            [
              1977,
              0
            ],
            [
              2001,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, DNSCookieServerRotate) {\n  std::vector<byte> server_cookie = { 1, 2, 3, 4, 5, 6, 7, 8 };\n  std::vector<byte> server_cookie_rotate = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF };\n\n  DNSPacket reply_cookie1;\n  reply_cookie1.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, {}, server_cookie, false));\n  DNSPacket reply_cookie2_badcookie;\n  reply_cookie2_badcookie.set_response().set_aa().set_rcode(ARES_RCODE_BADCOOKIE & 0xF)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR((ARES_RCODE_BADCOOKIE >> 4) & 0xFF, 0, 0, 1280, { }, server_cookie_rotate, false));\n  DNSPacket reply_cookie2;\n  reply_cookie2.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, server_cookie_rotate, true));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &reply_cookie1))\n    .WillOnce(SetReply(&server_, &reply_cookie2_badcookie))\n    .WillOnce(SetReply(&server_, &reply_cookie2));\n\n  /* This test will establish the server supports cookies, then the next reply\n   * the server returns BADCOOKIE indicating the cookie has rotated and\n   * returns a new cookie. Then the query will be automatically retried with\n   * the newly returned cookie. No timeouts should be indicated, and the\n   * client cookie should not rotate. */\n  QueryResult result1;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result1, NULL);\n  Process();\n  EXPECT_TRUE(result1.done_);\n  EXPECT_EQ(0, result1.timeouts_);\n\n  QueryResult result2;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result2, NULL);\n  Process();\n  EXPECT_TRUE(result2.done_);\n  EXPECT_EQ(0, result2.timeouts_);\n\n  /* Client cookie should NOT have rotated */\n  size_t len1;\n  const unsigned char *client_cookie_1 = fetch_client_cookie(result1.dnsrec_.dnsrec_, &len1);\n  size_t len2;\n  const unsigned char *client_cookie_2 = fetch_client_cookie(result2.dnsrec_.dnsrec_, &len2);\n  EXPECT_EQ(len1, 8);\n  EXPECT_EQ(len1, len2);\n  EXPECT_TRUE(memcmp(client_cookie_1, client_cookie_2, len1) == 0);\n}",
          "fn_code_pos": [
            [
              2004,
              0
            ],
            [
              2054,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, DNSCookieSpoof) {\n  std::vector<byte> client_cookie = { 1, 2, 3, 4, 5, 6, 7, 8 };\n  std::vector<byte> server_cookie = { 1, 2, 3, 4, 5, 6, 7, 8 };\n\n  DNSPacket reply_spoof;\n  reply_spoof.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, client_cookie, server_cookie, false));\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, server_cookie, false));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &reply_spoof))\n    .WillOnce(SetReply(&server_, &reply));\n\n  /* This test will return a reply that doesn't have the same client cookie as\n   * was sent, this should result in a drop of the packet alltogether, then\n   * the library will retry and a proper result will be sent. */\n  QueryResult result;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result, NULL);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              2056,
              0
            ],
            [
              2083,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, DNSCookieTCPUpgrade) {\n  std::vector<byte> server_cookie = { 1, 2, 3, 4, 5, 6, 7, 8 };\n\n  DNSPacket reply_badcookie;\n  reply_badcookie.set_response().set_aa().set_rcode(ARES_RCODE_BADCOOKIE & 0xF)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR((ARES_RCODE_BADCOOKIE >> 4) & 0xFF, 0, 0, 1280, { }, server_cookie, false));\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}))\n    .add_additional(new DNSOptRR(0, 0, 0, 1280, { }, { }, false));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &reply_badcookie))\n    .WillOnce(SetReply(&server_, &reply_badcookie))\n    .WillOnce(SetReply(&server_, &reply_badcookie))\n    .WillOnce(SetReply(&server_, &reply));\n\n  /* This test will establish the server supports cookies, but continuously\n   * returns BADCOOKIE which is an indicator that there is some form of\n   * AnyCast issue across servers, so it upgrades to TCP afterwards.  No\n   * timeouts are recorded as the queries are sent back-to-back as immediate\n   * reattempts after the response. */\n  QueryResult result;\n  ares_query_dnsrec(channel_, \"www.google.com\", ARES_CLASS_IN, ARES_REC_TYPE_A, QueryCallback, &result, NULL);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              2085,
              0
            ],
            [
              2115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, HostAlias) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  TempFile aliases(\"\\n\\n# www commentedout\\nwww www.google.com\\n\");\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              2119,
              0
            ],
            [
              2137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, HostAliasMissing) {\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  TempFile aliases(\"\\n\\n# www commentedout\\nww www.google.com\\n\");\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.first.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              2139,
              0
            ],
            [
              2156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, HostAliasMissingFile) {\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  EnvValue with_env(\"HOSTALIASES\", \"bogus.mcfile\");\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.first.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              2158,
              0
            ],
            [
              2174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, HostAliasUnreadable) {\n  TempFile aliases(\"www www.google.com\\n\");\n  EXPECT_EQ(chmod(aliases.filename(), 0), 0);\n\n  /* Perform OS sanity checks.  We are observing on Debian after the chmod(fn, 0)\n   * that we are still able to fopen() the file which is unexpected.  Skip the\n   * test if we observe this behavior */\n  struct stat st;\n  EXPECT_EQ(stat(aliases.filename(), &st), 0);\n  EXPECT_EQ(st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO), 0);\n  FILE *fp = fopen(aliases.filename(), \"r\");\n  if (fp != NULL) {\n    if (verbose) std::cerr << \"Skipping Test due to OS incompatibility (open file caching)\" << std::endl;\n    fclose(fp);\n    return;\n  }\n\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFILE, result.status_);\n  chmod(aliases.filename(), 0777);\n}",
          "fn_code_pos": [
            [
              2176,
              0
            ],
            [
              2201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockMultiServerChannelTest(ares_options *opts, int optmask)\n    : MockChannelOptsTest(3, GetParam().first, GetParam().second, false, opts, optmask) {}",
          "fn_code_pos": [
            [
              2208,
              2
            ],
            [
              2209,
              90
            ]
          ],
          "class_code": "9a5adda8621c4645b2ed988ff5c820c32c1362585c9a8e94b2bdc2e2063ea5a4",
          "class_node_pos": [
            [
              2204,
              0
            ],
            [
              2219,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockMultiServerChannelTest",
            "parameters": {
              "opts": "ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }",
          "fn_code_pos": [
            [
              2210,
              2
            ],
            [
              2218,
              3
            ]
          ],
          "class_code": "9a5adda8621c4645b2ed988ff5c820c32c1362585c9a8e94b2bdc2e2063ea5a4",
          "class_node_pos": [
            [
              2204,
              0
            ],
            [
              2219,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckExample",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "NoRotateMultiMockTest() : MockMultiServerChannelTest(nullptr, ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              2223,
              2
            ],
            [
              2223,
              85
            ]
          ],
          "class_code": "40284f315f94be019493562b35da1236e82397d3ac755e9b46af08f6f92b851f",
          "class_node_pos": [
            [
              2221,
              0
            ],
            [
              2224,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "NoRotateMultiMockTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockTest, ThirdServer) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &opts, &optmask));\n  EXPECT_EQ(ARES_OPT_NOROTATE, (optmask & ARES_OPT_NOROTATE));\n  ares_destroy_options(&opts);\n\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket notimplrsp;\n  notimplrsp.set_response().set_aa().set_rcode(NOTIMP)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  CheckExample();\n\n  // Second time around, still starts from server [2], as [0] and [1] both\n  // recorded failures\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Third time around, server order is [1] (f0), [2] (f1), [0] (f2), which\n  // means [1] will get called twice in a row as after the first call\n  // order will be  [1] (f1), [2] (f1), [0] (f2) since sort order is\n  // (failure count, index)\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              2227,
              0
            ],
            [
              2276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockTest, ServerNoResponseFailover) {\n  std::vector<byte> nothing;\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  /* Server #1 works fine on first attempt, then acts like its offline on\n   * second, then backonline on the third. */\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp))\n    .WillOnce(SetReplyData(servers_[0].get(), nothing))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n\n  /* Server #2 always acts like its offline */\n  ON_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReplyData(servers_[1].get(), nothing));\n\n  /* Server #3 works fine on first and second request, then no reply on 3rd */\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp))\n    .WillOnce(SetReplyData(servers_[2].get(), nothing));\n\n  HostResult result;\n\n  /* 1. First server returns a response on the first request immediately, normal\n   *    operation on channel. */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n  std::stringstream ss1;\n  ss1 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n\n  /* 2. On the second request, simulate the first and second servers not\n   *    returning a response at all, but the 3rd server works, so should have\n   *    2 timeouts. */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(2, result.timeouts_);\n  std::stringstream ss2;\n  ss2 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss2.str());\n\n  /* 3. On the third request, the active server should be #3, so should respond\n   *    immediately with no timeouts */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n  std::stringstream ss3;\n  ss3 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss3.str());\n\n  /* 4. On the fourth request, the active server should be #3, but will timeout,\n   *    and the first server should then respond */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n  std::stringstream ss4;\n  ss4 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss4.str());\n}",
          "fn_code_pos": [
            [
              2278,
              0
            ],
            [
              2344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ServerFailoverOptsMultiMockTest()\n    : MockChannelOptsTest(4, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              2356,
              2
            ],
            [
              2359,
              74
            ]
          ],
          "class_code": "3f8c810d2b863e937da8b906a9a6d97a60bc210a2c90c1942533b55184a83599",
          "class_node_pos": [
            [
              2352,
              0
            ],
            [
              2378,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ServerFailoverOptsMultiMockTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }",
          "fn_code_pos": [
            [
              2360,
              2
            ],
            [
              2368,
              3
            ]
          ],
          "class_code": "3f8c810d2b863e937da8b906a9a6d97a60bc210a2c90c1942533b55184a83599",
          "class_node_pos": [
            [
              2352,
              0
            ],
            [
              2378,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckExample",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = SERVER_FAILOVER_RETRY_DELAY;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              2370,
              2
            ],
            [
              2375,
              3
            ]
          ],
          "class_code": "3f8c810d2b863e937da8b906a9a6d97a60bc210a2c90c1942533b55184a83599",
          "class_node_pos": [
            [
              2352,
              0
            ],
            [
              2378,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ServerFailoverOptsMultiMockTest, ServerFailoverOpts) {\n DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  auto tv_begin = std::chrono::high_resolution_clock::now();\n  auto tv_now   = std::chrono::high_resolution_clock::now();\n  unsigned int delay_ms;\n\n  // At start all servers are healthy, first server should be selected\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: First server should be selected\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // Fail server #0 but leave server #1 as healthy.  This results in server\n  // order:\n  //  #1 (failures: 0), #2 (failures: 0), #3 (failures: 0), #0 (failures: 1)\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Server0 will fail but leave Server1 as healthy\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Sleep for the retry delay (actually a little more than the retry delay to account\n  // for unreliable timing, e.g. NTP slew) and send in another query. The real\n  // query will be sent to Server #1 (which will succeed) and Server #0 will\n  // be probed and return a successful result.  This leaves the server order\n  // of:\n  //   #0 (failures: 0), #1 (failures: 0), #2 (failures: 0), #3 (failures: 0)\n  tv_now = std::chrono::high_resolution_clock::now();\n  delay_ms = SERVER_FAILOVER_RETRY_DELAY + (SERVER_FAILOVER_RETRY_DELAY / 10);\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: sleep \" << delay_ms << \"ms\" << std::endl;\n  ares_sleep_time(delay_ms);\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Server0 should be past retry delay and should be probed (successful), server 1 will respond successful for real query\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n\n  // Fail all servers for the first round of tries. On the second round, #0\n  // responds successfully. This should leave server order of:\n  //   #1 (failures: 0), #2 (failures: 1), #3 (failures: 1), #0 (failures: 2)\n  // NOTE: A single query being retried won't spawn probes to downed servers,\n  //       only an initial query attempt is eligible to spawn probes.  So\n  //       no probes are sent for this test.\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: All 4 servers will fail on the first attempt, server 0 will fail on second. Server 1 will succeed on second.\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[3], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[3].get(), &servfailrsp));\n  CheckExample();\n\n\n  // Sleep for the retry delay and send in another query. Server #1 is the\n  // highest priority server and will respond with success, however a probe\n  // will be sent for Server #2 which will succeed:\n  //  #1 (failures: 0), #2 (failures: 0), #3 (failures: 1 - expired), #0 (failures: 2 - expired)\n  tv_now = std::chrono::high_resolution_clock::now();\n  delay_ms = SERVER_FAILOVER_RETRY_DELAY + (SERVER_FAILOVER_RETRY_DELAY / 10);\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: sleep \" << delay_ms << \"ms\" << std::endl;\n  ares_sleep_time(delay_ms);\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Past retry delay, will query Server 1 and probe Server 2, both will succeed.\" << std::endl;\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  CheckExample();\n\n  // Cause another server to fail so we have at least one non-expired failed\n  // server and one expired failed server.  #1 is highest priority, which we\n  // will fail, #2 will succeed, and #3 will be probed and succeed:\n  //  #2 (failures: 0), #3 (failures: 0), #1 (failures: 1 not expired), #0 (failures: 2 expired)\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Will query Server 1 and fail, Server 2 will answer successfully. Server 3 will be probed and succeed.\" << std::endl;\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  EXPECT_CALL(*servers_[3], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[3].get(), &okrsp));\n  CheckExample();\n\n  // We need to make sure that if there is a failed server that is higher priority\n  // but not yet expired that it will probe the next failed server instead.\n  // In this case #2 is the server that the query will go to and succeed, and\n  // then a probe will be sent for #0 (since #1 is not expired) and succeed.  We\n  // will sleep for 1/4 the retry duration before spawning the queries so we can\n  // then sleep for the rest for the follow-up test.  This will leave the servers\n  // in this state:\n  //   #0 (failures: 0), #2 (failures: 0), #3 (failures: 0), #1 (failures: 1 not expired)\n  tv_now = std::chrono::high_resolution_clock::now();\n\n  // We need to track retry delay time to know what is expired when.\n  auto elapse_start = tv_now;\n\n  delay_ms = (SERVER_FAILOVER_RETRY_DELAY/4);\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: sleep \" << delay_ms << \"ms\" << std::endl;\n  ares_sleep_time(delay_ms);\n  tv_now = std::chrono::high_resolution_clock::now();\n\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Retry delay has not been hit yet. Server2 will be queried and succeed. Server 0 (not server 1 due to non-expired retry delay) will be probed and succeed.\" << std::endl;\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // Finally we sleep for the remainder of the retry delay, send another\n  // query, which should succeed on Server #0, and also probe Server #1 which\n  // will also succeed.\n  tv_now = std::chrono::high_resolution_clock::now();\n\n  unsigned int elapsed_time = (unsigned int)std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - elapse_start).count();\n  delay_ms = (SERVER_FAILOVER_RETRY_DELAY) + (SERVER_FAILOVER_RETRY_DELAY / 10);\n  if (elapsed_time > delay_ms) {\n    if (verbose) std::cerr << \"elapsed duration \" << elapsed_time << \"ms greater than desired delay of \" << delay_ms << \"ms, not sleeping\" << std::endl;\n  } else {\n    delay_ms -= elapsed_time; // subtract already elapsed time\n    if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: sleep \" << delay_ms << \"ms\" << std::endl;\n    ares_sleep_time(delay_ms);\n  }\n  tv_now = std::chrono::high_resolution_clock::now();\n  if (verbose) std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(tv_now - tv_begin).count() << \"ms: Retry delay has expired on Server1, Server 0 will be queried and succeed, Server 1 will be probed and succeed.\" << std::endl;\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              2383,
              0
            ],
            [
              2529,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "const char *af_tostr(int af)\n{\n  switch (af) {\n    case AF_INET:\n      return \"ipv4\";\n    case AF_INET6:\n      return \"ipv6\";\n  }\n  return \"ipunknown\";\n}",
          "fn_code_pos": [
            [
              2531,
              0
            ],
            [
              2540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "af_tostr",
            "parameters": {
              "af": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *mode_tostr(bool mode)\n{\n  return mode?\"ForceTCP\":\"DefaultUDP\";\n}",
          "fn_code_pos": [
            [
              2542,
              0
            ],
            [
              2545,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mode_tostr",
            "parameters": {
              "mode": "bool"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "std::string PrintFamilyMode(const testing::TestParamInfo<std::pair<int, bool>> &info)\n{\n  std::string name;\n\n  name += af_tostr(std::get<0>(info.param));\n  name += \"_\";\n  name += mode_tostr(std::get<1>(info.param));\n  return name;\n}",
          "fn_code_pos": [
            [
              2547,
              0
            ],
            [
              2555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFamilyMode",
            "parameters": {
              "info": "testing::TestParamInfo<std::pair<int, bool>>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string PrintFamily(const testing::TestParamInfo<int> &info)\n{\n  std::string name;\n\n  name += af_tostr(info.param);\n  return name;\n}",
          "fn_code_pos": [
            [
              2557,
              0
            ],
            [
              2563,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFamily",
            "parameters": {
              "info": "testing::TestParamInfo<int>"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              50,
              30
            ],
            [
              50,
              69
            ]
          ],
          "class_code": "49d22d9448d8a4a3104fd768c18ff2a306c4c5f409502881a46ba928e1af33d3",
          "class_node_pos": [
            [
              42,
              0
            ],
            [
              57,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              458,
              30
            ],
            [
              458,
              69
            ]
          ],
          "class_code": "ea767858224c190ad7b278358faa0325a631462938236ef7fa704714a1e0c4fb",
          "class_node_pos": [
            [
              450,
              0
            ],
            [
              465,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              505,
              30
            ],
            [
              505,
              69
            ]
          ],
          "class_code": "3335d0964ca60c45952e017df71e6241ed132e5a6cadab397ed25543df3a2a98",
          "class_node_pos": [
            [
              497,
              0
            ],
            [
              512,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              670,
              30
            ],
            [
              670,
              69
            ]
          ],
          "class_code": "45a4604120c25c8bdfa969dcbc4c5fa08ed77ce94faedf7972410f6e40fab0e7",
          "class_node_pos": [
            [
              662,
              0
            ],
            [
              679,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts, int flags)",
          "fn_dec_pos": [
            [
              711,
              30
            ],
            [
              711,
              80
            ]
          ],
          "class_code": "8d1264bb9ce689dbe9c01453a9f88395362edf051ba45e61d544cb8f905f9767",
          "class_node_pos": [
            [
              704,
              0
            ],
            [
              718,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "fetch_server_cookie(const ares_dns_record_t *dnsrec, size_t *len)",
          "fn_dec_pos": [
            [
              1854,
              2
            ],
            [
              1854,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fetch_server_cookie",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "fetch_client_cookie(const ares_dns_record_t *dnsrec, size_t *len)",
          "fn_dec_pos": [
            [
              1880,
              2
            ],
            [
              1880,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fetch_client_cookie",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options *opts)",
          "fn_dec_pos": [
            [
              2370,
              30
            ],
            [
              2370,
              68
            ]
          ],
          "class_code": "3f8c810d2b863e937da8b906a9a6d97a60bc210a2c90c1942533b55184a83599",
          "class_node_pos": [
            [
              2352,
              0
            ],
            [
              2378,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "af_tostr(int af)",
          "fn_dec_pos": [
            [
              2531,
              12
            ],
            [
              2531,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "af_tostr",
            "parameters": {
              "af": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "mode_tostr(bool mode)",
          "fn_dec_pos": [
            [
              2542,
              12
            ],
            [
              2542,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mode_tostr",
            "parameters": {
              "mode": "bool"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "49d22d9448d8a4a3104fd768c18ff2a306c4c5f409502881a46ba928e1af33d3": {
          "class_code": "class NoDNS0x20MockTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface<int> {\n public:\n  NoDNS0x20MockTest()\n    : MockChannelOptsTest(1, GetParam(), false, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_EDNS;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "NoDNS0x20MockTest",
          "class_pos": [
            [
              42,
              0
            ],
            [
              57,
              1
            ]
          ]
        },
        "ea767858224c190ad7b278358faa0325a631462938236ef7fa704714a1e0c4fb": {
          "class_code": "class MockUDPMaxQueriesTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface<int> {\n public:\n  MockUDPMaxQueriesTest()\n    : MockChannelOptsTest(1, GetParam(), false, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->udp_max_queries = MAXUDPQUERIES_LIMIT;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockUDPMaxQueriesTest",
          "class_pos": [
            [
              450,
              0
            ],
            [
              465,
              1
            ]
          ]
        },
        "3335d0964ca60c45952e017df71e6241ed132e5a6cadab397ed25543df3a2a98": {
          "class_code": "class CacheQueriesTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface<int> {\n public:\n  CacheQueriesTest()\n    : MockChannelOptsTest(1, GetParam(), false, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_QUERY_CACHE) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->qcache_max_ttl = 3600;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "CacheQueriesTest",
          "class_pos": [
            [
              497,
              0
            ],
            [
              512,
              1
            ]
          ]
        },
        "45a4604120c25c8bdfa969dcbc4c5fa08ed77ce94faedf7972410f6e40fab0e7": {
          "class_code": "class MockExtraOptsTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockExtraOptsTest()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockExtraOptsTest",
          "class_pos": [
            [
              662,
              0
            ],
            [
              679,
              1
            ]
          ]
        },
        "8d1264bb9ce689dbe9c01453a9f88395362edf051ba45e61d544cb8f905f9767": {
          "class_code": "class MockFlagsChannelOptsTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockFlagsChannelOptsTest(int flags)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockFlagsChannelOptsTest",
          "class_pos": [
            [
              704,
              0
            ],
            [
              718,
              1
            ]
          ]
        },
        "e4acaa4e65fb26b4a2f5446e475cd09090d789045f1f025ba5402c4f3efeef4c": {
          "class_code": "class MockNoCheckRespChannelTest : public MockFlagsChannelOptsTest {\n public:\n  MockNoCheckRespChannelTest() : MockFlagsChannelOptsTest(ARES_FLAG_NOCHECKRESP) {}\n}",
          "class_name": "MockNoCheckRespChannelTest",
          "class_pos": [
            [
              720,
              0
            ],
            [
              723,
              1
            ]
          ]
        },
        "578e1e23b823c1565296c9cb13adf8dabc2015436f4fc8d77a7b2a8e6f151add": {
          "class_code": "class MockEDNSChannelTest : public MockFlagsChannelOptsTest {\n public:\n  MockEDNSChannelTest() : MockFlagsChannelOptsTest(ARES_FLAG_EDNS) {}\n}",
          "class_name": "MockEDNSChannelTest",
          "class_pos": [
            [
              767,
              0
            ],
            [
              770,
              1
            ]
          ]
        },
        "9974153922f31fa4380bfc281c6ef59b692c52dc52474286e889feabd0080257": {
          "class_code": "class ContainedMockChannelSysConfig\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface<std::pair<int, bool>> {\n public:\n  ContainedMockChannelSysConfig()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, true, nullptr, 0) {}\n}",
          "class_name": "ContainedMockChannelSysConfig",
          "class_pos": [
            [
              844,
              0
            ],
            [
              850,
              1
            ]
          ]
        },
        "9a5adda8621c4645b2ed988ff5c820c32c1362585c9a8e94b2bdc2e2063ea5a4": {
          "class_code": "class MockMultiServerChannelTest\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockMultiServerChannelTest(ares_options *opts, int optmask)\n    : MockChannelOptsTest(3, GetParam().first, GetParam().second, false, opts, optmask) {}\n  void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "class_name": "MockMultiServerChannelTest",
          "class_pos": [
            [
              2204,
              0
            ],
            [
              2219,
              1
            ]
          ]
        },
        "40284f315f94be019493562b35da1236e82397d3ac755e9b46af08f6f92b851f": {
          "class_code": "class NoRotateMultiMockTest : public MockMultiServerChannelTest {\n public:\n  NoRotateMultiMockTest() : MockMultiServerChannelTest(nullptr, ARES_OPT_NOROTATE) {}\n}",
          "class_name": "NoRotateMultiMockTest",
          "class_pos": [
            [
              2221,
              0
            ],
            [
              2224,
              1
            ]
          ]
        },
        "3f8c810d2b863e937da8b906a9a6d97a60bc210a2c90c1942533b55184a83599": {
          "class_code": "class ServerFailoverOptsMultiMockTest\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  ServerFailoverOptsMultiMockTest()\n    : MockChannelOptsTest(4, GetParam().first, GetParam().second, false,\n                          FillOptions(&opts_),\n                          ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}\n  void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n\n  static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = SERVER_FAILOVER_RETRY_DELAY;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "ServerFailoverOptsMultiMockTest",
          "class_pos": [
            [
              2352,
              0
            ],
            [
              2378,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ares_options",
          {},
          "",
          [
            50,
            9
          ],
          [
            50,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            50,
            42
          ],
          [
            50,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            51,
            27
          ],
          [
            51,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            56,
            2
          ],
          [
            56,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            458,
            9
          ],
          [
            458,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            458,
            42
          ],
          [
            458,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            459,
            27
          ],
          [
            459,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            464,
            2
          ],
          [
            464,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            505,
            9
          ],
          [
            505,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            505,
            42
          ],
          [
            505,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            506,
            27
          ],
          [
            506,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            511,
            2
          ],
          [
            511,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            670,
            9
          ],
          [
            670,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            670,
            42
          ],
          [
            670,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            671,
            27
          ],
          [
            671,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            678,
            2
          ],
          [
            678,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            711,
            9
          ],
          [
            711,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            711,
            42
          ],
          [
            711,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            712,
            27
          ],
          [
            712,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            717,
            2
          ],
          [
            717,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1441,
            2
          ],
          [
            1441,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1565,
            2
          ],
          [
            1565,
            16
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            2183,
            2
          ],
          [
            2183,
            13
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            2228,
            2
          ],
          [
            2228,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            2370,
            9
          ],
          [
            2370,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            2370,
            42
          ],
          [
            2370,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            2371,
            27
          ],
          [
            2371,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            2377,
            2
          ],
          [
            2377,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-internal.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, StringLength) {\n  const char data[] = \"test\\0test\";\n  size_t n = sizeof data;\n  for(size_t i = 0; i < n; ++i) {\n    EXPECT_EQ(ares_strlen(&data[i]), ares_strnlen(&data[i], n - i));\n  }\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, StringLengthNullPointer) {\n  EXPECT_EQ(ares_strlen(NULL), 0);\n  EXPECT_EQ(ares_strnlen(NULL, 0), 0);\n  EXPECT_EQ(ares_strnlen(NULL, 1), 0);\n  EXPECT_EQ(ares_strnlen(NULL, 42), 0);\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, StringLengthWithoutNullTerminator) {\n  std::string data = \"test\";\n  for(size_t i = 0; i < data.length(); ++i) {\n    EXPECT_EQ(ares_strnlen(data.c_str(), i), i);\n  }\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckPtoN4(int size, unsigned int value, const char *input) {\n  struct in_addr a4;\n  a4.s_addr = 0;\n  uint32_t expected = htonl(value);\n  EXPECT_EQ(size, ares_inet_net_pton(AF_INET, input, &a4, sizeof(a4)))\n    << \" for input \" << input;\n  EXPECT_EQ(expected, a4.s_addr) << \" for input \" << input;\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckPtoN4",
            "parameters": {
              "size": "int",
              "value": "unsigned int",
              "input": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, Strsplit) {\n  using std::vector;\n  using std::string;\n  size_t n;\n  struct {\n    vector<string> inputs;\n    vector<string> delimiters;\n    vector<vector<string>> expected;\n  } data = {\n    {\n      \"\",\n      \" \",\n      \"             \",\n      \"example.com, example.co\",\n      \"        a, b, A,c,     d, e,,,D,e,e,E\",\n    },\n    { \", \", \", \", \", \", \", \", \", \" },\n    {\n      {}, {}, {},\n      { \"example.com\", \"example.co\" },\n      { \"a\", \"b\", \"c\", \"d\", \"e\" },\n    },\n  };\n  for(size_t i = 0; i < data.inputs.size(); i++) {\n    char **out = ares_strsplit(data.inputs.at(i).c_str(),\n                               data.delimiters.at(i).c_str(), &n);\n    if(data.expected.at(i).size() == 0) {\n      EXPECT_EQ(out, nullptr);\n    }\n    else {\n      EXPECT_EQ(n, data.expected.at(i).size());\n      for(size_t j = 0; j < n && j < data.expected.at(i).size(); j++) {\n        EXPECT_STREQ(out[j], data.expected.at(i).at(j).c_str());\n      }\n    }\n    ares_strsplit_free(out, n);\n  }\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, InetNetPtoN) {\n  uint32_t expected;\n  struct in_addr a4;\n  struct in6_addr a6;\n  CheckPtoN4(4 * 8, 0x01020304, \"1.2.3.4\");\n  CheckPtoN4(4 * 8, 0x81010101, \"129.1.1.1\");\n  CheckPtoN4(4 * 8, 0xC0010101, \"192.1.1.1\");\n  CheckPtoN4(4 * 8, 0xE0010101, \"224.1.1.1\");\n  CheckPtoN4(4 * 8, 0xE1010101, \"225.1.1.1\");\n  CheckPtoN4(4, 0xE0000000, \"224\");\n  CheckPtoN4(4 * 8, 0xFD000000, \"253\");\n  CheckPtoN4(4 * 8, 0xF0010101, \"240.1.1.1\");\n  CheckPtoN4(4 * 8, 0x02030405, \"02.3.4.5\");\n  CheckPtoN4(3 * 8, 0x01020304, \"1.2.3.4/24\");\n  CheckPtoN4(3 * 8, 0x01020300, \"1.2.3/24\");\n  CheckPtoN4(2 * 8, 0xa0000000, \"0xa\");\n  CheckPtoN4(0, 0x02030405, \"2.3.4.5/000\");\n  CheckPtoN4(1 * 8, 0x01020000, \"1.2/8\");\n  CheckPtoN4(2 * 8, 0x01020000, \"0x0102/16\");\n  CheckPtoN4(4 * 8, 0x02030405, \"02.3.4.5\");\n\n  // Partially specified\n  // (ensures 4 octets are properly zeroed)\n  a4.s_addr = 0xFFFFFFFF;\n  ares_inet_net_pton(AF_INET, \"10/8\", &a4, sizeof(a4));\n  EXPECT_EQ(htonl(0x0A000000), a4.s_addr);\n\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"::\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"::1\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"1234:5678::\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"12:34::ff\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.4\", &a6, sizeof(a6)));\n  EXPECT_EQ(23, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.4/23\", &a6, sizeof(a6)));\n  EXPECT_EQ(3 * 8, ares_inet_net_pton(AF_INET6, \"12:34::ff/24\", &a6, sizeof(a6)));\n  EXPECT_EQ(0, ares_inet_net_pton(AF_INET6, \"12:34::ff/0\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"12:34::ffff:0.2\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234\", &a6, sizeof(a6)));\n  EXPECT_EQ(2, ares_inet_net_pton(AF_INET6, \"0::00:00:00/2\", &a6, sizeof(a6)));\n\n  // Various malformed versions\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \" \", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x \", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"x0\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0xXYZZY\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"xyzzy\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET+AF_INET6, \"1.2.3.4\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"257.2.3.4\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"002.3.4.x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"00.3.4.x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5.6\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5.6/12\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4:5\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5/120\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5/1x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5/x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/240\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/02\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/2y\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/y\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \":x\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \":\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \": :1234\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"::12345\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234::2345:3456::0011\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234:\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234::\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1.2.3.4\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \":1234:1234:1234:1234:1234:1234:1234:1234\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \":1234:1234:1234:1234:1234:1234:1234:1234:\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234:5678\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234:5678:5678\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234:5678:5678:5678\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:257.2.3.4\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.4.5.6\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.4.5\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.z\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3001.4\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3..4\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.\", &a6, sizeof(a6)));\n\n  // Hex constants are allowed.\n  EXPECT_EQ(4 * 8, ares_inet_net_pton(AF_INET, \"0x01020304\", &a4, sizeof(a4)));\n  expected = htonl(0x01020304);\n  EXPECT_EQ(expected, a4.s_addr);\n  EXPECT_EQ(4 * 8, ares_inet_net_pton(AF_INET, \"0x0a0b0c0d\", &a4, sizeof(a4)));\n  expected = htonl(0x0a0b0c0d);\n  EXPECT_EQ(expected, a4.s_addr);\n  EXPECT_EQ(4 * 8, ares_inet_net_pton(AF_INET, \"0x0A0B0C0D\", &a4, sizeof(a4)));\n  expected = htonl(0x0a0b0c0d);\n  EXPECT_EQ(expected, a4.s_addr);\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x0xyz\", &a4, sizeof(a4)));\n  EXPECT_EQ(4 * 8, ares_inet_net_pton(AF_INET, \"0x1122334\", &a4, sizeof(a4)));\n  expected = htonl(0x11223340);\n  EXPECT_EQ(expected, a4.s_addr);  // huh?\n\n  // No room, no room.\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"1.2.3.4\", &a4, sizeof(a4) - 1));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff\", &a6, sizeof(a6) - 1));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x01020304\", &a4, 2));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x01020304\", &a4, 0));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x0a0b0c0d\", &a4, 0));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x0xyz\", &a4, 0));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x1122334\", &a4, sizeof(a4) - 1));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"253\", &a4, sizeof(a4) - 1));\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, FreeLongChain) {\n  struct ares_addr_node *data = nullptr;\n  for (int ii = 0; ii < 100000; ii++) {\n    struct ares_addr_node *prev = (struct ares_addr_node*)ares_malloc_data(ARES_DATATYPE_ADDR_NODE);\n    prev->next = data;\n    data = prev;\n  }\n\n  ares_free_data(data);\n}",
          "fn_code_pos": [
            [
              246,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, MallocDataFail) {\n  EXPECT_EQ(nullptr, ares_malloc_data((ares_datatype)99));\n  SetAllocSizeFail(sizeof(struct ares_data));\n  EXPECT_EQ(nullptr, ares_malloc_data(ARES_DATATYPE_MX_REPLY));\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(Misc, OnionDomain) {\n  EXPECT_EQ(0, ares_is_onion_domain(\"onion.no\"));\n  EXPECT_EQ(0, ares_is_onion_domain(\".onion.no\"));\n  EXPECT_EQ(1, ares_is_onion_domain(\".onion\"));\n  EXPECT_EQ(1, ares_is_onion_domain(\".onion.\"));\n  EXPECT_EQ(1, ares_is_onion_domain(\"yes.onion\"));\n  EXPECT_EQ(1, ares_is_onion_domain(\"yes.onion.\"));\n  EXPECT_EQ(1, ares_is_onion_domain(\"YES.ONION\"));\n  EXPECT_EQ(1, ares_is_onion_domain(\"YES.ONION.\"));\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CatDomain) {\n  char *s;\n\n  ares_cat_domain(\"foo\", \"example.net\", &s);\n  EXPECT_STREQ(\"foo.example.net\", s);\n  ares_free(s);\n\n  ares_cat_domain(\"foo\", \".\", &s);\n  EXPECT_STREQ(\"foo.\", s);\n  ares_free(s);\n\n  ares_cat_domain(\"foo\", \"example.net.\", &s);\n  EXPECT_STREQ(\"foo.example.net.\", s);\n  ares_free(s);\n}",
          "fn_code_pos": [
            [
              274,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, SlistMisuse) {\n  EXPECT_EQ(NULL, ares_slist_create(NULL, NULL, NULL));\n  ares_slist_replace_destructor(NULL, NULL);\n  EXPECT_EQ(NULL, ares_slist_insert(NULL, NULL));\n  EXPECT_EQ(NULL, ares_slist_node_find(NULL, NULL));\n  EXPECT_EQ(NULL, ares_slist_node_first(NULL));\n  EXPECT_EQ(NULL, ares_slist_node_last(NULL));\n  EXPECT_EQ(NULL, ares_slist_node_next(NULL));\n  EXPECT_EQ(NULL, ares_slist_node_prev(NULL));\n  EXPECT_EQ(NULL, ares_slist_node_val(NULL));\n  EXPECT_EQ((size_t)0, ares_slist_len(NULL));\n  EXPECT_EQ(NULL, ares_slist_node_parent(NULL));\n  EXPECT_EQ(NULL, ares_slist_first_val(NULL));\n  EXPECT_EQ(NULL, ares_slist_last_val(NULL));\n  EXPECT_EQ(NULL, ares_slist_node_claim(NULL));\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              305,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, IfaceIPs) {\n  ares_status_t      status;\n  ares_iface_ips_t *ips = NULL;\n  size_t             i;\n\n  status = ares_iface_ips(&ips, ARES_IFACE_IP_DEFAULT, NULL);\n  EXPECT_TRUE(status == ARES_SUCCESS || status == ARES_ENOTIMP);\n\n  /* Not implemented, can't run tests */\n  if (status == ARES_ENOTIMP)\n    return;\n\n  EXPECT_NE(nullptr, ips);\n\n  for (i=0; i<ares_iface_ips_cnt(ips); i++) {\n    const char *name = ares_iface_ips_get_name(ips, i);\n    EXPECT_NE(nullptr, name);\n    int flags = (int)ares_iface_ips_get_flags(ips, i);\n    EXPECT_NE(0, (int)flags);\n    EXPECT_NE(nullptr, ares_iface_ips_get_addr(ips, i));\n    EXPECT_NE(0, ares_iface_ips_get_netmask(ips, i));\n    if (flags & ARES_IFACE_IP_LINKLOCAL && flags & ARES_IFACE_IP_V6) {\n      /* Hmm, seems not to work at least on MacOS\n       * EXPECT_NE(0, ares_iface_ips_get_ll_scope(ips, i));\n       */\n    } else {\n      EXPECT_EQ(0, ares_iface_ips_get_ll_scope(ips, i));\n    }\n    unsigned int idx = ares_os_if_nametoindex(name);\n    EXPECT_NE(0, idx);\n    char namebuf[256];\n    EXPECT_EQ(std::string(ares_os_if_indextoname(idx, namebuf, sizeof(namebuf))), std::string(name));\n  }\n\n\n  /* Negative checking */\n  ares_iface_ips_get_name(ips, ares_iface_ips_cnt(ips));\n  ares_iface_ips_get_flags(ips, ares_iface_ips_cnt(ips));\n  ares_iface_ips_get_addr(ips, ares_iface_ips_cnt(ips));\n  ares_iface_ips_get_netmask(ips, ares_iface_ips_cnt(ips));\n  ares_iface_ips_get_ll_scope(ips, ares_iface_ips_cnt(ips));\n\n  ares_iface_ips(NULL, ARES_IFACE_IP_DEFAULT, NULL);\n  ares_iface_ips_cnt(NULL);\n  ares_iface_ips_get_name(NULL, 0);\n  ares_iface_ips_get_flags(NULL, 0);\n  ares_iface_ips_get_addr(NULL, 0);\n  ares_iface_ips_get_netmask(NULL, 0);\n  ares_iface_ips_get_ll_scope(NULL, 0);\n  ares_iface_ips_destroy(NULL);\n  ares_os_if_nametoindex(NULL);\n  ares_os_if_indextoname(0, NULL, 0);\n\n  ares_iface_ips_destroy(ips);\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableMisuse) {\n  EXPECT_EQ(NULL, ares_htable_create(NULL, NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_insert(NULL, NULL));\n  EXPECT_EQ(NULL, ares_htable_get(NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_remove(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares_htable_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              371,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, URI) {\n  struct {\n    ares_bool_t success;\n    const char *uri;\n    const char *alt_match_uri;\n  } tests[] = {\n    { ARES_TRUE,  \"https://www.example.com\",                                                               NULL },\n    { ARES_TRUE,  \"https://www.example.com:8443\",                                                          NULL },\n    { ARES_TRUE,  \"https://user:password@www.example.com\",                                                 NULL },\n    { ARES_TRUE,  \"https://user%25:password@www.example.com\",                                              NULL },\n    { ARES_TRUE,  \"https://user:password%25@www.example.com\",                                              NULL },\n    { ARES_TRUE,  \"https://user@www.example.com\",                                                          NULL },\n    { ARES_TRUE,  \"https://www.example.com/path\",                                                          NULL },\n    { ARES_TRUE,  \"https://www.example.com/path/\",                                                         NULL },\n    { ARES_TRUE,  \"https://www.example.com/a/../\",                                                         \"https://www.example.com/\" },\n    { ARES_TRUE,  \"https://www.example.com/../a/\",                                                         \"https://www.example.com/a/\" },\n    { ARES_TRUE,  \"https://www.example.com/.././../a/\",                                                    \"https://www.example.com/a/\" },\n    { ARES_TRUE,  \"https://www.example.com/.././../a//b/c/d/../../\",                                       \"https://www.example.com/a/b/\" },\n    { ARES_TRUE,  \"https://www.example.com?key=val\",                                                       NULL },\n    { ARES_TRUE,  \"https://www.example.com?key\",                                                           NULL },\n    { ARES_TRUE,  \"https://www.example.com?key=\",                                                          \"https://www.example.com?key\" },\n    { ARES_TRUE,  \"https://www.example.com#fragment\",                                                      NULL },\n    { ARES_TRUE,  \"https://user:password@www.example.com/path\",                                            NULL },\n    { ARES_TRUE,  \"https://user:password@www.example.com/path#fragment\",                                   NULL },\n    { ARES_TRUE,  \"https://user:password@www.example.com/path?key=val\",                                    NULL },\n    { ARES_TRUE,  \"https://user:password@www.example.com/path?key=val#fragment\",                           NULL },\n    { ARES_TRUE,  \"https://user:password@www.example.com/path?key=val#fragment/with?chars\",                NULL },\n    { ARES_TRUE,  \"HTTPS://www.example.com\",                                                               \"https://www.example.com\" },\n    { ARES_TRUE,  \"https://www.example.com?key=hello+world\",                                               \"https://www.example.com?key=hello%20world\" },\n    { ARES_TRUE,  \"https://www.example.com?key=val%26\",                                                    NULL },\n    { ARES_TRUE,  \"https://www.example.com?key%26=val\",                                                    NULL },\n    { ARES_TRUE,  \"https://www.example.com?key=Aa2-._~/?!$'()*,;:@\",                                       NULL },\n    { ARES_TRUE,  \"https://www.example.com?key1=val1&key2=val2&key3=val3&key4=val4\",                       \"ignore\" }, /* keys get randomized, can't match */\n    { ARES_TRUE,  \"https://www.example.com?key=%41%61%32%2D%2E%5f%7e%2F%3F%21%24%27%28%29%2a%2C%3b%3a%40\", \"https://www.example.com?key=Aa2-._~/?!$'()*,;:@\" },\n    { ARES_TRUE,  \"dns+tls://192.168.1.1:53\",                                                              NULL },\n    { ARES_TRUE,  \"dns+tls://[fe80::1]:53\",                                                                NULL },\n    { ARES_TRUE,  \"dns://[fe80::b542:84df:1719:65e3%en0]\",                                                 NULL },\n    { ARES_TRUE,  \"dns+tls://[fe80:00::00:1]:53\",                                                          \"dns+tls://[fe80::1]:53\" },\n    { ARES_TRUE,  \"d.n+s-tls://www.example.com\",                                                           NULL },\n    { ARES_FALSE, \"dns*tls://www.example.com\",                                                             NULL }, /* invalid scheme character */\n    { ARES_FALSE, \"0dns://www.example.com\",                                                                NULL }, /* dns can't start with digits */\n    { ARES_FALSE, \"https://www.example.com?key=val%01\",                                                    NULL }, /* non-printable character */\n    { ARES_FALSE, \"abcdef0123456789://www.example.com\",                                                    NULL }, /* scheme too long */\n    { ARES_FALSE, \"www.example.com\",                                                                       NULL }, /* missing scheme */\n    { ARES_FALSE, \"https://www.example.com?key=val%0\",                                                     NULL }, /* truncated uri-encoding */\n    { ARES_FALSE, \"https://www.example.com?key=val%AZ\",                                                    NULL }, /* invalid uri-encoding sequence */\n    { ARES_FALSE, \"https://www.example.com?key=hello world\",                                               NULL }, /* invalid character in query value */\n    { ARES_FALSE, \"https://:password@www.example.com\",                                                     NULL }, /* can't have password without username */\n    { ARES_FALSE, \"dns+tls://[fe8G::1]\",                                                                   NULL }, /* invalid ipv6 address */\n\n    { ARES_FALSE, NULL, NULL }\n  };\n  size_t i;\n\n  for (i=0; tests[i].uri != NULL; i++) {\n    ares_uri_t *uri = NULL;\n    ares_status_t status;\n\n    if (verbose) std::cerr << \"Testing \" << tests[i].uri << std::endl;\n    status = ares_uri_parse(&uri, tests[i].uri);\n    if (tests[i].success) {\n      EXPECT_EQ(ARES_SUCCESS, status);\n    } else {\n      EXPECT_NE(ARES_SUCCESS, status);\n    }\n\n    if (status == ARES_SUCCESS) {\n      char *out = NULL;\n      EXPECT_EQ(ARES_SUCCESS, ares_uri_write(&out, uri));\n      if (tests[i].alt_match_uri == NULL || strcmp(tests[i].alt_match_uri, \"ignore\") != 0) {\n        EXPECT_STRCASEEQ(tests[i].alt_match_uri == NULL?tests[i].uri:tests[i].alt_match_uri, out);\n      }\n      ares_free(out);\n    }\n    ares_uri_destroy(uri);\n  }\n\n  /* Invalid tests  */\n  EXPECT_NE(ARES_SUCCESS, ares_uri_set_scheme(NULL, NULL));\n  EXPECT_EQ(nullptr, ares_uri_get_scheme(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_set_username(NULL, NULL));\n  EXPECT_EQ(nullptr, ares_uri_get_username(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_set_password(NULL, NULL));\n  EXPECT_EQ(nullptr, ares_uri_get_password(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_set_host(NULL, NULL));\n  EXPECT_EQ(nullptr, ares_uri_get_host(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_set_port(NULL, 0));\n  EXPECT_EQ(0, ares_uri_get_port(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_set_path(NULL, NULL));\n  EXPECT_EQ(nullptr, ares_uri_get_path(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_set_query_key(NULL, NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_del_query_key(NULL, NULL));\n  EXPECT_EQ(nullptr, ares_uri_get_query_key(NULL, NULL));\n  EXPECT_EQ(nullptr, ares_uri_get_query_keys(NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_set_fragment(NULL, NULL));\n  EXPECT_EQ(nullptr, ares_uri_get_fragment(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_write_buf(NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_write(NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_parse_buf(NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_uri_parse_buf(NULL, NULL));\n}",
          "fn_code_pos": [
            [
              373,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, InetPtoN) {\n  struct in_addr a4;\n  struct in6_addr a6;\n  EXPECT_EQ(1, ares_inet_pton(AF_INET, \"1.2.3.4\", &a4));\n  EXPECT_EQ(1, ares_inet_pton(AF_INET6, \"12:34::ff\", &a6));\n  EXPECT_EQ(1, ares_inet_pton(AF_INET6, \"12:34::ffff:1.2.3.4\", &a6));\n  EXPECT_EQ(0, ares_inet_pton(AF_INET, \"xyzzy\", &a4));\n  EXPECT_EQ(-1, ares_inet_pton(AF_INET+AF_INET6, \"1.2.3.4\", &a4));\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              484,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, FreeCorruptData) {\n  // ares_free_data(p) expects that there is a type field and a marker\n  // field in the memory before p.  Feed it incorrect versions of each.\n  struct ares_data *data = (struct ares_data *)malloc(sizeof(struct ares_data));\n  void* p = &(data->data);\n\n  // Invalid type\n  data->type = (ares_datatype)ARES_DATATYPE_LAST;\n  data->mark = ARES_DATATYPE_MARK;\n  ares_free_data(p);\n\n  // Invalid marker\n  data->type = (ares_datatype)ARES_DATATYPE_MX_REPLY;\n  data->mark = ARES_DATATYPE_MARK + 1;\n  ares_free_data(p);\n\n  // Null pointer\n  ares_free_data(nullptr);\n\n  free(data);\n}",
          "fn_code_pos": [
            [
              486,
              0
            ],
            [
              506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(LibraryInit, StrdupFailures) {\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  char* copy = ares_strdup(\"string\");\n  EXPECT_NE(nullptr, copy);\n  ares_free(copy);\n  ares_library_cleanup();\n}",
          "fn_code_pos": [
            [
              508,
              0
            ],
            [
              514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, StrdupFailures) {\n  SetAllocFail(1);\n  char* copy = ares_strdup(\"string\");\n  EXPECT_EQ(nullptr, copy);\n}",
          "fn_code_pos": [
            [
              516,
              0
            ],
            [
              520,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoHostsPositive) {\n  TempFile hostsfile(\"1.2.3.4 example.com  \\n\"\n                     \"  2.3.4.5\\tgoogle.com   www.google.com\\twww2.google.com\\n\"\n                     \"#comment\\n\"\n                     \"4.5.6.7\\n\"\n                     \"1.3.5.7  \\n\"\n                     \"::1    ipv6.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  AddrInfoResult result = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{example.com addr=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              522,
              0
            ],
            [
              540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoHostsSpaces) {\n  TempFile hostsfile(\"1.2.3.4 example.com  \\n\"\n                     \"  2.3.4.5\\tgoogle.com   www.google.com\\twww2.google.com\\n\"\n                     \"#comment\\n\"\n                     \"4.5.6.7\\n\"\n                     \"1.3.5.7  \\n\"\n                     \"::1    ipv6.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  AddrInfoResult result = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"google.com\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{www.google.com->google.com, www2.google.com->google.com addr=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              542,
              0
            ],
            [
              560,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoHostsByALias) {\n  TempFile hostsfile(\"1.2.3.4 example.com  \\n\"\n                     \"  2.3.4.5\\tgoogle.com   www.google.com\\twww2.google.com\\n\"\n                     \"#comment\\n\"\n                     \"4.5.6.7\\n\"\n                     \"1.3.5.7  \\n\"\n                     \"::1    ipv6.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  AddrInfoResult result = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www2.google.com\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{www.google.com->google.com, www2.google.com->google.com addr=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              562,
              0
            ],
            [
              580,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoHostsIPV6) {\n  TempFile hostsfile(\"1.2.3.4 example.com  \\n\"\n                     \"  2.3.4.5\\tgoogle.com   www.google.com\\twww2.google.com\\n\"\n                     \"#comment\\n\"\n                     \"4.5.6.7\\n\"\n                     \"1.3.5.7  \\n\"\n                     \"::1    ipv6.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints = {0, 0, 0, 0};\n  AddrInfoResult result = {};\n  hints.ai_family = AF_INET6;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"ipv6.com\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{ipv6.com addr=[[0000:0000:0000:0000:0000:0000:0000:0001]]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              582,
              0
            ],
            [
              600,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoInvalidService) {\n  TempFile hostsfile(\"1.2.3.4 example.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints{};\n  AddrInfoResult result{};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com\", \"invalid\", &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(result.status_, ARES_ESERVICE);\n}",
          "fn_code_pos": [
            [
              602,
              0
            ],
            [
              613,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoAllocFail) {\n  TempFile hostsfile(\"1.2.3.4 example.com alias1 alias2\\n\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints;\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = AF_INET;\n\n  // Fail a variety of different memory allocations, and confirm\n  // that the operation either fails with ENOMEM or succeeds\n  // with the expected result.\n  const int kCount = 34;\n  AddrInfoResult results[kCount];\n  for (int ii = 1; ii <= kCount; ii++) {\n    AddrInfoResult* result = &(results[ii - 1]);\n    ClearFails();\n    SetAllocFail(ii);\n    ares_getaddrinfo(channel_, \"example.com\", NULL, &hints, AddrInfoCallback, result);\n    Process();\n    EXPECT_TRUE(result->done_);\n    if (result->status_ == ARES_SUCCESS) {\n      std::stringstream ss;\n      ss << result->ai_;\n      EXPECT_EQ(\"{alias1->example.com, alias2->example.com addr=[1.2.3.4]}\", ss.str()) << \" failed alloc #\" << ii;\n      if (verbose) std::cerr << \"Succeeded despite failure of alloc #\" << ii << std::endl;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              615,
              0
            ],
            [
              642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, DNSRecord) {\n  ares_dns_record_t   *dnsrec = NULL;\n  ares_dns_rr_t       *rr     = NULL;\n  struct in_addr       addr;\n  struct ares_in6_addr addr6;\n  unsigned char       *msg    = NULL;\n  size_t               msglen = 0;\n  size_t               qdcount = 0;\n  size_t               ancount = 0;\n  size_t               nscount = 0;\n  size_t               arcount = 0;\n\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_create(&dnsrec, 0x1234,\n      ARES_FLAG_QR|ARES_FLAG_AA|ARES_FLAG_RD|ARES_FLAG_RA,\n      ARES_OPCODE_QUERY, ARES_RCODE_NOERROR));\n\n  /* == Question == */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_query_add(dnsrec, \"example.com\",\n      ARES_REC_TYPE_ANY,\n      ARES_CLASS_IN));\n\n  /* == Answer == */\n  /* A */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_A, ARES_CLASS_IN, 300));\n  EXPECT_LT(0, ares_inet_pton(AF_INET, \"1.1.1.1\", &addr));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_addr(rr, ARES_RR_A_ADDR, &addr));\n  /* AAAA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_AAAA, ARES_CLASS_IN, 300));\n  EXPECT_LT(0, ares_inet_pton(AF_INET6, \"2600::4\", &addr6));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_addr6(rr, ARES_RR_AAAA_ADDR, &addr6));\n  /* MX */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_MX, ARES_CLASS_IN, 3600));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_MX_PREFERENCE, 10));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_MX_EXCHANGE, \"mail.example.com\"));\n  /* CNAME */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_CNAME, ARES_CLASS_IN, 3600));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_CNAME_CNAME, \"b.example.com\"));\n  /* TXT */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_TXT, ARES_CLASS_IN, 3600));\n  const char txt1[] = \"blah=here blah=there anywhere\";\n  const char txt2[] = \"some other record\";\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_add_abin(rr, ARES_RR_TXT_DATA, (unsigned char *)txt1,\n      sizeof(txt1)-1));\n   EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_add_abin(rr, ARES_RR_TXT_DATA, (unsigned char *)txt2,\n      sizeof(txt2)-1));\n  /* SIG */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_SIG, ARES_CLASS_ANY, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SIG_TYPE_COVERED, ARES_REC_TYPE_TXT));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_SIG_ALGORITHM, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_SIG_LABELS, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SIG_ORIGINAL_TTL, 3200));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SIG_EXPIRATION, (unsigned int)time(NULL)));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SIG_INCEPTION, (unsigned int)time(NULL) - (86400 * 365)));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SIG_KEY_TAG, 0x1234));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SIG_SIGNERS_NAME, \"signer.example.com\"));\n  const unsigned char sig[] = {\n    0xd2, 0xab, 0xde, 0x24, 0x0d, 0x7c, 0xd3, 0xee, 0x6b, 0x4b, 0x28, 0xc5,\n    0x4d, 0xf0, 0x34, 0xb9, 0x79, 0x83, 0xa1, 0xd1, 0x6e, 0x8a, 0x41, 0x0e,\n    0x45, 0x61, 0xcb, 0x10, 0x66, 0x18, 0xe9, 0x71 };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_SIG_SIGNATURE, sig, sizeof(sig)));\n\n\n  /* == Authority == */\n  /* NS */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_AUTHORITY, \"example.com\",\n      ARES_REC_TYPE_NS, ARES_CLASS_IN, 38400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NS_NSDNAME, \"ns1.example.com\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_AUTHORITY, \"example.com\",\n      ARES_REC_TYPE_NS, ARES_CLASS_IN, 38400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NS_NSDNAME, \"ns2.example.com\"));\n  /* SOA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_AUTHORITY, \"example.com\",\n      ARES_REC_TYPE_SOA, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SOA_MNAME, \"ns1.example.com\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SOA_RNAME, \"tech\\\\.support.example.com\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_SERIAL, 2023110701));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_REFRESH, 28800));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_RETRY, 7200));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_EXPIRE, 604800));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_MINIMUM, 86400));\n\n  /* == Additional */\n  /* OPT */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n      ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE, 1280));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS, 0));\n  unsigned char optval[] = { 'c', '-', 'a', 'r', 'e', 's' };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_OPT_OPTIONS, 3 /* NSID */, optval, sizeof(optval)));\n  /* PTR -- doesn't make sense, but ok */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"example.com\",\n      ARES_REC_TYPE_PTR, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_PTR_DNAME, \"b.example.com\"));\n  /* HINFO */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"example.com\",\n      ARES_REC_TYPE_HINFO, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_HINFO_CPU, \"Virtual\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_HINFO_OS, \"Linux\"));\n  /* SRV */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"_ldap.example.com\", ARES_REC_TYPE_SRV, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SRV_PRIORITY, 100));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SRV_WEIGHT, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SRV_PORT, 389));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SRV_TARGET, \"ldap.example.com\"));\n  /* TLSA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"_443._tcp.example.com\", ARES_REC_TYPE_TLSA, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_CERT_USAGE, ARES_TLSA_USAGE_CA));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_SELECTOR, ARES_TLSA_SELECTOR_FULL));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_MATCH, ARES_TLSA_MATCH_SHA256));\n  const unsigned char tlsa[] = {\n    0xd2, 0xab, 0xde, 0x24, 0x0d, 0x7c, 0xd3, 0xee, 0x6b, 0x4b, 0x28, 0xc5,\n    0x4d, 0xf0, 0x34, 0xb9, 0x79, 0x83, 0xa1, 0xd1, 0x6e, 0x8a, 0x41, 0x0e,\n    0x45, 0x61, 0xcb, 0x10, 0x66, 0x18, 0xe9, 0x71 };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_TLSA_DATA, tlsa, sizeof(tlsa)));\n  /* SVCB */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"_1234._bar.example.com\", ARES_REC_TYPE_SVCB, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SVCB_PRIORITY, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SVCB_TARGET, \"svc1.example.net\"));\n  /* IPV6 hint is a list of IPV6 addresses in network byte order, concatenated */\n  struct ares_addr svcb_addr;\n  svcb_addr.family = AF_UNSPEC;\n  size_t               svcb_ipv6hint_len = 0;\n  const unsigned char *svcb_ipv6hint = (const unsigned char *)ares_dns_pton(\"2001:db8::1\", &svcb_addr, &svcb_ipv6hint_len);\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_SVCB_PARAMS, ARES_SVCB_PARAM_IPV6HINT,\n      svcb_ipv6hint, svcb_ipv6hint_len));\n  /* Port is 16bit big endian format */\n  unsigned short svcb_port = htons(1234);\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_SVCB_PARAMS, ARES_SVCB_PARAM_PORT,\n      (const unsigned char *)&svcb_port, sizeof(svcb_port)));\n  /* HTTPS */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"example.com\", ARES_REC_TYPE_HTTPS, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_HTTPS_PRIORITY, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_HTTPS_TARGET, \"\"));\n\n  /* In DNS string format which is 1 octet length indicator followed by string */\n  const unsigned char https_alpn[] = { 0x02, 'h', '3' };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_HTTPS_PARAMS, ARES_SVCB_PARAM_ALPN,\n      https_alpn, sizeof(https_alpn)));\n  /* URI */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"_ftp._tcp.example.com\", ARES_REC_TYPE_URI, ARES_CLASS_IN, 3600));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_URI_PRIORITY, 10));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_URI_WEIGHT, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_URI_TARGET, \"ftp://ftp.example.com/public\"));\n  /* CAA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"example.com\", ARES_REC_TYPE_CAA, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_CAA_CRITICAL, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_CAA_TAG, \"issue\"));\n  unsigned char caa[] = \"letsencrypt.org\";\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_CAA_VALUE, caa, sizeof(caa)));\n  /* NAPTR */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"example.com\", ARES_REC_TYPE_NAPTR, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_NAPTR_ORDER, 100));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_NAPTR_PREFERENCE, 10));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NAPTR_FLAGS, \"S\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NAPTR_SERVICES, \"SIP+D2U\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NAPTR_REGEXP,\n      \"!^.*$!sip:customer-service@example.com!\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NAPTR_REPLACEMENT,\n      \"_sip._udp.example.com.\"));\n  /* RAW_RR */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n      ARES_REC_TYPE_RAW_RR, ARES_CLASS_IN, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_RAW_RR_TYPE, 65432));\n  unsigned char data[] = { 0x00 };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_RAW_RR_DATA, data, sizeof(data)));\n\n  qdcount = ares_dns_record_query_cnt(dnsrec);\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  nscount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY);\n  arcount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL);\n\n  /* Write */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_write(dnsrec, &msg, &msglen));\n\n  ares_buf_t *hexdump = ares_buf_create();\n  EXPECT_EQ(ARES_SUCCESS, ares_buf_hexdump(hexdump, msg, msglen));\n  char *hexdata = ares_buf_finish_str(hexdump, NULL);\n  //printf(\"HEXDUMP\\n%s\", hexdata);\n  ares_free(hexdata);\n\n  ares_dns_record_destroy(dnsrec); dnsrec = NULL;\n\n  /* Parse */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_parse(msg, msglen, 0, &dnsrec));\n  ares_free_string(msg); msg = NULL;\n\n  /* Re-write */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_write(dnsrec, &msg, &msglen));\n\n  EXPECT_EQ(qdcount, ares_dns_record_query_cnt(dnsrec));\n  EXPECT_EQ(ancount, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  EXPECT_EQ(nscount, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY));\n  EXPECT_EQ(arcount, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n\n  /* Iterate and print */\n  ares_buf_t *printmsg = ares_buf_create();\n  ares_buf_append_str(printmsg, \";; ->>HEADER<<- opcode: \");\n  ares_buf_append_str(printmsg, ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)));\n  ares_buf_append_str(printmsg, \", status: \");\n  ares_buf_append_str(printmsg, ares_dns_rcode_tostr(ares_dns_record_get_rcode(dnsrec)));\n  ares_buf_append_str(printmsg, \", id: \");\n  ares_buf_append_num_dec(printmsg, (size_t)ares_dns_record_get_id(dnsrec), 0);\n  ares_buf_append_str(printmsg, \"\\n;; flags: \");\n  ares_buf_append_num_hex(printmsg, (size_t)ares_dns_record_get_flags(dnsrec), 0);\n  ares_buf_append_str(printmsg, \"; QUERY: \");\n  ares_buf_append_num_dec(printmsg, ares_dns_record_query_cnt(dnsrec), 0);\n  ares_buf_append_str(printmsg, \", ANSWER: \");\n  ares_buf_append_num_dec(printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER), 0);\n  ares_buf_append_str(printmsg, \", AUTHORITY: \");\n  ares_buf_append_num_dec(printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY), 0);\n  ares_buf_append_str(printmsg, \", ADDITIONAL: \");\n  ares_buf_append_num_dec(printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL), 0);\n  ares_buf_append_str(printmsg, \"\\n\\n\");\n  ares_buf_append_str(printmsg, \";; QUESTION SECTION:\\n\");\n  for (size_t i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    const char         *name;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n    ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass);\n    ares_buf_append_str(printmsg, \";\");\n    ares_buf_append_str(printmsg, name);\n    ares_buf_append_str(printmsg, \".\\t\\t\\t\");\n    ares_buf_append_str(printmsg, ares_dns_class_tostr(qclass));\n    ares_buf_append_str(printmsg, \"\\t\");\n    ares_buf_append_str(printmsg, ares_dns_rec_type_tostr(qtype));\n    ares_buf_append_str(printmsg, \"\\n\");\n  }\n  ares_buf_append_str(printmsg, \"\\n\");\n  for (size_t i = ARES_SECTION_ANSWER; i < ARES_SECTION_ADDITIONAL + 1; i++) {\n    ares_buf_append_str(printmsg, \";; \");\n    ares_buf_append_str(printmsg, ares_dns_section_tostr((ares_dns_section_t)i));\n    ares_buf_append_str(printmsg, \" SECTION:\\n\");\n    for (size_t j = 0; j < ares_dns_record_rr_cnt(dnsrec, (ares_dns_section_t)i); j++) {\n      rr = ares_dns_record_rr_get(dnsrec, (ares_dns_section_t)i, j);\n      ares_buf_append_str(printmsg, ares_dns_rr_get_name(rr));\n      ares_buf_append_str(printmsg, \".\\t\\t\\t\");\n      ares_buf_append_str(printmsg, ares_dns_class_tostr(ares_dns_rr_get_class(rr)));\n      ares_buf_append_str(printmsg, \"\\t\");\n      ares_buf_append_str(printmsg, ares_dns_rec_type_tostr(ares_dns_rr_get_type(rr)));\n      ares_buf_append_str(printmsg, \"\\t\");\n      ares_buf_append_num_dec(printmsg, ares_dns_rr_get_ttl(rr), 0);\n      ares_buf_append_str(printmsg, \"\\t\");\n\n      size_t keys_cnt;\n      const ares_dns_rr_key_t *keys = ares_dns_rr_get_keys(ares_dns_rr_get_type(rr), &keys_cnt);\n      for (size_t k = 0; k<keys_cnt; k++) {\n        char buf[256] = \"\";\n        ares_buf_append_str(printmsg, ares_dns_rr_key_tostr(keys[k]));\n        ares_buf_append_str(printmsg, \"=\");\n        switch (ares_dns_rr_key_datatype(keys[k])) {\n          case ARES_DATATYPE_INADDR:\n            ares_inet_ntop(AF_INET, ares_dns_rr_get_addr(rr, keys[k]), buf, sizeof(buf));\n            ares_buf_append_str(printmsg, buf);\n            break;\n          case ARES_DATATYPE_INADDR6:\n            ares_inet_ntop(AF_INET6, ares_dns_rr_get_addr6(rr, keys[k]), buf, sizeof(buf));\n            ares_buf_append_str(printmsg, buf);\n            break;\n          case ARES_DATATYPE_U8:\n            ares_buf_append_num_dec(printmsg, ares_dns_rr_get_u8(rr, keys[k]), 0);\n            break;\n          case ARES_DATATYPE_U16:\n            ares_buf_append_num_dec(printmsg, ares_dns_rr_get_u16(rr, keys[k]), 0);\n            break;\n          case ARES_DATATYPE_U32:\n            ares_buf_append_num_dec(printmsg, ares_dns_rr_get_u32(rr, keys[k]), 0);\n            break;\n          case ARES_DATATYPE_NAME:\n          case ARES_DATATYPE_STR:\n            ares_buf_append_byte(printmsg, '\"');\n            ares_buf_append_str(printmsg, ares_dns_rr_get_str(rr, keys[k]));\n            ares_buf_append_byte(printmsg, '\"');\n            break;\n          case ARES_DATATYPE_BIN:\n            /* TODO */\n            break;\n          case ARES_DATATYPE_BINP:\n            {\n              ares_buf_append_byte(printmsg, '\"');\n              size_t templen;\n              ares_buf_append_str(printmsg, (const char *)ares_dns_rr_get_bin(rr, keys[k], &templen));\n              ares_buf_append_byte(printmsg, '\"');\n            }\n            break;\n          case ARES_DATATYPE_ABINP:\n            for (size_t a=0; a<ares_dns_rr_get_abin_cnt(rr, keys[k]); a++) {\n              if (a != 0) {\n                ares_buf_append_byte(printmsg, ' ');\n              }\n              ares_buf_append_byte(printmsg, '\"');\n              size_t templen;\n              ares_buf_append_str(printmsg, (const char *)ares_dns_rr_get_abin(rr, keys[k], a, &templen));\n              ares_buf_append_byte(printmsg, '\"');\n            }\n            break;\n          case ARES_DATATYPE_OPT:\n            /* TODO */\n            break;\n        }\n        ares_buf_append_str(printmsg, \" \");\n      }\n      ares_buf_append_str(printmsg, \"\\n\");\n    }\n  }\n  ares_buf_append_str(printmsg, \";; SIZE: \");\n  ares_buf_append_num_dec(printmsg, msglen, 0);\n  ares_buf_append_str(printmsg, \"\\n\\n\");\n\n  char *printdata = ares_buf_finish_str(printmsg, NULL);\n  //printf(\"%s\", printdata);\n  ares_free(printdata);\n\n  ares_dns_record_destroy(dnsrec);\n  ares_free_string(msg);\n\n  // Invalid\n  EXPECT_NE(ARES_SUCCESS, ares_dns_parse(NULL, 0, 0, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_dns_record_create(NULL, 0, 0, ARES_OPCODE_QUERY, ARES_RCODE_NOERROR));\n  EXPECT_EQ(0, ares_dns_record_get_id(NULL));\n  EXPECT_EQ(0, ares_dns_record_get_flags(NULL));\n  EXPECT_EQ(0, (int)ares_dns_record_get_opcode(NULL));\n  EXPECT_EQ(0, (int)ares_dns_record_get_rcode(NULL));\n  EXPECT_EQ(0, (int)ares_dns_record_query_cnt(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_dns_record_query_set_name(NULL, 0, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_dns_record_query_set_type(NULL, 0, ARES_REC_TYPE_A));\n  EXPECT_NE(ARES_SUCCESS, ares_dns_record_query_get(NULL, 0, NULL, NULL, NULL));\n  EXPECT_EQ(0, ares_dns_record_rr_cnt(NULL, ARES_SECTION_ANSWER));\n  EXPECT_NE(ARES_SUCCESS, ares_dns_record_rr_add(NULL, NULL, ARES_SECTION_ANSWER, NULL, ARES_REC_TYPE_A, ARES_CLASS_IN, 0));\n  EXPECT_NE(ARES_SUCCESS, ares_dns_record_rr_del(NULL, ARES_SECTION_ANSWER, 0));\n  EXPECT_EQ(nullptr, ares_dns_record_rr_get(NULL, ARES_SECTION_ANSWER, 0));\n  EXPECT_EQ(nullptr, ares_dns_rr_get_name(NULL));\n  EXPECT_EQ(0, (int)ares_dns_rr_get_type(NULL));\n  EXPECT_EQ(0, (int)ares_dns_rr_get_class(NULL));\n  EXPECT_EQ(0, ares_dns_rr_get_ttl(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_dns_write(NULL, NULL, NULL));\n#ifndef CARES_SYMBOL_HIDING\n  ares_dns_record_ttl_decrement(NULL, 0);\n#endif\n  EXPECT_EQ(nullptr, ares_dns_rr_get_addr(NULL, ARES_RR_A_ADDR));\n  EXPECT_EQ(nullptr, ares_dns_rr_get_addr(NULL, ARES_RR_NS_NSDNAME));\n  EXPECT_EQ(nullptr, ares_dns_rr_get_addr6(NULL, ARES_RR_AAAA_ADDR));\n  EXPECT_EQ(nullptr, ares_dns_rr_get_addr6(NULL, ARES_RR_NS_NSDNAME));\n  EXPECT_EQ(0, ares_dns_rr_get_u8(NULL, ARES_RR_SIG_ALGORITHM));\n  EXPECT_EQ(0, ares_dns_rr_get_u8(NULL, ARES_RR_NS_NSDNAME));\n  EXPECT_EQ(0, ares_dns_rr_get_u16(NULL, ARES_RR_MX_PREFERENCE));\n  EXPECT_EQ(0, ares_dns_rr_get_u16(NULL, ARES_RR_NS_NSDNAME));\n  EXPECT_EQ(0, ares_dns_rr_get_u32(NULL, ARES_RR_SOA_SERIAL));\n  EXPECT_EQ(0, ares_dns_rr_get_u32(NULL, ARES_RR_NS_NSDNAME));\n  EXPECT_EQ(nullptr, ares_dns_rr_get_bin(NULL, ARES_RR_TXT_DATA, NULL));\n  EXPECT_EQ(nullptr, ares_dns_rr_get_bin(NULL, ARES_RR_NS_NSDNAME, NULL));\n  EXPECT_EQ(nullptr, ares_dns_rr_get_str(NULL, ARES_RR_NS_NSDNAME));\n  EXPECT_EQ(nullptr, ares_dns_rr_get_str(NULL, ARES_RR_MX_PREFERENCE));\n  EXPECT_EQ(0, ares_dns_rr_get_opt_cnt(NULL, ARES_RR_OPT_OPTIONS));\n  EXPECT_EQ(0, ares_dns_rr_get_opt_cnt(NULL, ARES_RR_A_ADDR));\n  EXPECT_EQ(65535, ares_dns_rr_get_opt(NULL, ARES_RR_OPT_OPTIONS, 0, NULL, NULL));\n  EXPECT_EQ(65535, ares_dns_rr_get_opt(NULL, ARES_RR_A_ADDR, 0, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_dns_rr_get_opt_byid(NULL, ARES_RR_OPT_OPTIONS, 1, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_dns_rr_get_opt_byid(NULL, ARES_RR_A_ADDR, 1, NULL, NULL));\n}",
          "fn_code_pos": [
            [
              644,
              0
            ],
            [
              1099,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, DNSParseFlags) {\n  ares_dns_record_t   *dnsrec = NULL;\n  ares_dns_rr_t       *rr     = NULL;\n  struct in_addr       addr;\n  unsigned char       *msg    = NULL;\n  size_t               msglen = 0;\n\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_create(&dnsrec, 0x1234,\n      ARES_FLAG_QR|ARES_FLAG_AA|ARES_FLAG_RD|ARES_FLAG_RA,\n      ARES_OPCODE_QUERY, ARES_RCODE_NOERROR));\n\n  /* == Question == */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_query_add(dnsrec, \"example.com\",\n      ARES_REC_TYPE_ANY,\n      ARES_CLASS_IN));\n\n  /* == Answer == */\n  /* A */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_A, ARES_CLASS_IN, 300));\n  EXPECT_LT(0, ares_inet_pton(AF_INET, \"1.1.1.1\", &addr));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_addr(rr, ARES_RR_A_ADDR, &addr));\n  /* TLSA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER,\n      \"_443._tcp.example.com\", ARES_REC_TYPE_TLSA, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_CERT_USAGE, ARES_TLSA_USAGE_CA));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_SELECTOR, ARES_TLSA_SELECTOR_FULL));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_MATCH, ARES_TLSA_MATCH_SHA256));\n  const unsigned char tlsa[] = {\n    0xd2, 0xab, 0xde, 0x24, 0x0d, 0x7c, 0xd3, 0xee, 0x6b, 0x4b, 0x28, 0xc5,\n    0x4d, 0xf0, 0x34, 0xb9, 0x79, 0x83, 0xa1, 0xd1, 0x6e, 0x8a, 0x41, 0x0e,\n    0x45, 0x61, 0xcb, 0x10, 0x66, 0x18, 0xe9, 0x71 };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_TLSA_DATA, tlsa, sizeof(tlsa)));\n\n  /* == Authority == */\n  /* NS */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_AUTHORITY, \"example.com\",\n      ARES_REC_TYPE_NS, ARES_CLASS_IN, 38400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NS_NSDNAME, \"ns1.example.com\"));\n\n  /* == Additional */\n  /* PTR -- doesn't make sense, but ok */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"example.com\",\n      ARES_REC_TYPE_PTR, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_PTR_DNAME, \"b.example.com\"));\n\n  /* Write */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_write(dnsrec, &msg, &msglen));\n\n  /* Cleanup - before reuse */\n  ares_dns_record_destroy(dnsrec);\n\n  /* Parse \"base\" type records (1035) */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_parse(msg, msglen, ARES_DNS_PARSE_AN_BASE_RAW |\n    ARES_DNS_PARSE_NS_BASE_RAW | ARES_DNS_PARSE_AR_BASE_RAW, &dnsrec));\n\n  EXPECT_EQ(1, ares_dns_record_query_cnt(dnsrec));\n  EXPECT_EQ(2, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 0);\n  EXPECT_EQ(ARES_REC_TYPE_RAW_RR, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 1);\n  EXPECT_EQ(ARES_REC_TYPE_TLSA, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_AUTHORITY, 0);\n  EXPECT_EQ(ARES_REC_TYPE_RAW_RR, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ADDITIONAL, 0);\n  EXPECT_EQ(ARES_REC_TYPE_RAW_RR, ares_dns_rr_get_type(rr));\n\n  /* Cleanup - before reuse */\n\n  ares_dns_record_destroy(dnsrec);\n\n  /* Parse later RFCs (no name compression) type records */\n\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_parse(msg, msglen, ARES_DNS_PARSE_AN_EXT_RAW |\n    ARES_DNS_PARSE_NS_EXT_RAW | ARES_DNS_PARSE_AR_EXT_RAW, &dnsrec));\n\n  EXPECT_EQ(1, ares_dns_record_query_cnt(dnsrec));\n  EXPECT_EQ(2, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 0);\n  EXPECT_EQ(ARES_REC_TYPE_A, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 1);\n  EXPECT_EQ(ARES_REC_TYPE_RAW_RR, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_AUTHORITY, 0);\n  EXPECT_EQ(ARES_REC_TYPE_NS, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ADDITIONAL, 0);\n  EXPECT_EQ(ARES_REC_TYPE_PTR, ares_dns_rr_get_type(rr));\n\n  ares_dns_record_destroy(dnsrec);\n  ares_free_string(msg); msg = NULL;\n}",
          "fn_code_pos": [
            [
              1101,
              0
            ],
            [
              1215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ArrayMisuse) {\n  EXPECT_EQ(NULL, ares_array_create(0, NULL));\n  ares_array_destroy(NULL);\n  EXPECT_EQ(NULL, ares_array_finish(NULL, NULL));\n  EXPECT_EQ(0, ares_array_len(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_insert_at(NULL, NULL, 0));\n  EXPECT_NE(ARES_SUCCESS, ares_array_insertdata_at(NULL, 0, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_insert_last(NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_insertdata_last(NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_insert_first(NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_insertdata_first(NULL, NULL));\n  EXPECT_EQ(NULL, ares_array_at(NULL, 0));\n  EXPECT_EQ(NULL, ares_array_first(NULL));\n  EXPECT_EQ(NULL, ares_array_last(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_claim_at(NULL, 0, NULL, 0));\n  EXPECT_NE(ARES_SUCCESS, ares_array_remove_at(NULL, 0));\n  EXPECT_NE(ARES_SUCCESS, ares_array_remove_first(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_remove_last(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_sort(NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_array_set_size(NULL, 0));\n}",
          "fn_code_pos": [
            [
              1217,
              0
            ],
            [
              1237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, BufMisuse) {\n  EXPECT_EQ(NULL, ares_buf_create_const(NULL, 0));\n  ares_buf_reclaim(NULL);\n  EXPECT_NE(ARES_SUCCESS, ares_buf_append(NULL, NULL, 55));\n  size_t len = 10;\n  EXPECT_EQ(NULL, ares_buf_append_start(NULL, &len));\n  EXPECT_EQ(NULL, ares_buf_append_start(NULL, NULL));\n  ares_buf_append_finish(NULL, 0);\n  EXPECT_EQ(NULL, ares_buf_finish_bin(NULL, NULL));\n  EXPECT_EQ(NULL, ares_buf_finish_str(NULL, NULL));\n  ares_buf_tag(NULL);\n  EXPECT_NE(ARES_SUCCESS, ares_buf_tag_rollback(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_buf_tag_clear(NULL));\n  EXPECT_EQ(NULL, ares_buf_tag_fetch(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares_buf_tag_length(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_buf_tag_fetch_bytes(NULL, NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_buf_tag_fetch_string(NULL, NULL, 0));\n  EXPECT_NE(ARES_SUCCESS, ares_buf_fetch_bytes_dup(NULL, 0, ARES_FALSE, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_buf_fetch_str_dup(NULL, 0, NULL));\n  EXPECT_EQ((size_t)0, ares_buf_consume_whitespace(NULL, ARES_FALSE));\n  EXPECT_EQ((size_t)0, ares_buf_consume_nonwhitespace(NULL));\n  EXPECT_EQ((size_t)0, ares_buf_consume_line(NULL, ARES_FALSE));\n  EXPECT_EQ(ARES_FALSE, ares_buf_begins_with(NULL, NULL, 0));\n  EXPECT_EQ((size_t)0, ares_buf_get_position(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares_buf_set_position(NULL, 0));\n  EXPECT_NE(ARES_SUCCESS, ares_buf_parse_dns_binstr(NULL, 0, NULL, NULL));\n}",
          "fn_code_pos": [
            [
              1239,
              0
            ],
            [
              1265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableAsvpMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares_htable_asvp_insert(NULL, ARES_SOCKET_BAD, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_asvp_get(NULL, ARES_SOCKET_BAD, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_asvp_remove(NULL, ARES_SOCKET_BAD));\n  EXPECT_EQ((size_t)0, ares_htable_asvp_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              1267,
              0
            ],
            [
              1272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableStrvpMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares_htable_strvp_insert(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_strvp_get(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_strvp_remove(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares_htable_strvp_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              1274,
              0
            ],
            [
              1279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableVpStrMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares_htable_vpstr_insert(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_vpstr_get(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_vpstr_remove(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares_htable_vpstr_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              1281,
              0
            ],
            [
              1286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableDictMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares_htable_dict_insert(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_dict_get(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_dict_remove(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares_htable_dict_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              1288,
              0
            ],
            [
              1293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableSzvpMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares_htable_szvp_insert(NULL, 0, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_szvp_get(NULL, 0, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_szvp_remove(NULL, 0));\n  EXPECT_EQ((size_t)0, ares_htable_szvp_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              1295,
              0
            ],
            [
              1300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableVpvpMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares_htable_vpvp_insert(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_vpvp_get(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares_htable_vpvp_remove(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares_htable_vpvp_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              1302,
              0
            ],
            [
              1307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, LlistMisuse) {\n  ares_llist_replace_destructor(NULL, NULL);\n  EXPECT_EQ(NULL, ares_llist_insert_before(NULL, NULL));\n  EXPECT_EQ(NULL, ares_llist_insert_after(NULL, NULL));\n  EXPECT_EQ(NULL, ares_llist_node_last(NULL));\n  EXPECT_EQ(NULL, ares_llist_node_next(NULL));\n  EXPECT_EQ(NULL, ares_llist_node_prev(NULL));\n  EXPECT_EQ((size_t)0, ares_llist_len(NULL));\n  EXPECT_EQ(NULL, ares_llist_node_parent(NULL));\n  EXPECT_EQ(NULL, ares_llist_node_claim(NULL));\n  ares_llist_node_replace(NULL, NULL);\n}",
          "fn_code_pos": [
            [
              1309,
              0
            ],
            [
              1320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static void array_member_init(void *mb, unsigned int id)\n{\n  array_member_t *m = (array_member_t *)mb;\n  m->id             = id;\n  m->buf            = ares_buf_create();\n  ares_buf_append_be32(m->buf, id);\n}",
          "fn_code_pos": [
            [
              1327,
              0
            ],
            [
              1333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "array_member_init",
            "parameters": {
              "mb": "void",
              "id": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void array_member_destroy(void *mb)\n{\n  array_member_t *m = (array_member_t *)mb;\n  ares_buf_destroy(m->buf);\n}",
          "fn_code_pos": [
            [
              1335,
              0
            ],
            [
              1339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "array_member_destroy",
            "parameters": {
              "mb": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int array_sort_cmp(const void *data1, const void *data2)\n{\n  const array_member_t *m1 = (const array_member_t *)data1;\n  const array_member_t *m2 = (const array_member_t *)data2;\n  if (m1->id > m2->id)\n    return 1;\n  if (m1->id < m2->id)\n    return -1;\n  return 0;\n}",
          "fn_code_pos": [
            [
              1341,
              0
            ],
            [
              1350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "array_sort_cmp",
            "parameters": {
              "data1": "void",
              "data2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, Array) {\n  ares_array_t   *a       = NULL;\n  array_member_t *m       = NULL;\n  array_member_t  mbuf;\n  unsigned int    cnt     = 0;\n  unsigned int    removed = 0;\n  void           *ptr     = NULL;\n  size_t          i;\n\n  a = ares_array_create(sizeof(array_member_t), array_member_destroy);\n  EXPECT_NE(nullptr, a);\n\n  /* Try to sort with no elements, should break out */\n  EXPECT_EQ(ARES_SUCCESS, ares_array_sort(a, array_sort_cmp));\n\n  /* Add 8 elements */\n  for ( ; cnt < 8 ; cnt++) {\n    EXPECT_EQ(ARES_SUCCESS, ares_array_insert_last(&ptr, a));\n    array_member_init(ptr, cnt+1);\n  }\n\n  /* Insert at invalid index */\n  EXPECT_NE(ARES_SUCCESS, ares_array_insert_at(&ptr, a, 12345678));\n\n  /* Verify count */\n  EXPECT_EQ(cnt, ares_array_len(a));\n\n  /* Remove the first 2 elements */\n  EXPECT_EQ(ARES_SUCCESS, ares_array_remove_first(a));\n  EXPECT_EQ(ARES_SUCCESS, ares_array_remove_first(a));\n  removed += 2;\n\n  /* Verify count */\n  EXPECT_EQ(cnt-removed, ares_array_len(a));\n\n  /* Verify id of first element */\n  m = (array_member_t *)ares_array_first(a);\n  EXPECT_NE(nullptr, m);\n  EXPECT_EQ(3, m->id);\n\n\n  /* Add 100 total elements, this should force a shift of memory at some\n   * to make sure moves are working */\n  for ( ; cnt < 100 ; cnt++) {\n    EXPECT_EQ(ARES_SUCCESS, ares_array_insert_last(&ptr, a));\n    array_member_init(ptr, cnt+1);\n  }\n\n  /* Verify count */\n  EXPECT_EQ(cnt-removed, ares_array_len(a));\n\n  /* Remove 2 from the end */\n  EXPECT_EQ(ARES_SUCCESS, ares_array_remove_last(a));\n  EXPECT_EQ(ARES_SUCCESS, ares_array_remove_last(a));\n  removed += 2;\n\n  /* Verify count */\n  EXPECT_EQ(cnt-removed, ares_array_len(a));\n\n  /* Verify expected id of last member */\n  m = (array_member_t *)ares_array_last(a);\n  EXPECT_NE(nullptr, m);\n  EXPECT_EQ(cnt-2, m->id);\n\n  /* Remove 3 middle members */\n  EXPECT_EQ(ARES_SUCCESS, ares_array_remove_at(a, ares_array_len(a)/2));\n  EXPECT_EQ(ARES_SUCCESS, ares_array_remove_at(a, ares_array_len(a)/2));\n  EXPECT_EQ(ARES_SUCCESS, ares_array_remove_at(a, ares_array_len(a)/2));\n  removed += 3;\n\n  /* Verify count */\n  EXPECT_EQ(cnt-removed, ares_array_len(a));\n\n  /* Claim a middle member then re-add it at the same position */\n  i = ares_array_len(a) / 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_array_claim_at(&mbuf, sizeof(mbuf), a, i));\n  EXPECT_EQ(ARES_SUCCESS, ares_array_insert_at(&ptr, a, i));\n  array_member_init(ptr, mbuf.id);\n  array_member_destroy((void *)&mbuf);\n  /* Verify count */\n  EXPECT_EQ(cnt-removed, ares_array_len(a));\n\n  /* Iterate across the array, make sure each entry is greater than the last and\n   * the data in the buffer matches the id in the array */\n  unsigned int last_id = 0;\n  for (i=0; i<ares_array_len(a); i++) {\n    m = (array_member_t *)ares_array_at(a, i);\n    EXPECT_NE(nullptr, m);\n    EXPECT_GT(m->id, last_id);\n    last_id = m->id;\n\n    unsigned int bufval = 0;\n    ares_buf_tag(m->buf);\n    EXPECT_EQ(ARES_SUCCESS, ares_buf_fetch_be32(m->buf, &bufval));\n    ares_buf_tag_rollback(m->buf);\n    EXPECT_EQ(bufval, m->id);\n  }\n\n  /* add a new element in the middle to the beginning with a high id */\n  EXPECT_EQ(ARES_SUCCESS, ares_array_insert_at(&ptr, a, ares_array_len(a)/2));\n  array_member_init(ptr, 100000);\n\n  /* Sort the array */\n  EXPECT_EQ(ARES_SUCCESS, ares_array_sort(a, array_sort_cmp));\n\n  /* Iterate across the array, make sure each entry is greater than the last and\n   * the data in the buffer matches the id in the array */\n  last_id = 0;\n  for (i=0; i<ares_array_len(a); i++) {\n    m = (array_member_t *)ares_array_at(a, i);\n    EXPECT_NE(nullptr, m);\n    EXPECT_GT(m->id, last_id);\n    last_id = m->id;\n\n    unsigned int bufval = 0;\n    ares_buf_tag(m->buf);\n    EXPECT_EQ(ARES_SUCCESS, ares_buf_fetch_be32(m->buf, &bufval));\n    ares_buf_tag_rollback(m->buf);\n    EXPECT_EQ(bufval, m->id);\n  }\n\n  ares_array_destroy(a);\n}",
          "fn_code_pos": [
            [
              1352,
              0
            ],
            [
              1474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableVpvp) {\n  ares_llist_t       *l = NULL;\n  ares_htable_vpvp_t *h = NULL;\n  ares_llist_node_t  *n = NULL;\n  size_t               i;\n\n#define VPVP_TABLE_SIZE 1000\n\n  l = ares_llist_create(NULL);\n  EXPECT_NE((void *)NULL, l);\n\n  h = ares_htable_vpvp_create(NULL, ares_free);\n  EXPECT_NE((void *)NULL, h);\n\n  for (i=0; i<VPVP_TABLE_SIZE; i++) {\n    void *p = ares_malloc_zero(4);\n    EXPECT_NE((void *)NULL, p);\n    EXPECT_NE((void *)NULL, ares_llist_insert_last(l, p));\n    EXPECT_TRUE(ares_htable_vpvp_insert(h, p, p));\n  }\n\n  EXPECT_EQ(VPVP_TABLE_SIZE, ares_llist_len(l));\n  EXPECT_EQ(VPVP_TABLE_SIZE, ares_htable_vpvp_num_keys(h));\n\n  n = ares_llist_node_first(l);\n  EXPECT_NE((void *)NULL, n);\n  while (n != NULL) {\n    ares_llist_node_t *next = ares_llist_node_next(n);\n    void               *p    = ares_llist_node_val(n);\n    EXPECT_NE((void *)NULL, p);\n    EXPECT_EQ(p, ares_htable_vpvp_get_direct(h, p));\n    EXPECT_TRUE(ares_htable_vpvp_get(h, p, NULL));\n    EXPECT_TRUE(ares_htable_vpvp_remove(h, p));\n    ares_llist_node_destroy(n);\n    n = next;\n  }\n\n  EXPECT_EQ(0, ares_llist_len(l));\n  EXPECT_EQ(0, ares_htable_vpvp_num_keys(h));\n\n  ares_llist_destroy(l);\n  ares_htable_vpvp_destroy(h);\n}",
          "fn_code_pos": [
            [
              1476,
              0
            ],
            [
              1518,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, BufSplitStr) {\n  ares_buf_t  *buf   = NULL;\n  char        **strs  = NULL;\n  size_t        nstrs = 0;\n\n  buf = ares_buf_create();\n  ares_buf_append_str(buf, \"string1\\nstring2 string3\\t   \\nstring4\");\n  ares_buf_split_str(buf, (const unsigned char *)\"\\n \\t\", 2, ARES_BUF_SPLIT_TRIM, 0, &strs, &nstrs);\n  ares_buf_destroy(buf);\n\n  EXPECT_EQ(4, nstrs);\n  EXPECT_TRUE(ares_streq(strs[0], \"string1\"));\n  EXPECT_TRUE(ares_streq(strs[1], \"string2\"));\n  EXPECT_TRUE(ares_streq(strs[2], \"string3\"));\n  EXPECT_TRUE(ares_streq(strs[3], \"string4\"));\n  ares_free_array(strs, nstrs, ares_free);\n}",
          "fn_code_pos": [
            [
              1520,
              0
            ],
            [
              1536,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, BufReplace) {\n  ares_buf_t  *buf = NULL;\n  size_t       i;\n  struct {\n    const char *input;\n    const char *srch;\n    const char *rplc;\n    const char *output;\n  } tests[] = {\n    /* Same size */\n    { \"nameserver_1.2.3.4\\nnameserver_2.3.4.5\\n\", \"_\", \" \", \"nameserver 1.2.3.4\\nnameserver 2.3.4.5\\n\" },\n    /* Longer */\n    { \"nameserver_1.2.3.4\\nnameserver_2.3.4.5\\n\", \"_\", \"|||\", \"nameserver|||1.2.3.4\\nnameserver|||2.3.4.5\\n\" },\n    /* Shorter */\n    { \"nameserver_1.2.3.4\\nnameserver_2.3.4.5\\n\", \"_\", \"\", \"nameserver1.2.3.4\\nnameserver2.3.4.5\\n\" }\n  };\n  char        *str = NULL;\n\n  for (i=0; i<sizeof(tests)/sizeof(*tests); i++) {\n    buf = ares_buf_create();\n    EXPECT_EQ(ARES_SUCCESS, ares_buf_append_str(buf, tests[i].input));\n    EXPECT_EQ(ARES_SUCCESS, ares_buf_replace(buf, (const unsigned char *)tests[i].srch, ares_strlen(tests[i].srch), (const unsigned char *)tests[i].rplc, ares_strlen(tests[i].rplc)));\n    str = ares_buf_finish_str(buf, NULL);\n    EXPECT_STREQ(str, tests[i].output);\n    ares_free(str);\n  }\n}",
          "fn_code_pos": [
            [
              1538,
              0
            ],
            [
              1564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableAsvp) {\n  ares_llist_t       *l = NULL;\n  ares_htable_asvp_t *h = NULL;\n  ares_llist_node_t  *n = NULL;\n  size_t               i;\n\n#define ASVP_TABLE_SIZE 1000\n\n  l = ares_llist_create(NULL);\n  EXPECT_NE((void *)NULL, l);\n\n  h = ares_htable_asvp_create(ares_free);\n  EXPECT_NE((void *)NULL, h);\n\n  for (i=0; i<ASVP_TABLE_SIZE; i++) {\n    test_htable_asvp_t *a = (test_htable_asvp_t *)ares_malloc_zero(sizeof(*a));\n    EXPECT_NE((void *)NULL, a);\n    a->s = (ares_socket_t)i+1;\n    EXPECT_NE((void *)NULL, ares_llist_insert_last(l, a));\n    EXPECT_TRUE(ares_htable_asvp_insert(h, a->s, a));\n  }\n\n  EXPECT_EQ(ASVP_TABLE_SIZE, ares_llist_len(l));\n  EXPECT_EQ(ASVP_TABLE_SIZE, ares_htable_asvp_num_keys(h));\n\n  n = ares_llist_node_first(l);\n  EXPECT_NE((void *)NULL, n);\n  while (n != NULL) {\n    ares_llist_node_t *next = ares_llist_node_next(n);\n    test_htable_asvp_t *a    = (test_htable_asvp_t *)ares_llist_node_val(n);\n    EXPECT_NE((void *)NULL, a);\n    EXPECT_EQ(a, ares_htable_asvp_get_direct(h, a->s));\n    EXPECT_TRUE(ares_htable_asvp_get(h, a->s, NULL));\n    EXPECT_TRUE(ares_htable_asvp_remove(h, a->s));\n    ares_llist_node_destroy(n);\n    n = next;\n  }\n\n  EXPECT_EQ(0, ares_llist_len(l));\n  EXPECT_EQ(0, ares_htable_asvp_num_keys(h));\n\n  ares_llist_destroy(l);\n  ares_htable_asvp_destroy(h);\n}",
          "fn_code_pos": [
            [
              1570,
              0
            ],
            [
              1613,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableSzvp) {\n  ares_llist_t       *l = NULL;\n  ares_htable_szvp_t *h = NULL;\n  ares_llist_node_t  *n = NULL;\n  size_t               i;\n\n#define SZVP_TABLE_SIZE 1000\n\n  l = ares_llist_create(NULL);\n  EXPECT_NE((void *)NULL, l);\n\n  h = ares_htable_szvp_create(ares_free);\n  EXPECT_NE((void *)NULL, h);\n\n  for (i=0; i<SZVP_TABLE_SIZE; i++) {\n    test_htable_szvp_t *s = (test_htable_szvp_t *)ares_malloc_zero(sizeof(*s));\n    EXPECT_NE((void *)NULL, s);\n    s->s = i+1;\n    EXPECT_NE((void *)NULL, ares_llist_insert_last(l, s));\n    EXPECT_TRUE(ares_htable_szvp_insert(h, s->s, s));\n  }\n\n  EXPECT_EQ(SZVP_TABLE_SIZE, ares_llist_len(l));\n  EXPECT_EQ(SZVP_TABLE_SIZE, ares_htable_szvp_num_keys(h));\n\n  n = ares_llist_node_first(l);\n  EXPECT_NE((void *)NULL, n);\n  while (n != NULL) {\n    ares_llist_node_t *next = ares_llist_node_next(n);\n    test_htable_szvp_t *s    = (test_htable_szvp_t *)ares_llist_node_val(n);\n    EXPECT_NE((void *)NULL, s);\n    EXPECT_EQ(s, ares_htable_szvp_get_direct(h, s->s));\n    EXPECT_TRUE(ares_htable_szvp_get(h, s->s, NULL));\n    EXPECT_TRUE(ares_htable_szvp_remove(h, s->s));\n    ares_llist_node_destroy(n);\n    n = next;\n  }\n\n  EXPECT_EQ(0, ares_llist_len(l));\n  EXPECT_EQ(0, ares_htable_szvp_num_keys(h));\n\n  ares_llist_destroy(l);\n  ares_htable_szvp_destroy(h);\n}",
          "fn_code_pos": [
            [
              1620,
              0
            ],
            [
              1663,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableVpstr) {\n  ares_llist_t        *l = NULL;\n  ares_htable_vpstr_t *h = NULL;\n  ares_llist_node_t   *n = NULL;\n  size_t                i;\n\n#define VPSTR_TABLE_SIZE 1000\n\n  l = ares_llist_create(ares_free);\n  EXPECT_NE((void *)NULL, l);\n\n  h = ares_htable_vpstr_create();\n  EXPECT_NE((void *)NULL, h);\n\n  for (i=0; i<VPSTR_TABLE_SIZE; i++) {\n    test_htable_vpstr_t *s = (test_htable_vpstr_t *)ares_malloc_zero(sizeof(*s));\n    EXPECT_NE((void *)NULL, s);\n    snprintf(s->s, sizeof(s->s), \"%d\", (int)i);\n    EXPECT_NE((void *)NULL, ares_llist_insert_last(l, s));\n    EXPECT_TRUE(ares_htable_vpstr_insert(h, s, s->s));\n  }\n\n  EXPECT_EQ(VPSTR_TABLE_SIZE, ares_llist_len(l));\n  EXPECT_EQ(VPSTR_TABLE_SIZE, ares_htable_vpstr_num_keys(h));\n\n  n = ares_llist_node_first(l);\n  EXPECT_NE((void *)NULL, n);\n  while (n != NULL) {\n    ares_llist_node_t *next = ares_llist_node_next(n);\n    test_htable_vpstr_t *s   = (test_htable_vpstr_t *)ares_llist_node_val(n);\n    EXPECT_NE((void *)NULL, s);\n    EXPECT_STREQ(s->s, ares_htable_vpstr_get_direct(h, s));\n    EXPECT_TRUE(ares_htable_vpstr_get(h, s, NULL));\n    EXPECT_TRUE(ares_htable_vpstr_remove(h, s));\n    ares_llist_node_destroy(n);\n    n = next;\n  }\n\n  EXPECT_EQ(0, ares_llist_len(l));\n  EXPECT_EQ(0, ares_htable_vpstr_num_keys(h));\n\n  ares_llist_destroy(l);\n  ares_htable_vpstr_destroy(h);\n}",
          "fn_code_pos": [
            [
              1669,
              0
            ],
            [
              1712,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableStrvp) {\n  ares_llist_t        *l = NULL;\n  ares_htable_strvp_t *h = NULL;\n  ares_llist_node_t   *n = NULL;\n  size_t                i;\n\n#define STRVP_TABLE_SIZE 1000\n\n  l = ares_llist_create(NULL);\n  EXPECT_NE((void *)NULL, l);\n\n  h = ares_htable_strvp_create(ares_free);\n  EXPECT_NE((void *)NULL, h);\n\n  for (i=0; i<STRVP_TABLE_SIZE; i++) {\n    test_htable_strvp_t *s = (test_htable_strvp_t *)ares_malloc_zero(sizeof(*s));\n    EXPECT_NE((void *)NULL, s);\n    snprintf(s->s, sizeof(s->s), \"%d\", (int)i);\n    EXPECT_NE((void *)NULL, ares_llist_insert_last(l, s));\n    EXPECT_TRUE(ares_htable_strvp_insert(h, s->s, s));\n  }\n\n  EXPECT_EQ(STRVP_TABLE_SIZE, ares_llist_len(l));\n  EXPECT_EQ(STRVP_TABLE_SIZE, ares_htable_strvp_num_keys(h));\n\n  n = ares_llist_node_first(l);\n  EXPECT_NE((void *)NULL, n);\n  while (n != NULL) {\n    ares_llist_node_t *next = ares_llist_node_next(n);\n    test_htable_strvp_t *s   = (test_htable_strvp_t *)ares_llist_node_val(n);\n    EXPECT_NE((void *)NULL, s);\n    EXPECT_EQ(s, ares_htable_strvp_get_direct(h, s->s));\n    EXPECT_TRUE(ares_htable_strvp_get(h, s->s, NULL));\n    EXPECT_TRUE(ares_htable_strvp_remove(h, s->s));\n    ares_llist_node_destroy(n);\n    n = next;\n  }\n\n  EXPECT_EQ(0, ares_llist_len(l));\n  EXPECT_EQ(0, ares_htable_strvp_num_keys(h));\n\n  ares_llist_destroy(l);\n  ares_htable_strvp_destroy(h);\n}",
          "fn_code_pos": [
            [
              1719,
              0
            ],
            [
              1762,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableDict) {\n  ares_htable_dict_t  *h = NULL;\n  size_t               i;\n  char               **keys;\n  size_t               nkeys;\n\n#define DICT_TABLE_SIZE 1000\n\n  h = ares_htable_dict_create();\n  EXPECT_NE((void *)NULL, h);\n\n  for (i=0; i<DICT_TABLE_SIZE; i++) {\n    char key[32];\n    char val[32];\n    snprintf(key, sizeof(key), \"%d\", (int)i);\n    snprintf(val, sizeof(val), \"val%d\", (int)i);\n    EXPECT_TRUE(ares_htable_dict_insert(h, key, val));\n  }\n\n  EXPECT_EQ(DICT_TABLE_SIZE, ares_htable_dict_num_keys(h));\n\n  keys = ares_htable_dict_keys(h, &nkeys);\n  for (i=0; i<nkeys; i++) {\n    char val[32];\n    snprintf(val, sizeof(val), \"val%s\", keys[i]);\n    EXPECT_STREQ(val, ares_htable_dict_get_direct(h, keys[i]));\n    EXPECT_TRUE(ares_htable_dict_get(h, keys[i], NULL));\n    EXPECT_TRUE(ares_htable_dict_remove(h, keys[i]));\n  }\n  ares_free_array(keys, nkeys, ares_free);\n\n  EXPECT_EQ(0, ares_htable_dict_num_keys(h));\n\n  ares_htable_dict_destroy(h);\n}",
          "fn_code_pos": [
            [
              1764,
              0
            ],
            [
              1798,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SaveInvalidChannel) {\n  ares_slist_t *saved = channel_->servers;\n  channel_->servers = NULL;\n  struct ares_options opts;\n  int optmask = 0;\n  EXPECT_EQ(ARES_ENODATA, ares_save_options(channel_, &opts, &optmask));\n  channel_->servers = saved;\n}",
          "fn_code_pos": [
            [
              1800,
              0
            ],
            [
              1807,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int configure_socket(ares_socket_t s) {\n  // transposed from ares-process, simplified non-block setter.\n#if defined(USE_BLOCKING_SOCKETS)\n  return 0; /* returns success */\n#elif defined(HAVE_FCNTL_O_NONBLOCK)\n  /* most recent unix versions */\n  int flags;\n  flags = fcntl(s, F_GETFL, 0);\n  return fcntl(s, F_SETFL, flags | O_NONBLOCK);\n#elif defined(HAVE_IOCTL_FIONBIO)\n  /* older unix versions */\n  int flags = 1;\n  return ioctl(s, FIONBIO, &flags);\n#elif defined(HAVE_IOCTLSOCKET_FIONBIO)\n#ifdef WATT32\n  char flags = 1;\n#else\n  /* Windows */\n  unsigned long flags = 1UL;\n#endif\n  return ioctlsocket(s, (long)FIONBIO, &flags);\n#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)\n  /* Amiga */\n  long flags = 1L;\n  return IoctlSocket(s, FIONBIO, flags);\n#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)\n  /* BeOS */\n  long b = 1L;\n  return setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));\n#else\n#  error \"no non-blocking method was found/used/set\"\n#endif\n}",
          "fn_code_pos": [
            [
              1811,
              0
            ],
            [
              1843,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "configure_socket",
            "parameters": {
              "s": "ares_socket_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n    vector<string> inputs;\n    vector<string> delimiters;\n    vector<vector<string>> expected;\n  }",
          {
            "inputs": "vector<string>",
            "delimiters": "vector<string>",
            "expected": "vector<vector<string>>"
          },
          "",
          [
            100,
            2
          ],
          [
            104,
            3
          ]
        ],
        [
          "struct {\n    ares_bool_t success;\n    const char *uri;\n    const char *alt_match_uri;\n  }",
          {
            "success": "ares_bool_t",
            "char": "const"
          },
          "",
          [
            374,
            2
          ],
          [
            378,
            3
          ]
        ],
        [
          "typedef struct {\n  unsigned int id;\n  ares_buf_t *buf;\n} array_member_t;",
          {
            "id": "unsigned int",
            "*buf": "ares_buf_t"
          },
          "array_member_t",
          [
            1322,
            0
          ],
          [
            1325,
            17
          ]
        ],
        [
          "struct {\n    const char *input;\n    const char *srch;\n    const char *rplc;\n    const char *output;\n  }",
          {
            "char": "const"
          },
          "",
          [
            1541,
            2
          ],
          [
            1546,
            3
          ]
        ],
        [
          "typedef struct {\n  ares_socket_t s;\n} test_htable_asvp_t;",
          {
            "s": "ares_socket_t"
          },
          "test_htable_asvp_t",
          [
            1566,
            0
          ],
          [
            1568,
            21
          ]
        ],
        [
          "typedef struct {\n  size_t s;\n} test_htable_szvp_t;",
          {
            "s": "size_t"
          },
          "test_htable_szvp_t",
          [
            1616,
            0
          ],
          [
            1618,
            21
          ]
        ],
        [
          "typedef struct {\n  char s[32];\n} test_htable_vpstr_t;",
          {
            "s[32]": "char"
          },
          "test_htable_vpstr_t",
          [
            1665,
            0
          ],
          [
            1667,
            22
          ]
        ],
        [
          "typedef struct {\n  char s[32];\n} test_htable_strvp_t;",
          {
            "s[32]": "char"
          },
          "test_htable_strvp_t",
          [
            1715,
            0
          ],
          [
            1717,
            22
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            88,
            2
          ],
          [
            88,
            16
          ]
        ],
        [
          "struct {\n    vector<string> inputs;\n    vector<string> delimiters;\n    vector<vector<string>> expected;\n  }",
          {
            "inputs": "vector<string>",
            "delimiters": "vector<string>",
            "expected": "vector<vector<string>>"
          },
          "",
          [
            100,
            2
          ],
          [
            104,
            3
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            137,
            2
          ],
          [
            137,
            16
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            138,
            2
          ],
          [
            138,
            17
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            247,
            2
          ],
          [
            247,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            249,
            4
          ],
          [
            249,
            25
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            249,
            35
          ],
          [
            249,
            56
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            259,
            26
          ],
          [
            259,
            42
          ]
        ],
        [
          "struct {\n    ares_bool_t success;\n    const char *uri;\n    const char *alt_match_uri;\n  }",
          {
            "success": "ares_bool_t",
            "char": "const"
          },
          "",
          [
            374,
            2
          ],
          [
            378,
            3
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            477,
            2
          ],
          [
            477,
            16
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            478,
            2
          ],
          [
            478,
            17
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            489,
            2
          ],
          [
            489,
            18
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            489,
            28
          ],
          [
            489,
            44
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            489,
            61
          ],
          [
            489,
            77
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            530,
            2
          ],
          [
            530,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            550,
            2
          ],
          [
            550,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            570,
            2
          ],
          [
            570,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            590,
            2
          ],
          [
            590,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            605,
            2
          ],
          [
            605,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            618,
            2
          ],
          [
            618,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            647,
            2
          ],
          [
            647,
            16
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            648,
            2
          ],
          [
            648,
            22
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            832,
            2
          ],
          [
            832,
            18
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1104,
            2
          ],
          [
            1104,
            16
          ]
        ],
        [
          "typedef struct {\n  unsigned int id;\n  ares_buf_t *buf;\n} array_member_t;",
          {
            "id": "unsigned int",
            "*buf": "ares_buf_t"
          },
          "array_member_t",
          [
            1322,
            0
          ],
          [
            1325,
            17
          ]
        ],
        [
          "struct {\n    const char *input;\n    const char *srch;\n    const char *rplc;\n    const char *output;\n  }",
          {
            "char": "const"
          },
          "",
          [
            1541,
            2
          ],
          [
            1546,
            3
          ]
        ],
        [
          "typedef struct {\n  ares_socket_t s;\n} test_htable_asvp_t;",
          {
            "s": "ares_socket_t"
          },
          "test_htable_asvp_t",
          [
            1566,
            0
          ],
          [
            1568,
            21
          ]
        ],
        [
          "typedef struct {\n  size_t s;\n} test_htable_szvp_t;",
          {
            "s": "size_t"
          },
          "test_htable_szvp_t",
          [
            1616,
            0
          ],
          [
            1618,
            21
          ]
        ],
        [
          "typedef struct {\n  char s[32];\n} test_htable_vpstr_t;",
          {
            "s[32]": "char"
          },
          "test_htable_vpstr_t",
          [
            1665,
            0
          ],
          [
            1667,
            22
          ]
        ],
        [
          "typedef struct {\n  char s[32];\n} test_htable_strvp_t;",
          {
            "s[32]": "char"
          },
          "test_htable_strvp_t",
          [
            1715,
            0
          ],
          [
            1717,
            22
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1803,
            2
          ],
          [
            1803,
            21
          ]
        ],
        [
          "struct ares_socket_functions",
          {},
          "",
          [
            1847,
            6
          ],
          [
            1847,
            34
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"str/ares_strsplit.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"dsa/ares_htable.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#  include <sys/uio.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/dns-dump.cc": {
      "fn_def_list": [
        {
          "fn_code": "static void ShowFile(const char* filename) {\n  int fd = open(filename, O_RDONLY);\n  if (fd < 0) {\n    std::cerr << \"Failed to open '\" << filename << \"'\" << std::endl;\n    return;\n  }\n  std::vector<unsigned char> contents;\n  while (true) {\n    unsigned char buffer[1024];\n    ares_ssize_t len = read(fd, buffer, sizeof(buffer));\n    if (len <= 0) break;\n    contents.insert(contents.end(), buffer, buffer + len);\n  }\n  std::cout << PacketToString(contents) << std::endl;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowFile",
            "parameters": {
              "filename": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char* argv[]) {\n  for (int ii = 1; ii < argc; ++ii) {\n    ares::ShowFile(argv[ii]);\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <sys/types.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <iostream>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-fuzz.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ProcessFile(int fd)\n{\n  ares_ssize_t count = read(fd, afl_buffer, kMaxAflInputSize);\n  /*\n   * Make a copy of the data so that it's not part of a larger\n   * buffer (where buffer overflows would go unnoticed).\n   */\n  if (count > 0) {\n    unsigned char *copied_data = (unsigned char *)malloc((size_t)count);\n    memcpy(copied_data, afl_buffer, (size_t)count);\n    LLVMFuzzerTestOneInput(copied_data, (size_t)count);\n    free(copied_data);\n  }\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ProcessFile",
            "parameters": {
              "fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n  if (argc == 1) {\n    int count = 0;\n    while (KEEP_FUZZING(count)) {\n#ifndef STDIN_FILENO\n      ProcessFile(fileno(stdin));\n#else\n      ProcessFile(STDIN_FILENO);\n#endif\n      count++;\n    }\n  } else {\n    int ii;\n    for (ii = 1; ii < argc; ++ii) {\n      int fd = open(argv[ii], O_RDONLY);\n      if (fd < 0) {\n        fprintf(stderr, \"Failed to open '%s'\\n\", argv[ii]);\n        continue;\n      }\n      ProcessFile(fd);\n      close(fd);\n    }\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)",
          "fn_dec_pos": [
            [
              55,
              4
            ],
            [
              55,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares_queryloop.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ai_callback(void *arg, int status, int timeouts,\n                        struct ares_addrinfo *result)\n{\n  struct ares_addrinfo_node *node = NULL;\n  (void)timeouts;\n\n\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"%s: %s\\n\", (char *)arg, ares_strerror(status));\n    return;\n  }\n\n  for (node = result->nodes; node != NULL; node = node->ai_next) {\n    char        addr_buf[64] = \"\";\n    const void *ptr          = NULL;\n    if (node->ai_family == AF_INET) {\n      const struct sockaddr_in *in_addr =\n        (const struct sockaddr_in *)((void *)node->ai_addr);\n      ptr = &in_addr->sin_addr;\n    } else if (node->ai_family == AF_INET6) {\n      const struct sockaddr_in6 *in_addr =\n        (const struct sockaddr_in6 *)((void *)node->ai_addr);\n      ptr = &in_addr->sin6_addr;\n    } else {\n      continue;\n    }\n    ares_inet_ntop(node->ai_family, ptr, addr_buf, sizeof(addr_buf));\n    printf(\"%-32s\\t%s\\n\", result->name, addr_buf);\n  }\n\n  ares_freeaddrinfo(result);\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ai_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "result": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static BOOL WINAPI ctrlc_handler(_In_ DWORD dwCtrlType)\n{\n  switch (dwCtrlType) {\n    case CTRL_C_EVENT:\n      is_running = ARES_FALSE;\n      return TRUE;\n    default:\n      break;\n  }\n  return FALSE;\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ctrlc_handler",
            "parameters": {
              "DWORD": "_In_"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "static void ctrlc_handler(int sig)\n{\n  switch (sig) {\n    case SIGINT:\n      is_running = ARES_FALSE;\n      break;\n    default:\n      break;\n  }\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ctrlc_handler",
            "parameters": {
              "sig": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n  struct ares_options options;\n  int                 optmask = 0;\n  ares_channel_t     *channel;\n  size_t              count;\n  ares_status_t       status;\n\n#ifdef _WIN32\n  WORD    wVersionRequested = MAKEWORD(2, 2);\n  WSADATA wsaData;\n  WSAStartup(wVersionRequested, &wsaData);\n#endif\n\n  if (argc != 2) {\n    printf(\"Usage: %s domain\\n\", argv[0]);\n    return 1;\n  }\n\n  status = (ares_status_t)ares_library_init(ARES_LIB_INIT_ALL);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_library_init: %s\\n\", ares_strerror((int)status));\n    return 1;\n  }\n\n  memset(&options, 0, sizeof(options));\n  optmask                |= ARES_OPT_EVENT_THREAD;\n  options.evsys           = ARES_EVSYS_DEFAULT;\n  optmask                |= ARES_OPT_QUERY_CACHE;\n  options.qcache_max_ttl  = 0;\n\n  status = (ares_status_t)ares_init_options(&channel, &options, optmask);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_init: %s\\n\", ares_strerror((int)status));\n    return 1;\n  }\n\n#ifdef _WIN32\n  SetConsoleCtrlHandler(ctrlc_handler, TRUE);\n#else\n  signal(SIGINT, ctrlc_handler);\n#endif\n\n  printf(\"Querying for %s every 1s, press CTRL-C to quit...\\n\", argv[1]);\n\n  for (count = 1; is_running == ARES_TRUE; count++) {\n    struct ares_addrinfo_hints hints;\n    char                      *servers = ares_get_servers_csv(channel);\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    printf(\"Attempt %u using server list: %s ...\\n\", (unsigned int)count,\n           servers);\n    ares_free_string(servers);\n\n    ares_getaddrinfo(channel, argv[1], NULL, &hints, ai_callback, argv[1]);\n#ifdef _WIN32\n    Sleep(1000);\n#else\n    sleep(1);\n#endif\n  }\n\n  printf(\"CTRL-C captured, cleaning up...\\n\");\n  ares_destroy(channel);\n  ares_library_cleanup();\n\n#ifdef _WIN32\n  WSACleanup();\n#endif\n  return 0;\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            47,
            24
          ],
          [
            47,
            44
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            49,
            2
          ],
          [
            49,
            27
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            62,
            12
          ],
          [
            62,
            30
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            63,
            15
          ],
          [
            63,
            33
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            66,
            12
          ],
          [
            66,
            31
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            67,
            15
          ],
          [
            67,
            34
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            109,
            2
          ],
          [
            109,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            153,
            4
          ],
          [
            153,
            30
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <winsock2.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <signal.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-txt.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtReplyOK) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b(\"ABC\\0ABC\", 7);\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_NE(nullptr, txt);\n  EXPECT_EQ(std::vector<byte>(expected1.data(), expected1.data() + expected1.size()),\n            std::vector<byte>(txt->txt, txt->txt + txt->length));\n\n  struct ares_txt_reply* txt2 = txt->next;\n  ASSERT_NE(nullptr, txt2);\n  EXPECT_EQ(std::vector<byte>(expected2a.data(), expected2a.data() + expected2a.size()),\n            std::vector<byte>(txt2->txt, txt2->txt + txt2->length));\n\n  struct ares_txt_reply* txt3 = txt2->next;\n  ASSERT_NE(nullptr, txt3);\n  EXPECT_EQ(std::vector<byte>(expected2b.data(), expected2b.data() + expected2b.size()),\n            std::vector<byte>(txt3->txt, txt3->txt + txt3->length));\n  EXPECT_EQ(nullptr, txt3->next);\n  ares_free_data(txt);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtExtReplyOK) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b(\"ABC\\0ABC\", 7);\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_txt_ext* txt = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_txt_reply_ext(data.data(), (int)data.size(), &txt));\n  ASSERT_NE(nullptr, txt);\n  EXPECT_EQ(std::vector<byte>(expected1.data(), expected1.data() + expected1.size()),\n            std::vector<byte>(txt->txt, txt->txt + txt->length));\n  EXPECT_EQ(1, txt->record_start);\n\n  struct ares_txt_ext* txt2 = txt->next;\n  ASSERT_NE(nullptr, txt2);\n  EXPECT_EQ(std::vector<byte>(expected2a.data(), expected2a.data() + expected2a.size()),\n            std::vector<byte>(txt2->txt, txt2->txt + txt2->length));\n  EXPECT_EQ(1, txt2->record_start);\n\n  struct ares_txt_ext* txt3 = txt2->next;\n  ASSERT_NE(nullptr, txt3);\n  EXPECT_EQ(std::vector<byte>(expected2b.data(), expected2b.data() + expected2b.size()),\n            std::vector<byte>(txt3->txt, txt3->txt + txt3->length));\n  EXPECT_EQ(nullptr, txt3->next);\n  EXPECT_EQ(0, txt3->record_start);\n  ares_free_data(txt);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtEmpty) {\n  DNSPacket pkt;\n  std::string expected1 = \"\";\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}));\n  std::vector<byte> data = pkt.data();\n\n  ares_dns_record_t   *dnsrec = NULL;\n  ares_dns_rr_t       *rr     = NULL;\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_parse(data.data(), data.size(), 0, &dnsrec));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 0);\n  ASSERT_NE(nullptr, rr);\n  EXPECT_EQ(ARES_REC_TYPE_TXT, ares_dns_rr_get_type(rr));\n\n  size_t txtdata_len;\n  const unsigned char *txtdata;\n\n  /* Using array methodology */\n  EXPECT_EQ(1, ares_dns_rr_get_abin_cnt(rr, ARES_RR_TXT_DATA));\n  txtdata = ares_dns_rr_get_abin(rr, ARES_RR_TXT_DATA, 0, &txtdata_len);\n  EXPECT_EQ(txtdata_len, 0);\n  EXPECT_NE(nullptr, txtdata);\n\n  /* Using combined methodology */\n  txtdata = ares_dns_rr_get_bin(rr, ARES_RR_TXT_DATA, &txtdata_len);\n  EXPECT_EQ(txtdata_len, 0);\n  EXPECT_NE(nullptr, txtdata);\n\n  ares_dns_record_destroy(dnsrec); dnsrec = NULL;\n}",
          "fn_code_pos": [
            [
              97,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply1) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x03,  // rdata length\n    0x12, 'a', 'b',  // invalid length\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply2) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    // truncated\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              187,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply3) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x13,  // rdata length INVALID\n    0x02, 'a', 'b',\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              218,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply4) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, // TRUNCATED\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
          "fn_code_pos": [
            [
              220,
              0
            ],
            [
              240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtReplyErrors) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b = \"txt2b\";\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n  struct ares_txt_reply* txt = nullptr;\n  struct ares_txt_ext* txt_ext = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_TXT));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}));\n\n  // Truncated packets.\n  for (size_t len = 1; len < data.size(); len++) {\n    txt = nullptr;\n    EXPECT_NE(ARES_SUCCESS, ares_parse_txt_reply(data.data(), (int)len, &txt));\n    EXPECT_EQ(nullptr, txt);\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), -1, &txt));\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply_ext(data.data(), -1, &txt_ext));\n}",
          "fn_code_pos": [
            [
              242,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtReplyAllocFail) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b = \"txt2b\";\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_TXT))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n  struct ares_txt_reply* txt = nullptr;\n\n  for (int ii = 1; ii <= 13; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_txt_reply(data.data(), (int)data.size(), &txt)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              303,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            45,
            2
          ],
          [
            45,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            51,
            2
          ],
          [
            51,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            56,
            2
          ],
          [
            56,
            23
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            75,
            2
          ],
          [
            75,
            21
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            82,
            2
          ],
          [
            82,
            21
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            88,
            2
          ],
          [
            88,
            21
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            156,
            2
          ],
          [
            156,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            184,
            2
          ],
          [
            184,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            215,
            2
          ],
          [
            215,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            237,
            2
          ],
          [
            237,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            253,
            2
          ],
          [
            253,
            23
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            254,
            2
          ],
          [
            254,
            21
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            315,
            2
          ],
          [
            315,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-aaaa.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}))\n    .add_answer(new DNSARR(\"example.com\", 0x01020304, {2,3,4,5}));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[5];\n  int count = 5;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(100, info[0].ttl);\n  EXPECT_EQ(0x01, info[0].ip6addr._S6_un._S6_u8[0]);\n  EXPECT_EQ(0x02, info[0].ip6addr._S6_un._S6_u8[4]);\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[0101:0101:0202:0202:0303:0303:0404:0404]}\", ss.str());\n  ares_free_hostent(host);\n\n  // Repeat without providing places to put the results\n  count = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                nullptr, info, &count));\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyCname) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 50, \"c.example.com\"))\n    .add_answer(new DNSAaaaRR(\"c.example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[5];\n  int count = 5;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(1, count);\n  // CNAME TTL overrides AAAA TTL.\n  EXPECT_EQ(50, info[0].ttl);\n  EXPECT_EQ(0x01, info[0].ip6addr._S6_un._S6_u8[0]);\n  EXPECT_EQ(0x02, info[0].ip6addr._S6_un._S6_u8[4]);\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'c.example.com' aliases=[example.com] addrs=[0101:0101:0202:0202:0303:0303:0404:0404]}\", ss.str());\n  ares_free_hostent(host);\n\n  // Repeat without providing a hostent\n  count = 5;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                nullptr, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(50, info[0].ttl);\n  EXPECT_EQ(0x01, info[0].ip6addr._S6_un._S6_u8[0]);\n  EXPECT_EQ(0x02, info[0].ip6addr._S6_un._S6_u8[4]);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyNoData) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(0, count);\n  EXPECT_EQ(nullptr, host);\n\n  // Again but with a CNAME.\n  pkt.add_answer(new DNSCnameRR(\"example.com\", 200, \"c.example.com\"));\n  EXPECT_EQ(ARES_ENODATA, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(0, count);\n  EXPECT_EQ(nullptr, host);\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n  std::vector<byte> data;\n\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[2];\n  int count = 2;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                 &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_AAAA));\n\n  // Question != answer, this is ok as of Issue #683\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_AAAA));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'axample.com' aliases=[] addrs=[0101:0101:0202:0202:0303:0303:0404:0404]}\", ss.str());\n  ares_free_hostent(host);\n\n  host = nullptr;\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_AAAA));\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_AAAA));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                 &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_AAAA));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), (int)len,\n                                                   &host, info, &count));\n    EXPECT_EQ(nullptr, host);\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), (int)len,\n                                                   nullptr, info, &count));\n  }\n\n  // Negative length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), -1,\n                                                 &host, info, &count));\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSAaaaRR(\"c.example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[2];\n  int count = 2;\n\n  for (int ii = 1; ii <= 8; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                 &host, info, &count)) << ii;\n    EXPECT_EQ(nullptr, host);\n  }\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            43,
            2
          ],
          [
            43,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            22
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            73,
            2
          ],
          [
            73,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            74,
            2
          ],
          [
            74,
            22
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            104,
            2
          ],
          [
            104,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            105,
            2
          ],
          [
            105,
            22
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            129,
            2
          ],
          [
            129,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            130,
            2
          ],
          [
            130,
            22
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            212,
            2
          ],
          [
            212,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            213,
            2
          ],
          [
            213,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-uri.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_URI))\n    .add_answer(new DNSUriRR(\"example.com\", 100, 10, 20, \"uri.example.com\"))\n    .add_answer(new DNSUriRR(\"example.com\", 200, 11, 21, \"uri2.example.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  ASSERT_NE(nullptr, uri);\n\n  EXPECT_EQ(\"uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(10, uri->priority);\n  EXPECT_EQ(20, uri->weight);\n  EXPECT_EQ(100, uri->ttl);\n\n  struct ares_uri_reply* uri2 = uri->next;\n  ASSERT_NE(nullptr, uri2);\n  EXPECT_EQ(\"uri2.example.com\", std::string(uri2->uri));\n  EXPECT_EQ(11, uri2->priority);\n  EXPECT_EQ(21, uri2->weight);\n  EXPECT_EQ(200, uri2->ttl);\n  EXPECT_EQ(nullptr, uri2->next);\n\n  ares_free_data(uri);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplySingle) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_URI))\n    .add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else1.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else2.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else3.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else4.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else5.where.com\"))\n    .add_additional(new DNSARR(\"else2.where.com\", 42, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else5.where.com\", 42, {172,19,0,2}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  ASSERT_NE(nullptr, uri);\n\n  EXPECT_EQ(\"example.abc.def.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(10, uri->weight);\n  EXPECT_EQ(180, uri->ttl);\n  EXPECT_EQ(nullptr, uri->next);\n\n  ares_free_data(uri);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyMalformed) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x01, 0x00,  // type URI\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x01, 0x00,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length -- too short\n    0x02, 0x03, 0x04, 0x05,\n  };\n\n  struct ares_uri_reply* uri = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  ASSERT_EQ(nullptr, uri);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_ra().set_rd()\n    .add_question(new DNSQuestion(\"uri.example.com\", T_URI))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 600, 0, 5, \"a1.uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 660, 0, 5, \"a2.uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 720, 0, 5, \"a3.uri.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns3.example.com\"))\n    .add_additional(new DNSARR(\"a1.uri.example.com\", 300, {172,19,1,1}))\n    .add_additional(new DNSARR(\"a2.uri.example.com\", 300, {172,19,1,2}))\n    .add_additional(new DNSARR(\"a3.uri.example.com\", 300, {172,19,1,3}))\n    .add_additional(new DNSARR(\"n1.example.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"n2.example.com\", 300, {172,19,0,2}))\n    .add_additional(new DNSARR(\"n3.example.com\", 300, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri0 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri0));\n  ASSERT_NE(nullptr, uri0);\n  struct ares_uri_reply* uri = uri0;\n\n  EXPECT_EQ(\"a1.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(600, uri->ttl);\n  EXPECT_NE(nullptr, uri->next);\n  uri = uri->next;\n\n  EXPECT_EQ(\"a2.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(660, uri->ttl);\n  EXPECT_NE(nullptr, uri->next);\n  uri = uri->next;\n\n  EXPECT_EQ(\"a3.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(720, uri->ttl);\n  EXPECT_EQ(nullptr, uri->next);\n\n  ares_free_data(uri0);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyCname) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_URI))\n    .add_answer(new DNSCnameRR(\"example.abc.def.com\", 300, \"cname.abc.def.com\"))\n    .add_answer(new DNSUriRR(\"cname.abc.def.com\", 600, 0, 10, \"uri.abc.def.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else1.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else2.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else3.where.com\"))\n    .add_additional(new DNSARR(\"example.abc.def.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else1.where.com\", 42, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else2.where.com\", 42, {172,19,0,2}))\n    .add_additional(new DNSARR(\"else3.where.com\", 42, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  ASSERT_NE(nullptr, uri);\n\n  EXPECT_EQ(\"uri.abc.def.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(10, uri->weight);\n  EXPECT_EQ(600, uri->ttl);\n  EXPECT_EQ(nullptr, uri->next);\n\n  ares_free_data(uri);\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyCnameMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_ra().set_rd()\n    .add_question(new DNSQuestion(\"query.example.com\", T_URI))\n    .add_answer(new DNSCnameRR(\"query.example.com\", 300, \"uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 600, 0, 5, \"a1.uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 660, 0, 5, \"a2.uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 720, 0, 5, \"a3.uri.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns3.example.com\"))\n    .add_additional(new DNSARR(\"a1.uri.example.com\", 300, {172,19,1,1}))\n    .add_additional(new DNSARR(\"a2.uri.example.com\", 300, {172,19,1,2}))\n    .add_additional(new DNSARR(\"a3.uri.example.com\", 300, {172,19,1,3}))\n    .add_additional(new DNSARR(\"n1.example.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"n2.example.com\", 300, {172,19,0,2}))\n    .add_additional(new DNSARR(\"n3.example.com\", 300, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri0 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri0));\n  ASSERT_NE(nullptr, uri0);\n  struct ares_uri_reply* uri = uri0;\n\n  EXPECT_EQ(\"a1.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(600, uri->ttl);\n  EXPECT_NE(nullptr, uri->next);\n  uri = uri->next;\n\n  EXPECT_EQ(\"a2.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(660, uri->ttl);\n  EXPECT_NE(nullptr, uri->next);\n  uri = uri->next;\n\n  EXPECT_EQ(\"a3.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(720, uri->ttl);\n  EXPECT_EQ(nullptr, uri->next);\n\n  ares_free_data(uri0);\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_URI))\n    .add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"));\n  std::vector<byte> data;\n  struct ares_uri_reply* uri = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  pkt.add_question(new DNSQuestion(\"example.abc.def.com\", T_URI));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_URI));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_URI));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.abc.def.com\", T_URI));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  EXPECT_EQ(nullptr, uri);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  pkt.add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    int rc = ares_parse_uri_reply(data.data(), (int)len, &uri);\n    EXPECT_TRUE(rc == ARES_EBADRESP || rc == ARES_EBADNAME);\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_uri_reply(data.data(), -1, &uri));\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_URI))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"));\n  std::vector<byte> data = pkt.data();\n  struct ares_uri_reply* uri = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_uri_reply(data.data(), (int)data.size(), &uri)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            51,
            2
          ],
          [
            51,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            76,
            2
          ],
          [
            76,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            115,
            2
          ],
          [
            115,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            138,
            2
          ],
          [
            138,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            141,
            2
          ],
          [
            141,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            181,
            2
          ],
          [
            181,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            213,
            2
          ],
          [
            213,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            216,
            2
          ],
          [
            216,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            247,
            2
          ],
          [
            247,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            305,
            2
          ],
          [
            305,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-parse-ns.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseNsReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NS))\n    .add_answer(new DNSNsRR(\"example.com\", 100, \"ns.example.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'example.com' aliases=[ns.example.com] addrs=[]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNsReplyMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(10501).set_response().set_rd().set_ra()\n    .add_question(new DNSQuestion(\"google.com\", T_NS))\n    .add_answer(new DNSNsRR(\"google.com\", 59, \"ns1.google.com\"))\n    .add_answer(new DNSNsRR(\"google.com\", 59, \"ns2.google.com\"))\n    .add_answer(new DNSNsRR(\"google.com\", 59, \"ns3.google.com\"))\n    .add_answer(new DNSNsRR(\"google.com\", 59, \"ns4.google.com\"))\n    .add_additional(new DNSARR(\"ns4.google.com\", 247, {216,239,38,10}))\n    .add_additional(new DNSARR(\"ns2.google.com\", 247, {216,239,34,10}))\n    .add_additional(new DNSARR(\"ns1.google.com\", 247, {216,239,32,10}))\n    .add_additional(new DNSARR(\"ns3.google.com\", 247, {216,239,36,10}));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'google.com' aliases=[ns1.google.com, ns2.google.com, ns3.google.com, ns4.google.com] addrs=[]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNsReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NS))\n    .add_answer(new DNSNsRR(\"example.com\", 100, \"ns.example.com\"));\n  std::vector<byte> data;\n  struct hostent *host = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NS));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_NS));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NS));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NS));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NS));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSNsRR(\"example.com\", 100, \"ns.example.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.add_answer(new DNSNsRR(\"example.com\", 100, \"ns.example.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_ns_reply(data.data(), (int)len, &host));\n  }\n\n  // Negative Length\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ns_reply(data.data(), -1, &host));\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNsReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NS))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSNsRR(\"c.example.com\", 100, \"ns.example.com\"));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n\n  for (int ii = 1; ii <= 8; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_ns_reply(data.data(), (int)data.size(), &host)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            41,
            2
          ],
          [
            41,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            64,
            2
          ],
          [
            64,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            79,
            2
          ],
          [
            79,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            135,
            2
          ],
          [
            135,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test.h": {
      "fn_def_list": [
        {
          "fn_code": "LibraryTest()\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_library_init_mem(\n                              ARES_LIB_INIT_ALL, &LibraryTest::amalloc,\n                              &LibraryTest::afree, &LibraryTest::arealloc));\n  }",
          "fn_code_pos": [
            [
              127,
              2
            ],
            [
              132,
              3
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "LibraryTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~LibraryTest()\n  {\n    ares_library_cleanup();\n    ClearFails();\n  }",
          "fn_code_pos": [
            [
              134,
              2
            ],
            [
              138,
              3
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DefaultChannelTest() : channel_(nullptr)\n  {\n    /* Enable query cache for live tests */\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.qcache_max_ttl = 300;\n    int optmask         = ARES_OPT_QUERY_CACHE;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n  }",
          "fn_code_pos": [
            [
              168,
              2
            ],
            [
              177,
              3
            ]
          ],
          "class_code": "4377d3f420d85d9a41440b06b546578a96b47dca69a9447aaed7c5f542523ef7",
          "class_node_pos": [
            [
              166,
              0
            ],
            [
              190,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~DefaultChannelTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }",
          "fn_code_pos": [
            [
              179,
              2
            ],
            [
              183,
              3
            ]
          ],
          "class_code": "4377d3f420d85d9a41440b06b546578a96b47dca69a9447aaed7c5f542523ef7",
          "class_node_pos": [
            [
              166,
              0
            ],
            [
              190,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "FileChannelTest() : channel_(nullptr)\n  {\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.lookups = strdup(\"f\");\n    int optmask  = ARES_OPT_LOOKUPS;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n    free(opts.lookups);\n  }",
          "fn_code_pos": [
            [
              195,
              2
            ],
            [
              204,
              3
            ]
          ],
          "class_code": "b8dcaef941176e3eff8d31f3d714b93d0bc8364f907ff77894f000f40d7f674f",
          "class_node_pos": [
            [
              193,
              0
            ],
            [
              217,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FileChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~FileChannelTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }",
          "fn_code_pos": [
            [
              206,
              2
            ],
            [
              210,
              3
            ]
          ],
          "class_code": "b8dcaef941176e3eff8d31f3d714b93d0bc8364f907ff77894f000f40d7f674f",
          "class_node_pos": [
            [
              193,
              0
            ],
            [
              217,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DefaultChannelModeTest() : channel_(nullptr)\n  {\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.lookups = strdup(GetParam().c_str());\n    int optmask  = ARES_OPT_LOOKUPS;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n    free(opts.lookups);\n  }",
          "fn_code_pos": [
            [
              224,
              2
            ],
            [
              233,
              3
            ]
          ],
          "class_code": "f1ed14826e6b3f8b7597523acf7a8b20d120521ee2c855a7cf7cb79fe709318b",
          "class_node_pos": [
            [
              220,
              0
            ],
            [
              246,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultChannelModeTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~DefaultChannelModeTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }",
          "fn_code_pos": [
            [
              235,
              2
            ],
            [
              239,
              3
            ]
          ],
          "class_code": "f1ed14826e6b3f8b7597523acf7a8b20d120521ee2c855a7cf7cb79fe709318b",
          "class_node_pos": [
            [
              220,
              0
            ],
            [
              246,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SetReplyData(const std::vector<byte> &reply)\n  {\n    exact_reply_ = reply;\n    reply_       = nullptr;\n  }",
          "fn_code_pos": [
            [
              260,
              2
            ],
            [
              264,
              3
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetReplyData",
            "parameters": {
              "reply": "std::vector<byte>"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetReply(const DNSPacket *reply)\n  {\n    reply_ = reply;\n    exact_reply_.clear();\n  }",
          "fn_code_pos": [
            [
              266,
              2
            ],
            [
              270,
              3
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetReply",
            "parameters": {
              "reply": "DNSPacket"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetReplyExpRequest(const DNSPacket *reply, const std::string &request)\n  {\n    expected_request_ = request;\n    reply_            = reply;\n  }",
          "fn_code_pos": [
            [
              275,
              2
            ],
            [
              279,
              3
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetReplyExpRequest",
            "parameters": {
              "reply": "DNSPacket",
              "request": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetReplyQID(int qid)\n  {\n    qid_ = qid;\n  }",
          "fn_code_pos": [
            [
              281,
              2
            ],
            [
              284,
              3
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetReplyQID",
            "parameters": {
              "qid": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Disconnect()\n  {\n    reply_ = nullptr;\n    exact_reply_.clear();\n    for (ares_socket_t fd : connfds_) {\n      sclose(fd);\n    }\n    connfds_.clear();\n    free(tcp_data_);\n    tcp_data_     = NULL;\n    tcp_data_len_ = 0;\n  }",
          "fn_code_pos": [
            [
              286,
              2
            ],
            [
              297,
              3
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Disconnect",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned short          udpport() const\n  {\n    return udpport_;\n  }",
          "fn_code_pos": [
            [
              306,
              2
            ],
            [
              309,
              3
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "udpport",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned short tcpport() const\n  {\n    return tcpport_;\n  }",
          "fn_code_pos": [
            [
              311,
              2
            ],
            [
              314,
              3
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "tcpport",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockChannelTest()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              370,
              2
            ],
            [
              374,
              3
            ]
          ],
          "class_code": "f335b4a3a1118096497e85cfdb83714340a8db552cf8abdee5390d19f098a4ad",
          "class_node_pos": [
            [
              366,
              0
            ],
            [
              375,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPChannelTest()\n    : MockChannelOptsTest(1, GetParam(), false, false, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              380,
              2
            ],
            [
              383,
              3
            ]
          ],
          "class_code": "bbb79b17a40fc1490b6dffa8c5db9e5f1f978448f98d6d43878ca851dc420ba4",
          "class_node_pos": [
            [
              377,
              0
            ],
            [
              384,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockTCPChannelTest()\n    : MockChannelOptsTest(1, GetParam(), true, false, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              389,
              2
            ],
            [
              392,
              3
            ]
          ],
          "class_code": "6749df7c8d2fe134d112ad9b8d5e42d42a448adab936865acd7afb4ed5f5f137",
          "class_node_pos": [
            [
              386,
              0
            ],
            [
              393,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockTCPChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockEventThreadOptsTest(int count, ares_evsys_t evsys, int family,\n                          bool force_tcp, struct ares_options *givenopts,\n                          int optmask)\n    : MockChannelOptsTest(count, family, force_tcp, false,\n                          FillOptionsET(&evopts_, givenopts, evsys),\n                          optmask | ARES_OPT_EVENT_THREAD)\n  {\n  }",
          "fn_code_pos": [
            [
              397,
              2
            ],
            [
              404,
              3
            ]
          ],
          "class_code": "29fb68852689845a74a7323a37c71544ef644918b700310176720517d4d00ecb",
          "class_node_pos": [
            [
              395,
              0
            ],
            [
              427,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEventThreadOptsTest",
            "parameters": {
              "count": "int",
              "evsys": "ares_evsys_t",
              "family": "int",
              "force_tcp": "bool",
              "givenopts": "struct ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~MockEventThreadOptsTest()\n  {\n  }",
          "fn_code_pos": [
            [
              406,
              2
            ],
            [
              408,
              3
            ]
          ],
          "class_code": "29fb68852689845a74a7323a37c71544ef644918b700310176720517d4d00ecb",
          "class_node_pos": [
            [
              395,
              0
            ],
            [
              427,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options *FillOptionsET(struct ares_options *opts,\n                                            struct ares_options *givenopts,\n                                            ares_evsys_t         evsys)\n  {\n    if (givenopts) {\n      memcpy(opts, givenopts, sizeof(*opts));\n    } else {\n      memset(opts, 0, sizeof(*opts));\n    }\n    opts->evsys = evsys;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              410,
              2
            ],
            [
              421,
              3
            ]
          ],
          "class_code": "29fb68852689845a74a7323a37c71544ef644918b700310176720517d4d00ecb",
          "class_node_pos": [
            [
              395,
              0
            ],
            [
              427,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptionsET",
            "parameters": {
              "opts": "struct ares_options",
              "givenopts": "struct ares_options",
              "evsys": "ares_evsys_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), std::get<2>(GetParam()),\n                              nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              433,
              2
            ],
            [
              438,
              3
            ]
          ],
          "class_code": "416df76708421d9b1b63f219e598c1d99434e60b86be545c567df10e27f71449",
          "class_node_pos": [
            [
              429,
              0
            ],
            [
              439,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), false, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              445,
              2
            ],
            [
              449,
              3
            ]
          ],
          "class_code": "ddf7729b016031b17cc0a730a53d015b716a3935fd4cf39b978858f1547bd8b3",
          "class_node_pos": [
            [
              441,
              0
            ],
            [
              450,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockTCPEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), true, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              456,
              2
            ],
            [
              460,
              3
            ]
          ],
          "class_code": "a013685d30abc31cef70628484c6c9542dcd713933a40d979c6c516fddd3bd28",
          "class_node_pos": [
            [
              452,
              0
            ],
            [
              461,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockTCPEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(SetReplyData, mockserver, data)\n{\n  mockserver->SetReplyData(data);\n}",
          "fn_code_pos": [
            [
              464,
              0
            ],
            [
              467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(SetReplyAndFailSend, mockserver, reply)\n{\n  mockserver->SetReply(reply);\n  LibraryTest::SetFailSend();\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(SetReply, mockserver, reply)\n{\n  mockserver->SetReply(reply);\n}",
          "fn_code_pos": [
            [
              475,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P3(SetReplyExpRequest, mockserver, reply, request)\n{\n  mockserver->SetReplyExpRequest(reply, request);\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P3",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(SetReplyQID, mockserver, qid)\n{\n  mockserver->SetReplyQID(qid);\n}",
          "fn_code_pos": [
            [
              487,
              0
            ],
            [
              490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(CancelChannel, mockserver, channel)\n{\n  ares_cancel(channel);\n}",
          "fn_code_pos": [
            [
              493,
              0
            ],
            [
              496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P(Disconnect, mockserver)\n{\n  mockserver->Disconnect();\n}",
          "fn_code_pos": [
            [
              499,
              0
            ],
            [
              502,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "HostEnt() : addrtype_(-1)\n  {\n  }",
          "fn_code_pos": [
            [
              506,
              2
            ],
            [
              508,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostEnt",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "HostResult() : done_(false), status_(0), timeouts_(0)\n  {\n  }",
          "fn_code_pos": [
            [
              521,
              2
            ],
            [
              523,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostResult",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~AresDnsRecord()\n  {\n    ares_dns_record_destroy(dnsrec_);\n    dnsrec_ = NULL;\n  }",
          "fn_code_pos": [
            [
              538,
              2
            ],
            [
              542,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "AresDnsRecord() : dnsrec_(NULL)\n  {\n  }",
          "fn_code_pos": [
            [
              544,
              2
            ],
            [
              546,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AresDnsRecord",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SetDnsRecord(const ares_dns_record_t *dnsrec)\n  {\n    if (dnsrec_ != NULL) {\n      ares_dns_record_destroy(dnsrec_);\n    }\n    if (dnsrec == NULL) {\n      return;\n    }\n    dnsrec_ = ares_dns_record_duplicate(dnsrec);\n  }",
          "fn_code_pos": [
            [
              548,
              2
            ],
            [
              557,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetDnsRecord",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "QueryResult() : done_(false), status_(ARES_SUCCESS), timeouts_(0)\n  {\n  }",
          "fn_code_pos": [
            [
              566,
              2
            ],
            [
              568,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QueryResult",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void operator()(ares_addrinfo *ptr)\n  {\n    if (ptr) {\n      ares_freeaddrinfo(ptr);\n    }\n  }",
          "fn_code_pos": [
            [
              607,
              2
            ],
            [
              612,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "AddrInfoResult() : done_(false), status_(-1), timeouts_(0)\n  {\n  }",
          "fn_code_pos": [
            [
              622,
              2
            ],
            [
              624,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddrInfoResult",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "const char *filename() const\n  {\n    return filename_.c_str();\n  }",
          "fn_code_pos": [
            [
              683,
              2
            ],
            [
              686,
              3
            ]
          ],
          "class_code": "2cc16f98fce1852edef7d3c48f8e921cce4d6c66e0c0d3fee230c5b716b9d89b",
          "class_node_pos": [
            [
              679,
              0
            ],
            [
              687,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "filename",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int setenv(const char *name, const char *value, int overwrite)\n{\n  char  *buffer;\n  size_t buf_size;\n\n  if (name == NULL) {\n    return -1;\n  }\n\n  if (value == NULL) {\n    value = \"\"; /* For unset */\n  }\n\n  if (!overwrite && getenv(name) != NULL) {\n    return -1;\n  }\n\n  buf_size = strlen(name) + strlen(value) + 1 /* = */ + 1 /* NULL */;\n  buffer   = (char *)malloc(buf_size);\n  _snprintf(buffer, buf_size, \"%s=%s\", name, value);\n  _putenv(buffer);\n  free(buffer);\n  return 0;\n}",
          "fn_code_pos": [
            [
              692,
              0
            ],
            [
              715,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setenv",
            "parameters": {
              "name": "char",
              "value": "char",
              "overwrite": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int unsetenv(const char *name)\n{\n  return setenv(name, NULL, 1);\n}",
          "fn_code_pos": [
            [
              717,
              0
            ],
            [
              720,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unsetenv",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "EnvValue(const char *name, const char *value) : name_(name), restore_(false)\n  {\n    char *original = getenv(name);\n    if (original) {\n      restore_  = true;\n      original_ = original;\n    }\n    setenv(name_.c_str(), value, 1);\n  }",
          "fn_code_pos": [
            [
              728,
              2
            ],
            [
              736,
              3
            ]
          ],
          "class_code": "aff6eb4bfc699ae6929d60d45c420c9f6484b251bfb6d7759078d873544c79a4",
          "class_node_pos": [
            [
              726,
              0
            ],
            [
              751,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EnvValue",
            "parameters": {
              "name": "char",
              "value": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~EnvValue()\n  {\n    if (restore_) {\n      setenv(name_.c_str(), original_.c_str(), 1);\n    } else {\n      unsetenv(name_.c_str());\n    }\n  }",
          "fn_code_pos": [
            [
              738,
              2
            ],
            [
              745,
              3
            ]
          ],
          "class_code": "aff6eb4bfc699ae6929d60d45c420c9f6484b251bfb6d7759078d873544c79a4",
          "class_node_pos": [
            [
              726,
              0
            ],
            [
              751,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::string root() const\n  {\n    return rootdir_;\n  }",
          "fn_code_pos": [
            [
              765,
              2
            ],
            [
              768,
              3
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              760,
              0
            ],
            [
              781,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "root",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::string mountpt() const\n  {\n    return mountpt_;\n  }",
          "fn_code_pos": [
            [
              770,
              2
            ],
            [
              773,
              3
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              760,
              0
            ],
            [
              781,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "mountpt",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_sleep_time(unsigned int ms)",
          "fn_dec_pos": [
            [
              107,
              24
            ],
            [
              107,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sleep_time",
            "parameters": {
              "ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ProcessWork(ares_channel_t                          *channel,\n                                    std::function<std::set<ares_socket_t>()> get_extrafds,\n                                    std::function<void(ares_socket_t)>       process_extra,\n                                    unsigned int                             cancel_ms = 0)",
          "fn_dec_pos": [
            [
              111,
              24
            ],
            [
              114,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ProcessWork",
            "parameters": {
              "channel": "ares_channel_t",
              "get_extrafds": "std::function<std::set<ares_socket_t>()>",
              "process_extra": "std::function<void(ares_socket_t)>"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "NoExtraFDs()",
          "fn_dec_pos": [
            [
              115,
              24
            ],
            [
              115,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NoExtraFDs",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "af_tostr(int af)",
          "fn_dec_pos": [
            [
              117,
              24
            ],
            [
              117,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "af_tostr",
            "parameters": {
              "af": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "mode_tostr(bool mode)",
          "fn_dec_pos": [
            [
              118,
              24
            ],
            [
              118,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mode_tostr",
            "parameters": {
              "mode": "bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PrintFamilyMode(const testing::TestParamInfo<std::pair<int, bool>> &info)",
          "fn_dec_pos": [
            [
              120,
              2
            ],
            [
              120,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFamilyMode",
            "parameters": {
              "info": "testing::TestParamInfo<std::pair<int, bool>>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PrintFamily(const testing::TestParamInfo<int> &info)",
          "fn_dec_pos": [
            [
              121,
              12
            ],
            [
              121,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFamily",
            "parameters": {
              "info": "testing::TestParamInfo<int>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "SetAllocFail(int nth)",
          "fn_dec_pos": [
            [
              142,
              15
            ],
            [
              142,
              36
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetAllocFail",
            "parameters": {
              "nth": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SetAllocSizeFail(size_t size)",
          "fn_dec_pos": [
            [
              144,
              15
            ],
            [
              144,
              44
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetAllocSizeFail",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ClearFails()",
          "fn_dec_pos": [
            [
              146,
              15
            ],
            [
              146,
              27
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ClearFails",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "amalloc(size_t size)",
          "fn_dec_pos": [
            [
              148,
              15
            ],
            [
              148,
              35
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "amalloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "arealloc(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              149,
              15
            ],
            [
              149,
              47
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "arealloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "afree(void *ptr)",
          "fn_dec_pos": [
            [
              150,
              15
            ],
            [
              150,
              31
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "afree",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SetFailSend(void)",
          "fn_dec_pos": [
            [
              152,
              14
            ],
            [
              152,
              31
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetFailSend",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_sendv_fail(ares_socket_t socket, const struct iovec *vec, int len,\n                                      void *user_data)",
          "fn_dec_pos": [
            [
              153,
              22
            ],
            [
              154,
              54
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ares_sendv_fail",
            "parameters": {
              "socket": "ares_socket_t",
              "vec": "struct iovec",
              "len": "int",
              "user_data": "void"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "ShouldAllocFail(size_t size)",
          "fn_dec_pos": [
            [
              158,
              31
            ],
            [
              158,
              59
            ]
          ],
          "class_code": "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f",
          "class_node_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ShouldAllocFail",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              186,
              7
            ],
            [
              186,
              42
            ]
          ],
          "class_code": "4377d3f420d85d9a41440b06b546578a96b47dca69a9447aaed7c5f542523ef7",
          "class_node_pos": [
            [
              166,
              0
            ],
            [
              190,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              213,
              7
            ],
            [
              213,
              42
            ]
          ],
          "class_code": "b8dcaef941176e3eff8d31f3d714b93d0bc8364f907ff77894f000f40d7f674f",
          "class_node_pos": [
            [
              193,
              0
            ],
            [
              217,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              242,
              7
            ],
            [
              242,
              42
            ]
          ],
          "class_code": "f1ed14826e6b3f8b7597523acf7a8b20d120521ee2c855a7cf7cb79fe709318b",
          "class_node_pos": [
            [
              220,
              0
            ],
            [
              246,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockServer(int family, unsigned short port)",
          "fn_dec_pos": [
            [
              251,
              2
            ],
            [
              251,
              45
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockServer",
            "parameters": {
              "family": "int",
              "port": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~MockServer()",
          "fn_dec_pos": [
            [
              252,
              2
            ],
            [
              252,
              15
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MOCK_METHOD2(OnRequest, void(const std::string &name, int rrtype))",
          "fn_dec_pos": [
            [
              256,
              2
            ],
            [
              256,
              68
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MOCK_METHOD2",
            "parameters": {
              "name": "std::string",
              "rrtype": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "fds() const",
          "fn_dec_pos": [
            [
              300,
              26
            ],
            [
              300,
              37
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "fds",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ProcessFD(ares_socket_t fd)",
          "fn_dec_pos": [
            [
              303,
              26
            ],
            [
              303,
              53
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessFD",
            "parameters": {
              "fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ProcessRequest(ares_socket_t fd, struct sockaddr_storage *addr,\n                                ares_socklen_t addrlen, const std::vector<byte> &req,\n                                const std::string &reqstr, int qid, const char *name,\n                                int rrtype)",
          "fn_dec_pos": [
            [
              317,
              17
            ],
            [
              320,
              43
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessRequest",
            "parameters": {
              "fd": "ares_socket_t",
              "addr": "struct sockaddr_storage",
              "addrlen": "ares_socklen_t",
              "req": "std::vector<byte>",
              "reqstr": "std::string",
              "qid": "int",
              "name": "char",
              "rrtype": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ProcessPacket(ares_socket_t fd, struct sockaddr_storage *addr,\n                               ares_socklen_t addrlen, byte *data, int len)",
          "fn_dec_pos": [
            [
              321,
              17
            ],
            [
              322,
              75
            ]
          ],
          "class_code": "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4",
          "class_node_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessPacket",
            "parameters": {
              "fd": "ares_socket_t",
              "addr": "struct sockaddr_storage",
              "addrlen": "ares_socklen_t",
              "data": "byte",
              "len": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockChannelOptsTest(int count, int family, bool force_tcp,\n                      bool honor_sysconfig, struct ares_options *givenopts,\n                      int optmask)",
          "fn_dec_pos": [
            [
              339,
              2
            ],
            [
              341,
              34
            ]
          ],
          "class_code": "f8613c5205842c7db643e5a9b84796701a2fe6498e9f1e727bf88fff39da47b3",
          "class_node_pos": [
            [
              337,
              0
            ],
            [
              364,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockChannelOptsTest",
            "parameters": {
              "count": "int",
              "family": "int",
              "force_tcp": "bool",
              "honor_sysconfig": "bool",
              "givenopts": "struct ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~MockChannelOptsTest()",
          "fn_dec_pos": [
            [
              342,
              2
            ],
            [
              342,
              24
            ]
          ],
          "class_code": "f8613c5205842c7db643e5a9b84796701a2fe6498e9f1e727bf88fff39da47b3",
          "class_node_pos": [
            [
              337,
              0
            ],
            [
              364,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ProcessAltChannel(ares_channel_t *chan, unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              346,
              7
            ],
            [
              346,
              74
            ]
          ],
          "class_code": "f8613c5205842c7db643e5a9b84796701a2fe6498e9f1e727bf88fff39da47b3",
          "class_node_pos": [
            [
              337,
              0
            ],
            [
              364,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessAltChannel",
            "parameters": {
              "chan": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              347,
              7
            ],
            [
              347,
              42
            ]
          ],
          "class_code": "f8613c5205842c7db643e5a9b84796701a2fe6498e9f1e727bf88fff39da47b3",
          "class_node_pos": [
            [
              337,
              0
            ],
            [
              364,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "fds() const",
          "fn_dec_pos": [
            [
              354,
              55
            ],
            [
              354,
              66
            ]
          ],
          "class_code": "f8613c5205842c7db643e5a9b84796701a2fe6498e9f1e727bf88fff39da47b3",
          "class_node_pos": [
            [
              337,
              0
            ],
            [
              364,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "fds",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ProcessFD(ares_socket_t fd)",
          "fn_dec_pos": [
            [
              355,
              25
            ],
            [
              355,
              52
            ]
          ],
          "class_code": "f8613c5205842c7db643e5a9b84796701a2fe6498e9f1e727bf88fff39da47b3",
          "class_node_pos": [
            [
              337,
              0
            ],
            [
              364,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessFD",
            "parameters": {
              "fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "BuildServers(int count, int family,\n                                      unsigned short base_port)",
          "fn_dec_pos": [
            [
              357,
              25
            ],
            [
              358,
              63
            ]
          ],
          "class_code": "f8613c5205842c7db643e5a9b84796701a2fe6498e9f1e727bf88fff39da47b3",
          "class_node_pos": [
            [
              337,
              0
            ],
            [
              364,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BuildServers",
            "parameters": {
              "count": "int",
              "family": "int",
              "base_port": "unsigned short"
            },
            "return_type": "NiceMockServers"
          }
        },
        {
          "fn_code": "FillOptionsET(struct ares_options *opts,\n                                            struct ares_options *givenopts,\n                                            ares_evsys_t         evsys)",
          "fn_dec_pos": [
            [
              410,
              30
            ],
            [
              412,
              71
            ]
          ],
          "class_code": "29fb68852689845a74a7323a37c71544ef644918b700310176720517d4d00ecb",
          "class_node_pos": [
            [
              395,
              0
            ],
            [
              427,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptionsET",
            "parameters": {
              "opts": "struct ares_options",
              "givenopts": "struct ares_options",
              "evsys": "ares_evsys_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              423,
              7
            ],
            [
              423,
              42
            ]
          ],
          "class_code": "29fb68852689845a74a7323a37c71544ef644918b700310176720517d4d00ecb",
          "class_node_pos": [
            [
              395,
              0
            ],
            [
              427,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "HostEnt(const struct hostent *hostent)",
          "fn_dec_pos": [
            [
              510,
              2
            ],
            [
              510,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostEnt",
            "parameters": {
              "hostent": "struct hostent"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const HostEnt &result)",
          "fn_dec_pos": [
            [
              517,
              14
            ],
            [
              517,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "HostEnt"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const HostResult &result)",
          "fn_dec_pos": [
            [
              534,
              14
            ],
            [
              534,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "HostResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const AresDnsRecord &result)",
          "fn_dec_pos": [
            [
              562,
              14
            ],
            [
              562,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "AresDnsRecord"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const QueryResult &result)",
          "fn_dec_pos": [
            [
              579,
              14
            ],
            [
              579,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "QueryResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const SearchResult &result)",
          "fn_dec_pos": [
            [
              591,
              14
            ],
            [
              591,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "SearchResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const NameInfoResult &result)",
          "fn_dec_pos": [
            [
              604,
              14
            ],
            [
              604,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "NameInfoResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const AddrInfo &result)",
          "fn_dec_pos": [
            [
              618,
              14
            ],
            [
              618,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "AddrInfo"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const AddrInfoResult &result)",
          "fn_dec_pos": [
            [
              635,
              14
            ],
            [
              635,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "AddrInfoResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "HostCallback(void *data, int status, int timeouts,\n                           struct hostent *hostent)",
          "fn_dec_pos": [
            [
              639,
              14
            ],
            [
              640,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "hostent": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "QueryCallback(void *data, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              641,
              14
            ],
            [
              642,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QueryCallback",
            "parameters": {
              "data": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SearchCallback(void *data, int status, int timeouts, unsigned char *abuf,\n                    int alen)",
          "fn_dec_pos": [
            [
              643,
              5
            ],
            [
              644,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "abuf": "unsigned char",
              "alen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SearchCallbackDnsRec(void *data, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              645,
              5
            ],
            [
              646,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchCallbackDnsRec",
            "parameters": {
              "data": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "NameInfoCallback(void *data, int status, int timeouts, char *node,\n                      char *service)",
          "fn_dec_pos": [
            [
              647,
              5
            ],
            [
              648,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NameInfoCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "node": "char",
              "service": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "AddrInfoCallback(void *data, int status, int timeouts,\n                      struct ares_addrinfo *res)",
          "fn_dec_pos": [
            [
              649,
              5
            ],
            [
              650,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddrInfoCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "res": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "GetNameServers(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              653,
              12
            ],
            [
              653,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetNameServers",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientDir(const std::string &dirname)",
          "fn_dec_pos": [
            [
              658,
              2
            ],
            [
              658,
              42
            ]
          ],
          "class_code": "f4000971275b5ab39b02fc25980d8c6168bd5ff4fc5ad590f06bc43c3d2086cc",
          "class_node_pos": [
            [
              656,
              0
            ],
            [
              663,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TransientDir",
            "parameters": {
              "dirname": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~TransientDir()",
          "fn_dec_pos": [
            [
              659,
              2
            ],
            [
              659,
              17
            ]
          ],
          "class_code": "f4000971275b5ab39b02fc25980d8c6168bd5ff4fc5ad590f06bc43c3d2086cc",
          "class_node_pos": [
            [
              656,
              0
            ],
            [
              663,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TempNam(const char *dir, const char *prefix)",
          "fn_dec_pos": [
            [
              666,
              12
            ],
            [
              666,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TempNam",
            "parameters": {
              "dir": "char",
              "prefix": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientFile(const std::string &filename, const std::string &contents)",
          "fn_dec_pos": [
            [
              671,
              2
            ],
            [
              671,
              73
            ]
          ],
          "class_code": "c29cae8889cb2f9c7a834d78235fdbbbf3060e3fddc198058d4f47776778b696",
          "class_node_pos": [
            [
              669,
              0
            ],
            [
              676,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TransientFile",
            "parameters": {
              "filename": "std::string",
              "contents": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~TransientFile()",
          "fn_dec_pos": [
            [
              672,
              2
            ],
            [
              672,
              18
            ]
          ],
          "class_code": "c29cae8889cb2f9c7a834d78235fdbbbf3060e3fddc198058d4f47776778b696",
          "class_node_pos": [
            [
              669,
              0
            ],
            [
              676,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TempFile(const std::string &contents)",
          "fn_dec_pos": [
            [
              681,
              2
            ],
            [
              681,
              39
            ]
          ],
          "class_code": "2cc16f98fce1852edef7d3c48f8e921cce4d6c66e0c0d3fee230c5b716b9d89b",
          "class_node_pos": [
            [
              679,
              0
            ],
            [
              687,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TempFile",
            "parameters": {
              "contents": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "filename() const",
          "fn_dec_pos": [
            [
              683,
              14
            ],
            [
              683,
              30
            ]
          ],
          "class_code": "2cc16f98fce1852edef7d3c48f8e921cce4d6c66e0c0d3fee230c5b716b9d89b",
          "class_node_pos": [
            [
              679,
              0
            ],
            [
              687,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "filename",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ContainerFilesystem(NameContentList files, const std::string &mountpt)",
          "fn_dec_pos": [
            [
              762,
              2
            ],
            [
              762,
              72
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              760,
              0
            ],
            [
              781,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ContainerFilesystem",
            "parameters": {
              "files": "NameContentList",
              "mountpt": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~ContainerFilesystem()",
          "fn_dec_pos": [
            [
              763,
              2
            ],
            [
              763,
              24
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              760,
              0
            ],
            [
              781,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "EnsureDirExists(const std::string &dir)",
          "fn_dec_pos": [
            [
              776,
              25
            ],
            [
              776,
              64
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              760,
              0
            ],
            [
              781,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EnsureDirExists",
            "parameters": {
              "dir": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "RunInContainer(ContainerFilesystem *fs, const std::string &hostname,\n                   const std::string &domainname, VoidToIntFn fn)",
          "fn_dec_pos": [
            [
              783,
              4
            ],
            [
              784,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RunInContainer",
            "parameters": {
              "fs": "ContainerFilesystem",
              "hostname": "std::string",
              "domainname": "std::string",
              "fn": "VoidToIntFn"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "VirtualizeIO(ares_channel)",
          "fn_dec_pos": [
            [
              863,
              2
            ],
            [
              863,
              28
            ]
          ],
          "class_code": "e856eee93a2c9edd8becd9b9f3bbd8f02b31a545dcdd4ce2a4f82a54999c8677",
          "class_node_pos": [
            [
              861,
              0
            ],
            [
              870,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VirtualizeIO",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~VirtualizeIO()",
          "fn_dec_pos": [
            [
              864,
              2
            ],
            [
              864,
              17
            ]
          ],
          "class_code": "e856eee93a2c9edd8becd9b9f3bbd8f02b31a545dcdd4ce2a4f82a54999c8677",
          "class_node_pos": [
            [
              861,
              0
            ],
            [
              870,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "d2ecc79f2899de93e3141eb0ef705ba85abc96753565e768e217959dd31ce12f": {
          "class_code": "class LibraryTest : public ::testing::Test {\npublic:\n  LibraryTest()\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_library_init_mem(\n                              ARES_LIB_INIT_ALL, &LibraryTest::amalloc,\n                              &LibraryTest::afree, &LibraryTest::arealloc));\n  }\n\n  ~LibraryTest()\n  {\n    ares_library_cleanup();\n    ClearFails();\n  }\n\n  // Set the n-th malloc call (of any size) from the library to fail.\n  // (nth == 1 means the next call)\n  static void  SetAllocFail(int nth);\n  // Set the next malloc call for the given size to fail.\n  static void  SetAllocSizeFail(size_t size);\n  // Remove any pending alloc failures.\n  static void  ClearFails();\n\n  static void *amalloc(size_t size);\n  static void *arealloc(void *ptr, size_t size);\n  static void  afree(void *ptr);\n\n  static void SetFailSend(void);\n  static ares_ssize_t ares_sendv_fail(ares_socket_t socket, const struct iovec *vec, int len,\n                                      void *user_data);\n\n\nprivate:\n  static bool                  ShouldAllocFail(size_t size);\n  static unsigned long long    fails_;\n  static std::map<size_t, int> size_fails_;\n  static std::mutex            lock_;\n  static bool                  failsend_;\n}",
          "class_name": "LibraryTest",
          "class_pos": [
            [
              125,
              0
            ],
            [
              163,
              1
            ]
          ]
        },
        "4377d3f420d85d9a41440b06b546578a96b47dca69a9447aaed7c5f542523ef7": {
          "class_code": "class DefaultChannelTest : public LibraryTest {\npublic:\n  DefaultChannelTest() : channel_(nullptr)\n  {\n    /* Enable query cache for live tests */\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.qcache_max_ttl = 300;\n    int optmask         = ARES_OPT_QUERY_CACHE;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n  }\n\n  ~DefaultChannelTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }\n\n  // Process all pending work on ares-owned file descriptors.\n  void Process(unsigned int cancel_ms = 0);\n\nprotected:\n  ares_channel_t *channel_;\n}",
          "class_name": "DefaultChannelTest",
          "class_pos": [
            [
              166,
              0
            ],
            [
              190,
              1
            ]
          ]
        },
        "b8dcaef941176e3eff8d31f3d714b93d0bc8364f907ff77894f000f40d7f674f": {
          "class_code": "class FileChannelTest : public LibraryTest {\npublic:\n  FileChannelTest() : channel_(nullptr)\n  {\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.lookups = strdup(\"f\");\n    int optmask  = ARES_OPT_LOOKUPS;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n    free(opts.lookups);\n  }\n\n  ~FileChannelTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }\n\n  // Process all pending work on ares-owned file descriptors.\n  void Process(unsigned int cancel_ms = 0);\n\nprotected:\n  ares_channel_t *channel_;\n}",
          "class_name": "FileChannelTest",
          "class_pos": [
            [
              193,
              0
            ],
            [
              217,
              1
            ]
          ]
        },
        "f1ed14826e6b3f8b7597523acf7a8b20d120521ee2c855a7cf7cb79fe709318b": {
          "class_code": "class DefaultChannelModeTest\n  : public LibraryTest,\n    public ::testing::WithParamInterface<std::string> {\npublic:\n  DefaultChannelModeTest() : channel_(nullptr)\n  {\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.lookups = strdup(GetParam().c_str());\n    int optmask  = ARES_OPT_LOOKUPS;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n    free(opts.lookups);\n  }\n\n  ~DefaultChannelModeTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }\n\n  // Process all pending work on ares-owned file descriptors.\n  void Process(unsigned int cancel_ms = 0);\n\nprotected:\n  ares_channel_t *channel_;\n}",
          "class_name": "DefaultChannelModeTest",
          "class_pos": [
            [
              220,
              0
            ],
            [
              246,
              1
            ]
          ]
        },
        "12acb55a33bb3f5a4e061db16372fee4c53297232ede53f8ad252d1a4309c2b4": {
          "class_code": "class MockServer {\npublic:\n  MockServer(int family, unsigned short port);\n  ~MockServer();\n\n  // Mock method indicating the processing of a particular <name, RRtype>\n  // request.\n  MOCK_METHOD2(OnRequest, void(const std::string &name, int rrtype));\n\n  // Set the reply to be sent next; the query ID field will be overwritten\n  // with the value from the request.\n  void SetReplyData(const std::vector<byte> &reply)\n  {\n    exact_reply_ = reply;\n    reply_       = nullptr;\n  }\n\n  void SetReply(const DNSPacket *reply)\n  {\n    reply_ = reply;\n    exact_reply_.clear();\n  }\n\n  // Set the reply to be sent next as well as the request (in string form) that\n  // the server should expect to receive; the query ID field in the reply will\n  // be overwritten with the value from the request.\n  void SetReplyExpRequest(const DNSPacket *reply, const std::string &request)\n  {\n    expected_request_ = request;\n    reply_            = reply;\n  }\n\n  void SetReplyQID(int qid)\n  {\n    qid_ = qid;\n  }\n\n  void Disconnect()\n  {\n    reply_ = nullptr;\n    exact_reply_.clear();\n    for (ares_socket_t fd : connfds_) {\n      sclose(fd);\n    }\n    connfds_.clear();\n    free(tcp_data_);\n    tcp_data_     = NULL;\n    tcp_data_len_ = 0;\n  }\n\n  // The set of file descriptors that the server handles.\n  std::set<ares_socket_t> fds() const;\n\n  // Process activity on a file descriptor.\n  void                    ProcessFD(ares_socket_t fd);\n\n  // Ports the server is responding to\n  unsigned short          udpport() const\n  {\n    return udpport_;\n  }\n\n  unsigned short tcpport() const\n  {\n    return tcpport_;\n  }\n\nprivate:\n  void           ProcessRequest(ares_socket_t fd, struct sockaddr_storage *addr,\n                                ares_socklen_t addrlen, const std::vector<byte> &req,\n                                const std::string &reqstr, int qid, const char *name,\n                                int rrtype);\n  void           ProcessPacket(ares_socket_t fd, struct sockaddr_storage *addr,\n                               ares_socklen_t addrlen, byte *data, int len);\n  unsigned short udpport_;\n  unsigned short tcpport_;\n  ares_socket_t  udpfd_;\n  ares_socket_t  tcpfd_;\n  std::set<ares_socket_t> connfds_;\n  std::vector<byte>       exact_reply_;\n  const DNSPacket        *reply_;\n  std::string             expected_request_;\n  int                     qid_;\n  unsigned char          *tcp_data_;\n  size_t                  tcp_data_len_;\n}",
          "class_name": "MockServer",
          "class_pos": [
            [
              249,
              0
            ],
            [
              334,
              1
            ]
          ]
        },
        "f8613c5205842c7db643e5a9b84796701a2fe6498e9f1e727bf88fff39da47b3": {
          "class_code": "class MockChannelOptsTest : public LibraryTest {\npublic:\n  MockChannelOptsTest(int count, int family, bool force_tcp,\n                      bool honor_sysconfig, struct ares_options *givenopts,\n                      int optmask);\n  ~MockChannelOptsTest();\n\n  // Process all pending work on ares-owned and mock-server-owned file\n  // descriptors.\n  void ProcessAltChannel(ares_channel_t *chan, unsigned int cancel_ms = 0);\n  void Process(unsigned int cancel_ms = 0);\n\nprotected:\n  // NiceMockServer doesn't complain about uninteresting calls.\n  typedef testing::NiceMock<MockServer>                NiceMockServer;\n  typedef std::vector<std::unique_ptr<NiceMockServer>> NiceMockServers;\n\n  std::set<ares_socket_t>                              fds() const;\n  void                   ProcessFD(ares_socket_t fd);\n\n  static NiceMockServers BuildServers(int count, int family,\n                                      unsigned short base_port);\n\n  NiceMockServers        servers_;\n  // Convenience reference to first server.\n  NiceMockServer        &server_;\n  ares_channel_t        *channel_;\n}",
          "class_name": "MockChannelOptsTest",
          "class_pos": [
            [
              337,
              0
            ],
            [
              364,
              1
            ]
          ]
        },
        "f335b4a3a1118096497e85cfdb83714340a8db552cf8abdee5390d19f098a4ad": {
          "class_code": "class MockChannelTest\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface<std::pair<int, bool>> {\npublic:\n  MockChannelTest()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockChannelTest",
          "class_pos": [
            [
              366,
              0
            ],
            [
              375,
              1
            ]
          ]
        },
        "bbb79b17a40fc1490b6dffa8c5db9e5f1f978448f98d6d43878ca851dc420ba4": {
          "class_code": "class MockUDPChannelTest : public MockChannelOptsTest,\n                           public ::testing::WithParamInterface<int> {\npublic:\n  MockUDPChannelTest()\n    : MockChannelOptsTest(1, GetParam(), false, false, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockUDPChannelTest",
          "class_pos": [
            [
              377,
              0
            ],
            [
              384,
              1
            ]
          ]
        },
        "6749df7c8d2fe134d112ad9b8d5e42d42a448adab936865acd7afb4ed5f5f137": {
          "class_code": "class MockTCPChannelTest : public MockChannelOptsTest,\n                           public ::testing::WithParamInterface<int> {\npublic:\n  MockTCPChannelTest()\n    : MockChannelOptsTest(1, GetParam(), true, false, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockTCPChannelTest",
          "class_pos": [
            [
              386,
              0
            ],
            [
              393,
              1
            ]
          ]
        },
        "29fb68852689845a74a7323a37c71544ef644918b700310176720517d4d00ecb": {
          "class_code": "class MockEventThreadOptsTest : public MockChannelOptsTest {\npublic:\n  MockEventThreadOptsTest(int count, ares_evsys_t evsys, int family,\n                          bool force_tcp, struct ares_options *givenopts,\n                          int optmask)\n    : MockChannelOptsTest(count, family, force_tcp, false,\n                          FillOptionsET(&evopts_, givenopts, evsys),\n                          optmask | ARES_OPT_EVENT_THREAD)\n  {\n  }\n\n  ~MockEventThreadOptsTest()\n  {\n  }\n\n  static struct ares_options *FillOptionsET(struct ares_options *opts,\n                                            struct ares_options *givenopts,\n                                            ares_evsys_t         evsys)\n  {\n    if (givenopts) {\n      memcpy(opts, givenopts, sizeof(*opts));\n    } else {\n      memset(opts, 0, sizeof(*opts));\n    }\n    opts->evsys = evsys;\n    return opts;\n  }\n\n  void Process(unsigned int cancel_ms = 0);\n\nprivate:\n  struct ares_options evopts_;\n}",
          "class_name": "MockEventThreadOptsTest",
          "class_pos": [
            [
              395,
              0
            ],
            [
              427,
              1
            ]
          ]
        },
        "416df76708421d9b1b63f219e598c1d99434e60b86be545c567df10e27f71449": {
          "class_code": "class MockEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int, bool>> {\npublic:\n  MockEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), std::get<2>(GetParam()),\n                              nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockEventThreadTest",
          "class_pos": [
            [
              429,
              0
            ],
            [
              439,
              1
            ]
          ]
        },
        "ddf7729b016031b17cc0a730a53d015b716a3935fd4cf39b978858f1547bd8b3": {
          "class_code": "class MockUDPEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int>> {\npublic:\n  MockUDPEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), false, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockUDPEventThreadTest",
          "class_pos": [
            [
              441,
              0
            ],
            [
              450,
              1
            ]
          ]
        },
        "a013685d30abc31cef70628484c6c9542dcd713933a40d979c6c516fddd3bd28": {
          "class_code": "class MockTCPEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int>> {\npublic:\n  MockTCPEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), true, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockTCPEventThreadTest",
          "class_pos": [
            [
              452,
              0
            ],
            [
              461,
              1
            ]
          ]
        },
        "f4000971275b5ab39b02fc25980d8c6168bd5ff4fc5ad590f06bc43c3d2086cc": {
          "class_code": "class TransientDir {\npublic:\n  TransientDir(const std::string &dirname);\n  ~TransientDir();\n\nprivate:\n  std::string dirname_;\n}",
          "class_name": "TransientDir",
          "class_pos": [
            [
              656,
              0
            ],
            [
              663,
              1
            ]
          ]
        },
        "c29cae8889cb2f9c7a834d78235fdbbbf3060e3fddc198058d4f47776778b696": {
          "class_code": "class TransientFile {\npublic:\n  TransientFile(const std::string &filename, const std::string &contents);\n  ~TransientFile();\n\nprotected:\n  std::string filename_;\n}",
          "class_name": "TransientFile",
          "class_pos": [
            [
              669,
              0
            ],
            [
              676,
              1
            ]
          ]
        },
        "2cc16f98fce1852edef7d3c48f8e921cce4d6c66e0c0d3fee230c5b716b9d89b": {
          "class_code": "class TempFile : public TransientFile {\npublic:\n  TempFile(const std::string &contents);\n\n  const char *filename() const\n  {\n    return filename_.c_str();\n  }\n}",
          "class_name": "TempFile",
          "class_pos": [
            [
              679,
              0
            ],
            [
              687,
              1
            ]
          ]
        },
        "aff6eb4bfc699ae6929d60d45c420c9f6484b251bfb6d7759078d873544c79a4": {
          "class_code": "class EnvValue {\npublic:\n  EnvValue(const char *name, const char *value) : name_(name), restore_(false)\n  {\n    char *original = getenv(name);\n    if (original) {\n      restore_  = true;\n      original_ = original;\n    }\n    setenv(name_.c_str(), value, 1);\n  }\n\n  ~EnvValue()\n  {\n    if (restore_) {\n      setenv(name_.c_str(), original_.c_str(), 1);\n    } else {\n      unsetenv(name_.c_str());\n    }\n  }\n\nprivate:\n  std::string name_;\n  bool        restore_;\n  std::string original_;\n}",
          "class_name": "EnvValue",
          "class_pos": [
            [
              726,
              0
            ],
            [
              751,
              1
            ]
          ]
        },
        "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283": {
          "class_code": "class ContainerFilesystem {\npublic:\n  ContainerFilesystem(NameContentList files, const std::string &mountpt);\n  ~ContainerFilesystem();\n\n  std::string root() const\n  {\n    return rootdir_;\n  }\n\n  std::string mountpt() const\n  {\n    return mountpt_;\n  }\n\nprivate:\n  void                   EnsureDirExists(const std::string &dir);\n  std::string            rootdir_;\n  std::string            mountpt_;\n  std::list<std::string> dirs_;\n  std::vector<std::unique_ptr<TransientFile>> files_;\n}",
          "class_name": "ContainerFilesystem",
          "class_pos": [
            [
              760,
              0
            ],
            [
              781,
              1
            ]
          ]
        },
        "e856eee93a2c9edd8becd9b9f3bbd8f02b31a545dcdd4ce2a4f82a54999c8677": {
          "class_code": "class VirtualizeIO {\npublic:\n  VirtualizeIO(ares_channel);\n  ~VirtualizeIO();\n\n  static const ares_socket_functions default_functions;\n\nprivate:\n  ares_channel_t *channel_;\n}",
          "class_name": "VirtualizeIO",
          "class_pos": [
            [
              861,
              0
            ],
            [
              870,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct iovec {\n  void  *iov_base; /* Pointer to data. */\n  size_t iov_len;  /* Length of data.  */\n}",
          {
            "*iov_base": "void",
            "iov_len": "size_t"
          },
          "iovec",
          [
            66,
            0
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct HostEnt {\n  HostEnt() : addrtype_(-1)\n  {\n  }\n\n  HostEnt(const struct hostent *hostent);\n  std::string              name_;\n  std::vector<std::string> aliases_;\n  int                      addrtype_;  // AF_INET or AF_INET6\n  std::vector<std::string> addrs_;\n}",
          {
            "name_": "std::string",
            "aliases_": "std::vector<std::string>",
            "addrtype_": "int",
            "addrs_": "std::vector<std::string>"
          },
          "HostEnt",
          [
            505,
            0
          ],
          [
            515,
            1
          ]
        ],
        [
          "struct HostResult {\n  HostResult() : done_(false), status_(0), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool    done_;\n  // Explicitly provided result information.\n  int     status_;\n  int     timeouts_;\n  // Contents of the hostent structure, if provided.\n  HostEnt host_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "host_": "HostEnt"
          },
          "HostResult",
          [
            520,
            0
          ],
          [
            532,
            1
          ]
        ],
        [
          "struct AresDnsRecord {\n  ~AresDnsRecord()\n  {\n    ares_dns_record_destroy(dnsrec_);\n    dnsrec_ = NULL;\n  }\n\n  AresDnsRecord() : dnsrec_(NULL)\n  {\n  }\n\n  void SetDnsRecord(const ares_dns_record_t *dnsrec)\n  {\n    if (dnsrec_ != NULL) {\n      ares_dns_record_destroy(dnsrec_);\n    }\n    if (dnsrec == NULL) {\n      return;\n    }\n    dnsrec_ = ares_dns_record_duplicate(dnsrec);\n  }\n\n  ares_dns_record_t *dnsrec_ = NULL;\n}",
          {
            "*dnsrec_": "ares_dns_record_t"
          },
          "AresDnsRecord",
          [
            537,
            0
          ],
          [
            560,
            1
          ]
        ],
        [
          "struct QueryResult {\n  QueryResult() : done_(false), status_(ARES_SUCCESS), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool          done_;\n  // Explicitly provided result information.\n  ares_status_t status_;\n  size_t        timeouts_;\n  // Contents of the ares_dns_record_t structure if provided\n  AresDnsRecord dnsrec_;\n}",
          {
            "done_": "bool",
            "status_": "ares_status_t",
            "timeouts_": "size_t",
            "dnsrec_": "AresDnsRecord"
          },
          "QueryResult",
          [
            565,
            0
          ],
          [
            577,
            1
          ]
        ],
        [
          "struct SearchResult {\n  // Whether the callback has been invoked.\n  bool              done_;\n  // Explicitly provided result information.\n  int               status_;\n  int               timeouts_;\n  std::vector<byte> data_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "data_": "std::vector<byte>"
          },
          "SearchResult",
          [
            582,
            0
          ],
          [
            589,
            1
          ]
        ],
        [
          "struct NameInfoResult {\n  // Whether the callback has been invoked.\n  bool        done_;\n  // Explicitly provided result information.\n  int         status_;\n  int         timeouts_;\n  std::string node_;\n  std::string service_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "node_": "std::string",
            "service_": "std::string"
          },
          "NameInfoResult",
          [
            594,
            0
          ],
          [
            602,
            1
          ]
        ],
        [
          "struct AddrInfoDeleter {\n  void operator()(ares_addrinfo *ptr)\n  {\n    if (ptr) {\n      ares_freeaddrinfo(ptr);\n    }\n  }\n}",
          {},
          "AddrInfoDeleter",
          [
            606,
            0
          ],
          [
            613,
            1
          ]
        ],
        [
          "struct AddrInfoResult {\n  AddrInfoResult() : done_(false), status_(-1), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool     done_;\n  // Explicitly provided result information.\n  int      status_;\n  int      timeouts_;\n  // Contents of the ares_addrinfo structure, if provided.\n  AddrInfo ai_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "ai_": "AddrInfo"
          },
          "AddrInfoResult",
          [
            621,
            0
          ],
          [
            633,
            1
          ]
        ],
        [
          "struct iovec {\n  void  *iov_base; /* Pointer to data. */\n  size_t iov_len;  /* Length of data.  */\n}",
          {
            "*iov_base": "void",
            "iov_len": "size_t"
          },
          "iovec",
          [
            66,
            0
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            153,
            66
          ],
          [
            153,
            78
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            171,
            4
          ],
          [
            171,
            23
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            197,
            4
          ],
          [
            197,
            23
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            226,
            4
          ],
          [
            226,
            23
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            317,
            50
          ],
          [
            317,
            73
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            321,
            49
          ],
          [
            321,
            72
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            340,
            44
          ],
          [
            340,
            63
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            398,
            42
          ],
          [
            398,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            410,
            9
          ],
          [
            410,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            410,
            44
          ],
          [
            410,
            63
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            411,
            44
          ],
          [
            411,
            63
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            426,
            2
          ],
          [
            426,
            21
          ]
        ],
        [
          "struct HostEnt {\n  HostEnt() : addrtype_(-1)\n  {\n  }\n\n  HostEnt(const struct hostent *hostent);\n  std::string              name_;\n  std::vector<std::string> aliases_;\n  int                      addrtype_;  // AF_INET or AF_INET6\n  std::vector<std::string> addrs_;\n}",
          {
            "name_": "std::string",
            "aliases_": "std::vector<std::string>",
            "addrtype_": "int",
            "addrs_": "std::vector<std::string>"
          },
          "HostEnt",
          [
            505,
            0
          ],
          [
            515,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            510,
            16
          ],
          [
            510,
            30
          ]
        ],
        [
          "struct HostResult {\n  HostResult() : done_(false), status_(0), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool    done_;\n  // Explicitly provided result information.\n  int     status_;\n  int     timeouts_;\n  // Contents of the hostent structure, if provided.\n  HostEnt host_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "host_": "HostEnt"
          },
          "HostResult",
          [
            520,
            0
          ],
          [
            532,
            1
          ]
        ],
        [
          "struct AresDnsRecord {\n  ~AresDnsRecord()\n  {\n    ares_dns_record_destroy(dnsrec_);\n    dnsrec_ = NULL;\n  }\n\n  AresDnsRecord() : dnsrec_(NULL)\n  {\n  }\n\n  void SetDnsRecord(const ares_dns_record_t *dnsrec)\n  {\n    if (dnsrec_ != NULL) {\n      ares_dns_record_destroy(dnsrec_);\n    }\n    if (dnsrec == NULL) {\n      return;\n    }\n    dnsrec_ = ares_dns_record_duplicate(dnsrec);\n  }\n\n  ares_dns_record_t *dnsrec_ = NULL;\n}",
          {
            "*dnsrec_": "ares_dns_record_t"
          },
          "AresDnsRecord",
          [
            537,
            0
          ],
          [
            560,
            1
          ]
        ],
        [
          "struct QueryResult {\n  QueryResult() : done_(false), status_(ARES_SUCCESS), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool          done_;\n  // Explicitly provided result information.\n  ares_status_t status_;\n  size_t        timeouts_;\n  // Contents of the ares_dns_record_t structure if provided\n  AresDnsRecord dnsrec_;\n}",
          {
            "done_": "bool",
            "status_": "ares_status_t",
            "timeouts_": "size_t",
            "dnsrec_": "AresDnsRecord"
          },
          "QueryResult",
          [
            565,
            0
          ],
          [
            577,
            1
          ]
        ],
        [
          "struct SearchResult {\n  // Whether the callback has been invoked.\n  bool              done_;\n  // Explicitly provided result information.\n  int               status_;\n  int               timeouts_;\n  std::vector<byte> data_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "data_": "std::vector<byte>"
          },
          "SearchResult",
          [
            582,
            0
          ],
          [
            589,
            1
          ]
        ],
        [
          "struct NameInfoResult {\n  // Whether the callback has been invoked.\n  bool        done_;\n  // Explicitly provided result information.\n  int         status_;\n  int         timeouts_;\n  std::string node_;\n  std::string service_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "node_": "std::string",
            "service_": "std::string"
          },
          "NameInfoResult",
          [
            594,
            0
          ],
          [
            602,
            1
          ]
        ],
        [
          "struct AddrInfoDeleter {\n  void operator()(ares_addrinfo *ptr)\n  {\n    if (ptr) {\n      ares_freeaddrinfo(ptr);\n    }\n  }\n}",
          {},
          "AddrInfoDeleter",
          [
            606,
            0
          ],
          [
            613,
            1
          ]
        ],
        [
          "struct AddrInfoResult {\n  AddrInfoResult() : done_(false), status_(-1), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool     done_;\n  // Explicitly provided result information.\n  int      status_;\n  int      timeouts_;\n  // Contents of the ares_addrinfo structure, if provided.\n  AddrInfo ai_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "ai_": "AddrInfo"
          },
          "AddrInfoResult",
          [
            621,
            0
          ],
          [
            633,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            640,
            27
          ],
          [
            640,
            41
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            650,
            22
          ],
          [
            650,
            42
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"gtest/gtest.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"gmock/gmock.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <functional>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <list>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <map>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <memory>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <set>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <mutex>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <thread>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <utility>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <chrono>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/ares-test-ai.h": {
      "fn_def_list": [
        {
          "fn_code": "MockChannelTestAI()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              44,
              3
            ]
          ],
          "class_code": "f76e7b3c6acee26281840d0fca0aba2a562e988e4d25816f4f548e2dca4be34a",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              45,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPChannelTestAI()\n    : MockChannelOptsTest(1, GetParam(), false, false, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              50,
              2
            ],
            [
              53,
              3
            ]
          ],
          "class_code": "cf5ebc4d3f3f749d8d26f786b08530ddd5790636fccce680242950b88ca58224",
          "class_node_pos": [
            [
              47,
              0
            ],
            [
              54,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockTCPChannelTestAI()\n    : MockChannelOptsTest(1, GetParam(), true, false, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              59,
              2
            ],
            [
              62,
              3
            ]
          ],
          "class_code": "fd73d5a847e3f2ed1dfe98435dca348f8c1d834e3d1cde88c256c1ba39351938",
          "class_node_pos": [
            [
              56,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockTCPChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DefaultChannelTestAI() : channel_(nullptr)\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_init(&channel_));\n    EXPECT_NE(nullptr, channel_);\n  }",
          "fn_code_pos": [
            [
              68,
              2
            ],
            [
              72,
              3
            ]
          ],
          "class_code": "3a21b7bebada56bd1393eb13e93453ddbc896d49bcaab2a12366c72839572f4b",
          "class_node_pos": [
            [
              66,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~DefaultChannelTestAI()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }",
          "fn_code_pos": [
            [
              74,
              2
            ],
            [
              78,
              3
            ]
          ],
          "class_code": "3a21b7bebada56bd1393eb13e93453ddbc896d49bcaab2a12366c72839572f4b",
          "class_node_pos": [
            [
              66,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Process()",
          "fn_dec_pos": [
            [
              81,
              7
            ],
            [
              81,
              16
            ]
          ],
          "class_code": "3a21b7bebada56bd1393eb13e93453ddbc896d49bcaab2a12366c72839572f4b",
          "class_node_pos": [
            [
              66,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "f76e7b3c6acee26281840d0fca0aba2a562e988e4d25816f4f548e2dca4be34a": {
          "class_code": "class MockChannelTestAI\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface<std::pair<int, bool>> {\npublic:\n  MockChannelTestAI()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, false,\n                          nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockChannelTestAI",
          "class_pos": [
            [
              36,
              0
            ],
            [
              45,
              1
            ]
          ]
        },
        "cf5ebc4d3f3f749d8d26f786b08530ddd5790636fccce680242950b88ca58224": {
          "class_code": "class MockUDPChannelTestAI : public MockChannelOptsTest,\n                             public ::testing::WithParamInterface<int> {\npublic:\n  MockUDPChannelTestAI()\n    : MockChannelOptsTest(1, GetParam(), false, false, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockUDPChannelTestAI",
          "class_pos": [
            [
              47,
              0
            ],
            [
              54,
              1
            ]
          ]
        },
        "fd73d5a847e3f2ed1dfe98435dca348f8c1d834e3d1cde88c256c1ba39351938": {
          "class_code": "class MockTCPChannelTestAI : public MockChannelOptsTest,\n                             public ::testing::WithParamInterface<int> {\npublic:\n  MockTCPChannelTestAI()\n    : MockChannelOptsTest(1, GetParam(), true, false, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockTCPChannelTestAI",
          "class_pos": [
            [
              56,
              0
            ],
            [
              63,
              1
            ]
          ]
        },
        "3a21b7bebada56bd1393eb13e93453ddbc896d49bcaab2a12366c72839572f4b": {
          "class_code": "class DefaultChannelTestAI : public LibraryTest {\npublic:\n  DefaultChannelTestAI() : channel_(nullptr)\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_init(&channel_));\n    EXPECT_NE(nullptr, channel_);\n  }\n\n  ~DefaultChannelTestAI()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }\n\n  // Process all pending work on ares-owned file descriptors.\n  void Process();\n\nprotected:\n  ares_channel_t *channel_;\n}",
          "class_name": "DefaultChannelTestAI",
          "class_pos": [
            [
              66,
              0
            ],
            [
              85,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <utility>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"gtest/gtest.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"gmock/gmock.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares-test.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/dns-proto.h": {
      "fn_def_list": [
        {
          "fn_code": "DNSQuestion(const std::string &name, int rrtype, int qclass)\n    : name_(name), rrtype_(rrtype), qclass_(qclass)\n  {\n  }",
          "fn_code_pos": [
            [
              74,
              2
            ],
            [
              77,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSQuestion",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "qclass": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSQuestion(const std::string &name, int rrtype)\n    : name_(name), rrtype_(rrtype), qclass_(C_IN)\n  {\n  }",
          "fn_code_pos": [
            [
              79,
              2
            ],
            [
              82,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSQuestion",
            "parameters": {
              "name": "std::string",
              "rrtype": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DNSQuestion()\n  {\n  }",
          "fn_code_pos": [
            [
              84,
              2
            ],
            [
              86,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const\n  {\n    return data(nullptr, dnsrec);\n  }",
          "fn_code_pos": [
            [
              91,
              2
            ],
            [
              94,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual std::vector<byte> data() const\n  {\n    return data(nullptr, nullptr);\n  }",
          "fn_code_pos": [
            [
              96,
              2
            ],
            [
              99,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNSRR(const std::string &name, int rrtype, int qclass, int ttl)\n    : DNSQuestion(name, rrtype, qclass), ttl_(ttl)\n  {\n  }",
          "fn_code_pos": [
            [
              107,
              2
            ],
            [
              110,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "qclass": "int",
              "ttl": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSRR(const std::string &name, int rrtype, int ttl)\n    : DNSQuestion(name, rrtype), ttl_(ttl)\n  {\n  }",
          "fn_code_pos": [
            [
              112,
              2
            ],
            [
              115,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "ttl": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DNSRR()\n  {\n  }",
          "fn_code_pos": [
            [
              117,
              2
            ],
            [
              119,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNSAddressRR(const std::string &name, int rrtype, int ttl, const byte *addr,\n               int addrlen)\n    : DNSRR(name, rrtype, ttl), addr_(addr, addr + addrlen)\n  {\n  }",
          "fn_code_pos": [
            [
              126,
              2
            ],
            [
              130,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAddressRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "ttl": "int",
              "addr": "byte",
              "addrlen": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSAddressRR(const std::string &name, int rrtype, int ttl,\n               const std::vector<byte> &addr)\n    : DNSRR(name, rrtype, ttl), addr_(addr)\n  {\n  }",
          "fn_code_pos": [
            [
              132,
              2
            ],
            [
              136,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAddressRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "ttl": "int",
              "addr": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSARR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_A, ttl, addr, addrlen)\n  {\n  }",
          "fn_code_pos": [
            [
              143,
              2
            ],
            [
              146,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSARR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "addr": "byte",
              "addrlen": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSARR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_A, ttl, addr)\n  {\n  }",
          "fn_code_pos": [
            [
              148,
              2
            ],
            [
              151,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSARR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "addr": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSAaaaRR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_AAAA, ttl, addr, addrlen)\n  {\n  }",
          "fn_code_pos": [
            [
              155,
              2
            ],
            [
              158,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAaaaRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "addr": "byte",
              "addrlen": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSAaaaRR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_AAAA, ttl, addr)\n  {\n  }",
          "fn_code_pos": [
            [
              160,
              2
            ],
            [
              163,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAaaaRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "addr": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSSingleNameRR(const std::string &name, int rrtype, int ttl,\n                  const std::string &other)\n    : DNSRR(name, rrtype, ttl), other_(other)\n  {\n  }",
          "fn_code_pos": [
            [
              167,
              2
            ],
            [
              171,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSingleNameRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSCnameRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_CNAME, ttl, other)\n  {\n  }",
          "fn_code_pos": [
            [
              178,
              2
            ],
            [
              181,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSCnameRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSNsRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_NS, ttl, other)\n  {\n  }",
          "fn_code_pos": [
            [
              185,
              2
            ],
            [
              188,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSNsRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSPtrRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_PTR, ttl, other)\n  {\n  }",
          "fn_code_pos": [
            [
              192,
              2
            ],
            [
              195,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSPtrRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSTxtRR(const std::string &name, int ttl,\n           const std::vector<std::string> &txt)\n    : DNSRR(name, T_TXT, ttl), txt_(txt)\n  {\n  }",
          "fn_code_pos": [
            [
              199,
              2
            ],
            [
              203,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSTxtRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "txt": "std::vector<std::string>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSMxRR(const std::string &name, int ttl, int pref, const std::string &other)\n    : DNSRR(name, T_MX, ttl), pref_(pref), other_(other)\n  {\n  }",
          "fn_code_pos": [
            [
              210,
              2
            ],
            [
              213,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSMxRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "pref": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSSrvRR(const std::string &name, int ttl, int prio, int weight, int port,\n           const std::string &target)\n    : DNSRR(name, T_SRV, ttl), prio_(prio), weight_(weight), port_(port),\n      target_(target)\n  {\n  }",
          "fn_code_pos": [
            [
              221,
              2
            ],
            [
              226,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSrvRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "prio": "int",
              "weight": "int",
              "port": "int",
              "target": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSUriRR(const std::string &name, int ttl, int prio, int weight,\n           const std::string &target)\n    : DNSRR(name, T_URI, ttl), prio_(prio), weight_(weight), target_(target)\n  {\n  }",
          "fn_code_pos": [
            [
              236,
              2
            ],
            [
              240,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSUriRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "prio": "int",
              "weight": "int",
              "target": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSSoaRR(const std::string &name, int ttl, const std::string &nsname,\n           const std::string &rname, int serial, int refresh, int retry,\n           int expire, int minimum)\n    : DNSRR(name, T_SOA, ttl), nsname_(nsname), rname_(rname), serial_(serial),\n      refresh_(refresh), retry_(retry), expire_(expire), minimum_(minimum)\n  {\n  }",
          "fn_code_pos": [
            [
              249,
              2
            ],
            [
              255,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSoaRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "nsname": "std::string",
              "rname": "std::string",
              "serial": "int",
              "refresh": "int",
              "retry": "int",
              "expire": "int",
              "minimum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSNaptrRR(const std::string &name, int ttl, int order, int pref,\n             const std::string &flags, const std::string &service,\n             const std::string &regexp, const std::string &replacement)\n    : DNSRR(name, T_NAPTR, ttl), order_(order), pref_(pref), flags_(flags),\n      service_(service), regexp_(regexp), replacement_(replacement)\n  {\n  }",
          "fn_code_pos": [
            [
              268,
              2
            ],
            [
              274,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSNaptrRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "order": "int",
              "pref": "int",
              "flags": "std::string",
              "service": "std::string",
              "regexp": "std::string",
              "replacement": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSOptRR(unsigned char extrcode, unsigned char version, unsigned short flags,\n           int udpsize, std::vector<byte> client_cookie,\n           std::vector<byte> server_cookie, bool expect_server_cookie)\n    : DNSRR(\"\", T_OPT, static_cast<int>(udpsize),\n            ((int)extrcode) << 24 | ((int)version) << 16 |\n              ((int)flags) /* ttl */)\n  {\n    client_cookie_        = client_cookie;\n    server_cookie_        = server_cookie;\n    expect_server_cookie_ = expect_server_cookie;\n  }",
          "fn_code_pos": [
            [
              291,
              2
            ],
            [
              301,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSOptRR",
            "parameters": {
              "extrcode": "unsigned char",
              "version": "unsigned char",
              "flags": "unsigned short",
              "udpsize": "int",
              "client_cookie": "std::vector<byte>",
              "server_cookie": "std::vector<byte>",
              "expect_server_cookie": "bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSPacket()\n    : qid_(0), response_(false), opcode_(O_QUERY), aa_(false), tc_(false),\n      rd_(false), ra_(false), z_(false), ad_(false), cd_(false), rcode_(NOERROR)\n  {\n  }",
          "fn_code_pos": [
            [
              311,
              2
            ],
            [
              315,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSPacket",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNSPacket &add_question(DNSQuestion *q)\n  {\n    questions_.push_back(std::unique_ptr<DNSQuestion>(q));\n    return *this;\n  }",
          "fn_code_pos": [
            [
              318,
              2
            ],
            [
              322,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &add_answer(DNSRR *q)\n  {\n    answers_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }",
          "fn_code_pos": [
            [
              324,
              2
            ],
            [
              328,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &add_auth(DNSRR *q)\n  {\n    auths_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }",
          "fn_code_pos": [
            [
              330,
              2
            ],
            [
              334,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &add_additional(DNSRR *q)\n  {\n    adds_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }",
          "fn_code_pos": [
            [
              336,
              2
            ],
            [
              340,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_qid(int qid)\n  {\n    qid_ = qid;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              343,
              2
            ],
            [
              347,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_response(bool v = true)\n  {\n    response_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              349,
              2
            ],
            [
              353,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_aa(bool v = true)\n  {\n    aa_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              355,
              2
            ],
            [
              359,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_tc(bool v = true)\n  {\n    tc_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              361,
              2
            ],
            [
              365,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_rd(bool v = true)\n  {\n    rd_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              367,
              2
            ],
            [
              371,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_ra(bool v = true)\n  {\n    ra_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              373,
              2
            ],
            [
              377,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_z(bool v = true)\n  {\n    z_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              379,
              2
            ],
            [
              383,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_ad(bool v = true)\n  {\n    ad_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              385,
              2
            ],
            [
              389,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_cd(bool v = true)\n  {\n    cd_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              391,
              2
            ],
            [
              395,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_rcode(int rcode)\n  {\n    rcode_ = rcode;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              397,
              2
            ],
            [
              401,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "std::vector<byte> data() const\n  {\n    return data(nullptr, nullptr);\n  }",
          "fn_code_pos": [
            [
              407,
              2
            ],
            [
              410,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "arestest_strtolower(char *dest, const char *src,\n                                    size_t dest_size)",
          "fn_dec_pos": [
            [
              38,
              16
            ],
            [
              39,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "arestest_strtolower",
            "parameters": {
              "dest": "char",
              "src": "char",
              "dest_size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "HexDump(std::vector<byte> data)",
          "fn_dec_pos": [
            [
              45,
              22
            ],
            [
              45,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "HexDump(const byte *data, int len)",
          "fn_dec_pos": [
            [
              46,
              22
            ],
            [
              46,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "HexDump(const char *data, int len)",
          "fn_dec_pos": [
            [
              47,
              22
            ],
            [
              47,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "char",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "StatusToString(int status)",
          "fn_dec_pos": [
            [
              49,
              22
            ],
            [
              49,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StatusToString",
            "parameters": {
              "status": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "RcodeToString(int rcode)",
          "fn_dec_pos": [
            [
              50,
              22
            ],
            [
              50,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RcodeToString",
            "parameters": {
              "rcode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "RRTypeToString(int rrtype)",
          "fn_dec_pos": [
            [
              51,
              22
            ],
            [
              51,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RRTypeToString",
            "parameters": {
              "rrtype": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ClassToString(int qclass)",
          "fn_dec_pos": [
            [
              52,
              22
            ],
            [
              52,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ClassToString",
            "parameters": {
              "qclass": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AddressToString(const void *addr, int len)",
          "fn_dec_pos": [
            [
              53,
              22
            ],
            [
              53,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddressToString",
            "parameters": {
              "addr": "void",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "fetch_rr_opt(const ares_dns_record_t *rec)",
          "fn_dec_pos": [
            [
              55,
              22
            ],
            [
              55,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fetch_rr_opt",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PacketToString(const std::vector<byte> &packet)",
          "fn_dec_pos": [
            [
              61,
              22
            ],
            [
              61,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PacketToString",
            "parameters": {
              "packet": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "QuestionToString(const std::vector<byte> &packet, const byte **data,\n                             int *len)",
          "fn_dec_pos": [
            [
              62,
              12
            ],
            [
              63,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QuestionToString",
            "parameters": {
              "packet": "std::vector<byte>",
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "RRToString(const std::vector<byte> &packet, const byte **data,\n                       int *len)",
          "fn_dec_pos": [
            [
              64,
              12
            ],
            [
              65,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RRToString",
            "parameters": {
              "packet": "std::vector<byte>",
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PushInt32(std::vector<byte> *data, int value)",
          "fn_dec_pos": [
            [
              69,
              12
            ],
            [
              69,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PushInt32",
            "parameters": {
              "data": "std::vector<byte>",
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "PushInt16(std::vector<byte> *data, int value)",
          "fn_dec_pos": [
            [
              70,
              12
            ],
            [
              70,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PushInt16",
            "parameters": {
              "data": "std::vector<byte>",
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "EncodeString(const std::string &name)",
          "fn_dec_pos": [
            [
              71,
              18
            ],
            [
              71,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncodeString",
            "parameters": {
              "name": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const char              *request_name,\n                                 const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              88,
              28
            ],
            [
              89,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "request_name": "char",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              121,
              28
            ],
            [
              121,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              138,
              28
            ],
            [
              138,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              173,
              28
            ],
            [
              173,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              205,
              28
            ],
            [
              205,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              215,
              28
            ],
            [
              215,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              228,
              28
            ],
            [
              228,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              242,
              28
            ],
            [
              242,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              257,
              28
            ],
            [
              257,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              276,
              28
            ],
            [
              276,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              303,
              28
            ],
            [
              303,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "add_question(DNSQuestion *q)",
          "fn_dec_pos": [
            [
              318,
              13
            ],
            [
              318,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_question",
            "parameters": {
              "q": "DNSQuestion"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "add_answer(DNSRR *q)",
          "fn_dec_pos": [
            [
              324,
              13
            ],
            [
              324,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_answer",
            "parameters": {
              "q": "DNSRR"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "add_auth(DNSRR *q)",
          "fn_dec_pos": [
            [
              330,
              13
            ],
            [
              330,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_auth",
            "parameters": {
              "q": "DNSRR"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "add_additional(DNSRR *q)",
          "fn_dec_pos": [
            [
              336,
              13
            ],
            [
              336,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_additional",
            "parameters": {
              "q": "DNSRR"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "set_qid(int qid)",
          "fn_dec_pos": [
            [
              343,
              13
            ],
            [
              343,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_qid",
            "parameters": {
              "qid": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "set_response(bool v = true)",
          "fn_dec_pos": [
            [
              349,
              13
            ],
            [
              349,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_response",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_aa(bool v = true)",
          "fn_dec_pos": [
            [
              355,
              13
            ],
            [
              355,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_aa",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_tc(bool v = true)",
          "fn_dec_pos": [
            [
              361,
              13
            ],
            [
              361,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_tc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_rd(bool v = true)",
          "fn_dec_pos": [
            [
              367,
              13
            ],
            [
              367,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_rd",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_ra(bool v = true)",
          "fn_dec_pos": [
            [
              373,
              13
            ],
            [
              373,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_ra",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_z(bool v = true)",
          "fn_dec_pos": [
            [
              379,
              13
            ],
            [
              379,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_z",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_ad(bool v = true)",
          "fn_dec_pos": [
            [
              385,
              13
            ],
            [
              385,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_ad",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_cd(bool v = true)",
          "fn_dec_pos": [
            [
              391,
              13
            ],
            [
              391,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_cd",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_rcode(int rcode)",
          "fn_dec_pos": [
            [
              397,
              13
            ],
            [
              397,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_rcode",
            "parameters": {
              "rcode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data(const char              *request_name,\n                         const ares_dns_record_t *dnsrec) const",
          "fn_dec_pos": [
            [
              404,
              20
            ],
            [
              405,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {
              "request_name": "char",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct DNSQuestion {\n  DNSQuestion(const std::string &name, int rrtype, int qclass)\n    : name_(name), rrtype_(rrtype), qclass_(qclass)\n  {\n  }\n\n  DNSQuestion(const std::string &name, int rrtype)\n    : name_(name), rrtype_(rrtype), qclass_(C_IN)\n  {\n  }\n\n  virtual ~DNSQuestion()\n  {\n  }\n\n  virtual std::vector<byte> data(const char              *request_name,\n                                 const ares_dns_record_t *dnsrec) const;\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const\n  {\n    return data(nullptr, dnsrec);\n  }\n\n  virtual std::vector<byte> data() const\n  {\n    return data(nullptr, nullptr);\n  }\n\n  std::string name_;\n  int         rrtype_;\n  int         qclass_;\n}",
          {
            "std::vector<byte>": "virtual",
            "name_": "std::string",
            "rrtype_": "int",
            "qclass_": "int"
          },
          "DNSQuestion",
          [
            73,
            0
          ],
          [
            104,
            1
          ]
        ],
        [
          "struct DNSRR : public DNSQuestion {\n  DNSRR(const std::string &name, int rrtype, int qclass, int ttl)\n    : DNSQuestion(name, rrtype, qclass), ttl_(ttl)\n  {\n  }\n\n  DNSRR(const std::string &name, int rrtype, int ttl)\n    : DNSQuestion(name, rrtype), ttl_(ttl)\n  {\n  }\n\n  virtual ~DNSRR()\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const = 0;\n  int                       ttl_;\n}",
          {
            "std::vector<byte>": "virtual",
            "ttl_": "int"
          },
          "",
          [
            106,
            0
          ],
          [
            123,
            1
          ]
        ],
        [
          "struct DNSAddressRR : public DNSRR {\n  DNSAddressRR(const std::string &name, int rrtype, int ttl, const byte *addr,\n               int addrlen)\n    : DNSRR(name, rrtype, ttl), addr_(addr, addr + addrlen)\n  {\n  }\n\n  DNSAddressRR(const std::string &name, int rrtype, int ttl,\n               const std::vector<byte> &addr)\n    : DNSRR(name, rrtype, ttl), addr_(addr)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::vector<byte>         addr_;\n}",
          {
            "std::vector<byte>": "virtual",
            "addr_": "std::vector<byte>"
          },
          "",
          [
            125,
            0
          ],
          [
            140,
            1
          ]
        ],
        [
          "struct DNSARR : public DNSAddressRR {\n  DNSARR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_A, ttl, addr, addrlen)\n  {\n  }\n\n  DNSARR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_A, ttl, addr)\n  {\n  }\n}",
          {},
          "",
          [
            142,
            0
          ],
          [
            152,
            1
          ]
        ],
        [
          "struct DNSAaaaRR : public DNSAddressRR {\n  DNSAaaaRR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_AAAA, ttl, addr, addrlen)\n  {\n  }\n\n  DNSAaaaRR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_AAAA, ttl, addr)\n  {\n  }\n}",
          {},
          "",
          [
            154,
            0
          ],
          [
            164,
            1
          ]
        ],
        [
          "struct DNSSingleNameRR : public DNSRR {\n  DNSSingleNameRR(const std::string &name, int rrtype, int ttl,\n                  const std::string &other)\n    : DNSRR(name, rrtype, ttl), other_(other)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::string               other_;\n}",
          {
            "std::vector<byte>": "virtual",
            "other_": "std::string"
          },
          "",
          [
            166,
            0
          ],
          [
            175,
            1
          ]
        ],
        [
          "struct DNSCnameRR : public DNSSingleNameRR {\n  DNSCnameRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_CNAME, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            177,
            0
          ],
          [
            182,
            1
          ]
        ],
        [
          "struct DNSNsRR : public DNSSingleNameRR {\n  DNSNsRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_NS, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            184,
            0
          ],
          [
            189,
            1
          ]
        ],
        [
          "struct DNSPtrRR : public DNSSingleNameRR {\n  DNSPtrRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_PTR, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            191,
            0
          ],
          [
            196,
            1
          ]
        ],
        [
          "struct DNSTxtRR : public DNSRR {\n  DNSTxtRR(const std::string &name, int ttl,\n           const std::vector<std::string> &txt)\n    : DNSRR(name, T_TXT, ttl), txt_(txt)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::vector<std::string>  txt_;\n}",
          {
            "std::vector<byte>": "virtual",
            "txt_": "std::vector<std::string>"
          },
          "",
          [
            198,
            0
          ],
          [
            207,
            1
          ]
        ],
        [
          "struct DNSMxRR : public DNSRR {\n  DNSMxRR(const std::string &name, int ttl, int pref, const std::string &other)\n    : DNSRR(name, T_MX, ttl), pref_(pref), other_(other)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  int                       pref_;\n  std::string               other_;\n}",
          {
            "std::vector<byte>": "virtual",
            "pref_": "int",
            "other_": "std::string"
          },
          "",
          [
            209,
            0
          ],
          [
            218,
            1
          ]
        ],
        [
          "struct DNSSrvRR : public DNSRR {\n  DNSSrvRR(const std::string &name, int ttl, int prio, int weight, int port,\n           const std::string &target)\n    : DNSRR(name, T_SRV, ttl), prio_(prio), weight_(weight), port_(port),\n      target_(target)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  int                       prio_;\n  int                       weight_;\n  int                       port_;\n  std::string               target_;\n}",
          {
            "std::vector<byte>": "virtual",
            "prio_": "int",
            "weight_": "int",
            "port_": "int",
            "target_": "std::string"
          },
          "",
          [
            220,
            0
          ],
          [
            233,
            1
          ]
        ],
        [
          "struct DNSUriRR : public DNSRR {\n  DNSUriRR(const std::string &name, int ttl, int prio, int weight,\n           const std::string &target)\n    : DNSRR(name, T_URI, ttl), prio_(prio), weight_(weight), target_(target)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  int                       prio_;\n  int                       weight_;\n  std::string               target_;\n}",
          {
            "std::vector<byte>": "virtual",
            "prio_": "int",
            "weight_": "int",
            "target_": "std::string"
          },
          "",
          [
            235,
            0
          ],
          [
            246,
            1
          ]
        ],
        [
          "struct DNSSoaRR : public DNSRR {\n  DNSSoaRR(const std::string &name, int ttl, const std::string &nsname,\n           const std::string &rname, int serial, int refresh, int retry,\n           int expire, int minimum)\n    : DNSRR(name, T_SOA, ttl), nsname_(nsname), rname_(rname), serial_(serial),\n      refresh_(refresh), retry_(retry), expire_(expire), minimum_(minimum)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::string               nsname_;\n  std::string               rname_;\n  int                       serial_;\n  int                       refresh_;\n  int                       retry_;\n  int                       expire_;\n  int                       minimum_;\n}",
          {
            "std::vector<byte>": "virtual",
            "nsname_": "std::string",
            "rname_": "std::string",
            "serial_": "int",
            "refresh_": "int",
            "retry_": "int",
            "expire_": "int",
            "minimum_": "int"
          },
          "",
          [
            248,
            0
          ],
          [
            265,
            1
          ]
        ],
        [
          "struct DNSNaptrRR : public DNSRR {\n  DNSNaptrRR(const std::string &name, int ttl, int order, int pref,\n             const std::string &flags, const std::string &service,\n             const std::string &regexp, const std::string &replacement)\n    : DNSRR(name, T_NAPTR, ttl), order_(order), pref_(pref), flags_(flags),\n      service_(service), regexp_(regexp), replacement_(replacement)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  int                       order_;\n  int                       pref_;\n  std::string               flags_;\n  std::string               service_;\n  std::string               regexp_;\n  std::string               replacement_;\n}",
          {
            "std::vector<byte>": "virtual",
            "order_": "int",
            "pref_": "int",
            "flags_": "std::string",
            "service_": "std::string",
            "regexp_": "std::string",
            "replacement_": "std::string"
          },
          "",
          [
            267,
            0
          ],
          [
            283,
            1
          ]
        ],
        [
          "struct DNSOption {\n  int               code_;\n  std::vector<byte> data_;\n}",
          {
            "code_": "int",
            "data_": "std::vector<byte>"
          },
          "DNSOption",
          [
            285,
            0
          ],
          [
            288,
            1
          ]
        ],
        [
          "struct DNSOptRR : public DNSRR {\n  DNSOptRR(unsigned char extrcode, unsigned char version, unsigned short flags,\n           int udpsize, std::vector<byte> client_cookie,\n           std::vector<byte> server_cookie, bool expect_server_cookie)\n    : DNSRR(\"\", T_OPT, static_cast<int>(udpsize),\n            ((int)extrcode) << 24 | ((int)version) << 16 |\n              ((int)flags) /* ttl */)\n  {\n    client_cookie_        = client_cookie;\n    server_cookie_        = server_cookie;\n    expect_server_cookie_ = expect_server_cookie;\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::vector<DNSOption>    opts_;\n  std::vector<byte>         client_cookie_;\n  std::vector<byte>         server_cookie_;\n  bool                      expect_server_cookie_;\n}",
          {
            "std::vector<byte>": "virtual",
            "opts_": "std::vector<DNSOption>",
            "client_cookie_": "std::vector<byte>",
            "server_cookie_": "std::vector<byte>",
            "expect_server_cookie_": "bool"
          },
          "",
          [
            290,
            0
          ],
          [
            308,
            1
          ]
        ],
        [
          "struct DNSPacket {\n  DNSPacket()\n    : qid_(0), response_(false), opcode_(O_QUERY), aa_(false), tc_(false),\n      rd_(false), ra_(false), z_(false), ad_(false), cd_(false), rcode_(NOERROR)\n  {\n  }\n\n  // Convenience functions that take ownership of given pointers.\n  DNSPacket &add_question(DNSQuestion *q)\n  {\n    questions_.push_back(std::unique_ptr<DNSQuestion>(q));\n    return *this;\n  }\n\n  DNSPacket &add_answer(DNSRR *q)\n  {\n    answers_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  DNSPacket &add_auth(DNSRR *q)\n  {\n    auths_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  DNSPacket &add_additional(DNSRR *q)\n  {\n    adds_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  // Chainable setters.\n  DNSPacket &set_qid(int qid)\n  {\n    qid_ = qid;\n    return *this;\n  }\n\n  DNSPacket &set_response(bool v = true)\n  {\n    response_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_aa(bool v = true)\n  {\n    aa_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_tc(bool v = true)\n  {\n    tc_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_rd(bool v = true)\n  {\n    rd_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_ra(bool v = true)\n  {\n    ra_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_z(bool v = true)\n  {\n    z_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_ad(bool v = true)\n  {\n    ad_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_cd(bool v = true)\n  {\n    cd_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_rcode(int rcode)\n  {\n    rcode_ = rcode;\n    return *this;\n  }\n\n  // Return the encoded packet.\n  std::vector<byte> data(const char              *request_name,\n                         const ares_dns_record_t *dnsrec) const;\n\n  std::vector<byte> data() const\n  {\n    return data(nullptr, nullptr);\n  }\n\n  int                                       qid_;\n  bool                                      response_;\n  int                                       opcode_;\n  bool                                      aa_;\n  bool                                      tc_;\n  bool                                      rd_;\n  bool                                      ra_;\n  bool                                      z_;\n  bool                                      ad_;\n  bool                                      cd_;\n  int                                       rcode_;\n  std::vector<std::unique_ptr<DNSQuestion>> questions_;\n  std::vector<std::unique_ptr<DNSRR>>       answers_;\n  std::vector<std::unique_ptr<DNSRR>>       auths_;\n  std::vector<std::unique_ptr<DNSRR>>       adds_;\n}",
          {
            "data(const char              *request_name,\n                         const ares_dns_record_t *dnsrec) const": "std::vector<byte>",
            "qid_": "int",
            "response_": "bool",
            "opcode_": "int",
            "aa_": "bool",
            "tc_": "bool",
            "rd_": "bool",
            "ra_": "bool",
            "z_": "bool",
            "ad_": "bool",
            "cd_": "bool",
            "rcode_": "int",
            "questions_": "std::vector<std::unique_ptr<DNSQuestion>>",
            "answers_": "std::vector<std::unique_ptr<DNSRR>>",
            "auths_": "std::vector<std::unique_ptr<DNSRR>>",
            "adds_": "std::vector<std::unique_ptr<DNSRR>>"
          },
          "DNSPacket",
          [
            310,
            0
          ],
          [
            427,
            1
          ]
        ],
        [
          "struct DNSQuestion {\n  DNSQuestion(const std::string &name, int rrtype, int qclass)\n    : name_(name), rrtype_(rrtype), qclass_(qclass)\n  {\n  }\n\n  DNSQuestion(const std::string &name, int rrtype)\n    : name_(name), rrtype_(rrtype), qclass_(C_IN)\n  {\n  }\n\n  virtual ~DNSQuestion()\n  {\n  }\n\n  virtual std::vector<byte> data(const char              *request_name,\n                                 const ares_dns_record_t *dnsrec) const;\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const\n  {\n    return data(nullptr, dnsrec);\n  }\n\n  virtual std::vector<byte> data() const\n  {\n    return data(nullptr, nullptr);\n  }\n\n  std::string name_;\n  int         rrtype_;\n  int         qclass_;\n}",
          {
            "std::vector<byte>": "virtual",
            "name_": "std::string",
            "rrtype_": "int",
            "qclass_": "int"
          },
          "DNSQuestion",
          [
            73,
            0
          ],
          [
            104,
            1
          ]
        ],
        [
          "struct DNSRR : public DNSQuestion {\n  DNSRR(const std::string &name, int rrtype, int qclass, int ttl)\n    : DNSQuestion(name, rrtype, qclass), ttl_(ttl)\n  {\n  }\n\n  DNSRR(const std::string &name, int rrtype, int ttl)\n    : DNSQuestion(name, rrtype), ttl_(ttl)\n  {\n  }\n\n  virtual ~DNSRR()\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const = 0;\n  int                       ttl_;\n}",
          {
            "std::vector<byte>": "virtual",
            "ttl_": "int"
          },
          "",
          [
            106,
            0
          ],
          [
            123,
            1
          ]
        ],
        [
          "struct DNSAddressRR : public DNSRR {\n  DNSAddressRR(const std::string &name, int rrtype, int ttl, const byte *addr,\n               int addrlen)\n    : DNSRR(name, rrtype, ttl), addr_(addr, addr + addrlen)\n  {\n  }\n\n  DNSAddressRR(const std::string &name, int rrtype, int ttl,\n               const std::vector<byte> &addr)\n    : DNSRR(name, rrtype, ttl), addr_(addr)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::vector<byte>         addr_;\n}",
          {
            "std::vector<byte>": "virtual",
            "addr_": "std::vector<byte>"
          },
          "",
          [
            125,
            0
          ],
          [
            140,
            1
          ]
        ],
        [
          "struct DNSARR : public DNSAddressRR {\n  DNSARR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_A, ttl, addr, addrlen)\n  {\n  }\n\n  DNSARR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_A, ttl, addr)\n  {\n  }\n}",
          {},
          "",
          [
            142,
            0
          ],
          [
            152,
            1
          ]
        ],
        [
          "struct DNSAaaaRR : public DNSAddressRR {\n  DNSAaaaRR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_AAAA, ttl, addr, addrlen)\n  {\n  }\n\n  DNSAaaaRR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_AAAA, ttl, addr)\n  {\n  }\n}",
          {},
          "",
          [
            154,
            0
          ],
          [
            164,
            1
          ]
        ],
        [
          "struct DNSSingleNameRR : public DNSRR {\n  DNSSingleNameRR(const std::string &name, int rrtype, int ttl,\n                  const std::string &other)\n    : DNSRR(name, rrtype, ttl), other_(other)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::string               other_;\n}",
          {
            "std::vector<byte>": "virtual",
            "other_": "std::string"
          },
          "",
          [
            166,
            0
          ],
          [
            175,
            1
          ]
        ],
        [
          "struct DNSCnameRR : public DNSSingleNameRR {\n  DNSCnameRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_CNAME, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            177,
            0
          ],
          [
            182,
            1
          ]
        ],
        [
          "struct DNSNsRR : public DNSSingleNameRR {\n  DNSNsRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_NS, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            184,
            0
          ],
          [
            189,
            1
          ]
        ],
        [
          "struct DNSPtrRR : public DNSSingleNameRR {\n  DNSPtrRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_PTR, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            191,
            0
          ],
          [
            196,
            1
          ]
        ],
        [
          "struct DNSTxtRR : public DNSRR {\n  DNSTxtRR(const std::string &name, int ttl,\n           const std::vector<std::string> &txt)\n    : DNSRR(name, T_TXT, ttl), txt_(txt)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::vector<std::string>  txt_;\n}",
          {
            "std::vector<byte>": "virtual",
            "txt_": "std::vector<std::string>"
          },
          "",
          [
            198,
            0
          ],
          [
            207,
            1
          ]
        ],
        [
          "struct DNSMxRR : public DNSRR {\n  DNSMxRR(const std::string &name, int ttl, int pref, const std::string &other)\n    : DNSRR(name, T_MX, ttl), pref_(pref), other_(other)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  int                       pref_;\n  std::string               other_;\n}",
          {
            "std::vector<byte>": "virtual",
            "pref_": "int",
            "other_": "std::string"
          },
          "",
          [
            209,
            0
          ],
          [
            218,
            1
          ]
        ],
        [
          "struct DNSSrvRR : public DNSRR {\n  DNSSrvRR(const std::string &name, int ttl, int prio, int weight, int port,\n           const std::string &target)\n    : DNSRR(name, T_SRV, ttl), prio_(prio), weight_(weight), port_(port),\n      target_(target)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  int                       prio_;\n  int                       weight_;\n  int                       port_;\n  std::string               target_;\n}",
          {
            "std::vector<byte>": "virtual",
            "prio_": "int",
            "weight_": "int",
            "port_": "int",
            "target_": "std::string"
          },
          "",
          [
            220,
            0
          ],
          [
            233,
            1
          ]
        ],
        [
          "struct DNSUriRR : public DNSRR {\n  DNSUriRR(const std::string &name, int ttl, int prio, int weight,\n           const std::string &target)\n    : DNSRR(name, T_URI, ttl), prio_(prio), weight_(weight), target_(target)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  int                       prio_;\n  int                       weight_;\n  std::string               target_;\n}",
          {
            "std::vector<byte>": "virtual",
            "prio_": "int",
            "weight_": "int",
            "target_": "std::string"
          },
          "",
          [
            235,
            0
          ],
          [
            246,
            1
          ]
        ],
        [
          "struct DNSSoaRR : public DNSRR {\n  DNSSoaRR(const std::string &name, int ttl, const std::string &nsname,\n           const std::string &rname, int serial, int refresh, int retry,\n           int expire, int minimum)\n    : DNSRR(name, T_SOA, ttl), nsname_(nsname), rname_(rname), serial_(serial),\n      refresh_(refresh), retry_(retry), expire_(expire), minimum_(minimum)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::string               nsname_;\n  std::string               rname_;\n  int                       serial_;\n  int                       refresh_;\n  int                       retry_;\n  int                       expire_;\n  int                       minimum_;\n}",
          {
            "std::vector<byte>": "virtual",
            "nsname_": "std::string",
            "rname_": "std::string",
            "serial_": "int",
            "refresh_": "int",
            "retry_": "int",
            "expire_": "int",
            "minimum_": "int"
          },
          "",
          [
            248,
            0
          ],
          [
            265,
            1
          ]
        ],
        [
          "struct DNSNaptrRR : public DNSRR {\n  DNSNaptrRR(const std::string &name, int ttl, int order, int pref,\n             const std::string &flags, const std::string &service,\n             const std::string &regexp, const std::string &replacement)\n    : DNSRR(name, T_NAPTR, ttl), order_(order), pref_(pref), flags_(flags),\n      service_(service), regexp_(regexp), replacement_(replacement)\n  {\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  int                       order_;\n  int                       pref_;\n  std::string               flags_;\n  std::string               service_;\n  std::string               regexp_;\n  std::string               replacement_;\n}",
          {
            "std::vector<byte>": "virtual",
            "order_": "int",
            "pref_": "int",
            "flags_": "std::string",
            "service_": "std::string",
            "regexp_": "std::string",
            "replacement_": "std::string"
          },
          "",
          [
            267,
            0
          ],
          [
            283,
            1
          ]
        ],
        [
          "struct DNSOption {\n  int               code_;\n  std::vector<byte> data_;\n}",
          {
            "code_": "int",
            "data_": "std::vector<byte>"
          },
          "DNSOption",
          [
            285,
            0
          ],
          [
            288,
            1
          ]
        ],
        [
          "struct DNSOptRR : public DNSRR {\n  DNSOptRR(unsigned char extrcode, unsigned char version, unsigned short flags,\n           int udpsize, std::vector<byte> client_cookie,\n           std::vector<byte> server_cookie, bool expect_server_cookie)\n    : DNSRR(\"\", T_OPT, static_cast<int>(udpsize),\n            ((int)extrcode) << 24 | ((int)version) << 16 |\n              ((int)flags) /* ttl */)\n  {\n    client_cookie_        = client_cookie;\n    server_cookie_        = server_cookie;\n    expect_server_cookie_ = expect_server_cookie;\n  }\n\n  virtual std::vector<byte> data(const ares_dns_record_t *dnsrec) const;\n  std::vector<DNSOption>    opts_;\n  std::vector<byte>         client_cookie_;\n  std::vector<byte>         server_cookie_;\n  bool                      expect_server_cookie_;\n}",
          {
            "std::vector<byte>": "virtual",
            "opts_": "std::vector<DNSOption>",
            "client_cookie_": "std::vector<byte>",
            "server_cookie_": "std::vector<byte>",
            "expect_server_cookie_": "bool"
          },
          "",
          [
            290,
            0
          ],
          [
            308,
            1
          ]
        ],
        [
          "struct DNSPacket {\n  DNSPacket()\n    : qid_(0), response_(false), opcode_(O_QUERY), aa_(false), tc_(false),\n      rd_(false), ra_(false), z_(false), ad_(false), cd_(false), rcode_(NOERROR)\n  {\n  }\n\n  // Convenience functions that take ownership of given pointers.\n  DNSPacket &add_question(DNSQuestion *q)\n  {\n    questions_.push_back(std::unique_ptr<DNSQuestion>(q));\n    return *this;\n  }\n\n  DNSPacket &add_answer(DNSRR *q)\n  {\n    answers_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  DNSPacket &add_auth(DNSRR *q)\n  {\n    auths_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  DNSPacket &add_additional(DNSRR *q)\n  {\n    adds_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  // Chainable setters.\n  DNSPacket &set_qid(int qid)\n  {\n    qid_ = qid;\n    return *this;\n  }\n\n  DNSPacket &set_response(bool v = true)\n  {\n    response_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_aa(bool v = true)\n  {\n    aa_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_tc(bool v = true)\n  {\n    tc_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_rd(bool v = true)\n  {\n    rd_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_ra(bool v = true)\n  {\n    ra_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_z(bool v = true)\n  {\n    z_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_ad(bool v = true)\n  {\n    ad_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_cd(bool v = true)\n  {\n    cd_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_rcode(int rcode)\n  {\n    rcode_ = rcode;\n    return *this;\n  }\n\n  // Return the encoded packet.\n  std::vector<byte> data(const char              *request_name,\n                         const ares_dns_record_t *dnsrec) const;\n\n  std::vector<byte> data() const\n  {\n    return data(nullptr, nullptr);\n  }\n\n  int                                       qid_;\n  bool                                      response_;\n  int                                       opcode_;\n  bool                                      aa_;\n  bool                                      tc_;\n  bool                                      rd_;\n  bool                                      ra_;\n  bool                                      z_;\n  bool                                      ad_;\n  bool                                      cd_;\n  int                                       rcode_;\n  std::vector<std::unique_ptr<DNSQuestion>> questions_;\n  std::vector<std::unique_ptr<DNSRR>>       answers_;\n  std::vector<std::unique_ptr<DNSRR>>       auths_;\n  std::vector<std::unique_ptr<DNSRR>>       adds_;\n}",
          {
            "data(const char              *request_name,\n                         const ares_dns_record_t *dnsrec) const": "std::vector<byte>",
            "qid_": "int",
            "response_": "bool",
            "opcode_": "int",
            "aa_": "bool",
            "tc_": "bool",
            "rd_": "bool",
            "ra_": "bool",
            "z_": "bool",
            "ad_": "bool",
            "cd_": "bool",
            "rcode_": "int",
            "questions_": "std::vector<std::unique_ptr<DNSQuestion>>",
            "answers_": "std::vector<std::unique_ptr<DNSRR>>",
            "auths_": "std::vector<std::unique_ptr<DNSRR>>",
            "adds_": "std::vector<std::unique_ptr<DNSRR>>"
          },
          "DNSPacket",
          [
            310,
            0
          ],
          [
            427,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <memory>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/walkiiiy/RosFuzzer/docker_shared/source_code/c-ares/test/Makefile.inc": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}