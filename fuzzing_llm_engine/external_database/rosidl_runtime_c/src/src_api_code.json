{
  "get_message_typesupport_handle": "const rosidl_message_type_support_t * get_message_typesupport_handle(\n  const rosidl_message_type_support_t * handle, const char * identifier)\n{\n  assert(handle);\n  assert(handle->func);\n  rosidl_message_typesupport_handle_function func =\n    (rosidl_message_typesupport_handle_function)(handle->func);\n  return func(handle, identifier);\n}",
  "get_message_typesupport_handle_function": "const rosidl_message_type_support_t * get_message_typesupport_handle_function(\n  const rosidl_message_type_support_t * handle, const char * identifier)\n{\n  assert(handle);\n  assert(handle->typesupport_identifier);\n  assert(identifier);\n  if (strcmp(handle->typesupport_identifier, identifier) == 0) {\n    return handle;\n  }\n  return 0;\n}",
  "get_sequence_bound_handle": "const rosidl_runtime_c__Sequence__bound * get_sequence_bound_handle(\n  const rosidl_runtime_c__Sequence__bound * handle, const char * identifier)\n{\n  assert(handle);\n  assert(handle->func);\n  rosidl_runtime_c__bound_handle_function func =\n    (rosidl_runtime_c__bound_handle_function)(handle->func);\n  return func(handle, identifier);\n}",
  "get_sequence_bound_handle_function": "const rosidl_runtime_c__Sequence__bound * get_sequence_bound_handle_function(\n  const rosidl_runtime_c__Sequence__bound * handle, const char * identifier)\n{\n  assert(handle);\n  assert(handle->typesupport_identifier);\n  assert(identifier);\n  if (strcmp(handle->typesupport_identifier, identifier) == 0) {\n    return handle;\n  }\n  return 0;\n}",
  "get_service_typesupport_handle": "const rosidl_service_type_support_t * get_service_typesupport_handle(\n  const rosidl_service_type_support_t * handle, const char * identifier)\n{\n  assert(handle);\n  assert(handle->func);\n  rosidl_service_typesupport_handle_function func =\n    (rosidl_service_typesupport_handle_function)(handle->func);\n  return func(handle, identifier);\n}",
  "get_service_typesupport_handle_function": "const rosidl_service_type_support_t * get_service_typesupport_handle_function(\n  const rosidl_service_type_support_t * handle, const char * identifier)\n{\n  assert(handle);\n  assert(handle->typesupport_identifier);\n  assert(identifier);\n  if (strcmp(handle->typesupport_identifier, identifier) == 0) {\n    return handle;\n  }\n  return 0;\n}",
  "rosidl_runtime_c__String__Sequence__are_equal": "bool\nrosidl_runtime_c__String__Sequence__are_equal(\n  const rosidl_runtime_c__String__Sequence * lhs,\n  const rosidl_runtime_c__String__Sequence * rhs)\n{\n  if (!lhs || !rhs) {\n    return false;\n  }\n  if (lhs->size != rhs->size) {\n    return false;\n  }\n  for (size_t i = 0; i < lhs->size; ++i) {\n    if (!rosidl_runtime_c__String__are_equal(\n        &(lhs->data[i]), &(rhs->data[i])))\n    {\n      return false;\n    }\n  }\n  return true;\n}",
  "rosidl_runtime_c__String__Sequence__copy": "bool\nrosidl_runtime_c__String__Sequence__copy(\n  const rosidl_runtime_c__String__Sequence * input,\n  rosidl_runtime_c__String__Sequence * output)\n{\n  if (!input || !output) {\n    return false;\n  }\n  if (output->capacity < input->size) {\n    const size_t allocation_size =\n      input->size * sizeof(rosidl_runtime_c__String);\n    rcutils_allocator_t allocator = rcutils_get_default_allocator();\n    rosidl_runtime_c__String * data =\n      (rosidl_runtime_c__String *)allocator.reallocate(\n      output->data, allocation_size, allocator.state);\n    if (!data) {\n      return false;\n    }\n    // If reallocation succeeded, memory may or may not have been moved\n    // to fulfill the allocation request, invalidating output->data.\n    output->data = data;\n    for (size_t i = output->capacity; i < input->size; ++i) {\n      if (!rosidl_runtime_c__String__init(&output->data[i])) {\n        // If initialization of any new item fails, roll back all\n        // previously initialized items. Existing items in output\n        // are to be left unmodified.\n        for (; i-- > output->capacity; ) {\n          rosidl_runtime_c__String__fini(&output->data[i]);\n        }\n        return false;\n      }\n    }\n    output->capacity = input->size;\n  }\n  output->size = input->size;\n  for (size_t i = 0; i < input->size; ++i) {\n    if (!rosidl_runtime_c__String__copy(\n        &(input->data[i]), &(output->data[i])))\n    {\n      return false;\n    }\n  }\n  return true;\n}",
  "rosidl_runtime_c__String__Sequence__create": "rosidl_runtime_c__String__Sequence *\nrosidl_runtime_c__String__Sequence__create(size_t size)\n{\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  rosidl_runtime_c__String__Sequence * sequence =\n    (rosidl_runtime_c__String__Sequence *)allocator.allocate(\n    sizeof(rosidl_runtime_c__String__Sequence), allocator.state);\n  if (!sequence) {\n    return NULL;\n  }\n  bool success = rosidl_runtime_c__String__Sequence__init(sequence, size);\n  if (!success) {\n    allocator.deallocate(sequence, allocator.state);\n    return NULL;\n  }\n  return sequence;\n}",
  "rosidl_runtime_c__String__Sequence__destroy": "void\nrosidl_runtime_c__String__Sequence__destroy(\n  rosidl_runtime_c__String__Sequence * sequence)\n{\n  if (sequence) {\n    rosidl_runtime_c__String__Sequence__fini(sequence);\n  }\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  allocator.deallocate(sequence, allocator.state);\n}",
  "rosidl_runtime_c__String__Sequence__fini": "void\nrosidl_runtime_c__String__Sequence__fini(\n  rosidl_runtime_c__String__Sequence * sequence)\n{\n  if (!sequence) {\n    return;\n  }\n  if (sequence->data) {\n    // ensure that data and capacity values are consistent\n    assert(sequence->capacity > 0);\n    // finalize all sequence elements\n    for (size_t i = 0; i < sequence->capacity; ++i) {\n      rosidl_runtime_c__String__fini(&sequence->data[i]);\n    }\n    rcutils_allocator_t allocator = rcutils_get_default_allocator();\n    allocator.deallocate(sequence->data, allocator.state);\n    sequence->data = NULL;\n    sequence->size = 0;\n    sequence->capacity = 0;\n  } else {\n    // ensure that data, size, and capacity values are consistent\n    assert(0 == sequence->size);\n    assert(0 == sequence->capacity);\n  }\n}",
  "rosidl_runtime_c__String__Sequence__init": "bool\nrosidl_runtime_c__String__Sequence__init(\n  rosidl_runtime_c__String__Sequence * sequence, size_t size)\n{\n  RCUTILS_CAN_RETURN_WITH_ERROR_OF(false);\n\n  if (!sequence) {\n    return false;\n  }\n  rosidl_runtime_c__String * data = NULL;\n  if (size) {\n    rcutils_allocator_t allocator = rcutils_get_default_allocator();\n    data = (rosidl_runtime_c__String *)allocator.zero_allocate(\n      size, sizeof(rosidl_runtime_c__String), allocator.state);\n    if (!data) {\n      return false;\n    }\n    // initialize all sequence elements\n    for (size_t i = 0; i < size; ++i) {\n      if (!rosidl_runtime_c__String__init(&data[i])) {\n        /* free currently allocated and return false */\n        for (; i-- > 0; ) {\n          rosidl_runtime_c__String__fini(&data[i]);\n        }\n        allocator.deallocate(data, allocator.state);\n        return false;\n      }\n    }\n  }\n  sequence->data = data;\n  sequence->size = size;\n  sequence->capacity = size;\n  return true;\n}",
  "rosidl_runtime_c__String__are_equal": "bool\nrosidl_runtime_c__String__are_equal(\n  const rosidl_runtime_c__String * lhs,\n  const rosidl_runtime_c__String * rhs)\n{\n  if (!lhs || !rhs) {\n    return false;\n  }\n  if (lhs->size != rhs->size) {\n    return false;\n  }\n  return memcmp(lhs->data, rhs->data, lhs->size) == 0;\n}",
  "rosidl_runtime_c__String__assign": "bool\nrosidl_runtime_c__String__assign(\n  rosidl_runtime_c__String * str, const char * value)\n{\n  if (!value) {\n    // strlen is not defined for nullptr, let assignn take care of other bad values\n    return false;\n  }\n  return rosidl_runtime_c__String__assignn(\n    str, value, strlen(value));\n}",
  "rosidl_runtime_c__String__assignn": "bool\nrosidl_runtime_c__String__assignn(\n  rosidl_runtime_c__String * str, const char * value, size_t n)\n{\n  if (!str) {\n    return false;\n  }\n  // a NULL value is not valid\n  if (!value) {\n    return false;\n  }\n  // since n + 1 bytes are being allocated n can't be the maximum value\n  if (n == SIZE_MAX) {\n    return false;\n  }\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  char * data = allocator.reallocate(str->data, n + 1, allocator.state);\n  if (!data) {\n    return false;\n  }\n  memcpy(data, value, n);\n  data[n] = '\\0';\n  str->data = data;\n  str->size = n;\n  str->capacity = n + 1;\n  return true;\n}",
  "rosidl_runtime_c__String__copy": "bool\nrosidl_runtime_c__String__copy(\n  const rosidl_runtime_c__String * input,\n  rosidl_runtime_c__String * output)\n{\n  if (!input) {\n    return false;\n  }\n  return rosidl_runtime_c__String__assignn(\n    output, input->data, input->size);\n}",
  "rosidl_runtime_c__String__fini": "void\nrosidl_runtime_c__String__fini(rosidl_runtime_c__String * str)\n{\n  if (!str) {\n    return;\n  }\n  if (str->data) {\n    /* ensure that data and capacity values are consistent */\n    if (str->capacity <= 0) {\n      fprintf(\n        stderr, \"Unexpected condition: string capacity was zero for allocated data! \"\n        \"Exiting.\\n\");\n      exit(-1);\n    }\n    rcutils_allocator_t allocator = rcutils_get_default_allocator();\n    allocator.deallocate(str->data, allocator.state);\n    str->data = NULL;\n    str->size = 0;\n    str->capacity = 0;\n  } else {\n    /* ensure that data, size, and capacity values are consistent */\n    if (0 != str->size) {\n      fprintf(\n        stderr, \"Unexpected condition: string size was non-zero for deallocated data! \"\n        \"Exiting.\\n\");\n      exit(-1);\n    }\n    if (0 != str->capacity) {\n      fprintf(\n        stderr, \"Unexpected behavior: string capacity was non-zero for deallocated data! \"\n        \"Exiting.\\n\");\n      exit(-1);\n    }\n  }\n}",
  "rosidl_runtime_c__String__init": "bool\nrosidl_runtime_c__String__init(rosidl_runtime_c__String * str)\n{\n  RCUTILS_CAN_RETURN_WITH_ERROR_OF(false);\n\n  if (!str) {\n    return false;\n  }\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  str->data = allocator.allocate(1, allocator.state);\n  if (!str->data) {\n    return false;\n  }\n  str->data[0] = '\\0';\n  str->size = 0;\n  str->capacity = 1;\n  return true;\n}",
  "rosidl_runtime_c__U16String__Sequence__are_equal": "bool\nrosidl_runtime_c__U16String__Sequence__are_equal(\n  const rosidl_runtime_c__U16String__Sequence * lhs,\n  const rosidl_runtime_c__U16String__Sequence * rhs)\n{\n  if (!lhs || !rhs) {\n    return false;\n  }\n  if (lhs->size != rhs->size) {\n    return false;\n  }\n  for (size_t i = 0; i < lhs->size; ++i) {\n    if (!rosidl_runtime_c__U16String__are_equal(\n        &(lhs->data[i]), &(rhs->data[i])))\n    {\n      return false;\n    }\n  }\n  return true;\n}",
  "rosidl_runtime_c__U16String__Sequence__copy": "bool\nrosidl_runtime_c__U16String__Sequence__copy(\n  const rosidl_runtime_c__U16String__Sequence * input,\n  rosidl_runtime_c__U16String__Sequence * output)\n{\n  if (!input || !output) {\n    return false;\n  }\n  if (output->capacity < input->size) {\n    const size_t size =\n      input->size * sizeof(rosidl_runtime_c__U16String);\n    rcutils_allocator_t allocator = rcutils_get_default_allocator();\n    rosidl_runtime_c__U16String * data =\n      (rosidl_runtime_c__U16String *)allocator.reallocate(\n      output->data, size, allocator.state);\n    if (!data) {\n      return false;\n    }\n    // If reallocation succeeded, memory may or may not have been moved\n    // to fulfill the allocation request, invalidating output->data.\n    output->data = data;\n    for (size_t i = output->capacity; i < input->size; ++i) {\n      if (!rosidl_runtime_c__U16String__init(&output->data[i])) {\n        // If initialization of any new items fails, roll back all\n        // previously initialized items. Existing items in output\n        // are to be left unmodified.\n        for (; i-- > output->capacity; ) {\n          rosidl_runtime_c__U16String__fini(&output->data[i]);\n        }\n        return false;\n      }\n    }\n    output->capacity = input->size;\n  }\n  output->size = input->size;\n  for (size_t i = 0; i < input->size; ++i) {\n    if (!rosidl_runtime_c__U16String__copy(\n        &(input->data[i]), &(output->data[i])))\n    {\n      return false;\n    }\n  }\n  return true;\n}",
  "rosidl_runtime_c__U16String__Sequence__create": "rosidl_runtime_c__U16String__Sequence *\nrosidl_runtime_c__U16String__Sequence__create(size_t size)\n{\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  rosidl_runtime_c__U16String__Sequence * sequence =\n    (rosidl_runtime_c__U16String__Sequence *)allocator.allocate(\n    sizeof(rosidl_runtime_c__U16String__Sequence), allocator.state);\n  if (!sequence) {\n    return NULL;\n  }\n  bool success = rosidl_runtime_c__U16String__Sequence__init(sequence, size);\n  if (!success) {\n    allocator.deallocate(sequence, allocator.state);\n    return NULL;\n  }\n  return sequence;\n}",
  "rosidl_runtime_c__U16String__Sequence__destroy": "void\nrosidl_runtime_c__U16String__Sequence__destroy(\n  rosidl_runtime_c__U16String__Sequence * sequence)\n{\n  if (sequence) {\n    rosidl_runtime_c__U16String__Sequence__fini(sequence);\n  }\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  allocator.deallocate(sequence, allocator.state);\n}",
  "rosidl_runtime_c__U16String__Sequence__fini": "void\nrosidl_runtime_c__U16String__Sequence__fini(\n  rosidl_runtime_c__U16String__Sequence * sequence)\n{\n  if (!sequence) {\n    return;\n  }\n  if (sequence->data) {\n    // ensure that data and capacity values are consistent\n    assert(sequence->capacity > 0);\n    // finalize all sequence elements\n    for (size_t i = 0; i < sequence->capacity; ++i) {\n      rosidl_runtime_c__U16String__fini(&sequence->data[i]);\n    }\n    rcutils_allocator_t allocator = rcutils_get_default_allocator();\n    allocator.deallocate(sequence->data, allocator.state);\n    sequence->data = NULL;\n    sequence->size = 0;\n    sequence->capacity = 0;\n  } else {\n    // ensure that data, size, and capacity values are consistent\n    assert(0 == sequence->size);\n    assert(0 == sequence->capacity);\n  }\n}",
  "rosidl_runtime_c__U16String__Sequence__init": "bool\nrosidl_runtime_c__U16String__Sequence__init(\n  rosidl_runtime_c__U16String__Sequence * sequence, size_t size)\n{\n  RCUTILS_CAN_RETURN_WITH_ERROR_OF(false);\n\n  if (!sequence) {\n    return false;\n  }\n  rosidl_runtime_c__U16String * data = NULL;\n  if (size) {\n    rcutils_allocator_t allocator = rcutils_get_default_allocator();\n    data = (rosidl_runtime_c__U16String *)allocator.allocate(\n      size * sizeof(rosidl_runtime_c__U16String), allocator.state);\n    if (!data) {\n      return false;\n    }\n    // initialize all sequence elements\n    for (size_t i = 0; i < size; ++i) {\n      if (!rosidl_runtime_c__U16String__init(&data[i])) {\n        /* free currently allocated and return false */\n        for (; i-- > 0; ) {\n          rosidl_runtime_c__U16String__fini(&data[i]);\n        }\n        allocator.deallocate(data, allocator.state);\n        return false;\n      }\n    }\n  }\n  sequence->data = data;\n  sequence->size = size;\n  sequence->capacity = size;\n  return true;\n}",
  "rosidl_runtime_c__U16String__are_equal": "bool\nrosidl_runtime_c__U16String__are_equal(\n  const rosidl_runtime_c__U16String * lhs,\n  const rosidl_runtime_c__U16String * rhs)\n{\n  if (!lhs || !rhs) {\n    return false;\n  }\n  if (lhs->size != rhs->size) {\n    return false;\n  }\n  return memcmp(lhs->data, rhs->data, lhs->size * sizeof(uint16_t)) == 0;\n}",
  "rosidl_runtime_c__U16String__assign": "bool\nrosidl_runtime_c__U16String__assign(\n  rosidl_runtime_c__U16String * str, const uint16_t * value)\n{\n  return rosidl_runtime_c__U16String__assignn(\n    str, value, rosidl_runtime_c__U16String__len(value));\n}",
  "rosidl_runtime_c__U16String__assignn": "bool\nrosidl_runtime_c__U16String__assignn(\n  rosidl_runtime_c__U16String * str, const uint16_t * value, size_t n)\n{\n  if (!str) {\n    return false;\n  }\n  // a NULL value is not valid\n  if (!value) {\n    return false;\n  }\n  // since n + 1 bytes are being allocated n can't be the maximum value\n  if (n == SIZE_MAX) {\n    return false;\n  }\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  uint16_t * data = allocator.reallocate(str->data, (n + 1) * sizeof(uint16_t), allocator.state);\n  if (!data) {\n    return false;\n  }\n  memcpy(data, value, n * sizeof(uint16_t));\n  data[n] = 0;\n  str->data = data;\n  str->size = n;\n  str->capacity = n + 1;\n  return true;\n}",
  "rosidl_runtime_c__U16String__assignn_from_char": "bool\nrosidl_runtime_c__U16String__assignn_from_char(\n  rosidl_runtime_c__U16String * str, const char * value, size_t n)\n{\n  // since n represents the number of 8-bit characters it must be an even number\n  if (n % 2 != 0) {\n    return false;\n  }\n  return rosidl_runtime_c__U16String__assignn(\n    str, (const uint16_t *)value, n / 2);\n}",
  "rosidl_runtime_c__U16String__copy": "bool\nrosidl_runtime_c__U16String__copy(\n  const rosidl_runtime_c__U16String * input,\n  rosidl_runtime_c__U16String * output)\n{\n  if (!input) {\n    return false;\n  }\n  return rosidl_runtime_c__U16String__assignn(\n    output, input->data, input->size);\n}",
  "rosidl_runtime_c__U16String__fini": "void\nrosidl_runtime_c__U16String__fini(rosidl_runtime_c__U16String * str)\n{\n  if (!str) {\n    return;\n  }\n  if (str->data) {\n    /* ensure that data and capacity values are consistent */\n    if (str->capacity <= 0) {\n      fprintf(\n        stderr, \"Unexpected condition: string capacity was zero for allocated data! \"\n        \"Exiting.\\n\");\n      exit(-1);\n    }\n    rcutils_allocator_t allocator = rcutils_get_default_allocator();\n    allocator.deallocate(str->data, allocator.state);\n    str->data = NULL;\n    str->size = 0;\n    str->capacity = 0;\n  } else {\n    /* ensure that data, size, and capacity values are consistent */\n    if (0 != str->size) {\n      fprintf(\n        stderr, \"Unexpected condition: string size was non-zero for deallocated data! \"\n        \"Exiting.\\n\");\n      exit(-1);\n    }\n    if (0 != str->capacity) {\n      fprintf(\n        stderr, \"Unexpected behavior: string capacity was non-zero for deallocated data! \"\n        \"Exiting.\\n\");\n      exit(-1);\n    }\n  }\n}",
  "rosidl_runtime_c__U16String__init": "bool\nrosidl_runtime_c__U16String__init(rosidl_runtime_c__U16String * str)\n{\n  RCUTILS_CAN_RETURN_WITH_ERROR_OF(false);\n\n  if (!str) {\n    return false;\n  }\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  str->data = allocator.allocate(sizeof(uint16_t), allocator.state);\n  if (!str->data) {\n    return false;\n  }\n  str->data[0] = 0;\n  str->size = 0;\n  str->capacity = 1;\n  return true;\n}",
  "rosidl_runtime_c__U16String__len": "size_t\nrosidl_runtime_c__U16String__len(const uint16_t * value)\n{\n  if (!value) {\n    return 0;\n  }\n  size_t len = 0;\n  while (value[len]) {\n    len++;\n  }\n  return len;\n}",
  "rosidl_runtime_c__U16String__resize": "bool\nrosidl_runtime_c__U16String__resize(\n  rosidl_runtime_c__U16String * str, size_t n)\n{\n  if (!str) {\n    return false;\n  }\n  // check valid range of n before allocating n + 1 characters\n  if (n > SIZE_MAX / sizeof(uint16_t) - 1) {\n    return false;\n  }\n  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n  uint16_t * data = allocator.reallocate(str->data, (n + 1) * sizeof(uint16_t), allocator.state);\n  if (!data) {\n    return false;\n  }\n  data[n] = 0;\n  str->data = data;\n  str->size = n;\n  str->capacity = n + 1;\n  return true;\n}",
  "rosidl_runtime_c__bool__Sequence__are_equal": "bool rosidl_runtime_c__bool__Sequence__are_equal(\n  const rosidl_runtime_c__boolean__Sequence * lhs,\n  const rosidl_runtime_c__boolean__Sequence * rhs)\n{\n  return rosidl_runtime_c__boolean__Sequence__are_equal(lhs, rhs);\n}",
  "rosidl_runtime_c__bool__Sequence__copy": "bool rosidl_runtime_c__bool__Sequence__copy(\n  const rosidl_runtime_c__boolean__Sequence * input,\n  rosidl_runtime_c__boolean__Sequence * output)\n{\n  return rosidl_runtime_c__boolean__Sequence__copy(input, output);\n}",
  "rosidl_runtime_c__bool__Sequence__fini": "void rosidl_runtime_c__bool__Sequence__fini(\n  rosidl_runtime_c__boolean__Sequence * sequence)\n{\n  rosidl_runtime_c__boolean__Sequence__fini(\n    sequence);\n}",
  "rosidl_runtime_c__bool__Sequence__init": "bool rosidl_runtime_c__bool__Sequence__init(\n  rosidl_runtime_c__boolean__Sequence * sequence, size_t size)\n{\n  return rosidl_runtime_c__boolean__Sequence__init(\n    sequence, size);\n}",
  "rosidl_runtime_c__byte__Sequence__are_equal": "bool rosidl_runtime_c__byte__Sequence__are_equal(\n  const rosidl_runtime_c__octet__Sequence * lhs,\n  const rosidl_runtime_c__octet__Sequence * rhs)\n{\n  return rosidl_runtime_c__octet__Sequence__are_equal(lhs, rhs);\n}",
  "rosidl_runtime_c__byte__Sequence__copy": "bool rosidl_runtime_c__byte__Sequence__copy(\n  const rosidl_runtime_c__octet__Sequence * input,\n  rosidl_runtime_c__octet__Sequence * output)\n{\n  return rosidl_runtime_c__octet__Sequence__copy(input, output);\n}",
  "rosidl_runtime_c__byte__Sequence__fini": "void rosidl_runtime_c__byte__Sequence__fini(\n  rosidl_runtime_c__octet__Sequence * sequence)\n{\n  rosidl_runtime_c__octet__Sequence__fini(\n    sequence);\n}",
  "rosidl_runtime_c__byte__Sequence__init": "bool rosidl_runtime_c__byte__Sequence__init(\n  rosidl_runtime_c__octet__Sequence * sequence, size_t size)\n{\n  return rosidl_runtime_c__octet__Sequence__init(\n    sequence, size);\n}",
  "rosidl_runtime_c__float32__Sequence__are_equal": "bool rosidl_runtime_c__float32__Sequence__are_equal(\n  const rosidl_runtime_c__float__Sequence * lhs,\n  const rosidl_runtime_c__float__Sequence * rhs)\n{\n  return rosidl_runtime_c__float__Sequence__are_equal(lhs, rhs);\n}",
  "rosidl_runtime_c__float32__Sequence__copy": "bool rosidl_runtime_c__float32__Sequence__copy(\n  const rosidl_runtime_c__float__Sequence * input,\n  rosidl_runtime_c__float__Sequence * output)\n{\n  return rosidl_runtime_c__float__Sequence__copy(input, output);\n}",
  "rosidl_runtime_c__float32__Sequence__fini": "void rosidl_runtime_c__float32__Sequence__fini(\n  rosidl_runtime_c__float__Sequence * sequence)\n{\n  rosidl_runtime_c__float__Sequence__fini(\n    sequence);\n}",
  "rosidl_runtime_c__float32__Sequence__init": "bool rosidl_runtime_c__float32__Sequence__init(\n  rosidl_runtime_c__float__Sequence * sequence, size_t size)\n{\n  return rosidl_runtime_c__float__Sequence__init(\n    sequence, size);\n}",
  "rosidl_runtime_c__float64__Sequence__are_equal": "bool rosidl_runtime_c__float64__Sequence__are_equal(\n  const rosidl_runtime_c__double__Sequence * lhs,\n  const rosidl_runtime_c__double__Sequence * rhs)\n{\n  return rosidl_runtime_c__double__Sequence__are_equal(lhs, rhs);\n}",
  "rosidl_runtime_c__float64__Sequence__copy": "bool rosidl_runtime_c__float64__Sequence__copy(\n  const rosidl_runtime_c__double__Sequence * input,\n  rosidl_runtime_c__double__Sequence * output)\n{\n  return rosidl_runtime_c__double__Sequence__copy(input, output);\n}",
  "rosidl_runtime_c__float64__Sequence__fini": "void rosidl_runtime_c__float64__Sequence__fini(\n  rosidl_runtime_c__double__Sequence * sequence)\n{\n  rosidl_runtime_c__double__Sequence__fini(\n    sequence);\n}",
  "rosidl_runtime_c__float64__Sequence__init": "bool rosidl_runtime_c__float64__Sequence__init(\n  rosidl_runtime_c__double__Sequence * sequence, size_t size)\n{\n  return rosidl_runtime_c__double__Sequence__init(\n    sequence, size);\n}"
}